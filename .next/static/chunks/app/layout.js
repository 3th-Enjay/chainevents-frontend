/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-sans%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistSans%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-mono%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fcomponents%2FProviders.jsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-sans%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistSans%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-mono%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fcomponents%2FProviders.jsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.jsx\",\"import\":\"Geist\",\"arguments\":[{\"variable\":\"--font-geist-sans\",\"subsets\":[\"latin\"]}],\"variableName\":\"geistSans\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.jsx\\\",\\\"import\\\":\\\"Geist\\\",\\\"arguments\\\":[{\\\"variable\\\":\\\"--font-geist-sans\\\",\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"geistSans\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.jsx\",\"import\":\"Geist_Mono\",\"arguments\":[{\"variable\":\"--font-geist-mono\",\"subsets\":[\"latin\"]}],\"variableName\":\"geistMono\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.jsx\\\",\\\"import\\\":\\\"Geist_Mono\\\",\\\"arguments\\\":[{\\\"variable\\\":\\\"--font-geist-mono\\\",\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"geistMono\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/Providers.jsx */ \"(app-pages-browser)/./src/components/Providers.jsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRndpbGZyaWQtayUyRnByb2plY3RzJTJGb25seWR1c3QlMkZjaGFpbmV2ZW50cy1mcm9udGVuZCUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZmb250JTJGZ29vZ2xlJTJGdGFyZ2V0LmNzcyUzRiU3QiU1QyUyMnBhdGglNUMlMjIlM0ElNUMlMjJzcmMlMkZhcHAlMkZsYXlvdXQuanN4JTVDJTIyJTJDJTVDJTIyaW1wb3J0JTVDJTIyJTNBJTVDJTIyR2Vpc3QlNUMlMjIlMkMlNUMlMjJhcmd1bWVudHMlNUMlMjIlM0ElNUIlN0IlNUMlMjJ2YXJpYWJsZSU1QyUyMiUzQSU1QyUyMi0tZm9udC1nZWlzdC1zYW5zJTVDJTIyJTJDJTVDJTIyc3Vic2V0cyU1QyUyMiUzQSU1QiU1QyUyMmxhdGluJTVDJTIyJTVEJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIyZ2Vpc3RTYW5zJTVDJTIyJTdEJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZ3aWxmcmlkLWslMkZwcm9qZWN0cyUyRm9ubHlkdXN0JTJGY2hhaW5ldmVudHMtZnJvbnRlbmQlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZm9udCUyRmdvb2dsZSUyRnRhcmdldC5jc3MlM0YlN0IlNUMlMjJwYXRoJTVDJTIyJTNBJTVDJTIyc3JjJTJGYXBwJTJGbGF5b3V0LmpzeCU1QyUyMiUyQyU1QyUyMmltcG9ydCU1QyUyMiUzQSU1QyUyMkdlaXN0X01vbm8lNUMlMjIlMkMlNUMlMjJhcmd1bWVudHMlNUMlMjIlM0ElNUIlN0IlNUMlMjJ2YXJpYWJsZSU1QyUyMiUzQSU1QyUyMi0tZm9udC1nZWlzdC1tb25vJTVDJTIyJTJDJTVDJTIyc3Vic2V0cyU1QyUyMiUzQSU1QiU1QyUyMmxhdGluJTVDJTIyJTVEJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIyZ2Vpc3RNb25vJTVDJTIyJTdEJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZ3aWxmcmlkLWslMkZwcm9qZWN0cyUyRm9ubHlkdXN0JTJGY2hhaW5ldmVudHMtZnJvbnRlbmQlMkZzcmMlMkZhcHAlMkZnbG9iYWxzLmNzcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGd2lsZnJpZC1rJTJGcHJvamVjdHMlMkZvbmx5ZHVzdCUyRmNoYWluZXZlbnRzLWZyb250ZW5kJTJGc3JjJTJGY29tcG9uZW50cyUyRlByb3ZpZGVycy5qc3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJQcm92aWRlcnMlMjIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxvZ0JBQXVTO0FBQ3ZTO0FBQ0EsOGdCQUE0UztBQUM1UztBQUNBLG9LQUErRztBQUMvRztBQUNBLHNMQUF1SiIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwic3JjL2FwcC9sYXlvdXQuanN4XFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiR2Vpc3RcXFwiLFxcXCJhcmd1bWVudHNcXFwiOlt7XFxcInZhcmlhYmxlXFxcIjpcXFwiLS1mb250LWdlaXN0LXNhbnNcXFwiLFxcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwiZ2Vpc3RTYW5zXFxcIn1cIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcXFwicGF0aFxcXCI6XFxcInNyYy9hcHAvbGF5b3V0LmpzeFxcXCIsXFxcImltcG9ydFxcXCI6XFxcIkdlaXN0X01vbm9cXFwiLFxcXCJhcmd1bWVudHNcXFwiOlt7XFxcInZhcmlhYmxlXFxcIjpcXFwiLS1mb250LWdlaXN0LW1vbm9cXFwiLFxcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwiZ2Vpc3RNb25vXFxcIn1cIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9zcmMvYXBwL2dsb2JhbHMuY3NzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJQcm92aWRlcnNcIl0gKi8gXCIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvUHJvdmlkZXJzLmpzeFwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-sans%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistSans%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-mono%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fcomponents%2FProviders.jsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/eventemitter3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/isomorphic-fetch/fetch-npm-browserify.js":
/*!***************************************************************!*\
  !*** ./node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(/*! whatwg-fetch */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js\");\nmodule.exports = self.fetch.bind(self);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLWZldGNoL2ZldGNoLW5wbS1icm93c2VyaWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQyx3R0FBYztBQUN0QiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLWZldGNoL2ZldGNoLW5wbS1icm93c2VyaWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoZSB3aGF0d2ctZmV0Y2ggcG9seWZpbGwgaW5zdGFsbHMgdGhlIGZldGNoKCkgZnVuY3Rpb25cbi8vIG9uIHRoZSBnbG9iYWwgb2JqZWN0ICh3aW5kb3cgb3Igc2VsZilcbi8vXG4vLyBSZXR1cm4gdGhhdCBhcyB0aGUgZXhwb3J0IGZvciB1c2UgaW4gV2VicGFjaywgQnJvd3NlcmlmeSBldGMuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaC5iaW5kKHNlbGYpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/isomorphic-fetch/fetch-npm-browserify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* globals self */ \nexports.Headers = self.Headers;\nexports.Request = self.Request;\nexports.Response = self.Response;\nexports.fetch = self.fetch;\n\n//# sourceMappingURL=whatwg-fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL2ZldGNoL3doYXR3Zy1mZXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBZ0M7QUFDaEMsZUFBZTtBQUNmLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsYUFBYTs7QUFFYiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL2ZldGNoL3doYXR3Zy1mZXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIHNlbGYgKi8gXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkhlYWRlcnMgPSBzZWxmLkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBzZWxmLlJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gc2VsZi5SZXNwb25zZTtcbmV4cG9ydHMuZmV0Y2ggPSBzZWxmLmZldGNoO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aGF0d2ctZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={413:(e,r,t)=>{var n=t(916);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},916:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(413);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs0MTM6KGUscix0KT0+e3ZhciBuPXQoOTE2KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDkxNjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNDEzKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js":
/*!**********************************************************!*\
  !*** ./node_modules/set-cookie-parser/lib/set-cookie.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else if (key === \"partitioned\") {\n      cookie.partitioned = true;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQSxzRUFBc0U7QUFDdEUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb01BQW9NLGNBQWM7QUFDbE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixpQ0FBaUMiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvc2V0LWNvb2tpZS1wYXJzZXIvbGliL3NldC1jb29raWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICBkZWNvZGVWYWx1ZXM6IHRydWUsXG4gIG1hcDogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IHNldENvb2tpZVZhbHVlLnNwbGl0KFwiO1wiKS5maWx0ZXIoaXNOb25FbXB0eVN0cmluZyk7XG5cbiAgdmFyIG5hbWVWYWx1ZVBhaXJTdHIgPSBwYXJ0cy5zaGlmdCgpO1xuICB2YXIgcGFyc2VkID0gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpO1xuICB2YXIgbmFtZSA9IHBhcnNlZC5uYW1lO1xuICB2YXIgdmFsdWUgPSBwYXJzZWQudmFsdWU7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIHRyeSB7XG4gICAgdmFsdWUgPSBvcHRpb25zLmRlY29kZVZhbHVlcyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTsgLy8gZGVjb2RlIGNvb2tpZSB2YWx1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgK1xuICAgICAgICB2YWx1ZSArXG4gICAgICAgIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgZVxuICAgICk7XG4gIH1cblxuICB2YXIgY29va2llID0ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICB9O1xuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB2YXIgc2lkZXMgPSBwYXJ0LnNwbGl0KFwiPVwiKTtcbiAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gc2lkZXMuam9pbihcIj1cIik7XG4gICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImh0dHBvbmx5XCIpIHtcbiAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgY29va2llLnNhbWVTaXRlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwicGFydGl0aW9uZWRcIikge1xuICAgICAgY29va2llLnBhcnRpdGlvbmVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29va2llW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb29raWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKSB7XG4gIC8vIFBhcnNlcyBuYW1lLXZhbHVlLXBhaXIgYWNjb3JkaW5nIHRvIHJmYzYyNjViaXMgZHJhZnRcblxuICB2YXIgbmFtZSA9IFwiXCI7XG4gIHZhciB2YWx1ZSA9IFwiXCI7XG4gIHZhciBuYW1lVmFsdWVBcnIgPSBuYW1lVmFsdWVQYWlyU3RyLnNwbGl0KFwiPVwiKTtcbiAgaWYgKG5hbWVWYWx1ZUFyci5sZW5ndGggPiAxKSB7XG4gICAgbmFtZSA9IG5hbWVWYWx1ZUFyci5zaGlmdCgpO1xuICAgIHZhbHVlID0gbmFtZVZhbHVlQXJyLmpvaW4oXCI9XCIpOyAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCA9LCBqb2luZWQgYnkgYSBcIj1cIiBpZiB0aGVyZSB3YXMgbW9yZSB0aGFuIG9uZSBwYXJ0XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyU3RyO1xuICB9XG5cbiAgcmV0dXJuIHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIWlucHV0KSB7XG4gICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIGZvciBmZXRjaCByZXNwb25zZXMgLSB0aGV5IGNvbWJpbmUgaGVhZGVycyBvZiB0aGUgc2FtZSB0eXBlIGluIHRoZSBoZWFkZXJzIGFycmF5LFxuICAgICAgLy8gYnV0IGdldFNldENvb2tpZSByZXR1cm5zIGFuIHVuY29tYmluZWQgYXJyYXlcbiAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUoKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgICAvLyBmYXN0LXBhdGggZm9yIG5vZGUuanMgKHdoaWNoIGF1dG9tYXRpY2FsbHkgbm9ybWFsaXplcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXItY2FzZVxuICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2xvdy1wYXRoIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBzZWUgIzI1XG4gICAgICB2YXIgc2NoID1cbiAgICAgICAgaW5wdXQuaGVhZGVyc1tcbiAgICAgICAgICBPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCI7XG4gICAgICAgICAgfSlcbiAgICAgICAgXTtcbiAgICAgIC8vIHdhcm4gaWYgY2FsbGVkIG9uIGEgcmVxdWVzdC1saWtlIG9iamVjdCB3aXRoIGEgY29va2llIGhlYWRlciByYXRoZXIgdGhhbiBhIHNldC1jb29raWUgaGVhZGVyIC0gc2VlICMzNCwgMzZcbiAgICAgIGlmICghc2NoICYmIGlucHV0LmhlYWRlcnMuY29va2llICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJXYXJuaW5nOiBzZXQtY29va2llLXBhcnNlciBhcHBlYXJzIHRvIGhhdmUgYmVlbiBjYWxsZWQgb24gYSByZXF1ZXN0IG9iamVjdC4gSXQgaXMgZGVzaWduZWQgdG8gcGFyc2UgU2V0LUNvb2tpZSBoZWFkZXJzIGZyb20gcmVzcG9uc2VzLCBub3QgQ29va2llIGhlYWRlcnMgZnJvbSByZXF1ZXN0cy4gU2V0IHRoZSBvcHRpb24ge3NpbGVudDogdHJ1ZX0gdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IHNjaDtcbiAgICB9XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlucHV0ID0gW2lucHV0XTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29va2llcyA9IHt9O1xuICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykucmVkdWNlKGZ1bmN0aW9uIChjb29raWVzLCBzdHIpIHtcbiAgICAgIHZhciBjb29raWUgPSBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgY29va2llc1tjb29raWUubmFtZV0gPSBjb29raWU7XG4gICAgICByZXR1cm4gY29va2llcztcbiAgICB9LCBjb29raWVzKTtcbiAgfVxufVxuXG4vKlxuICBTZXQtQ29va2llIGhlYWRlciBmaWVsZC12YWx1ZXMgYXJlIHNvbWV0aW1lcyBjb21tYSBqb2luZWQgaW4gb25lIHN0cmluZy4gVGhpcyBzcGxpdHMgdGhlbSB3aXRob3V0IGNob2tpbmcgb24gY29tbWFzXG4gIHRoYXQgYXJlIHdpdGhpbiBhIHNpbmdsZSBzZXQtY29va2llIGZpZWxkLXZhbHVlLCBzdWNoIGFzIGluIHRoZSBFeHBpcmVzIHBvcnRpb24uXG5cbiAgVGhpcyBpcyB1bmNvbW1vbiwgYnV0IGV4cGxpY2l0bHkgYWxsb3dlZCAtIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNiNzZWN0aW9uLTQuMlxuICBOb2RlLmpzIGRvZXMgdGhpcyBmb3IgZXZlcnkgaGVhZGVyICpleGNlcHQqIHNldC1jb29raWUgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZDVlMzYzYjc3ZWJhZjFjYWY2N2NkNzUyODIyNGI2NTFjODY4MTVjMS9saWIvX2h0dHBfaW5jb21pbmcuanMjTDEyOFxuICBSZWFjdCBOYXRpdmUncyBmZXRjaCBkb2VzIHRoaXMgZm9yICpldmVyeSogaGVhZGVyLCBpbmNsdWRpbmcgc2V0LWNvb2tpZS5cblxuICBCYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9qMm9iamMvY29tbWl0LzE2ODIwZmRiYzhmNzZjYTBjMzM0NzI4MTBjZTBjYjAzZDIwZWZlMjVcbiAgQ3JlZGl0cyB0bzogaHR0cHM6Ly9naXRodWIuY29tL3RvbWJhbGwgZm9yIG9yaWdpbmFsIGFuZCBodHRwczovL2dpdGh1Yi5jb20vY2hydXNhcnQgZm9yIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiovXG5mdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llc1N0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzU3RyaW5nKSkge1xuICAgIHJldHVybiBjb29raWVzU3RyaW5nO1xuICB9XG4gIGlmICh0eXBlb2YgY29va2llc1N0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgY2g7XG4gIHZhciBsYXN0Q29tbWE7XG4gIHZhciBuZXh0U3RhcnQ7XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG5cbiAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gIH1cblxuICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHBvcztcbiAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICBpZiAoY2ggPT09IFwiLFwiKSB7XG4gICAgICAgIC8vICcsJyBpcyBhIGNvb2tpZSBzZXBhcmF0b3IgaWYgd2UgaGF2ZSBsYXRlciBmaXJzdCAnPScsIG5vdCAnOycgb3IgJywnXG4gICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgcG9zICs9IDE7XG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50bHkgc3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgLy8gd2UgZm91bmQgY29va2llcyBzZXBhcmF0b3JcbiAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgIC8vIHBvcyBpcyBpbnNpZGUgdGhlIG5leHQgY29va2llLCBzbyBiYWNrIHVwIGFuZCByZXR1cm4gaXQuXG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHBhcmFtICcsJyBvciBwYXJhbSBzZXBhcmF0b3IgJzsnLFxuICAgICAgICAgIC8vIHdlIGNvbnRpbnVlIGZyb20gdGhhdCBjb21tYVxuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29va2llc1N0cmluZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbm1vZHVsZS5leHBvcnRzLnNwbGl0Q29va2llc1N0cmluZyA9IHNwbGl0Q29va2llc1N0cmluZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/index.js":
/*!***************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastPathLookup: () => (/* reexport safe */ _src_lookup_fast_path__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   getEmptyResult: () => (/* reexport safe */ _src_factory__WEBPACK_IMPORTED_MODULE_0__.getEmptyResult),\n/* harmony export */   parseImpl: () => (/* reexport safe */ _src_factory__WEBPACK_IMPORTED_MODULE_0__.parseImpl),\n/* harmony export */   resetResult: () => (/* reexport safe */ _src_factory__WEBPACK_IMPORTED_MODULE_0__.resetResult),\n/* harmony export */   setDefaults: () => (/* reexport safe */ _src_options__WEBPACK_IMPORTED_MODULE_2__.setDefaults)\n/* harmony export */ });\n/* harmony import */ var _src_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/factory */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/factory.js\");\n/* harmony import */ var _src_lookup_fast_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/lookup/fast-path */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/lookup/fast-path.js\");\n/* harmony import */ var _src_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/options */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/options.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdFO0FBQ0w7QUFDdkI7QUFDNUMiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMtY29yZS9kaXN0L2VzNi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBwYXJzZUltcGwsIGdldEVtcHR5UmVzdWx0LCByZXNldFJlc3VsdCwgfSBmcm9tICcuL3NyYy9mYWN0b3J5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmFzdFBhdGhMb29rdXAgfSBmcm9tICcuL3NyYy9sb29rdXAvZmFzdC1wYXRoJztcbmV4cG9ydCB7IHNldERlZmF1bHRzIH0gZnJvbSAnLi9zcmMvb3B0aW9ucyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/domain-without-suffix.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/domain-without-suffix.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getDomainWithoutSuffix)\n/* harmony export */ });\n/**\n * Return the part of domain without suffix.\n *\n * Example: for domain 'foo.com', the result would be 'foo'.\n */\nfunction getDomainWithoutSuffix(domain, suffix) {\n    // Note: here `domain` and `suffix` cannot have the same length because in\n    // this case we set `domain` to `null` instead. It is thus safe to assume\n    // that `suffix` is shorter than `domain`.\n    return domain.slice(0, -suffix.length - 1);\n}\n//# sourceMappingURL=domain-without-suffix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9kb21haW4td2l0aG91dC1zdWZmaXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9kb21haW4td2l0aG91dC1zdWZmaXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXR1cm4gdGhlIHBhcnQgb2YgZG9tYWluIHdpdGhvdXQgc3VmZml4LlxuICpcbiAqIEV4YW1wbGU6IGZvciBkb21haW4gJ2Zvby5jb20nLCB0aGUgcmVzdWx0IHdvdWxkIGJlICdmb28nLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb21haW5XaXRob3V0U3VmZml4KGRvbWFpbiwgc3VmZml4KSB7XG4gICAgLy8gTm90ZTogaGVyZSBgZG9tYWluYCBhbmQgYHN1ZmZpeGAgY2Fubm90IGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGJlY2F1c2UgaW5cbiAgICAvLyB0aGlzIGNhc2Ugd2Ugc2V0IGBkb21haW5gIHRvIGBudWxsYCBpbnN0ZWFkLiBJdCBpcyB0aHVzIHNhZmUgdG8gYXNzdW1lXG4gICAgLy8gdGhhdCBgc3VmZml4YCBpcyBzaG9ydGVyIHRoYW4gYGRvbWFpbmAuXG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgwLCAtc3VmZml4Lmxlbmd0aCAtIDEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tYWluLXdpdGhvdXQtc3VmZml4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/domain-without-suffix.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/domain.js":
/*!********************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/domain.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getDomain)\n/* harmony export */ });\n/**\n * Check if `vhost` is a valid suffix of `hostname` (top-domain)\n *\n * It means that `vhost` needs to be a suffix of `hostname` and we then need to\n * make sure that: either they are equal, or the character preceding `vhost` in\n * `hostname` is a '.' (it should not be a partial label).\n *\n * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok\n * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok\n * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok\n */\nfunction shareSameDomainSuffix(hostname, vhost) {\n    if (hostname.endsWith(vhost)) {\n        return (hostname.length === vhost.length ||\n            hostname[hostname.length - vhost.length - 1] === '.');\n    }\n    return false;\n}\n/**\n * Given a hostname and its public suffix, extract the general domain.\n */\nfunction extractDomainWithSuffix(hostname, publicSuffix) {\n    // Locate the index of the last '.' in the part of the `hostname` preceding\n    // the public suffix.\n    //\n    // examples:\n    //   1. not.evil.co.uk  => evil.co.uk\n    //         ^    ^\n    //         |    | start of public suffix\n    //         | index of the last dot\n    //\n    //   2. example.co.uk   => example.co.uk\n    //     ^       ^\n    //     |       | start of public suffix\n    //     |\n    //     | (-1) no dot found before the public suffix\n    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;\n    const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);\n    // No '.' found, then `hostname` is the general domain (no sub-domain)\n    if (lastDotBeforeSuffixIndex === -1) {\n        return hostname;\n    }\n    // Extract the part between the last '.'\n    return hostname.slice(lastDotBeforeSuffixIndex + 1);\n}\n/**\n * Detects the domain based on rules and upon and a host string\n */\nfunction getDomain(suffix, hostname, options) {\n    // Check if `hostname` ends with a member of `validHosts`.\n    if (options.validHosts !== null) {\n        const validHosts = options.validHosts;\n        for (const vhost of validHosts) {\n            if ( /*@__INLINE__*/shareSameDomainSuffix(hostname, vhost)) {\n                return vhost;\n            }\n        }\n    }\n    let numberOfLeadingDots = 0;\n    if (hostname.startsWith('.')) {\n        while (numberOfLeadingDots < hostname.length &&\n            hostname[numberOfLeadingDots] === '.') {\n            numberOfLeadingDots += 1;\n        }\n    }\n    // If `hostname` is a valid public suffix, then there is no domain to return.\n    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`\n    // there is no need to perform a string comparison and we only compare the\n    // size.\n    if (suffix.length === hostname.length - numberOfLeadingDots) {\n        return null;\n    }\n    // To extract the general domain, we start by identifying the public suffix\n    // (if any), then consider the domain to be the public suffix with one added\n    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:\n    // `co.uk`, then we take one more level: `evil`, giving the final result:\n    // `evil.co.uk`).\n    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);\n}\n//# sourceMappingURL=domain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9kb21haW4uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMtY29yZS9kaXN0L2VzNi9zcmMvZG9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2sgaWYgYHZob3N0YCBpcyBhIHZhbGlkIHN1ZmZpeCBvZiBgaG9zdG5hbWVgICh0b3AtZG9tYWluKVxuICpcbiAqIEl0IG1lYW5zIHRoYXQgYHZob3N0YCBuZWVkcyB0byBiZSBhIHN1ZmZpeCBvZiBgaG9zdG5hbWVgIGFuZCB3ZSB0aGVuIG5lZWQgdG9cbiAqIG1ha2Ugc3VyZSB0aGF0OiBlaXRoZXIgdGhleSBhcmUgZXF1YWwsIG9yIHRoZSBjaGFyYWN0ZXIgcHJlY2VkaW5nIGB2aG9zdGAgaW5cbiAqIGBob3N0bmFtZWAgaXMgYSAnLicgKGl0IHNob3VsZCBub3QgYmUgYSBwYXJ0aWFsIGxhYmVsKS5cbiAqXG4gKiAqIGhvc3RuYW1lID0gJ25vdC5ldmlsLmNvbScgYW5kIHZob3N0ID0gJ3ZpbC5jb20nICAgICAgPT4gbm90IG9rXG4gKiAqIGhvc3RuYW1lID0gJ25vdC5ldmlsLmNvbScgYW5kIHZob3N0ID0gJ2V2aWwuY29tJyAgICAgPT4gb2tcbiAqICogaG9zdG5hbWUgPSAnbm90LmV2aWwuY29tJyBhbmQgdmhvc3QgPSAnbm90LmV2aWwuY29tJyA9PiBva1xuICovXG5mdW5jdGlvbiBzaGFyZVNhbWVEb21haW5TdWZmaXgoaG9zdG5hbWUsIHZob3N0KSB7XG4gICAgaWYgKGhvc3RuYW1lLmVuZHNXaXRoKHZob3N0KSkge1xuICAgICAgICByZXR1cm4gKGhvc3RuYW1lLmxlbmd0aCA9PT0gdmhvc3QubGVuZ3RoIHx8XG4gICAgICAgICAgICBob3N0bmFtZVtob3N0bmFtZS5sZW5ndGggLSB2aG9zdC5sZW5ndGggLSAxXSA9PT0gJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBHaXZlbiBhIGhvc3RuYW1lIGFuZCBpdHMgcHVibGljIHN1ZmZpeCwgZXh0cmFjdCB0aGUgZ2VuZXJhbCBkb21haW4uXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3REb21haW5XaXRoU3VmZml4KGhvc3RuYW1lLCBwdWJsaWNTdWZmaXgpIHtcbiAgICAvLyBMb2NhdGUgdGhlIGluZGV4IG9mIHRoZSBsYXN0ICcuJyBpbiB0aGUgcGFydCBvZiB0aGUgYGhvc3RuYW1lYCBwcmVjZWRpbmdcbiAgICAvLyB0aGUgcHVibGljIHN1ZmZpeC5cbiAgICAvL1xuICAgIC8vIGV4YW1wbGVzOlxuICAgIC8vICAgMS4gbm90LmV2aWwuY28udWsgID0+IGV2aWwuY28udWtcbiAgICAvLyAgICAgICAgIF4gICAgXlxuICAgIC8vICAgICAgICAgfCAgICB8IHN0YXJ0IG9mIHB1YmxpYyBzdWZmaXhcbiAgICAvLyAgICAgICAgIHwgaW5kZXggb2YgdGhlIGxhc3QgZG90XG4gICAgLy9cbiAgICAvLyAgIDIuIGV4YW1wbGUuY28udWsgICA9PiBleGFtcGxlLmNvLnVrXG4gICAgLy8gICAgIF4gICAgICAgXlxuICAgIC8vICAgICB8ICAgICAgIHwgc3RhcnQgb2YgcHVibGljIHN1ZmZpeFxuICAgIC8vICAgICB8XG4gICAgLy8gICAgIHwgKC0xKSBubyBkb3QgZm91bmQgYmVmb3JlIHRoZSBwdWJsaWMgc3VmZml4XG4gICAgY29uc3QgcHVibGljU3VmZml4SW5kZXggPSBob3N0bmFtZS5sZW5ndGggLSBwdWJsaWNTdWZmaXgubGVuZ3RoIC0gMjtcbiAgICBjb25zdCBsYXN0RG90QmVmb3JlU3VmZml4SW5kZXggPSBob3N0bmFtZS5sYXN0SW5kZXhPZignLicsIHB1YmxpY1N1ZmZpeEluZGV4KTtcbiAgICAvLyBObyAnLicgZm91bmQsIHRoZW4gYGhvc3RuYW1lYCBpcyB0aGUgZ2VuZXJhbCBkb21haW4gKG5vIHN1Yi1kb21haW4pXG4gICAgaWYgKGxhc3REb3RCZWZvcmVTdWZmaXhJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGhvc3RuYW1lO1xuICAgIH1cbiAgICAvLyBFeHRyYWN0IHRoZSBwYXJ0IGJldHdlZW4gdGhlIGxhc3QgJy4nXG4gICAgcmV0dXJuIGhvc3RuYW1lLnNsaWNlKGxhc3REb3RCZWZvcmVTdWZmaXhJbmRleCArIDEpO1xufVxuLyoqXG4gKiBEZXRlY3RzIHRoZSBkb21haW4gYmFzZWQgb24gcnVsZXMgYW5kIHVwb24gYW5kIGEgaG9zdCBzdHJpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9tYWluKHN1ZmZpeCwgaG9zdG5hbWUsIG9wdGlvbnMpIHtcbiAgICAvLyBDaGVjayBpZiBgaG9zdG5hbWVgIGVuZHMgd2l0aCBhIG1lbWJlciBvZiBgdmFsaWRIb3N0c2AuXG4gICAgaWYgKG9wdGlvbnMudmFsaWRIb3N0cyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB2YWxpZEhvc3RzID0gb3B0aW9ucy52YWxpZEhvc3RzO1xuICAgICAgICBmb3IgKGNvbnN0IHZob3N0IG9mIHZhbGlkSG9zdHMpIHtcbiAgICAgICAgICAgIGlmICggLypAX19JTkxJTkVfXyovc2hhcmVTYW1lRG9tYWluU3VmZml4KGhvc3RuYW1lLCB2aG9zdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG51bWJlck9mTGVhZGluZ0RvdHMgPSAwO1xuICAgIGlmIChob3N0bmFtZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgd2hpbGUgKG51bWJlck9mTGVhZGluZ0RvdHMgPCBob3N0bmFtZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGhvc3RuYW1lW251bWJlck9mTGVhZGluZ0RvdHNdID09PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlck9mTGVhZGluZ0RvdHMgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBgaG9zdG5hbWVgIGlzIGEgdmFsaWQgcHVibGljIHN1ZmZpeCwgdGhlbiB0aGVyZSBpcyBubyBkb21haW4gdG8gcmV0dXJuLlxuICAgIC8vIFNpbmNlIHdlIGFscmVhZHkga25vdyB0aGF0IGBnZXRQdWJsaWNTdWZmaXhgIHJldHVybnMgYSBzdWZmaXggb2YgYGhvc3RuYW1lYFxuICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gcGVyZm9ybSBhIHN0cmluZyBjb21wYXJpc29uIGFuZCB3ZSBvbmx5IGNvbXBhcmUgdGhlXG4gICAgLy8gc2l6ZS5cbiAgICBpZiAoc3VmZml4Lmxlbmd0aCA9PT0gaG9zdG5hbWUubGVuZ3RoIC0gbnVtYmVyT2ZMZWFkaW5nRG90cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVG8gZXh0cmFjdCB0aGUgZ2VuZXJhbCBkb21haW4sIHdlIHN0YXJ0IGJ5IGlkZW50aWZ5aW5nIHRoZSBwdWJsaWMgc3VmZml4XG4gICAgLy8gKGlmIGFueSksIHRoZW4gY29uc2lkZXIgdGhlIGRvbWFpbiB0byBiZSB0aGUgcHVibGljIHN1ZmZpeCB3aXRoIG9uZSBhZGRlZFxuICAgIC8vIGxldmVsIG9mIGRlcHRoLiAoZS5nLjogaWYgaG9zdG5hbWUgaXMgYG5vdC5ldmlsLmNvLnVrYCBhbmQgcHVibGljIHN1ZmZpeDpcbiAgICAvLyBgY28udWtgLCB0aGVuIHdlIHRha2Ugb25lIG1vcmUgbGV2ZWw6IGBldmlsYCwgZ2l2aW5nIHRoZSBmaW5hbCByZXN1bHQ6XG4gICAgLy8gYGV2aWwuY28udWtgKS5cbiAgICByZXR1cm4gLypAX19JTkxJTkVfXyovIGV4dHJhY3REb21haW5XaXRoU3VmZml4KGhvc3RuYW1lLCBzdWZmaXgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tYWluLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/domain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/extract-hostname.js":
/*!******************************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/extract-hostname.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ extractHostname)\n/* harmony export */ });\n/**\n * @param url - URL we want to extract a hostname from.\n * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.\n */\nfunction extractHostname(url, urlIsValidHostname) {\n    let start = 0;\n    let end = url.length;\n    let hasUpper = false;\n    // If url is not already a valid hostname, then try to extract hostname.\n    if (!urlIsValidHostname) {\n        // Special handling of data URLs\n        if (url.startsWith('data:')) {\n            return null;\n        }\n        // Trim leading spaces\n        while (start < url.length && url.charCodeAt(start) <= 32) {\n            start += 1;\n        }\n        // Trim trailing spaces\n        while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {\n            end -= 1;\n        }\n        // Skip scheme.\n        if (url.charCodeAt(start) === 47 /* '/' */ &&\n            url.charCodeAt(start + 1) === 47 /* '/' */) {\n            start += 2;\n        }\n        else {\n            const indexOfProtocol = url.indexOf(':/', start);\n            if (indexOfProtocol !== -1) {\n                // Implement fast-path for common protocols. We expect most protocols\n                // should be one of these 4 and thus we will not need to perform the\n                // more expansive validity check most of the time.\n                const protocolSize = indexOfProtocol - start;\n                const c0 = url.charCodeAt(start);\n                const c1 = url.charCodeAt(start + 1);\n                const c2 = url.charCodeAt(start + 2);\n                const c3 = url.charCodeAt(start + 3);\n                const c4 = url.charCodeAt(start + 4);\n                if (protocolSize === 5 &&\n                    c0 === 104 /* 'h' */ &&\n                    c1 === 116 /* 't' */ &&\n                    c2 === 116 /* 't' */ &&\n                    c3 === 112 /* 'p' */ &&\n                    c4 === 115 /* 's' */) {\n                    // https\n                }\n                else if (protocolSize === 4 &&\n                    c0 === 104 /* 'h' */ &&\n                    c1 === 116 /* 't' */ &&\n                    c2 === 116 /* 't' */ &&\n                    c3 === 112 /* 'p' */) {\n                    // http\n                }\n                else if (protocolSize === 3 &&\n                    c0 === 119 /* 'w' */ &&\n                    c1 === 115 /* 's' */ &&\n                    c2 === 115 /* 's' */) {\n                    // wss\n                }\n                else if (protocolSize === 2 &&\n                    c0 === 119 /* 'w' */ &&\n                    c1 === 115 /* 's' */) {\n                    // ws\n                }\n                else {\n                    // Check that scheme is valid\n                    for (let i = start; i < indexOfProtocol; i += 1) {\n                        const lowerCaseCode = url.charCodeAt(i) | 32;\n                        if (!(((lowerCaseCode >= 97 && lowerCaseCode <= 122) || // [a, z]\n                            (lowerCaseCode >= 48 && lowerCaseCode <= 57) || // [0, 9]\n                            lowerCaseCode === 46 || // '.'\n                            lowerCaseCode === 45 || // '-'\n                            lowerCaseCode === 43) // '+'\n                        )) {\n                            return null;\n                        }\n                    }\n                }\n                // Skip 0, 1 or more '/' after ':/'\n                start = indexOfProtocol + 2;\n                while (url.charCodeAt(start) === 47 /* '/' */) {\n                    start += 1;\n                }\n            }\n        }\n        // Detect first occurrence of '/', '?' or '#'. We also keep track of the\n        // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of\n        // (respectively), identifier, ipv6 or port.\n        let indexOfIdentifier = -1;\n        let indexOfClosingBracket = -1;\n        let indexOfPort = -1;\n        for (let i = start; i < end; i += 1) {\n            const code = url.charCodeAt(i);\n            if (code === 35 || // '#'\n                code === 47 || // '/'\n                code === 63 // '?'\n            ) {\n                end = i;\n                break;\n            }\n            else if (code === 64) {\n                // '@'\n                indexOfIdentifier = i;\n            }\n            else if (code === 93) {\n                // ']'\n                indexOfClosingBracket = i;\n            }\n            else if (code === 58) {\n                // ':'\n                indexOfPort = i;\n            }\n            else if (code >= 65 && code <= 90) {\n                hasUpper = true;\n            }\n        }\n        // Detect identifier: '@'\n        if (indexOfIdentifier !== -1 &&\n            indexOfIdentifier > start &&\n            indexOfIdentifier < end) {\n            start = indexOfIdentifier + 1;\n        }\n        // Handle ipv6 addresses\n        if (url.charCodeAt(start) === 91 /* '[' */) {\n            if (indexOfClosingBracket !== -1) {\n                return url.slice(start + 1, indexOfClosingBracket).toLowerCase();\n            }\n            return null;\n        }\n        else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {\n            // Detect port: ':'\n            end = indexOfPort;\n        }\n    }\n    // Trim trailing dots\n    while (end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */) {\n        end -= 1;\n    }\n    const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;\n    if (hasUpper) {\n        return hostname.toLowerCase();\n    }\n    return hostname;\n}\n//# sourceMappingURL=extract-hostname.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9leHRyYWN0LWhvc3RuYW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RsZHRzLWNvcmUvZGlzdC9lczYvc3JjL2V4dHJhY3QtaG9zdG5hbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFyYW0gdXJsIC0gVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBhIGhvc3RuYW1lIGZyb20uXG4gKiBAcGFyYW0gdXJsSXNWYWxpZEhvc3RuYW1lIC0gaGludCBmcm9tIGNhbGxlcjsgdHJ1ZSBpZiBgdXJsYCBpcyBhbHJlYWR5IGEgdmFsaWQgaG9zdG5hbWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4dHJhY3RIb3N0bmFtZSh1cmwsIHVybElzVmFsaWRIb3N0bmFtZSkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IHVybC5sZW5ndGg7XG4gICAgbGV0IGhhc1VwcGVyID0gZmFsc2U7XG4gICAgLy8gSWYgdXJsIGlzIG5vdCBhbHJlYWR5IGEgdmFsaWQgaG9zdG5hbWUsIHRoZW4gdHJ5IHRvIGV4dHJhY3QgaG9zdG5hbWUuXG4gICAgaWYgKCF1cmxJc1ZhbGlkSG9zdG5hbWUpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBvZiBkYXRhIFVSTHNcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIGxlYWRpbmcgc3BhY2VzXG4gICAgICAgIHdoaWxlIChzdGFydCA8IHVybC5sZW5ndGggJiYgdXJsLmNoYXJDb2RlQXQoc3RhcnQpIDw9IDMyKSB7XG4gICAgICAgICAgICBzdGFydCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyaW0gdHJhaWxpbmcgc3BhY2VzXG4gICAgICAgIHdoaWxlIChlbmQgPiBzdGFydCArIDEgJiYgdXJsLmNoYXJDb2RlQXQoZW5kIC0gMSkgPD0gMzIpIHtcbiAgICAgICAgICAgIGVuZCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgc2NoZW1lLlxuICAgICAgICBpZiAodXJsLmNoYXJDb2RlQXQoc3RhcnQpID09PSA0NyAvKiAnLycgKi8gJiZcbiAgICAgICAgICAgIHVybC5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgPT09IDQ3IC8qICcvJyAqLykge1xuICAgICAgICAgICAgc3RhcnQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZQcm90b2NvbCA9IHVybC5pbmRleE9mKCc6LycsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChpbmRleE9mUHJvdG9jb2wgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGVtZW50IGZhc3QtcGF0aCBmb3IgY29tbW9uIHByb3RvY29scy4gV2UgZXhwZWN0IG1vc3QgcHJvdG9jb2xzXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG9uZSBvZiB0aGVzZSA0IGFuZCB0aHVzIHdlIHdpbGwgbm90IG5lZWQgdG8gcGVyZm9ybSB0aGVcbiAgICAgICAgICAgICAgICAvLyBtb3JlIGV4cGFuc2l2ZSB2YWxpZGl0eSBjaGVjayBtb3N0IG9mIHRoZSB0aW1lLlxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3RvY29sU2l6ZSA9IGluZGV4T2ZQcm90b2NvbCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGMwID0gdXJsLmNoYXJDb2RlQXQoc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMxID0gdXJsLmNoYXJDb2RlQXQoc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjMiA9IHVybC5jaGFyQ29kZUF0KHN0YXJ0ICsgMik7XG4gICAgICAgICAgICAgICAgY29uc3QgYzMgPSB1cmwuY2hhckNvZGVBdChzdGFydCArIDMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGM0ID0gdXJsLmNoYXJDb2RlQXQoc3RhcnQgKyA0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdG9jb2xTaXplID09PSA1ICYmXG4gICAgICAgICAgICAgICAgICAgIGMwID09PSAxMDQgLyogJ2gnICovICYmXG4gICAgICAgICAgICAgICAgICAgIGMxID09PSAxMTYgLyogJ3QnICovICYmXG4gICAgICAgICAgICAgICAgICAgIGMyID09PSAxMTYgLyogJ3QnICovICYmXG4gICAgICAgICAgICAgICAgICAgIGMzID09PSAxMTIgLyogJ3AnICovICYmXG4gICAgICAgICAgICAgICAgICAgIGM0ID09PSAxMTUgLyogJ3MnICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvY29sU2l6ZSA9PT0gNCAmJlxuICAgICAgICAgICAgICAgICAgICBjMCA9PT0gMTA0IC8qICdoJyAqLyAmJlxuICAgICAgICAgICAgICAgICAgICBjMSA9PT0gMTE2IC8qICd0JyAqLyAmJlxuICAgICAgICAgICAgICAgICAgICBjMiA9PT0gMTE2IC8qICd0JyAqLyAmJlxuICAgICAgICAgICAgICAgICAgICBjMyA9PT0gMTEyIC8qICdwJyAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvY29sU2l6ZSA9PT0gMyAmJlxuICAgICAgICAgICAgICAgICAgICBjMCA9PT0gMTE5IC8qICd3JyAqLyAmJlxuICAgICAgICAgICAgICAgICAgICBjMSA9PT0gMTE1IC8qICdzJyAqLyAmJlxuICAgICAgICAgICAgICAgICAgICBjMiA9PT0gMTE1IC8qICdzJyAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyB3c3NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdG9jb2xTaXplID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIGMwID09PSAxMTkgLyogJ3cnICovICYmXG4gICAgICAgICAgICAgICAgICAgIGMxID09PSAxMTUgLyogJ3MnICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHNjaGVtZSBpcyB2YWxpZFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBpbmRleE9mUHJvdG9jb2w7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJDYXNlQ29kZSA9IHVybC5jaGFyQ29kZUF0KGkpIHwgMzI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoKGxvd2VyQ2FzZUNvZGUgPj0gOTcgJiYgbG93ZXJDYXNlQ29kZSA8PSAxMjIpIHx8IC8vIFthLCB6XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb3dlckNhc2VDb2RlID49IDQ4ICYmIGxvd2VyQ2FzZUNvZGUgPD0gNTcpIHx8IC8vIFswLCA5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyQ2FzZUNvZGUgPT09IDQ2IHx8IC8vICcuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyQ2FzZUNvZGUgPT09IDQ1IHx8IC8vICctJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyQ2FzZUNvZGUgPT09IDQzKSAvLyAnKydcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTa2lwIDAsIDEgb3IgbW9yZSAnLycgYWZ0ZXIgJzovJ1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXhPZlByb3RvY29sICsgMjtcbiAgICAgICAgICAgICAgICB3aGlsZSAodXJsLmNoYXJDb2RlQXQoc3RhcnQpID09PSA0NyAvKiAnLycgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZWN0IGZpcnN0IG9jY3VycmVuY2Ugb2YgJy8nLCAnPycgb3IgJyMnLiBXZSBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlXG4gICAgICAgIC8vIGxhc3Qgb2NjdXJyZW5jZSBvZiAnQCcsICddJyBvciAnOicgdG8gc3BlZWQtdXAgc3Vic2VxdWVudCBwYXJzaW5nIG9mXG4gICAgICAgIC8vIChyZXNwZWN0aXZlbHkpLCBpZGVudGlmaWVyLCBpcHY2IG9yIHBvcnQuXG4gICAgICAgIGxldCBpbmRleE9mSWRlbnRpZmllciA9IC0xO1xuICAgICAgICBsZXQgaW5kZXhPZkNsb3NpbmdCcmFja2V0ID0gLTE7XG4gICAgICAgIGxldCBpbmRleE9mUG9ydCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHVybC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDM1IHx8IC8vICcjJ1xuICAgICAgICAgICAgICAgIGNvZGUgPT09IDQ3IHx8IC8vICcvJ1xuICAgICAgICAgICAgICAgIGNvZGUgPT09IDYzIC8vICc/J1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgLy8gJ0AnXG4gICAgICAgICAgICAgICAgaW5kZXhPZklkZW50aWZpZXIgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gOTMpIHtcbiAgICAgICAgICAgICAgICAvLyAnXSdcbiAgICAgICAgICAgICAgICBpbmRleE9mQ2xvc2luZ0JyYWNrZXQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gNTgpIHtcbiAgICAgICAgICAgICAgICAvLyAnOidcbiAgICAgICAgICAgICAgICBpbmRleE9mUG9ydCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgICAgICBoYXNVcHBlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZWN0IGlkZW50aWZpZXI6ICdAJ1xuICAgICAgICBpZiAoaW5kZXhPZklkZW50aWZpZXIgIT09IC0xICYmXG4gICAgICAgICAgICBpbmRleE9mSWRlbnRpZmllciA+IHN0YXJ0ICYmXG4gICAgICAgICAgICBpbmRleE9mSWRlbnRpZmllciA8IGVuZCkge1xuICAgICAgICAgICAgc3RhcnQgPSBpbmRleE9mSWRlbnRpZmllciArIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlwdjYgYWRkcmVzc2VzXG4gICAgICAgIGlmICh1cmwuY2hhckNvZGVBdChzdGFydCkgPT09IDkxIC8qICdbJyAqLykge1xuICAgICAgICAgICAgaWYgKGluZGV4T2ZDbG9zaW5nQnJhY2tldCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsLnNsaWNlKHN0YXJ0ICsgMSwgaW5kZXhPZkNsb3NpbmdCcmFja2V0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhPZlBvcnQgIT09IC0xICYmIGluZGV4T2ZQb3J0ID4gc3RhcnQgJiYgaW5kZXhPZlBvcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCBwb3J0OiAnOidcbiAgICAgICAgICAgIGVuZCA9IGluZGV4T2ZQb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyaW0gdHJhaWxpbmcgZG90c1xuICAgIHdoaWxlIChlbmQgPiBzdGFydCArIDEgJiYgdXJsLmNoYXJDb2RlQXQoZW5kIC0gMSkgPT09IDQ2IC8qICcuJyAqLykge1xuICAgICAgICBlbmQgLT0gMTtcbiAgICB9XG4gICAgY29uc3QgaG9zdG5hbWUgPSBzdGFydCAhPT0gMCB8fCBlbmQgIT09IHVybC5sZW5ndGggPyB1cmwuc2xpY2Uoc3RhcnQsIGVuZCkgOiB1cmw7XG4gICAgaWYgKGhhc1VwcGVyKSB7XG4gICAgICAgIHJldHVybiBob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdG5hbWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0LWhvc3RuYW1lLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/extract-hostname.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/factory.js":
/*!*********************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/factory.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEmptyResult: () => (/* binding */ getEmptyResult),\n/* harmony export */   parseImpl: () => (/* binding */ parseImpl),\n/* harmony export */   resetResult: () => (/* binding */ resetResult)\n/* harmony export */ });\n/* harmony import */ var _domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domain */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/domain.js\");\n/* harmony import */ var _domain_without_suffix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domain-without-suffix */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/domain-without-suffix.js\");\n/* harmony import */ var _extract_hostname__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extract-hostname */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/extract-hostname.js\");\n/* harmony import */ var _is_ip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-ip */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/is-ip.js\");\n/* harmony import */ var _is_valid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is-valid */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/is-valid.js\");\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./options */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/options.js\");\n/* harmony import */ var _subdomain__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./subdomain */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/subdomain.js\");\n/**\n * Implement a factory allowing to plug different implementations of suffix\n * lookup (e.g.: using a trie or the packed hashes datastructures). This is used\n * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.\n */\n\n\n\n\n\n\n\nfunction getEmptyResult() {\n    return {\n        domain: null,\n        domainWithoutSuffix: null,\n        hostname: null,\n        isIcann: null,\n        isIp: null,\n        isPrivate: null,\n        publicSuffix: null,\n        subdomain: null,\n    };\n}\nfunction resetResult(result) {\n    result.domain = null;\n    result.domainWithoutSuffix = null;\n    result.hostname = null;\n    result.isIcann = null;\n    result.isIp = null;\n    result.isPrivate = null;\n    result.publicSuffix = null;\n    result.subdomain = null;\n}\nfunction parseImpl(url, step, suffixLookup, partialOptions, result) {\n    const options = /*@__INLINE__*/ (0,_options__WEBPACK_IMPORTED_MODULE_5__.setDefaults)(partialOptions);\n    // Very fast approximate check to make sure `url` is a string. This is needed\n    // because the library will not necessarily be used in a typed setup and\n    // values of arbitrary types might be given as argument.\n    if (typeof url !== 'string') {\n        return result;\n    }\n    // Extract hostname from `url` only if needed. This can be made optional\n    // using `options.extractHostname`. This option will typically be used\n    // whenever we are sure the inputs to `parse` are already hostnames and not\n    // arbitrary URLs.\n    //\n    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames\n    // as input. If only hostnames are expected then `extractHostname` can be\n    // set to `false` to speed-up parsing. If only URLs are expected then\n    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint\n    // and will not change the behavior of the library.\n    if (!options.extractHostname) {\n        result.hostname = url;\n    }\n    else if (options.mixedInputs) {\n        result.hostname = (0,_extract_hostname__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(url, (0,_is_valid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(url));\n    }\n    else {\n        result.hostname = (0,_extract_hostname__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(url, false);\n    }\n    if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {\n        return result;\n    }\n    // Check if `hostname` is a valid ip address\n    if (options.detectIp) {\n        result.isIp = (0,_is_ip__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(result.hostname);\n        if (result.isIp) {\n            return result;\n        }\n    }\n    // Perform optional hostname validation. If hostname is not valid, no need to\n    // go further as there will be no valid domain or sub-domain.\n    if (options.validateHostname &&\n        options.extractHostname &&\n        !(0,_is_valid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(result.hostname)) {\n        result.hostname = null;\n        return result;\n    }\n    // Extract public suffix\n    suffixLookup(result.hostname, options, result);\n    if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {\n        return result;\n    }\n    // Extract domain\n    result.domain = (0,_domain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(result.publicSuffix, result.hostname, options);\n    if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {\n        return result;\n    }\n    // Extract subdomain\n    result.subdomain = (0,_subdomain__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(result.hostname, result.domain);\n    if (step === 4 /* FLAG.SUB_DOMAIN */) {\n        return result;\n    }\n    // Extract domain without suffix\n    result.domainWithoutSuffix = (0,_domain_without_suffix__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(result.domain, result.publicSuffix);\n    return result;\n}\n//# sourceMappingURL=factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lDO0FBQzRCO0FBQ1o7QUFDdEI7QUFDYztBQUNEO0FBQ0Q7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9DQUFvQyxxREFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZEQUFlLE1BQU0scURBQWU7QUFDOUQ7QUFDQTtBQUNBLDBCQUEwQiw2REFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscURBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtFQUFzQjtBQUN2RDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMtY29yZS9kaXN0L2VzNi9zcmMvZmFjdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEltcGxlbWVudCBhIGZhY3RvcnkgYWxsb3dpbmcgdG8gcGx1ZyBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIG9mIHN1ZmZpeFxuICogbG9va3VwIChlLmcuOiB1c2luZyBhIHRyaWUgb3IgdGhlIHBhY2tlZCBoYXNoZXMgZGF0YXN0cnVjdHVyZXMpLiBUaGlzIGlzIHVzZWRcbiAqIGFuZCBleHBvc2VkIGluIGB0bGR0cy50c2AgYW5kIGB0bGR0cy1leHBlcmltZW50YWwudHNgIGJ1bmRsZSBlbnRyeXBvaW50cy5cbiAqL1xuaW1wb3J0IGdldERvbWFpbiBmcm9tICcuL2RvbWFpbic7XG5pbXBvcnQgZ2V0RG9tYWluV2l0aG91dFN1ZmZpeCBmcm9tICcuL2RvbWFpbi13aXRob3V0LXN1ZmZpeCc7XG5pbXBvcnQgZXh0cmFjdEhvc3RuYW1lIGZyb20gJy4vZXh0cmFjdC1ob3N0bmFtZSc7XG5pbXBvcnQgaXNJcCBmcm9tICcuL2lzLWlwJztcbmltcG9ydCBpc1ZhbGlkSG9zdG5hbWUgZnJvbSAnLi9pcy12YWxpZCc7XG5pbXBvcnQgeyBzZXREZWZhdWx0cyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgZ2V0U3ViZG9tYWluIGZyb20gJy4vc3ViZG9tYWluJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRFbXB0eVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb21haW46IG51bGwsXG4gICAgICAgIGRvbWFpbldpdGhvdXRTdWZmaXg6IG51bGwsXG4gICAgICAgIGhvc3RuYW1lOiBudWxsLFxuICAgICAgICBpc0ljYW5uOiBudWxsLFxuICAgICAgICBpc0lwOiBudWxsLFxuICAgICAgICBpc1ByaXZhdGU6IG51bGwsXG4gICAgICAgIHB1YmxpY1N1ZmZpeDogbnVsbCxcbiAgICAgICAgc3ViZG9tYWluOiBudWxsLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXRSZXN1bHQocmVzdWx0KSB7XG4gICAgcmVzdWx0LmRvbWFpbiA9IG51bGw7XG4gICAgcmVzdWx0LmRvbWFpbldpdGhvdXRTdWZmaXggPSBudWxsO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LmlzSWNhbm4gPSBudWxsO1xuICAgIHJlc3VsdC5pc0lwID0gbnVsbDtcbiAgICByZXN1bHQuaXNQcml2YXRlID0gbnVsbDtcbiAgICByZXN1bHQucHVibGljU3VmZml4ID0gbnVsbDtcbiAgICByZXN1bHQuc3ViZG9tYWluID0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUltcGwodXJsLCBzdGVwLCBzdWZmaXhMb29rdXAsIHBhcnRpYWxPcHRpb25zLCByZXN1bHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gLypAX19JTkxJTkVfXyovIHNldERlZmF1bHRzKHBhcnRpYWxPcHRpb25zKTtcbiAgICAvLyBWZXJ5IGZhc3QgYXBwcm94aW1hdGUgY2hlY2sgdG8gbWFrZSBzdXJlIGB1cmxgIGlzIGEgc3RyaW5nLiBUaGlzIGlzIG5lZWRlZFxuICAgIC8vIGJlY2F1c2UgdGhlIGxpYnJhcnkgd2lsbCBub3QgbmVjZXNzYXJpbHkgYmUgdXNlZCBpbiBhIHR5cGVkIHNldHVwIGFuZFxuICAgIC8vIHZhbHVlcyBvZiBhcmJpdHJhcnkgdHlwZXMgbWlnaHQgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEV4dHJhY3QgaG9zdG5hbWUgZnJvbSBgdXJsYCBvbmx5IGlmIG5lZWRlZC4gVGhpcyBjYW4gYmUgbWFkZSBvcHRpb25hbFxuICAgIC8vIHVzaW5nIGBvcHRpb25zLmV4dHJhY3RIb3N0bmFtZWAuIFRoaXMgb3B0aW9uIHdpbGwgdHlwaWNhbGx5IGJlIHVzZWRcbiAgICAvLyB3aGVuZXZlciB3ZSBhcmUgc3VyZSB0aGUgaW5wdXRzIHRvIGBwYXJzZWAgYXJlIGFscmVhZHkgaG9zdG5hbWVzIGFuZCBub3RcbiAgICAvLyBhcmJpdHJhcnkgVVJMcy5cbiAgICAvL1xuICAgIC8vIGBtaXhlZElucHV0YCBhbGxvd3MgdG8gc3BlY2lmeSBpZiB3ZSBleHBlY3QgYSBtaXggb2YgVVJMcyBhbmQgaG9zdG5hbWVzXG4gICAgLy8gYXMgaW5wdXQuIElmIG9ubHkgaG9zdG5hbWVzIGFyZSBleHBlY3RlZCB0aGVuIGBleHRyYWN0SG9zdG5hbWVgIGNhbiBiZVxuICAgIC8vIHNldCB0byBgZmFsc2VgIHRvIHNwZWVkLXVwIHBhcnNpbmcuIElmIG9ubHkgVVJMcyBhcmUgZXhwZWN0ZWQgdGhlblxuICAgIC8vIGBtaXhlZElucHV0c2AgY2FuIGJlIHNldCB0byBgZmFsc2VgLiBUaGUgYG1peGVkSW5wdXRzYCBpcyBvbmx5IGEgaGludFxuICAgIC8vIGFuZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHRoZSBsaWJyYXJ5LlxuICAgIGlmICghb3B0aW9ucy5leHRyYWN0SG9zdG5hbWUpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gdXJsO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLm1peGVkSW5wdXRzKSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IGV4dHJhY3RIb3N0bmFtZSh1cmwsIGlzVmFsaWRIb3N0bmFtZSh1cmwpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IGV4dHJhY3RIb3N0bmFtZSh1cmwsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHN0ZXAgPT09IDAgLyogRkxBRy5IT1NUTkFNRSAqLyB8fCByZXN1bHQuaG9zdG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYGhvc3RuYW1lYCBpcyBhIHZhbGlkIGlwIGFkZHJlc3NcbiAgICBpZiAob3B0aW9ucy5kZXRlY3RJcCkge1xuICAgICAgICByZXN1bHQuaXNJcCA9IGlzSXAocmVzdWx0Lmhvc3RuYW1lKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc0lwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBlcmZvcm0gb3B0aW9uYWwgaG9zdG5hbWUgdmFsaWRhdGlvbi4gSWYgaG9zdG5hbWUgaXMgbm90IHZhbGlkLCBubyBuZWVkIHRvXG4gICAgLy8gZ28gZnVydGhlciBhcyB0aGVyZSB3aWxsIGJlIG5vIHZhbGlkIGRvbWFpbiBvciBzdWItZG9tYWluLlxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlSG9zdG5hbWUgJiZcbiAgICAgICAgb3B0aW9ucy5leHRyYWN0SG9zdG5hbWUgJiZcbiAgICAgICAgIWlzVmFsaWRIb3N0bmFtZShyZXN1bHQuaG9zdG5hbWUpKSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEV4dHJhY3QgcHVibGljIHN1ZmZpeFxuICAgIHN1ZmZpeExvb2t1cChyZXN1bHQuaG9zdG5hbWUsIG9wdGlvbnMsIHJlc3VsdCk7XG4gICAgaWYgKHN0ZXAgPT09IDIgLyogRkxBRy5QVUJMSUNfU1VGRklYICovIHx8IHJlc3VsdC5wdWJsaWNTdWZmaXggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRXh0cmFjdCBkb21haW5cbiAgICByZXN1bHQuZG9tYWluID0gZ2V0RG9tYWluKHJlc3VsdC5wdWJsaWNTdWZmaXgsIHJlc3VsdC5ob3N0bmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKHN0ZXAgPT09IDMgLyogRkxBRy5ET01BSU4gKi8gfHwgcmVzdWx0LmRvbWFpbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBFeHRyYWN0IHN1YmRvbWFpblxuICAgIHJlc3VsdC5zdWJkb21haW4gPSBnZXRTdWJkb21haW4ocmVzdWx0Lmhvc3RuYW1lLCByZXN1bHQuZG9tYWluKTtcbiAgICBpZiAoc3RlcCA9PT0gNCAvKiBGTEFHLlNVQl9ET01BSU4gKi8pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRXh0cmFjdCBkb21haW4gd2l0aG91dCBzdWZmaXhcbiAgICByZXN1bHQuZG9tYWluV2l0aG91dFN1ZmZpeCA9IGdldERvbWFpbldpdGhvdXRTdWZmaXgocmVzdWx0LmRvbWFpbiwgcmVzdWx0LnB1YmxpY1N1ZmZpeCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/factory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/is-ip.js":
/*!*******************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/is-ip.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isIp)\n/* harmony export */ });\n/**\n * Check if a hostname is an IP. You should be aware that this only works\n * because `hostname` is already garanteed to be a valid hostname!\n */\nfunction isProbablyIpv4(hostname) {\n    // Cannot be shorted than 1.1.1.1\n    if (hostname.length < 7) {\n        return false;\n    }\n    // Cannot be longer than: 255.255.255.255\n    if (hostname.length > 15) {\n        return false;\n    }\n    let numberOfDots = 0;\n    for (let i = 0; i < hostname.length; i += 1) {\n        const code = hostname.charCodeAt(i);\n        if (code === 46 /* '.' */) {\n            numberOfDots += 1;\n        }\n        else if (code < 48 /* '0' */ || code > 57 /* '9' */) {\n            return false;\n        }\n    }\n    return (numberOfDots === 3 &&\n        hostname.charCodeAt(0) !== 46 /* '.' */ &&\n        hostname.charCodeAt(hostname.length - 1) !== 46 /* '.' */);\n}\n/**\n * Similar to isProbablyIpv4.\n */\nfunction isProbablyIpv6(hostname) {\n    if (hostname.length < 3) {\n        return false;\n    }\n    let start = hostname.startsWith('[') ? 1 : 0;\n    let end = hostname.length;\n    if (hostname[end - 1] === ']') {\n        end -= 1;\n    }\n    // We only consider the maximum size of a normal IPV6. Note that this will\n    // fail on so-called \"IPv4 mapped IPv6 addresses\" but this is a corner-case\n    // and a proper validation library should be used for these.\n    if (end - start > 39) {\n        return false;\n    }\n    let hasColon = false;\n    for (; start < end; start += 1) {\n        const code = hostname.charCodeAt(start);\n        if (code === 58 /* ':' */) {\n            hasColon = true;\n        }\n        else if (!(((code >= 48 && code <= 57) || // 0-9\n            (code >= 97 && code <= 102) || // a-f\n            (code >= 65 && code <= 90)) // A-F\n        )) {\n            return false;\n        }\n    }\n    return hasColon;\n}\n/**\n * Check if `hostname` is *probably* a valid ip addr (either ipv6 or ipv4).\n * This *will not* work on any string. We need `hostname` to be a valid\n * hostname.\n */\nfunction isIp(hostname) {\n    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);\n}\n//# sourceMappingURL=is-ip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9pcy1pcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMtY29yZS9kaXN0L2VzNi9zcmMvaXMtaXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVjayBpZiBhIGhvc3RuYW1lIGlzIGFuIElQLiBZb3Ugc2hvdWxkIGJlIGF3YXJlIHRoYXQgdGhpcyBvbmx5IHdvcmtzXG4gKiBiZWNhdXNlIGBob3N0bmFtZWAgaXMgYWxyZWFkeSBnYXJhbnRlZWQgdG8gYmUgYSB2YWxpZCBob3N0bmFtZSFcbiAqL1xuZnVuY3Rpb24gaXNQcm9iYWJseUlwdjQoaG9zdG5hbWUpIHtcbiAgICAvLyBDYW5ub3QgYmUgc2hvcnRlZCB0aGFuIDEuMS4xLjFcbiAgICBpZiAoaG9zdG5hbWUubGVuZ3RoIDwgNykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIENhbm5vdCBiZSBsb25nZXIgdGhhbjogMjU1LjI1NS4yNTUuMjU1XG4gICAgaWYgKGhvc3RuYW1lLmxlbmd0aCA+IDE1KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG51bWJlck9mRG90cyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3N0bmFtZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjb2RlID0gaG9zdG5hbWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qICcuJyAqLykge1xuICAgICAgICAgICAgbnVtYmVyT2ZEb3RzICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZSA8IDQ4IC8qICcwJyAqLyB8fCBjb2RlID4gNTcgLyogJzknICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChudW1iZXJPZkRvdHMgPT09IDMgJiZcbiAgICAgICAgaG9zdG5hbWUuY2hhckNvZGVBdCgwKSAhPT0gNDYgLyogJy4nICovICYmXG4gICAgICAgIGhvc3RuYW1lLmNoYXJDb2RlQXQoaG9zdG5hbWUubGVuZ3RoIC0gMSkgIT09IDQ2IC8qICcuJyAqLyk7XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gaXNQcm9iYWJseUlwdjQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvYmFibHlJcHY2KGhvc3RuYW1lKSB7XG4gICAgaWYgKGhvc3RuYW1lLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSBob3N0bmFtZS5zdGFydHNXaXRoKCdbJykgPyAxIDogMDtcbiAgICBsZXQgZW5kID0gaG9zdG5hbWUubGVuZ3RoO1xuICAgIGlmIChob3N0bmFtZVtlbmQgLSAxXSA9PT0gJ10nKSB7XG4gICAgICAgIGVuZCAtPSAxO1xuICAgIH1cbiAgICAvLyBXZSBvbmx5IGNvbnNpZGVyIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBub3JtYWwgSVBWNi4gTm90ZSB0aGF0IHRoaXMgd2lsbFxuICAgIC8vIGZhaWwgb24gc28tY2FsbGVkIFwiSVB2NCBtYXBwZWQgSVB2NiBhZGRyZXNzZXNcIiBidXQgdGhpcyBpcyBhIGNvcm5lci1jYXNlXG4gICAgLy8gYW5kIGEgcHJvcGVyIHZhbGlkYXRpb24gbGlicmFyeSBzaG91bGQgYmUgdXNlZCBmb3IgdGhlc2UuXG4gICAgaWYgKGVuZCAtIHN0YXJ0ID4gMzkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaGFzQ29sb24gPSBmYWxzZTtcbiAgICBmb3IgKDsgc3RhcnQgPCBlbmQ7IHN0YXJ0ICs9IDEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGhvc3RuYW1lLmNoYXJDb2RlQXQoc3RhcnQpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNTggLyogJzonICovKSB7XG4gICAgICAgICAgICBoYXNDb2xvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoISgoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgLy8gMC05XG4gICAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikgfHwgLy8gYS1mXG4gICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSkgLy8gQS1GXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzQ29sb247XG59XG4vKipcbiAqIENoZWNrIGlmIGBob3N0bmFtZWAgaXMgKnByb2JhYmx5KiBhIHZhbGlkIGlwIGFkZHIgKGVpdGhlciBpcHY2IG9yIGlwdjQpLlxuICogVGhpcyAqd2lsbCBub3QqIHdvcmsgb24gYW55IHN0cmluZy4gV2UgbmVlZCBgaG9zdG5hbWVgIHRvIGJlIGEgdmFsaWRcbiAqIGhvc3RuYW1lLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0lwKGhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIGlzUHJvYmFibHlJcHY2KGhvc3RuYW1lKSB8fCBpc1Byb2JhYmx5SXB2NChob3N0bmFtZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1pcC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/is-ip.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/is-valid.js":
/*!**********************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/is-valid.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Implements fast shallow verification of hostnames. This does not perform a\n * struct check on the content of labels (classes of Unicode characters, etc.)\n * but instead check that the structure is valid (number of labels, length of\n * labels, etc.).\n *\n * If you need stricter validation, consider using an external library.\n */\nfunction isValidAscii(code) {\n    return ((code >= 97 && code <= 122) || (code >= 48 && code <= 57) || code > 127);\n}\n/**\n * Check if a hostname string is valid. It's usually a preliminary check before\n * trying to use getDomain or anything else.\n *\n * Beware: it does not check if the TLD exists.\n */\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(hostname) {\n    if (hostname.length > 255) {\n        return false;\n    }\n    if (hostname.length === 0) {\n        return false;\n    }\n    if (\n    /*@__INLINE__*/ !isValidAscii(hostname.charCodeAt(0)) &&\n        hostname.charCodeAt(0) !== 46 && // '.' (dot)\n        hostname.charCodeAt(0) !== 95 // '_' (underscore)\n    ) {\n        return false;\n    }\n    // Validate hostname according to RFC\n    let lastDotIndex = -1;\n    let lastCharCode = -1;\n    const len = hostname.length;\n    for (let i = 0; i < len; i += 1) {\n        const code = hostname.charCodeAt(i);\n        if (code === 46 /* '.' */) {\n            if (\n            // Check that previous label is < 63 bytes long (64 = 63 + '.')\n            i - lastDotIndex > 64 ||\n                // Check that previous character was not already a '.'\n                lastCharCode === 46 ||\n                // Check that the previous label does not end with a '-' (dash)\n                lastCharCode === 45 ||\n                // Check that the previous label does not end with a '_' (underscore)\n                lastCharCode === 95) {\n                return false;\n            }\n            lastDotIndex = i;\n        }\n        else if (!( /*@__INLINE__*/(isValidAscii(code) || code === 45 || code === 95))) {\n            // Check if there is a forbidden character in the label\n            return false;\n        }\n        lastCharCode = code;\n    }\n    return (\n    // Check that last label is shorter than 63 chars\n    len - lastDotIndex - 1 <= 63 &&\n        // Check that the last character is an allowed trailing label character.\n        // Since we already checked that the char is a valid hostname character,\n        // we only need to check that it's different from '-'.\n        lastCharCode !== 45);\n}\n//# sourceMappingURL=is-valid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9pcy12YWxpZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUFlLG9DQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMtY29yZS9kaXN0L2VzNi9zcmMvaXMtdmFsaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbXBsZW1lbnRzIGZhc3Qgc2hhbGxvdyB2ZXJpZmljYXRpb24gb2YgaG9zdG5hbWVzLiBUaGlzIGRvZXMgbm90IHBlcmZvcm0gYVxuICogc3RydWN0IGNoZWNrIG9uIHRoZSBjb250ZW50IG9mIGxhYmVscyAoY2xhc3NlcyBvZiBVbmljb2RlIGNoYXJhY3RlcnMsIGV0Yy4pXG4gKiBidXQgaW5zdGVhZCBjaGVjayB0aGF0IHRoZSBzdHJ1Y3R1cmUgaXMgdmFsaWQgKG51bWJlciBvZiBsYWJlbHMsIGxlbmd0aCBvZlxuICogbGFiZWxzLCBldGMuKS5cbiAqXG4gKiBJZiB5b3UgbmVlZCBzdHJpY3RlciB2YWxpZGF0aW9uLCBjb25zaWRlciB1c2luZyBhbiBleHRlcm5hbCBsaWJyYXJ5LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXNjaWkoY29kZSkge1xuICAgIHJldHVybiAoKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8IChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IGNvZGUgPiAxMjcpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGhvc3RuYW1lIHN0cmluZyBpcyB2YWxpZC4gSXQncyB1c3VhbGx5IGEgcHJlbGltaW5hcnkgY2hlY2sgYmVmb3JlXG4gKiB0cnlpbmcgdG8gdXNlIGdldERvbWFpbiBvciBhbnl0aGluZyBlbHNlLlxuICpcbiAqIEJld2FyZTogaXQgZG9lcyBub3QgY2hlY2sgaWYgdGhlIFRMRCBleGlzdHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAgIGlmIChob3N0bmFtZS5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaG9zdG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFxuICAgIC8qQF9fSU5MSU5FX18qLyAhaXNWYWxpZEFzY2lpKGhvc3RuYW1lLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAgIGhvc3RuYW1lLmNoYXJDb2RlQXQoMCkgIT09IDQ2ICYmIC8vICcuJyAoZG90KVxuICAgICAgICBob3N0bmFtZS5jaGFyQ29kZUF0KDApICE9PSA5NSAvLyAnXycgKHVuZGVyc2NvcmUpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgaG9zdG5hbWUgYWNjb3JkaW5nIHRvIFJGQ1xuICAgIGxldCBsYXN0RG90SW5kZXggPSAtMTtcbiAgICBsZXQgbGFzdENoYXJDb2RlID0gLTE7XG4gICAgY29uc3QgbGVuID0gaG9zdG5hbWUubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGhvc3RuYW1lLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0NiAvKiAnLicgKi8pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgcHJldmlvdXMgbGFiZWwgaXMgPCA2MyBieXRlcyBsb25nICg2NCA9IDYzICsgJy4nKVxuICAgICAgICAgICAgaSAtIGxhc3REb3RJbmRleCA+IDY0IHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBwcmV2aW91cyBjaGFyYWN0ZXIgd2FzIG5vdCBhbHJlYWR5IGEgJy4nXG4gICAgICAgICAgICAgICAgbGFzdENoYXJDb2RlID09PSA0NiB8fFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHByZXZpb3VzIGxhYmVsIGRvZXMgbm90IGVuZCB3aXRoIGEgJy0nIChkYXNoKVxuICAgICAgICAgICAgICAgIGxhc3RDaGFyQ29kZSA9PT0gNDUgfHxcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwcmV2aW91cyBsYWJlbCBkb2VzIG5vdCBlbmQgd2l0aCBhICdfJyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgICAgICBsYXN0Q2hhckNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdERvdEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKCAvKkBfX0lOTElORV9fKi8oaXNWYWxpZEFzY2lpKGNvZGUpIHx8IGNvZGUgPT09IDQ1IHx8IGNvZGUgPT09IDk1KSkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgZm9yYmlkZGVuIGNoYXJhY3RlciBpbiB0aGUgbGFiZWxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgIC8vIENoZWNrIHRoYXQgbGFzdCBsYWJlbCBpcyBzaG9ydGVyIHRoYW4gNjMgY2hhcnNcbiAgICBsZW4gLSBsYXN0RG90SW5kZXggLSAxIDw9IDYzICYmXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGFuIGFsbG93ZWQgdHJhaWxpbmcgbGFiZWwgY2hhcmFjdGVyLlxuICAgICAgICAvLyBTaW5jZSB3ZSBhbHJlYWR5IGNoZWNrZWQgdGhhdCB0aGUgY2hhciBpcyBhIHZhbGlkIGhvc3RuYW1lIGNoYXJhY3RlcixcbiAgICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIGNoZWNrIHRoYXQgaXQncyBkaWZmZXJlbnQgZnJvbSAnLScuXG4gICAgICAgIGxhc3RDaGFyQ29kZSAhPT0gNDUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdmFsaWQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/is-valid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/lookup/fast-path.js":
/*!******************************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/lookup/fast-path.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(hostname, options, out) {\n    // Fast path for very popular suffixes; this allows to by-pass lookup\n    // completely as well as any extra allocation or string manipulation.\n    if (!options.allowPrivateDomains && hostname.length > 3) {\n        const last = hostname.length - 1;\n        const c3 = hostname.charCodeAt(last);\n        const c2 = hostname.charCodeAt(last - 1);\n        const c1 = hostname.charCodeAt(last - 2);\n        const c0 = hostname.charCodeAt(last - 3);\n        if (c3 === 109 /* 'm' */ &&\n            c2 === 111 /* 'o' */ &&\n            c1 === 99 /* 'c' */ &&\n            c0 === 46 /* '.' */) {\n            out.isIcann = true;\n            out.isPrivate = false;\n            out.publicSuffix = 'com';\n            return true;\n        }\n        else if (c3 === 103 /* 'g' */ &&\n            c2 === 114 /* 'r' */ &&\n            c1 === 111 /* 'o' */ &&\n            c0 === 46 /* '.' */) {\n            out.isIcann = true;\n            out.isPrivate = false;\n            out.publicSuffix = 'org';\n            return true;\n        }\n        else if (c3 === 117 /* 'u' */ &&\n            c2 === 100 /* 'd' */ &&\n            c1 === 101 /* 'e' */ &&\n            c0 === 46 /* '.' */) {\n            out.isIcann = true;\n            out.isPrivate = false;\n            out.publicSuffix = 'edu';\n            return true;\n        }\n        else if (c3 === 118 /* 'v' */ &&\n            c2 === 111 /* 'o' */ &&\n            c1 === 103 /* 'g' */ &&\n            c0 === 46 /* '.' */) {\n            out.isIcann = true;\n            out.isPrivate = false;\n            out.publicSuffix = 'gov';\n            return true;\n        }\n        else if (c3 === 116 /* 't' */ &&\n            c2 === 101 /* 'e' */ &&\n            c1 === 110 /* 'n' */ &&\n            c0 === 46 /* '.' */) {\n            out.isIcann = true;\n            out.isPrivate = false;\n            out.publicSuffix = 'net';\n            return true;\n        }\n        else if (c3 === 101 /* 'e' */ &&\n            c2 === 100 /* 'd' */ &&\n            c1 === 46 /* '.' */) {\n            out.isIcann = true;\n            out.isPrivate = false;\n            out.publicSuffix = 'de';\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=fast-path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9sb29rdXAvZmFzdC1wYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2QkFBZSxvQ0FBVTtBQUN6Qiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMtY29yZS9kaXN0L2VzNi9zcmMvbG9va3VwL2Zhc3QtcGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoaG9zdG5hbWUsIG9wdGlvbnMsIG91dCkge1xuICAgIC8vIEZhc3QgcGF0aCBmb3IgdmVyeSBwb3B1bGFyIHN1ZmZpeGVzOyB0aGlzIGFsbG93cyB0byBieS1wYXNzIGxvb2t1cFxuICAgIC8vIGNvbXBsZXRlbHkgYXMgd2VsbCBhcyBhbnkgZXh0cmEgYWxsb2NhdGlvbiBvciBzdHJpbmcgbWFuaXB1bGF0aW9uLlxuICAgIGlmICghb3B0aW9ucy5hbGxvd1ByaXZhdGVEb21haW5zICYmIGhvc3RuYW1lLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IGhvc3RuYW1lLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGMzID0gaG9zdG5hbWUuY2hhckNvZGVBdChsYXN0KTtcbiAgICAgICAgY29uc3QgYzIgPSBob3N0bmFtZS5jaGFyQ29kZUF0KGxhc3QgLSAxKTtcbiAgICAgICAgY29uc3QgYzEgPSBob3N0bmFtZS5jaGFyQ29kZUF0KGxhc3QgLSAyKTtcbiAgICAgICAgY29uc3QgYzAgPSBob3N0bmFtZS5jaGFyQ29kZUF0KGxhc3QgLSAzKTtcbiAgICAgICAgaWYgKGMzID09PSAxMDkgLyogJ20nICovICYmXG4gICAgICAgICAgICBjMiA9PT0gMTExIC8qICdvJyAqLyAmJlxuICAgICAgICAgICAgYzEgPT09IDk5IC8qICdjJyAqLyAmJlxuICAgICAgICAgICAgYzAgPT09IDQ2IC8qICcuJyAqLykge1xuICAgICAgICAgICAgb3V0LmlzSWNhbm4gPSB0cnVlO1xuICAgICAgICAgICAgb3V0LmlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgb3V0LnB1YmxpY1N1ZmZpeCA9ICdjb20nO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzMgPT09IDEwMyAvKiAnZycgKi8gJiZcbiAgICAgICAgICAgIGMyID09PSAxMTQgLyogJ3InICovICYmXG4gICAgICAgICAgICBjMSA9PT0gMTExIC8qICdvJyAqLyAmJlxuICAgICAgICAgICAgYzAgPT09IDQ2IC8qICcuJyAqLykge1xuICAgICAgICAgICAgb3V0LmlzSWNhbm4gPSB0cnVlO1xuICAgICAgICAgICAgb3V0LmlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgb3V0LnB1YmxpY1N1ZmZpeCA9ICdvcmcnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzMgPT09IDExNyAvKiAndScgKi8gJiZcbiAgICAgICAgICAgIGMyID09PSAxMDAgLyogJ2QnICovICYmXG4gICAgICAgICAgICBjMSA9PT0gMTAxIC8qICdlJyAqLyAmJlxuICAgICAgICAgICAgYzAgPT09IDQ2IC8qICcuJyAqLykge1xuICAgICAgICAgICAgb3V0LmlzSWNhbm4gPSB0cnVlO1xuICAgICAgICAgICAgb3V0LmlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgb3V0LnB1YmxpY1N1ZmZpeCA9ICdlZHUnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzMgPT09IDExOCAvKiAndicgKi8gJiZcbiAgICAgICAgICAgIGMyID09PSAxMTEgLyogJ28nICovICYmXG4gICAgICAgICAgICBjMSA9PT0gMTAzIC8qICdnJyAqLyAmJlxuICAgICAgICAgICAgYzAgPT09IDQ2IC8qICcuJyAqLykge1xuICAgICAgICAgICAgb3V0LmlzSWNhbm4gPSB0cnVlO1xuICAgICAgICAgICAgb3V0LmlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgb3V0LnB1YmxpY1N1ZmZpeCA9ICdnb3YnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzMgPT09IDExNiAvKiAndCcgKi8gJiZcbiAgICAgICAgICAgIGMyID09PSAxMDEgLyogJ2UnICovICYmXG4gICAgICAgICAgICBjMSA9PT0gMTEwIC8qICduJyAqLyAmJlxuICAgICAgICAgICAgYzAgPT09IDQ2IC8qICcuJyAqLykge1xuICAgICAgICAgICAgb3V0LmlzSWNhbm4gPSB0cnVlO1xuICAgICAgICAgICAgb3V0LmlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgb3V0LnB1YmxpY1N1ZmZpeCA9ICduZXQnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzMgPT09IDEwMSAvKiAnZScgKi8gJiZcbiAgICAgICAgICAgIGMyID09PSAxMDAgLyogJ2QnICovICYmXG4gICAgICAgICAgICBjMSA9PT0gNDYgLyogJy4nICovKSB7XG4gICAgICAgICAgICBvdXQuaXNJY2FubiA9IHRydWU7XG4gICAgICAgICAgICBvdXQuaXNQcml2YXRlID0gZmFsc2U7XG4gICAgICAgICAgICBvdXQucHVibGljU3VmZml4ID0gJ2RlJztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhc3QtcGF0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/lookup/fast-path.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/options.js":
/*!*********************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/options.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setDefaults: () => (/* binding */ setDefaults)\n/* harmony export */ });\nfunction setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {\n    return {\n        allowIcannDomains,\n        allowPrivateDomains,\n        detectIp,\n        extractHostname,\n        mixedInputs,\n        validHosts,\n        validateHostname,\n    };\n}\nconst DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});\nfunction setDefaults(options) {\n    if (options === undefined) {\n        return DEFAULT_OPTIONS;\n    }\n    return /*@__INLINE__*/ setDefaultsImpl(options);\n}\n//# sourceMappingURL=options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwyQkFBMkIsaUtBQWlLO0FBQzVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RsZHRzLWNvcmUvZGlzdC9lczYvc3JjL29wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gc2V0RGVmYXVsdHNJbXBsKHsgYWxsb3dJY2FubkRvbWFpbnMgPSB0cnVlLCBhbGxvd1ByaXZhdGVEb21haW5zID0gZmFsc2UsIGRldGVjdElwID0gdHJ1ZSwgZXh0cmFjdEhvc3RuYW1lID0gdHJ1ZSwgbWl4ZWRJbnB1dHMgPSB0cnVlLCB2YWxpZEhvc3RzID0gbnVsbCwgdmFsaWRhdGVIb3N0bmFtZSA9IHRydWUsIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd0ljYW5uRG9tYWlucyxcbiAgICAgICAgYWxsb3dQcml2YXRlRG9tYWlucyxcbiAgICAgICAgZGV0ZWN0SXAsXG4gICAgICAgIGV4dHJhY3RIb3N0bmFtZSxcbiAgICAgICAgbWl4ZWRJbnB1dHMsXG4gICAgICAgIHZhbGlkSG9zdHMsXG4gICAgICAgIHZhbGlkYXRlSG9zdG5hbWUsXG4gICAgfTtcbn1cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IC8qQF9fSU5MSU5FX18qLyBzZXREZWZhdWx0c0ltcGwoe30pO1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX09QVElPTlM7XG4gICAgfVxuICAgIHJldHVybiAvKkBfX0lOTElORV9fKi8gc2V0RGVmYXVsdHNJbXBsKG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/options.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/subdomain.js":
/*!***********************************************************!*\
  !*** ./node_modules/tldts-core/dist/es6/src/subdomain.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getSubdomain)\n/* harmony export */ });\n/**\n * Returns the subdomain of a hostname string\n */\nfunction getSubdomain(hostname, domain) {\n    // If `hostname` and `domain` are the same, then there is no sub-domain\n    if (domain.length === hostname.length) {\n        return '';\n    }\n    return hostname.slice(0, -domain.length - 1);\n}\n//# sourceMappingURL=subdomain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy1jb3JlL2Rpc3QvZXM2L3NyYy9zdWJkb21haW4uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMtY29yZS9kaXN0L2VzNi9zcmMvc3ViZG9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmV0dXJucyB0aGUgc3ViZG9tYWluIG9mIGEgaG9zdG5hbWUgc3RyaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFN1YmRvbWFpbihob3N0bmFtZSwgZG9tYWluKSB7XG4gICAgLy8gSWYgYGhvc3RuYW1lYCBhbmQgYGRvbWFpbmAgYXJlIHRoZSBzYW1lLCB0aGVuIHRoZXJlIGlzIG5vIHN1Yi1kb21haW5cbiAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gaG9zdG5hbWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGhvc3RuYW1lLnNsaWNlKDAsIC1kb21haW4ubGVuZ3RoIC0gMSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJkb21haW4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts-core/dist/es6/src/subdomain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts/dist/es6/index.js":
/*!**********************************************!*\
  !*** ./node_modules/tldts/dist/es6/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDomain: () => (/* binding */ getDomain),\n/* harmony export */   getDomainWithoutSuffix: () => (/* binding */ getDomainWithoutSuffix),\n/* harmony export */   getHostname: () => (/* binding */ getHostname),\n/* harmony export */   getPublicSuffix: () => (/* binding */ getPublicSuffix),\n/* harmony export */   getSubdomain: () => (/* binding */ getSubdomain),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var tldts_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tldts-core */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/index.js\");\n/* harmony import */ var _src_suffix_trie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/suffix-trie */ \"(app-pages-browser)/./node_modules/tldts/dist/es6/src/suffix-trie.js\");\n\n\n// For all methods but 'parse', it does not make sense to allocate an object\n// every single time to only return the value of a specific attribute. To avoid\n// this un-necessary allocation, we use a global object which is re-used.\nconst RESULT = (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.getEmptyResult)();\nfunction parse(url, options = {}) {\n    return (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.parseImpl)(url, 5 /* FLAG.ALL */, _src_suffix_trie__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options, (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.getEmptyResult)());\n}\nfunction getHostname(url, options = {}) {\n    /*@__INLINE__*/ (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.resetResult)(RESULT);\n    return (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.parseImpl)(url, 0 /* FLAG.HOSTNAME */, _src_suffix_trie__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options, RESULT).hostname;\n}\nfunction getPublicSuffix(url, options = {}) {\n    /*@__INLINE__*/ (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.resetResult)(RESULT);\n    return (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.parseImpl)(url, 2 /* FLAG.PUBLIC_SUFFIX */, _src_suffix_trie__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options, RESULT)\n        .publicSuffix;\n}\nfunction getDomain(url, options = {}) {\n    /*@__INLINE__*/ (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.resetResult)(RESULT);\n    return (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.parseImpl)(url, 3 /* FLAG.DOMAIN */, _src_suffix_trie__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options, RESULT).domain;\n}\nfunction getSubdomain(url, options = {}) {\n    /*@__INLINE__*/ (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.resetResult)(RESULT);\n    return (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.parseImpl)(url, 4 /* FLAG.SUB_DOMAIN */, _src_suffix_trie__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options, RESULT)\n        .subdomain;\n}\nfunction getDomainWithoutSuffix(url, options = {}) {\n    /*@__INLINE__*/ (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.resetResult)(RESULT);\n    return (0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.parseImpl)(url, 5 /* FLAG.ALL */, _src_suffix_trie__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options, RESULT)\n        .domainWithoutSuffix;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy9kaXN0L2VzNi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxRTtBQUN4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFjO0FBQ3RCLGdDQUFnQztBQUN2QyxXQUFXLHFEQUFTLHdCQUF3Qix3REFBWSxXQUFXLDBEQUFjO0FBQ2pGO0FBQ08sc0NBQXNDO0FBQzdDLG9CQUFvQix1REFBVztBQUMvQixXQUFXLHFEQUFTLDZCQUE2Qix3REFBWTtBQUM3RDtBQUNPLDBDQUEwQztBQUNqRCxvQkFBb0IsdURBQVc7QUFDL0IsV0FBVyxxREFBUyxrQ0FBa0Msd0RBQVk7QUFDbEU7QUFDQTtBQUNPLG9DQUFvQztBQUMzQyxvQkFBb0IsdURBQVc7QUFDL0IsV0FBVyxxREFBUywyQkFBMkIsd0RBQVk7QUFDM0Q7QUFDTyx1Q0FBdUM7QUFDOUMsb0JBQW9CLHVEQUFXO0FBQy9CLFdBQVcscURBQVMsK0JBQStCLHdEQUFZO0FBQy9EO0FBQ0E7QUFDTyxpREFBaUQ7QUFDeEQsb0JBQW9CLHVEQUFXO0FBQy9CLFdBQVcscURBQVMsd0JBQXdCLHdEQUFZO0FBQ3hEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90bGR0cy9kaXN0L2VzNi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRFbXB0eVJlc3VsdCwgcGFyc2VJbXBsLCByZXNldFJlc3VsdCwgfSBmcm9tICd0bGR0cy1jb3JlJztcbmltcG9ydCBzdWZmaXhMb29rdXAgZnJvbSAnLi9zcmMvc3VmZml4LXRyaWUnO1xuLy8gRm9yIGFsbCBtZXRob2RzIGJ1dCAncGFyc2UnLCBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIHRvIGFsbG9jYXRlIGFuIG9iamVjdFxuLy8gZXZlcnkgc2luZ2xlIHRpbWUgdG8gb25seSByZXR1cm4gdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgYXR0cmlidXRlLiBUbyBhdm9pZFxuLy8gdGhpcyB1bi1uZWNlc3NhcnkgYWxsb2NhdGlvbiwgd2UgdXNlIGEgZ2xvYmFsIG9iamVjdCB3aGljaCBpcyByZS11c2VkLlxuY29uc3QgUkVTVUxUID0gZ2V0RW1wdHlSZXN1bHQoKTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBwYXJzZUltcGwodXJsLCA1IC8qIEZMQUcuQUxMICovLCBzdWZmaXhMb29rdXAsIG9wdGlvbnMsIGdldEVtcHR5UmVzdWx0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvc3RuYW1lKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLypAX19JTkxJTkVfXyovIHJlc2V0UmVzdWx0KFJFU1VMVCk7XG4gICAgcmV0dXJuIHBhcnNlSW1wbCh1cmwsIDAgLyogRkxBRy5IT1NUTkFNRSAqLywgc3VmZml4TG9va3VwLCBvcHRpb25zLCBSRVNVTFQpLmhvc3RuYW1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY1N1ZmZpeCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qQF9fSU5MSU5FX18qLyByZXNldFJlc3VsdChSRVNVTFQpO1xuICAgIHJldHVybiBwYXJzZUltcGwodXJsLCAyIC8qIEZMQUcuUFVCTElDX1NVRkZJWCAqLywgc3VmZml4TG9va3VwLCBvcHRpb25zLCBSRVNVTFQpXG4gICAgICAgIC5wdWJsaWNTdWZmaXg7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tYWluKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLypAX19JTkxJTkVfXyovIHJlc2V0UmVzdWx0KFJFU1VMVCk7XG4gICAgcmV0dXJuIHBhcnNlSW1wbCh1cmwsIDMgLyogRkxBRy5ET01BSU4gKi8sIHN1ZmZpeExvb2t1cCwgb3B0aW9ucywgUkVTVUxUKS5kb21haW47XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3ViZG9tYWluKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLypAX19JTkxJTkVfXyovIHJlc2V0UmVzdWx0KFJFU1VMVCk7XG4gICAgcmV0dXJuIHBhcnNlSW1wbCh1cmwsIDQgLyogRkxBRy5TVUJfRE9NQUlOICovLCBzdWZmaXhMb29rdXAsIG9wdGlvbnMsIFJFU1VMVClcbiAgICAgICAgLnN1YmRvbWFpbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21haW5XaXRob3V0U3VmZml4KHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLypAX19JTkxJTkVfXyovIHJlc2V0UmVzdWx0KFJFU1VMVCk7XG4gICAgcmV0dXJuIHBhcnNlSW1wbCh1cmwsIDUgLyogRkxBRy5BTEwgKi8sIHN1ZmZpeExvb2t1cCwgb3B0aW9ucywgUkVTVUxUKVxuICAgICAgICAuZG9tYWluV2l0aG91dFN1ZmZpeDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts/dist/es6/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts/dist/es6/src/data/trie.js":
/*!******************************************************!*\
  !*** ./node_modules/tldts/dist/es6/src/data/trie.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exceptions: () => (/* binding */ exceptions),\n/* harmony export */   rules: () => (/* binding */ rules)\n/* harmony export */ });\nconst exceptions = (function () {\n    const _0 = [1, {}], _1 = [2, {}], _2 = [0, { \"city\": _0 }];\n    const exceptions = [0, { \"ck\": [0, { \"www\": _0 }], \"jp\": [0, { \"kawasaki\": _2, \"kitakyushu\": _2, \"kobe\": _2, \"nagoya\": _2, \"sapporo\": _2, \"sendai\": _2, \"yokohama\": _2 }], \"dev\": [0, { \"hrsn\": [0, { \"psl\": [0, { \"wc\": [0, { \"ignored\": _1, \"sub\": [0, { \"ignored\": _1 }] }] }] }] }] }];\n    return exceptions;\n})();\nconst rules = (function () {\n    const _3 = [1, {}], _4 = [2, {}], _5 = [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3 }], _6 = [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], _7 = [0, { \"*\": _4 }], _8 = [0, { \"relay\": _4 }], _9 = [2, { \"id\": _4 }], _10 = [1, { \"gov\": _3 }], _11 = [0, { \"transfer-webapp\": _4 }], _12 = [0, { \"notebook\": _4, \"studio\": _4 }], _13 = [0, { \"labeling\": _4, \"notebook\": _4, \"studio\": _4 }], _14 = [0, { \"notebook\": _4 }], _15 = [0, { \"labeling\": _4, \"notebook\": _4, \"notebook-fips\": _4, \"studio\": _4 }], _16 = [0, { \"notebook\": _4, \"notebook-fips\": _4, \"studio\": _4, \"studio-fips\": _4 }], _17 = [0, { \"*\": _3 }], _18 = [1, { \"co\": _4 }], _19 = [0, { \"objects\": _4 }], _20 = [2, { \"nodes\": _4 }], _21 = [0, { \"my\": _7 }], _22 = [0, { \"s3\": _4, \"s3-accesspoint\": _4, \"s3-website\": _4 }], _23 = [0, { \"s3\": _4, \"s3-accesspoint\": _4 }], _24 = [0, { \"direct\": _4 }], _25 = [0, { \"webview-assets\": _4 }], _26 = [0, { \"vfs\": _4, \"webview-assets\": _4 }], _27 = [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _22, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"aws-cloud9\": _25, \"cloud9\": _26 }], _28 = [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _23, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"aws-cloud9\": _25, \"cloud9\": _26 }], _29 = [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _22, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"analytics-gateway\": _4, \"aws-cloud9\": _25, \"cloud9\": _26 }], _30 = [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _22, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4 }], _31 = [0, { \"s3\": _4, \"s3-accesspoint\": _4, \"s3-accesspoint-fips\": _4, \"s3-fips\": _4, \"s3-website\": _4 }], _32 = [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _31, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-accesspoint-fips\": _4, \"s3-fips\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"aws-cloud9\": _25, \"cloud9\": _26 }], _33 = [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _31, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-accesspoint-fips\": _4, \"s3-deprecated\": _4, \"s3-fips\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"analytics-gateway\": _4, \"aws-cloud9\": _25, \"cloud9\": _26 }], _34 = [0, { \"s3\": _4, \"s3-accesspoint\": _4, \"s3-accesspoint-fips\": _4, \"s3-fips\": _4 }], _35 = [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _34, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-accesspoint-fips\": _4, \"s3-fips\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4 }], _36 = [0, { \"auth\": _4 }], _37 = [0, { \"auth\": _4, \"auth-fips\": _4 }], _38 = [0, { \"apps\": _4 }], _39 = [0, { \"paas\": _4 }], _40 = [2, { \"eu\": _4 }], _41 = [0, { \"app\": _4 }], _42 = [0, { \"site\": _4 }], _43 = [1, { \"com\": _3, \"edu\": _3, \"net\": _3, \"org\": _3 }], _44 = [0, { \"j\": _4 }], _45 = [0, { \"dyn\": _4 }], _46 = [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3 }], _47 = [0, { \"p\": _4 }], _48 = [0, { \"user\": _4 }], _49 = [0, { \"shop\": _4 }], _50 = [0, { \"cust\": _4, \"reservd\": _4 }], _51 = [0, { \"cust\": _4 }], _52 = [0, { \"s3\": _4 }], _53 = [1, { \"biz\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"net\": _3, \"org\": _3 }], _54 = [1, { \"framer\": _4 }], _55 = [0, { \"forgot\": _4 }], _56 = [0, { \"cdn\": _4 }], _57 = [1, { \"gs\": _3 }], _58 = [0, { \"nes\": _3 }], _59 = [1, { \"k12\": _3, \"cc\": _3, \"lib\": _3 }], _60 = [1, { \"cc\": _3, \"lib\": _3 }];\n    const rules = [0, { \"ac\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"drr\": _4, \"feedback\": _4, \"forms\": _4 }], \"ad\": _3, \"ae\": [1, { \"ac\": _3, \"co\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"sch\": _3 }], \"aero\": [1, { \"airline\": _3, \"airport\": _3, \"accident-investigation\": _3, \"accident-prevention\": _3, \"aerobatic\": _3, \"aeroclub\": _3, \"aerodrome\": _3, \"agents\": _3, \"air-surveillance\": _3, \"air-traffic-control\": _3, \"aircraft\": _3, \"airtraffic\": _3, \"ambulance\": _3, \"association\": _3, \"author\": _3, \"ballooning\": _3, \"broker\": _3, \"caa\": _3, \"cargo\": _3, \"catering\": _3, \"certification\": _3, \"championship\": _3, \"charter\": _3, \"civilaviation\": _3, \"club\": _3, \"conference\": _3, \"consultant\": _3, \"consulting\": _3, \"control\": _3, \"council\": _3, \"crew\": _3, \"design\": _3, \"dgca\": _3, \"educator\": _3, \"emergency\": _3, \"engine\": _3, \"engineer\": _3, \"entertainment\": _3, \"equipment\": _3, \"exchange\": _3, \"express\": _3, \"federation\": _3, \"flight\": _3, \"freight\": _3, \"fuel\": _3, \"gliding\": _3, \"government\": _3, \"groundhandling\": _3, \"group\": _3, \"hanggliding\": _3, \"homebuilt\": _3, \"insurance\": _3, \"journal\": _3, \"journalist\": _3, \"leasing\": _3, \"logistics\": _3, \"magazine\": _3, \"maintenance\": _3, \"marketplace\": _3, \"media\": _3, \"microlight\": _3, \"modelling\": _3, \"navigation\": _3, \"parachuting\": _3, \"paragliding\": _3, \"passenger-association\": _3, \"pilot\": _3, \"press\": _3, \"production\": _3, \"recreation\": _3, \"repbody\": _3, \"res\": _3, \"research\": _3, \"rotorcraft\": _3, \"safety\": _3, \"scientist\": _3, \"services\": _3, \"show\": _3, \"skydiving\": _3, \"software\": _3, \"student\": _3, \"taxi\": _3, \"trader\": _3, \"trading\": _3, \"trainer\": _3, \"union\": _3, \"workinggroup\": _3, \"works\": _3 }], \"af\": _5, \"ag\": [1, { \"co\": _3, \"com\": _3, \"net\": _3, \"nom\": _3, \"org\": _3 }], \"ai\": [1, { \"com\": _3, \"net\": _3, \"off\": _3, \"org\": _3, \"uwu\": _4, \"framer\": _4 }], \"al\": _6, \"am\": [1, { \"co\": _3, \"com\": _3, \"commune\": _3, \"net\": _3, \"org\": _3, \"radio\": _4 }], \"ao\": [1, { \"co\": _3, \"ed\": _3, \"edu\": _3, \"gov\": _3, \"gv\": _3, \"it\": _3, \"og\": _3, \"org\": _3, \"pb\": _3 }], \"aq\": _3, \"ar\": [1, { \"bet\": _3, \"com\": _3, \"coop\": _3, \"edu\": _3, \"gob\": _3, \"gov\": _3, \"int\": _3, \"mil\": _3, \"musica\": _3, \"mutual\": _3, \"net\": _3, \"org\": _3, \"senasa\": _3, \"tur\": _3 }], \"arpa\": [1, { \"e164\": _3, \"home\": _3, \"in-addr\": _3, \"ip6\": _3, \"iris\": _3, \"uri\": _3, \"urn\": _3 }], \"as\": _10, \"asia\": [1, { \"cloudns\": _4, \"daemon\": _4, \"dix\": _4 }], \"at\": [1, { \"ac\": [1, { \"sth\": _3 }], \"co\": _3, \"gv\": _3, \"or\": _3, \"funkfeuer\": [0, { \"wien\": _4 }], \"futurecms\": [0, { \"*\": _4, \"ex\": _7, \"in\": _7 }], \"futurehosting\": _4, \"futuremailing\": _4, \"ortsinfo\": [0, { \"ex\": _7, \"kunden\": _7 }], \"biz\": _4, \"info\": _4, \"123webseite\": _4, \"priv\": _4, \"myspreadshop\": _4, \"12hp\": _4, \"2ix\": _4, \"4lima\": _4, \"lima-city\": _4 }], \"au\": [1, { \"asn\": _3, \"com\": [1, { \"cloudlets\": [0, { \"mel\": _4 }], \"myspreadshop\": _4 }], \"edu\": [1, { \"act\": _3, \"catholic\": _3, \"nsw\": [1, { \"schools\": _3 }], \"nt\": _3, \"qld\": _3, \"sa\": _3, \"tas\": _3, \"vic\": _3, \"wa\": _3 }], \"gov\": [1, { \"qld\": _3, \"sa\": _3, \"tas\": _3, \"vic\": _3, \"wa\": _3 }], \"id\": _3, \"net\": _3, \"org\": _3, \"conf\": _3, \"oz\": _3, \"act\": _3, \"nsw\": _3, \"nt\": _3, \"qld\": _3, \"sa\": _3, \"tas\": _3, \"vic\": _3, \"wa\": _3 }], \"aw\": [1, { \"com\": _3 }], \"ax\": _3, \"az\": [1, { \"biz\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"int\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"pp\": _3, \"pro\": _3 }], \"ba\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"rs\": _4 }], \"bb\": [1, { \"biz\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"net\": _3, \"org\": _3, \"store\": _3, \"tv\": _3 }], \"bd\": _17, \"be\": [1, { \"ac\": _3, \"cloudns\": _4, \"webhosting\": _4, \"interhostsolutions\": [0, { \"cloud\": _4 }], \"kuleuven\": [0, { \"ezproxy\": _4 }], \"123website\": _4, \"myspreadshop\": _4, \"transurl\": _7 }], \"bf\": _10, \"bg\": [1, { \"0\": _3, \"1\": _3, \"2\": _3, \"3\": _3, \"4\": _3, \"5\": _3, \"6\": _3, \"7\": _3, \"8\": _3, \"9\": _3, \"a\": _3, \"b\": _3, \"c\": _3, \"d\": _3, \"e\": _3, \"f\": _3, \"g\": _3, \"h\": _3, \"i\": _3, \"j\": _3, \"k\": _3, \"l\": _3, \"m\": _3, \"n\": _3, \"o\": _3, \"p\": _3, \"q\": _3, \"r\": _3, \"s\": _3, \"t\": _3, \"u\": _3, \"v\": _3, \"w\": _3, \"x\": _3, \"y\": _3, \"z\": _3, \"barsy\": _4 }], \"bh\": _5, \"bi\": [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"or\": _3, \"org\": _3 }], \"biz\": [1, { \"activetrail\": _4, \"cloud-ip\": _4, \"cloudns\": _4, \"jozi\": _4, \"dyndns\": _4, \"for-better\": _4, \"for-more\": _4, \"for-some\": _4, \"for-the\": _4, \"selfip\": _4, \"webhop\": _4, \"orx\": _4, \"mmafan\": _4, \"myftp\": _4, \"no-ip\": _4, \"dscloud\": _4 }], \"bj\": [1, { \"africa\": _3, \"agro\": _3, \"architectes\": _3, \"assur\": _3, \"avocats\": _3, \"co\": _3, \"com\": _3, \"eco\": _3, \"econo\": _3, \"edu\": _3, \"info\": _3, \"loisirs\": _3, \"money\": _3, \"net\": _3, \"org\": _3, \"ote\": _3, \"restaurant\": _3, \"resto\": _3, \"tourism\": _3, \"univ\": _3 }], \"bm\": _5, \"bn\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"co\": _4 }], \"bo\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"int\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"tv\": _3, \"web\": _3, \"academia\": _3, \"agro\": _3, \"arte\": _3, \"blog\": _3, \"bolivia\": _3, \"ciencia\": _3, \"cooperativa\": _3, \"democracia\": _3, \"deporte\": _3, \"ecologia\": _3, \"economia\": _3, \"empresa\": _3, \"indigena\": _3, \"industria\": _3, \"info\": _3, \"medicina\": _3, \"movimiento\": _3, \"musica\": _3, \"natural\": _3, \"nombre\": _3, \"noticias\": _3, \"patria\": _3, \"plurinacional\": _3, \"politica\": _3, \"profesional\": _3, \"pueblo\": _3, \"revista\": _3, \"salud\": _3, \"tecnologia\": _3, \"tksat\": _3, \"transporte\": _3, \"wiki\": _3 }], \"br\": [1, { \"9guacu\": _3, \"abc\": _3, \"adm\": _3, \"adv\": _3, \"agr\": _3, \"aju\": _3, \"am\": _3, \"anani\": _3, \"aparecida\": _3, \"app\": _3, \"arq\": _3, \"art\": _3, \"ato\": _3, \"b\": _3, \"barueri\": _3, \"belem\": _3, \"bet\": _3, \"bhz\": _3, \"bib\": _3, \"bio\": _3, \"blog\": _3, \"bmd\": _3, \"boavista\": _3, \"bsb\": _3, \"campinagrande\": _3, \"campinas\": _3, \"caxias\": _3, \"cim\": _3, \"cng\": _3, \"cnt\": _3, \"com\": [1, { \"simplesite\": _4 }], \"contagem\": _3, \"coop\": _3, \"coz\": _3, \"cri\": _3, \"cuiaba\": _3, \"curitiba\": _3, \"def\": _3, \"des\": _3, \"det\": _3, \"dev\": _3, \"ecn\": _3, \"eco\": _3, \"edu\": _3, \"emp\": _3, \"enf\": _3, \"eng\": _3, \"esp\": _3, \"etc\": _3, \"eti\": _3, \"far\": _3, \"feira\": _3, \"flog\": _3, \"floripa\": _3, \"fm\": _3, \"fnd\": _3, \"fortal\": _3, \"fot\": _3, \"foz\": _3, \"fst\": _3, \"g12\": _3, \"geo\": _3, \"ggf\": _3, \"goiania\": _3, \"gov\": [1, { \"ac\": _3, \"al\": _3, \"am\": _3, \"ap\": _3, \"ba\": _3, \"ce\": _3, \"df\": _3, \"es\": _3, \"go\": _3, \"ma\": _3, \"mg\": _3, \"ms\": _3, \"mt\": _3, \"pa\": _3, \"pb\": _3, \"pe\": _3, \"pi\": _3, \"pr\": _3, \"rj\": _3, \"rn\": _3, \"ro\": _3, \"rr\": _3, \"rs\": _3, \"sc\": _3, \"se\": _3, \"sp\": _3, \"to\": _3 }], \"gru\": _3, \"imb\": _3, \"ind\": _3, \"inf\": _3, \"jab\": _3, \"jampa\": _3, \"jdf\": _3, \"joinville\": _3, \"jor\": _3, \"jus\": _3, \"leg\": [1, { \"ac\": _4, \"al\": _4, \"am\": _4, \"ap\": _4, \"ba\": _4, \"ce\": _4, \"df\": _4, \"es\": _4, \"go\": _4, \"ma\": _4, \"mg\": _4, \"ms\": _4, \"mt\": _4, \"pa\": _4, \"pb\": _4, \"pe\": _4, \"pi\": _4, \"pr\": _4, \"rj\": _4, \"rn\": _4, \"ro\": _4, \"rr\": _4, \"rs\": _4, \"sc\": _4, \"se\": _4, \"sp\": _4, \"to\": _4 }], \"leilao\": _3, \"lel\": _3, \"log\": _3, \"londrina\": _3, \"macapa\": _3, \"maceio\": _3, \"manaus\": _3, \"maringa\": _3, \"mat\": _3, \"med\": _3, \"mil\": _3, \"morena\": _3, \"mp\": _3, \"mus\": _3, \"natal\": _3, \"net\": _3, \"niteroi\": _3, \"nom\": _17, \"not\": _3, \"ntr\": _3, \"odo\": _3, \"ong\": _3, \"org\": _3, \"osasco\": _3, \"palmas\": _3, \"poa\": _3, \"ppg\": _3, \"pro\": _3, \"psc\": _3, \"psi\": _3, \"pvh\": _3, \"qsl\": _3, \"radio\": _3, \"rec\": _3, \"recife\": _3, \"rep\": _3, \"ribeirao\": _3, \"rio\": _3, \"riobranco\": _3, \"riopreto\": _3, \"salvador\": _3, \"sampa\": _3, \"santamaria\": _3, \"santoandre\": _3, \"saobernardo\": _3, \"saogonca\": _3, \"seg\": _3, \"sjc\": _3, \"slg\": _3, \"slz\": _3, \"sorocaba\": _3, \"srv\": _3, \"taxi\": _3, \"tc\": _3, \"tec\": _3, \"teo\": _3, \"the\": _3, \"tmp\": _3, \"trd\": _3, \"tur\": _3, \"tv\": _3, \"udi\": _3, \"vet\": _3, \"vix\": _3, \"vlog\": _3, \"wiki\": _3, \"zlg\": _3 }], \"bs\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"we\": _4 }], \"bt\": _5, \"bv\": _3, \"bw\": [1, { \"ac\": _3, \"co\": _3, \"gov\": _3, \"net\": _3, \"org\": _3 }], \"by\": [1, { \"gov\": _3, \"mil\": _3, \"com\": _3, \"of\": _3, \"mediatech\": _4 }], \"bz\": [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"za\": _4, \"mydns\": _4, \"gsj\": _4 }], \"ca\": [1, { \"ab\": _3, \"bc\": _3, \"mb\": _3, \"nb\": _3, \"nf\": _3, \"nl\": _3, \"ns\": _3, \"nt\": _3, \"nu\": _3, \"on\": _3, \"pe\": _3, \"qc\": _3, \"sk\": _3, \"yk\": _3, \"gc\": _3, \"barsy\": _4, \"awdev\": _7, \"co\": _4, \"no-ip\": _4, \"myspreadshop\": _4, \"box\": _4 }], \"cat\": _3, \"cc\": [1, { \"cleverapps\": _4, \"cloudns\": _4, \"ftpaccess\": _4, \"game-server\": _4, \"myphotos\": _4, \"scrapping\": _4, \"twmail\": _4, \"csx\": _4, \"fantasyleague\": _4, \"spawn\": [0, { \"instances\": _4 }] }], \"cd\": _10, \"cf\": _3, \"cg\": _3, \"ch\": [1, { \"square7\": _4, \"cloudns\": _4, \"cloudscale\": [0, { \"cust\": _4, \"lpg\": _19, \"rma\": _19 }], \"flow\": [0, { \"ae\": [0, { \"alp1\": _4 }], \"appengine\": _4 }], \"linkyard-cloud\": _4, \"gotdns\": _4, \"dnsking\": _4, \"123website\": _4, \"myspreadshop\": _4, \"firenet\": [0, { \"*\": _4, \"svc\": _7 }], \"12hp\": _4, \"2ix\": _4, \"4lima\": _4, \"lima-city\": _4 }], \"ci\": [1, { \"ac\": _3, \"xn--aroport-bya\": _3, \"aéroport\": _3, \"asso\": _3, \"co\": _3, \"com\": _3, \"ed\": _3, \"edu\": _3, \"go\": _3, \"gouv\": _3, \"int\": _3, \"net\": _3, \"or\": _3, \"org\": _3 }], \"ck\": _17, \"cl\": [1, { \"co\": _3, \"gob\": _3, \"gov\": _3, \"mil\": _3, \"cloudns\": _4 }], \"cm\": [1, { \"co\": _3, \"com\": _3, \"gov\": _3, \"net\": _3 }], \"cn\": [1, { \"ac\": _3, \"com\": [1, { \"amazonaws\": [0, { \"cn-north-1\": [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _22, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-deprecated\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4 }], \"cn-northwest-1\": [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _23, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4 }], \"compute\": _7, \"airflow\": [0, { \"cn-north-1\": _7, \"cn-northwest-1\": _7 }], \"eb\": [0, { \"cn-north-1\": _4, \"cn-northwest-1\": _4 }], \"elb\": _7 }], \"sagemaker\": [0, { \"cn-north-1\": _12, \"cn-northwest-1\": _12 }] }], \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"xn--55qx5d\": _3, \"公司\": _3, \"xn--od0alg\": _3, \"網絡\": _3, \"xn--io0a7i\": _3, \"网络\": _3, \"ah\": _3, \"bj\": _3, \"cq\": _3, \"fj\": _3, \"gd\": _3, \"gs\": _3, \"gx\": _3, \"gz\": _3, \"ha\": _3, \"hb\": _3, \"he\": _3, \"hi\": _3, \"hk\": _3, \"hl\": _3, \"hn\": _3, \"jl\": _3, \"js\": _3, \"jx\": _3, \"ln\": _3, \"mo\": _3, \"nm\": _3, \"nx\": _3, \"qh\": _3, \"sc\": _3, \"sd\": _3, \"sh\": [1, { \"as\": _4 }], \"sn\": _3, \"sx\": _3, \"tj\": _3, \"tw\": _3, \"xj\": _3, \"xz\": _3, \"yn\": _3, \"zj\": _3, \"canva-apps\": _4, \"canvasite\": _21, \"myqnapcloud\": _4, \"quickconnect\": _24 }], \"co\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"nom\": _3, \"org\": _3, \"carrd\": _4, \"crd\": _4, \"otap\": _7, \"leadpages\": _4, \"lpages\": _4, \"mypi\": _4, \"xmit\": _7, \"firewalledreplit\": _9, \"repl\": _9, \"supabase\": _4 }], \"com\": [1, { \"a2hosted\": _4, \"cpserver\": _4, \"adobeaemcloud\": [2, { \"dev\": _7 }], \"africa\": _4, \"airkitapps\": _4, \"airkitapps-au\": _4, \"aivencloud\": _4, \"kasserver\": _4, \"amazonaws\": [0, { \"af-south-1\": _27, \"ap-east-1\": _28, \"ap-northeast-1\": _29, \"ap-northeast-2\": _29, \"ap-northeast-3\": _27, \"ap-south-1\": _29, \"ap-south-2\": _30, \"ap-southeast-1\": _29, \"ap-southeast-2\": _29, \"ap-southeast-3\": _30, \"ap-southeast-4\": _30, \"ap-southeast-5\": [0, { \"execute-api\": _4, \"dualstack\": _22, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-deprecated\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4 }], \"ca-central-1\": _32, \"ca-west-1\": [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _31, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-accesspoint-fips\": _4, \"s3-fips\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4 }], \"eu-central-1\": _29, \"eu-central-2\": _30, \"eu-north-1\": _28, \"eu-south-1\": _27, \"eu-south-2\": _30, \"eu-west-1\": [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _22, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-deprecated\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"analytics-gateway\": _4, \"aws-cloud9\": _25, \"cloud9\": _26 }], \"eu-west-2\": _28, \"eu-west-3\": _27, \"il-central-1\": [0, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _22, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"aws-cloud9\": _25, \"cloud9\": [0, { \"vfs\": _4 }] }], \"me-central-1\": _30, \"me-south-1\": _28, \"sa-east-1\": _27, \"us-east-1\": [2, { \"execute-api\": _4, \"emrappui-prod\": _4, \"emrnotebooks-prod\": _4, \"emrstudio-prod\": _4, \"dualstack\": _31, \"s3\": _4, \"s3-accesspoint\": _4, \"s3-accesspoint-fips\": _4, \"s3-deprecated\": _4, \"s3-fips\": _4, \"s3-object-lambda\": _4, \"s3-website\": _4, \"analytics-gateway\": _4, \"aws-cloud9\": _25, \"cloud9\": _26 }], \"us-east-2\": _33, \"us-gov-east-1\": _35, \"us-gov-west-1\": _35, \"us-west-1\": _32, \"us-west-2\": _33, \"compute\": _7, \"compute-1\": _7, \"airflow\": [0, { \"af-south-1\": _7, \"ap-east-1\": _7, \"ap-northeast-1\": _7, \"ap-northeast-2\": _7, \"ap-northeast-3\": _7, \"ap-south-1\": _7, \"ap-south-2\": _7, \"ap-southeast-1\": _7, \"ap-southeast-2\": _7, \"ap-southeast-3\": _7, \"ap-southeast-4\": _7, \"ca-central-1\": _7, \"ca-west-1\": _7, \"eu-central-1\": _7, \"eu-central-2\": _7, \"eu-north-1\": _7, \"eu-south-1\": _7, \"eu-south-2\": _7, \"eu-west-1\": _7, \"eu-west-2\": _7, \"eu-west-3\": _7, \"il-central-1\": _7, \"me-central-1\": _7, \"me-south-1\": _7, \"sa-east-1\": _7, \"us-east-1\": _7, \"us-east-2\": _7, \"us-west-1\": _7, \"us-west-2\": _7 }], \"s3\": _4, \"s3-1\": _4, \"s3-ap-east-1\": _4, \"s3-ap-northeast-1\": _4, \"s3-ap-northeast-2\": _4, \"s3-ap-northeast-3\": _4, \"s3-ap-south-1\": _4, \"s3-ap-southeast-1\": _4, \"s3-ap-southeast-2\": _4, \"s3-ca-central-1\": _4, \"s3-eu-central-1\": _4, \"s3-eu-north-1\": _4, \"s3-eu-west-1\": _4, \"s3-eu-west-2\": _4, \"s3-eu-west-3\": _4, \"s3-external-1\": _4, \"s3-fips-us-gov-east-1\": _4, \"s3-fips-us-gov-west-1\": _4, \"s3-global\": [0, { \"accesspoint\": [0, { \"mrap\": _4 }] }], \"s3-me-south-1\": _4, \"s3-sa-east-1\": _4, \"s3-us-east-2\": _4, \"s3-us-gov-east-1\": _4, \"s3-us-gov-west-1\": _4, \"s3-us-west-1\": _4, \"s3-us-west-2\": _4, \"s3-website-ap-northeast-1\": _4, \"s3-website-ap-southeast-1\": _4, \"s3-website-ap-southeast-2\": _4, \"s3-website-eu-west-1\": _4, \"s3-website-sa-east-1\": _4, \"s3-website-us-east-1\": _4, \"s3-website-us-gov-west-1\": _4, \"s3-website-us-west-1\": _4, \"s3-website-us-west-2\": _4, \"elb\": _7 }], \"amazoncognito\": [0, { \"af-south-1\": _36, \"ap-east-1\": _36, \"ap-northeast-1\": _36, \"ap-northeast-2\": _36, \"ap-northeast-3\": _36, \"ap-south-1\": _36, \"ap-south-2\": _36, \"ap-southeast-1\": _36, \"ap-southeast-2\": _36, \"ap-southeast-3\": _36, \"ap-southeast-4\": _36, \"ca-central-1\": _36, \"ca-west-1\": _36, \"eu-central-1\": _36, \"eu-central-2\": _36, \"eu-north-1\": _36, \"eu-south-1\": _36, \"eu-south-2\": _36, \"eu-west-1\": _36, \"eu-west-2\": _36, \"eu-west-3\": _36, \"il-central-1\": _36, \"me-central-1\": _36, \"me-south-1\": _36, \"sa-east-1\": _36, \"us-east-1\": _37, \"us-east-2\": _37, \"us-gov-west-1\": [0, { \"auth-fips\": _4 }], \"us-west-1\": _37, \"us-west-2\": _37 }], \"amplifyapp\": _4, \"awsapprunner\": _7, \"awsapps\": _4, \"elasticbeanstalk\": [2, { \"af-south-1\": _4, \"ap-east-1\": _4, \"ap-northeast-1\": _4, \"ap-northeast-2\": _4, \"ap-northeast-3\": _4, \"ap-south-1\": _4, \"ap-southeast-1\": _4, \"ap-southeast-2\": _4, \"ap-southeast-3\": _4, \"ca-central-1\": _4, \"eu-central-1\": _4, \"eu-north-1\": _4, \"eu-south-1\": _4, \"eu-west-1\": _4, \"eu-west-2\": _4, \"eu-west-3\": _4, \"il-central-1\": _4, \"me-south-1\": _4, \"sa-east-1\": _4, \"us-east-1\": _4, \"us-east-2\": _4, \"us-gov-east-1\": _4, \"us-gov-west-1\": _4, \"us-west-1\": _4, \"us-west-2\": _4 }], \"awsglobalaccelerator\": _4, \"siiites\": _4, \"appspacehosted\": _4, \"appspaceusercontent\": _4, \"on-aptible\": _4, \"myasustor\": _4, \"balena-devices\": _4, \"boutir\": _4, \"bplaced\": _4, \"cafjs\": _4, \"canva-apps\": _4, \"cdn77-storage\": _4, \"br\": _4, \"cn\": _4, \"de\": _4, \"eu\": _4, \"jpn\": _4, \"mex\": _4, \"ru\": _4, \"sa\": _4, \"uk\": _4, \"us\": _4, \"za\": _4, \"clever-cloud\": [0, { \"services\": _7 }], \"dnsabr\": _4, \"ip-ddns\": _4, \"jdevcloud\": _4, \"wpdevcloud\": _4, \"cf-ipfs\": _4, \"cloudflare-ipfs\": _4, \"trycloudflare\": _4, \"co\": _4, \"builtwithdark\": _4, \"datadetect\": [0, { \"demo\": _4, \"instance\": _4 }], \"dattolocal\": _4, \"dattorelay\": _4, \"dattoweb\": _4, \"mydatto\": _4, \"digitaloceanspaces\": _7, \"discordsays\": _4, \"discordsez\": _4, \"drayddns\": _4, \"dreamhosters\": _4, \"durumis\": _4, \"mydrobo\": _4, \"blogdns\": _4, \"cechire\": _4, \"dnsalias\": _4, \"dnsdojo\": _4, \"doesntexist\": _4, \"dontexist\": _4, \"doomdns\": _4, \"dyn-o-saur\": _4, \"dynalias\": _4, \"dyndns-at-home\": _4, \"dyndns-at-work\": _4, \"dyndns-blog\": _4, \"dyndns-free\": _4, \"dyndns-home\": _4, \"dyndns-ip\": _4, \"dyndns-mail\": _4, \"dyndns-office\": _4, \"dyndns-pics\": _4, \"dyndns-remote\": _4, \"dyndns-server\": _4, \"dyndns-web\": _4, \"dyndns-wiki\": _4, \"dyndns-work\": _4, \"est-a-la-maison\": _4, \"est-a-la-masion\": _4, \"est-le-patron\": _4, \"est-mon-blogueur\": _4, \"from-ak\": _4, \"from-al\": _4, \"from-ar\": _4, \"from-ca\": _4, \"from-ct\": _4, \"from-dc\": _4, \"from-de\": _4, \"from-fl\": _4, \"from-ga\": _4, \"from-hi\": _4, \"from-ia\": _4, \"from-id\": _4, \"from-il\": _4, \"from-in\": _4, \"from-ks\": _4, \"from-ky\": _4, \"from-ma\": _4, \"from-md\": _4, \"from-mi\": _4, \"from-mn\": _4, \"from-mo\": _4, \"from-ms\": _4, \"from-mt\": _4, \"from-nc\": _4, \"from-nd\": _4, \"from-ne\": _4, \"from-nh\": _4, \"from-nj\": _4, \"from-nm\": _4, \"from-nv\": _4, \"from-oh\": _4, \"from-ok\": _4, \"from-or\": _4, \"from-pa\": _4, \"from-pr\": _4, \"from-ri\": _4, \"from-sc\": _4, \"from-sd\": _4, \"from-tn\": _4, \"from-tx\": _4, \"from-ut\": _4, \"from-va\": _4, \"from-vt\": _4, \"from-wa\": _4, \"from-wi\": _4, \"from-wv\": _4, \"from-wy\": _4, \"getmyip\": _4, \"gotdns\": _4, \"hobby-site\": _4, \"homelinux\": _4, \"homeunix\": _4, \"iamallama\": _4, \"is-a-anarchist\": _4, \"is-a-blogger\": _4, \"is-a-bookkeeper\": _4, \"is-a-bulls-fan\": _4, \"is-a-caterer\": _4, \"is-a-chef\": _4, \"is-a-conservative\": _4, \"is-a-cpa\": _4, \"is-a-cubicle-slave\": _4, \"is-a-democrat\": _4, \"is-a-designer\": _4, \"is-a-doctor\": _4, \"is-a-financialadvisor\": _4, \"is-a-geek\": _4, \"is-a-green\": _4, \"is-a-guru\": _4, \"is-a-hard-worker\": _4, \"is-a-hunter\": _4, \"is-a-landscaper\": _4, \"is-a-lawyer\": _4, \"is-a-liberal\": _4, \"is-a-libertarian\": _4, \"is-a-llama\": _4, \"is-a-musician\": _4, \"is-a-nascarfan\": _4, \"is-a-nurse\": _4, \"is-a-painter\": _4, \"is-a-personaltrainer\": _4, \"is-a-photographer\": _4, \"is-a-player\": _4, \"is-a-republican\": _4, \"is-a-rockstar\": _4, \"is-a-socialist\": _4, \"is-a-student\": _4, \"is-a-teacher\": _4, \"is-a-techie\": _4, \"is-a-therapist\": _4, \"is-an-accountant\": _4, \"is-an-actor\": _4, \"is-an-actress\": _4, \"is-an-anarchist\": _4, \"is-an-artist\": _4, \"is-an-engineer\": _4, \"is-an-entertainer\": _4, \"is-certified\": _4, \"is-gone\": _4, \"is-into-anime\": _4, \"is-into-cars\": _4, \"is-into-cartoons\": _4, \"is-into-games\": _4, \"is-leet\": _4, \"is-not-certified\": _4, \"is-slick\": _4, \"is-uberleet\": _4, \"is-with-theband\": _4, \"isa-geek\": _4, \"isa-hockeynut\": _4, \"issmarterthanyou\": _4, \"likes-pie\": _4, \"likescandy\": _4, \"neat-url\": _4, \"saves-the-whales\": _4, \"selfip\": _4, \"sells-for-less\": _4, \"sells-for-u\": _4, \"servebbs\": _4, \"simple-url\": _4, \"space-to-rent\": _4, \"teaches-yoga\": _4, \"writesthisblog\": _4, \"ddnsfree\": _4, \"ddnsgeek\": _4, \"giize\": _4, \"gleeze\": _4, \"kozow\": _4, \"loseyourip\": _4, \"ooguy\": _4, \"theworkpc\": _4, \"mytuleap\": _4, \"tuleap-partners\": _4, \"encoreapi\": _4, \"evennode\": [0, { \"eu-1\": _4, \"eu-2\": _4, \"eu-3\": _4, \"eu-4\": _4, \"us-1\": _4, \"us-2\": _4, \"us-3\": _4, \"us-4\": _4 }], \"onfabrica\": _4, \"fastly-edge\": _4, \"fastly-terrarium\": _4, \"fastvps-server\": _4, \"mydobiss\": _4, \"firebaseapp\": _4, \"fldrv\": _4, \"forgeblocks\": _4, \"framercanvas\": _4, \"freebox-os\": _4, \"freeboxos\": _4, \"freemyip\": _4, \"aliases121\": _4, \"gentapps\": _4, \"gentlentapis\": _4, \"githubusercontent\": _4, \"0emm\": _7, \"appspot\": [2, { \"r\": _7 }], \"blogspot\": _4, \"codespot\": _4, \"googleapis\": _4, \"googlecode\": _4, \"pagespeedmobilizer\": _4, \"withgoogle\": _4, \"withyoutube\": _4, \"grayjayleagues\": _4, \"hatenablog\": _4, \"hatenadiary\": _4, \"herokuapp\": _4, \"gr\": _4, \"smushcdn\": _4, \"wphostedmail\": _4, \"wpmucdn\": _4, \"pixolino\": _4, \"apps-1and1\": _4, \"live-website\": _4, \"dopaas\": _4, \"hosted-by-previder\": _39, \"hosteur\": [0, { \"rag-cloud\": _4, \"rag-cloud-ch\": _4 }], \"ik-server\": [0, { \"jcloud\": _4, \"jcloud-ver-jpc\": _4 }], \"jelastic\": [0, { \"demo\": _4 }], \"massivegrid\": _39, \"wafaicloud\": [0, { \"jed\": _4, \"ryd\": _4 }], \"webadorsite\": _4, \"joyent\": [0, { \"cns\": _7 }], \"lpusercontent\": _4, \"linode\": [0, { \"members\": _4, \"nodebalancer\": _7 }], \"linodeobjects\": _7, \"linodeusercontent\": [0, { \"ip\": _4 }], \"barsycenter\": _4, \"barsyonline\": _4, \"modelscape\": _4, \"mwcloudnonprod\": _4, \"polyspace\": _4, \"mazeplay\": _4, \"miniserver\": _4, \"atmeta\": _4, \"fbsbx\": _38, \"meteorapp\": _40, \"routingthecloud\": _4, \"mydbserver\": _4, \"hostedpi\": _4, \"mythic-beasts\": [0, { \"caracal\": _4, \"customer\": _4, \"fentiger\": _4, \"lynx\": _4, \"ocelot\": _4, \"oncilla\": _4, \"onza\": _4, \"sphinx\": _4, \"vs\": _4, \"x\": _4, \"yali\": _4 }], \"nospamproxy\": [0, { \"cloud\": [2, { \"o365\": _4 }] }], \"4u\": _4, \"nfshost\": _4, \"3utilities\": _4, \"blogsyte\": _4, \"ciscofreak\": _4, \"damnserver\": _4, \"ddnsking\": _4, \"ditchyourip\": _4, \"dnsiskinky\": _4, \"dynns\": _4, \"geekgalaxy\": _4, \"health-carereform\": _4, \"homesecuritymac\": _4, \"homesecuritypc\": _4, \"myactivedirectory\": _4, \"mysecuritycamera\": _4, \"myvnc\": _4, \"net-freaks\": _4, \"onthewifi\": _4, \"point2this\": _4, \"quicksytes\": _4, \"securitytactics\": _4, \"servebeer\": _4, \"servecounterstrike\": _4, \"serveexchange\": _4, \"serveftp\": _4, \"servegame\": _4, \"servehalflife\": _4, \"servehttp\": _4, \"servehumour\": _4, \"serveirc\": _4, \"servemp3\": _4, \"servep2p\": _4, \"servepics\": _4, \"servequake\": _4, \"servesarcasm\": _4, \"stufftoread\": _4, \"unusualperson\": _4, \"workisboring\": _4, \"myiphost\": _4, \"observableusercontent\": [0, { \"static\": _4 }], \"simplesite\": _4, \"orsites\": _4, \"operaunite\": _4, \"customer-oci\": [0, { \"*\": _4, \"oci\": _7, \"ocp\": _7, \"ocs\": _7 }], \"oraclecloudapps\": _7, \"oraclegovcloudapps\": _7, \"authgear-staging\": _4, \"authgearapps\": _4, \"skygearapp\": _4, \"outsystemscloud\": _4, \"ownprovider\": _4, \"pgfog\": _4, \"pagexl\": _4, \"gotpantheon\": _4, \"paywhirl\": _7, \"upsunapp\": _4, \"postman-echo\": _4, \"prgmr\": [0, { \"xen\": _4 }], \"pythonanywhere\": _40, \"qa2\": _4, \"alpha-myqnapcloud\": _4, \"dev-myqnapcloud\": _4, \"mycloudnas\": _4, \"mynascloud\": _4, \"myqnapcloud\": _4, \"qualifioapp\": _4, \"ladesk\": _4, \"qbuser\": _4, \"quipelements\": _7, \"rackmaze\": _4, \"readthedocs-hosted\": _4, \"rhcloud\": _4, \"onrender\": _4, \"render\": _41, \"subsc-pay\": _4, \"180r\": _4, \"dojin\": _4, \"sakuratan\": _4, \"sakuraweb\": _4, \"x0\": _4, \"code\": [0, { \"builder\": _7, \"dev-builder\": _7, \"stg-builder\": _7 }], \"salesforce\": [0, { \"platform\": [0, { \"code-builder-stg\": [0, { \"test\": [0, { \"001\": _7 }] }] }] }], \"logoip\": _4, \"scrysec\": _4, \"firewall-gateway\": _4, \"myshopblocks\": _4, \"myshopify\": _4, \"shopitsite\": _4, \"1kapp\": _4, \"appchizi\": _4, \"applinzi\": _4, \"sinaapp\": _4, \"vipsinaapp\": _4, \"streamlitapp\": _4, \"try-snowplow\": _4, \"playstation-cloud\": _4, \"myspreadshop\": _4, \"w-corp-staticblitz\": _4, \"w-credentialless-staticblitz\": _4, \"w-staticblitz\": _4, \"stackhero-network\": _4, \"stdlib\": [0, { \"api\": _4 }], \"strapiapp\": [2, { \"media\": _4 }], \"streak-link\": _4, \"streaklinks\": _4, \"streakusercontent\": _4, \"temp-dns\": _4, \"dsmynas\": _4, \"familyds\": _4, \"mytabit\": _4, \"taveusercontent\": _4, \"tb-hosting\": _42, \"reservd\": _4, \"thingdustdata\": _4, \"townnews-staging\": _4, \"typeform\": [0, { \"pro\": _4 }], \"hk\": _4, \"it\": _4, \"vultrobjects\": _7, \"wafflecell\": _4, \"hotelwithflight\": _4, \"reserve-online\": _4, \"cprapid\": _4, \"pleskns\": _4, \"remotewd\": _4, \"wiardweb\": [0, { \"pages\": _4 }], \"wixsite\": _4, \"wixstudio\": _4, \"messwithdns\": _4, \"woltlab-demo\": _4, \"wpenginepowered\": [2, { \"js\": _4 }], \"xnbay\": [2, { \"u2\": _4, \"u2-local\": _4 }], \"yolasite\": _4 }], \"coop\": _3, \"cr\": [1, { \"ac\": _3, \"co\": _3, \"ed\": _3, \"fi\": _3, \"go\": _3, \"or\": _3, \"sa\": _3 }], \"cu\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"inf\": _3, \"nat\": _3, \"net\": _3, \"org\": _3 }], \"cv\": [1, { \"com\": _3, \"edu\": _3, \"id\": _3, \"int\": _3, \"net\": _3, \"nome\": _3, \"org\": _3, \"publ\": _3 }], \"cw\": _43, \"cx\": [1, { \"gov\": _3, \"cloudns\": _4, \"ath\": _4, \"info\": _4, \"assessments\": _4, \"calculators\": _4, \"funnels\": _4, \"paynow\": _4, \"quizzes\": _4, \"researched\": _4, \"tests\": _4 }], \"cy\": [1, { \"ac\": _3, \"biz\": _3, \"com\": [1, { \"scaleforce\": _44 }], \"ekloges\": _3, \"gov\": _3, \"ltd\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"press\": _3, \"pro\": _3, \"tm\": _3 }], \"cz\": [1, { \"contentproxy9\": [0, { \"rsc\": _4 }], \"realm\": _4, \"e4\": _4, \"co\": _4, \"metacentrum\": [0, { \"cloud\": _7, \"custom\": _4 }], \"muni\": [0, { \"cloud\": [0, { \"flt\": _4, \"usr\": _4 }] }] }], \"de\": [1, { \"bplaced\": _4, \"square7\": _4, \"com\": _4, \"cosidns\": _45, \"dnsupdater\": _4, \"dynamisches-dns\": _4, \"internet-dns\": _4, \"l-o-g-i-n\": _4, \"ddnss\": [2, { \"dyn\": _4, \"dyndns\": _4 }], \"dyn-ip24\": _4, \"dyndns1\": _4, \"home-webserver\": [2, { \"dyn\": _4 }], \"myhome-server\": _4, \"dnshome\": _4, \"fuettertdasnetz\": _4, \"isteingeek\": _4, \"istmein\": _4, \"lebtimnetz\": _4, \"leitungsen\": _4, \"traeumtgerade\": _4, \"frusky\": _7, \"goip\": _4, \"xn--gnstigbestellen-zvb\": _4, \"günstigbestellen\": _4, \"xn--gnstigliefern-wob\": _4, \"günstigliefern\": _4, \"hs-heilbronn\": [0, { \"it\": [0, { \"pages\": _4, \"pages-research\": _4 }] }], \"dyn-berlin\": _4, \"in-berlin\": _4, \"in-brb\": _4, \"in-butter\": _4, \"in-dsl\": _4, \"in-vpn\": _4, \"iservschule\": _4, \"mein-iserv\": _4, \"schulplattform\": _4, \"schulserver\": _4, \"test-iserv\": _4, \"keymachine\": _4, \"git-repos\": _4, \"lcube-server\": _4, \"svn-repos\": _4, \"barsy\": _4, \"webspaceconfig\": _4, \"123webseite\": _4, \"rub\": _4, \"ruhr-uni-bochum\": [2, { \"noc\": [0, { \"io\": _4 }] }], \"logoip\": _4, \"firewall-gateway\": _4, \"my-gateway\": _4, \"my-router\": _4, \"spdns\": _4, \"speedpartner\": [0, { \"customer\": _4 }], \"myspreadshop\": _4, \"taifun-dns\": _4, \"12hp\": _4, \"2ix\": _4, \"4lima\": _4, \"lima-city\": _4, \"dd-dns\": _4, \"dray-dns\": _4, \"draydns\": _4, \"dyn-vpn\": _4, \"dynvpn\": _4, \"mein-vigor\": _4, \"my-vigor\": _4, \"my-wan\": _4, \"syno-ds\": _4, \"synology-diskstation\": _4, \"synology-ds\": _4, \"uberspace\": _7, \"virtual-user\": _4, \"virtualuser\": _4, \"community-pro\": _4, \"diskussionsbereich\": _4 }], \"dj\": _3, \"dk\": [1, { \"biz\": _4, \"co\": _4, \"firm\": _4, \"reg\": _4, \"store\": _4, \"123hjemmeside\": _4, \"myspreadshop\": _4 }], \"dm\": _46, \"do\": [1, { \"art\": _3, \"com\": _3, \"edu\": _3, \"gob\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"sld\": _3, \"web\": _3 }], \"dz\": [1, { \"art\": _3, \"asso\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"pol\": _3, \"soc\": _3, \"tm\": _3 }], \"ec\": [1, { \"com\": _3, \"edu\": _3, \"fin\": _3, \"gob\": _3, \"gov\": _3, \"info\": _3, \"k12\": _3, \"med\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"pro\": _3, \"base\": _4, \"official\": _4 }], \"edu\": [1, { \"rit\": [0, { \"git-pages\": _4 }] }], \"ee\": [1, { \"aip\": _3, \"com\": _3, \"edu\": _3, \"fie\": _3, \"gov\": _3, \"lib\": _3, \"med\": _3, \"org\": _3, \"pri\": _3, \"riik\": _3 }], \"eg\": [1, { \"ac\": _3, \"com\": _3, \"edu\": _3, \"eun\": _3, \"gov\": _3, \"info\": _3, \"me\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"sci\": _3, \"sport\": _3, \"tv\": _3 }], \"er\": _17, \"es\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"nom\": _3, \"org\": _3, \"123miweb\": _4, \"myspreadshop\": _4 }], \"et\": [1, { \"biz\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"name\": _3, \"net\": _3, \"org\": _3 }], \"eu\": [1, { \"airkitapps\": _4, \"cloudns\": _4, \"dogado\": [0, { \"jelastic\": _4 }], \"barsy\": _4, \"spdns\": _4, \"transurl\": _7, \"diskstation\": _4 }], \"fi\": [1, { \"aland\": _3, \"dy\": _4, \"xn--hkkinen-5wa\": _4, \"häkkinen\": _4, \"iki\": _4, \"cloudplatform\": [0, { \"fi\": _4 }], \"datacenter\": [0, { \"demo\": _4, \"paas\": _4 }], \"kapsi\": _4, \"123kotisivu\": _4, \"myspreadshop\": _4 }], \"fj\": [1, { \"ac\": _3, \"biz\": _3, \"com\": _3, \"gov\": _3, \"info\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"pro\": _3 }], \"fk\": _17, \"fm\": [1, { \"com\": _3, \"edu\": _3, \"net\": _3, \"org\": _3, \"radio\": _4, \"user\": _7 }], \"fo\": _3, \"fr\": [1, { \"asso\": _3, \"com\": _3, \"gouv\": _3, \"nom\": _3, \"prd\": _3, \"tm\": _3, \"avoues\": _3, \"cci\": _3, \"greta\": _3, \"huissier-justice\": _3, \"en-root\": _4, \"fbx-os\": _4, \"fbxos\": _4, \"freebox-os\": _4, \"freeboxos\": _4, \"goupile\": _4, \"123siteweb\": _4, \"on-web\": _4, \"chirurgiens-dentistes-en-france\": _4, \"dedibox\": _4, \"aeroport\": _4, \"avocat\": _4, \"chambagri\": _4, \"chirurgiens-dentistes\": _4, \"experts-comptables\": _4, \"medecin\": _4, \"notaires\": _4, \"pharmacien\": _4, \"port\": _4, \"veterinaire\": _4, \"myspreadshop\": _4, \"ynh\": _4 }], \"ga\": _3, \"gb\": _3, \"gd\": [1, { \"edu\": _3, \"gov\": _3 }], \"ge\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"pvt\": _3, \"school\": _3 }], \"gf\": _3, \"gg\": [1, { \"co\": _3, \"net\": _3, \"org\": _3, \"botdash\": _4, \"kaas\": _4, \"stackit\": _4, \"panel\": [2, { \"daemon\": _4 }] }], \"gh\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"org\": _3 }], \"gi\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"ltd\": _3, \"mod\": _3, \"org\": _3 }], \"gl\": [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"net\": _3, \"org\": _3, \"biz\": _4 }], \"gm\": _3, \"gn\": [1, { \"ac\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3 }], \"gov\": _3, \"gp\": [1, { \"asso\": _3, \"com\": _3, \"edu\": _3, \"mobi\": _3, \"net\": _3, \"org\": _3 }], \"gq\": _3, \"gr\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"barsy\": _4, \"simplesite\": _4 }], \"gs\": _3, \"gt\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"ind\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], \"gu\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"guam\": _3, \"info\": _3, \"net\": _3, \"org\": _3, \"web\": _3 }], \"gw\": _3, \"gy\": _46, \"hk\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"idv\": _3, \"net\": _3, \"org\": _3, \"xn--ciqpn\": _3, \"个人\": _3, \"xn--gmqw5a\": _3, \"個人\": _3, \"xn--55qx5d\": _3, \"公司\": _3, \"xn--mxtq1m\": _3, \"政府\": _3, \"xn--lcvr32d\": _3, \"敎育\": _3, \"xn--wcvs22d\": _3, \"教育\": _3, \"xn--gmq050i\": _3, \"箇人\": _3, \"xn--uc0atv\": _3, \"組織\": _3, \"xn--uc0ay4a\": _3, \"組织\": _3, \"xn--od0alg\": _3, \"網絡\": _3, \"xn--zf0avx\": _3, \"網络\": _3, \"xn--mk0axi\": _3, \"组織\": _3, \"xn--tn0ag\": _3, \"组织\": _3, \"xn--od0aq3b\": _3, \"网絡\": _3, \"xn--io0a7i\": _3, \"网络\": _3, \"inc\": _4, \"ltd\": _4 }], \"hm\": _3, \"hn\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], \"hr\": [1, { \"com\": _3, \"from\": _3, \"iz\": _3, \"name\": _3, \"brendly\": _49 }], \"ht\": [1, { \"adult\": _3, \"art\": _3, \"asso\": _3, \"com\": _3, \"coop\": _3, \"edu\": _3, \"firm\": _3, \"gouv\": _3, \"info\": _3, \"med\": _3, \"net\": _3, \"org\": _3, \"perso\": _3, \"pol\": _3, \"pro\": _3, \"rel\": _3, \"shop\": _3, \"rt\": _4 }], \"hu\": [1, { \"2000\": _3, \"agrar\": _3, \"bolt\": _3, \"casino\": _3, \"city\": _3, \"co\": _3, \"erotica\": _3, \"erotika\": _3, \"film\": _3, \"forum\": _3, \"games\": _3, \"hotel\": _3, \"info\": _3, \"ingatlan\": _3, \"jogasz\": _3, \"konyvelo\": _3, \"lakas\": _3, \"media\": _3, \"news\": _3, \"org\": _3, \"priv\": _3, \"reklam\": _3, \"sex\": _3, \"shop\": _3, \"sport\": _3, \"suli\": _3, \"szex\": _3, \"tm\": _3, \"tozsde\": _3, \"utazas\": _3, \"video\": _3 }], \"id\": [1, { \"ac\": _3, \"biz\": _3, \"co\": _3, \"desa\": _3, \"go\": _3, \"mil\": _3, \"my\": _3, \"net\": _3, \"or\": _3, \"ponpes\": _3, \"sch\": _3, \"web\": _3 }], \"ie\": [1, { \"gov\": _3, \"myspreadshop\": _4 }], \"il\": [1, { \"ac\": _3, \"co\": [1, { \"ravpage\": _4, \"mytabit\": _4, \"tabitorder\": _4 }], \"gov\": _3, \"idf\": _3, \"k12\": _3, \"muni\": _3, \"net\": _3, \"org\": _3 }], \"xn--4dbrk0ce\": [1, { \"xn--4dbgdty6c\": _3, \"xn--5dbhl8d\": _3, \"xn--8dbq2a\": _3, \"xn--hebda8b\": _3 }], \"ישראל\": [1, { \"אקדמיה\": _3, \"ישוב\": _3, \"צהל\": _3, \"ממשל\": _3 }], \"im\": [1, { \"ac\": _3, \"co\": [1, { \"ltd\": _3, \"plc\": _3 }], \"com\": _3, \"net\": _3, \"org\": _3, \"tt\": _3, \"tv\": _3 }], \"in\": [1, { \"5g\": _3, \"6g\": _3, \"ac\": _3, \"ai\": _3, \"am\": _3, \"bihar\": _3, \"biz\": _3, \"business\": _3, \"ca\": _3, \"cn\": _3, \"co\": _3, \"com\": _3, \"coop\": _3, \"cs\": _3, \"delhi\": _3, \"dr\": _3, \"edu\": _3, \"er\": _3, \"firm\": _3, \"gen\": _3, \"gov\": _3, \"gujarat\": _3, \"ind\": _3, \"info\": _3, \"int\": _3, \"internet\": _3, \"io\": _3, \"me\": _3, \"mil\": _3, \"net\": _3, \"nic\": _3, \"org\": _3, \"pg\": _3, \"post\": _3, \"pro\": _3, \"res\": _3, \"travel\": _3, \"tv\": _3, \"uk\": _3, \"up\": _3, \"us\": _3, \"cloudns\": _4, \"barsy\": _4, \"web\": _4, \"supabase\": _4 }], \"info\": [1, { \"cloudns\": _4, \"dynamic-dns\": _4, \"barrel-of-knowledge\": _4, \"barrell-of-knowledge\": _4, \"dyndns\": _4, \"for-our\": _4, \"groks-the\": _4, \"groks-this\": _4, \"here-for-more\": _4, \"knowsitall\": _4, \"selfip\": _4, \"webhop\": _4, \"barsy\": _4, \"mayfirst\": _4, \"mittwald\": _4, \"mittwaldserver\": _4, \"typo3server\": _4, \"dvrcam\": _4, \"ilovecollege\": _4, \"no-ip\": _4, \"forumz\": _4, \"nsupdate\": _4, \"dnsupdate\": _4, \"v-info\": _4 }], \"int\": [1, { \"eu\": _3 }], \"io\": [1, { \"2038\": _4, \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"nom\": _3, \"org\": _3, \"on-acorn\": _7, \"myaddr\": _4, \"apigee\": _4, \"b-data\": _4, \"beagleboard\": _4, \"bitbucket\": _4, \"bluebite\": _4, \"boxfuse\": _4, \"brave\": [0, { \"s\": _7 }], \"browsersafetymark\": _4, \"bigv\": [0, { \"uk0\": _4 }], \"cleverapps\": _4, \"cloudbeesusercontent\": _4, \"dappnode\": [0, { \"dyndns\": _4 }], \"darklang\": _4, \"definima\": _4, \"dedyn\": _4, \"fh-muenster\": _4, \"shw\": _4, \"forgerock\": [0, { \"id\": _4 }], \"github\": _4, \"gitlab\": _4, \"lolipop\": _4, \"hasura-app\": _4, \"hostyhosting\": _4, \"hypernode\": _4, \"moonscale\": _7, \"beebyte\": _39, \"beebyteapp\": [0, { \"sekd1\": _4 }], \"jele\": _4, \"webthings\": _4, \"loginline\": _4, \"barsy\": _4, \"azurecontainer\": _7, \"ngrok\": [2, { \"ap\": _4, \"au\": _4, \"eu\": _4, \"in\": _4, \"jp\": _4, \"sa\": _4, \"us\": _4 }], \"nodeart\": [0, { \"stage\": _4 }], \"pantheonsite\": _4, \"pstmn\": [2, { \"mock\": _4 }], \"protonet\": _4, \"qcx\": [2, { \"sys\": _7 }], \"qoto\": _4, \"vaporcloud\": _4, \"myrdbx\": _4, \"rb-hosting\": _42, \"on-k3s\": _7, \"on-rio\": _7, \"readthedocs\": _4, \"resindevice\": _4, \"resinstaging\": [0, { \"devices\": _4 }], \"hzc\": _4, \"sandcats\": _4, \"scrypted\": [0, { \"client\": _4 }], \"mo-siemens\": _4, \"lair\": _38, \"stolos\": _7, \"musician\": _4, \"utwente\": _4, \"edugit\": _4, \"telebit\": _4, \"thingdust\": [0, { \"dev\": _50, \"disrec\": _50, \"prod\": _51, \"testing\": _50 }], \"tickets\": _4, \"webflow\": _4, \"webflowtest\": _4, \"editorx\": _4, \"wixstudio\": _4, \"basicserver\": _4, \"virtualserver\": _4 }], \"iq\": _6, \"ir\": [1, { \"ac\": _3, \"co\": _3, \"gov\": _3, \"id\": _3, \"net\": _3, \"org\": _3, \"sch\": _3, \"xn--mgba3a4f16a\": _3, \"ایران\": _3, \"xn--mgba3a4fra\": _3, \"ايران\": _3, \"arvanedge\": _4 }], \"is\": _3, \"it\": [1, { \"edu\": _3, \"gov\": _3, \"abr\": _3, \"abruzzo\": _3, \"aosta-valley\": _3, \"aostavalley\": _3, \"bas\": _3, \"basilicata\": _3, \"cal\": _3, \"calabria\": _3, \"cam\": _3, \"campania\": _3, \"emilia-romagna\": _3, \"emiliaromagna\": _3, \"emr\": _3, \"friuli-v-giulia\": _3, \"friuli-ve-giulia\": _3, \"friuli-vegiulia\": _3, \"friuli-venezia-giulia\": _3, \"friuli-veneziagiulia\": _3, \"friuli-vgiulia\": _3, \"friuliv-giulia\": _3, \"friulive-giulia\": _3, \"friulivegiulia\": _3, \"friulivenezia-giulia\": _3, \"friuliveneziagiulia\": _3, \"friulivgiulia\": _3, \"fvg\": _3, \"laz\": _3, \"lazio\": _3, \"lig\": _3, \"liguria\": _3, \"lom\": _3, \"lombardia\": _3, \"lombardy\": _3, \"lucania\": _3, \"mar\": _3, \"marche\": _3, \"mol\": _3, \"molise\": _3, \"piedmont\": _3, \"piemonte\": _3, \"pmn\": _3, \"pug\": _3, \"puglia\": _3, \"sar\": _3, \"sardegna\": _3, \"sardinia\": _3, \"sic\": _3, \"sicilia\": _3, \"sicily\": _3, \"taa\": _3, \"tos\": _3, \"toscana\": _3, \"trentin-sud-tirol\": _3, \"xn--trentin-sd-tirol-rzb\": _3, \"trentin-süd-tirol\": _3, \"trentin-sudtirol\": _3, \"xn--trentin-sdtirol-7vb\": _3, \"trentin-südtirol\": _3, \"trentin-sued-tirol\": _3, \"trentin-suedtirol\": _3, \"trentino\": _3, \"trentino-a-adige\": _3, \"trentino-aadige\": _3, \"trentino-alto-adige\": _3, \"trentino-altoadige\": _3, \"trentino-s-tirol\": _3, \"trentino-stirol\": _3, \"trentino-sud-tirol\": _3, \"xn--trentino-sd-tirol-c3b\": _3, \"trentino-süd-tirol\": _3, \"trentino-sudtirol\": _3, \"xn--trentino-sdtirol-szb\": _3, \"trentino-südtirol\": _3, \"trentino-sued-tirol\": _3, \"trentino-suedtirol\": _3, \"trentinoa-adige\": _3, \"trentinoaadige\": _3, \"trentinoalto-adige\": _3, \"trentinoaltoadige\": _3, \"trentinos-tirol\": _3, \"trentinostirol\": _3, \"trentinosud-tirol\": _3, \"xn--trentinosd-tirol-rzb\": _3, \"trentinosüd-tirol\": _3, \"trentinosudtirol\": _3, \"xn--trentinosdtirol-7vb\": _3, \"trentinosüdtirol\": _3, \"trentinosued-tirol\": _3, \"trentinosuedtirol\": _3, \"trentinsud-tirol\": _3, \"xn--trentinsd-tirol-6vb\": _3, \"trentinsüd-tirol\": _3, \"trentinsudtirol\": _3, \"xn--trentinsdtirol-nsb\": _3, \"trentinsüdtirol\": _3, \"trentinsued-tirol\": _3, \"trentinsuedtirol\": _3, \"tuscany\": _3, \"umb\": _3, \"umbria\": _3, \"val-d-aosta\": _3, \"val-daosta\": _3, \"vald-aosta\": _3, \"valdaosta\": _3, \"valle-aosta\": _3, \"valle-d-aosta\": _3, \"valle-daosta\": _3, \"valleaosta\": _3, \"valled-aosta\": _3, \"valledaosta\": _3, \"vallee-aoste\": _3, \"xn--valle-aoste-ebb\": _3, \"vallée-aoste\": _3, \"vallee-d-aoste\": _3, \"xn--valle-d-aoste-ehb\": _3, \"vallée-d-aoste\": _3, \"valleeaoste\": _3, \"xn--valleaoste-e7a\": _3, \"valléeaoste\": _3, \"valleedaoste\": _3, \"xn--valledaoste-ebb\": _3, \"valléedaoste\": _3, \"vao\": _3, \"vda\": _3, \"ven\": _3, \"veneto\": _3, \"ag\": _3, \"agrigento\": _3, \"al\": _3, \"alessandria\": _3, \"alto-adige\": _3, \"altoadige\": _3, \"an\": _3, \"ancona\": _3, \"andria-barletta-trani\": _3, \"andria-trani-barletta\": _3, \"andriabarlettatrani\": _3, \"andriatranibarletta\": _3, \"ao\": _3, \"aosta\": _3, \"aoste\": _3, \"ap\": _3, \"aq\": _3, \"aquila\": _3, \"ar\": _3, \"arezzo\": _3, \"ascoli-piceno\": _3, \"ascolipiceno\": _3, \"asti\": _3, \"at\": _3, \"av\": _3, \"avellino\": _3, \"ba\": _3, \"balsan\": _3, \"balsan-sudtirol\": _3, \"xn--balsan-sdtirol-nsb\": _3, \"balsan-südtirol\": _3, \"balsan-suedtirol\": _3, \"bari\": _3, \"barletta-trani-andria\": _3, \"barlettatraniandria\": _3, \"belluno\": _3, \"benevento\": _3, \"bergamo\": _3, \"bg\": _3, \"bi\": _3, \"biella\": _3, \"bl\": _3, \"bn\": _3, \"bo\": _3, \"bologna\": _3, \"bolzano\": _3, \"bolzano-altoadige\": _3, \"bozen\": _3, \"bozen-sudtirol\": _3, \"xn--bozen-sdtirol-2ob\": _3, \"bozen-südtirol\": _3, \"bozen-suedtirol\": _3, \"br\": _3, \"brescia\": _3, \"brindisi\": _3, \"bs\": _3, \"bt\": _3, \"bulsan\": _3, \"bulsan-sudtirol\": _3, \"xn--bulsan-sdtirol-nsb\": _3, \"bulsan-südtirol\": _3, \"bulsan-suedtirol\": _3, \"bz\": _3, \"ca\": _3, \"cagliari\": _3, \"caltanissetta\": _3, \"campidano-medio\": _3, \"campidanomedio\": _3, \"campobasso\": _3, \"carbonia-iglesias\": _3, \"carboniaiglesias\": _3, \"carrara-massa\": _3, \"carraramassa\": _3, \"caserta\": _3, \"catania\": _3, \"catanzaro\": _3, \"cb\": _3, \"ce\": _3, \"cesena-forli\": _3, \"xn--cesena-forl-mcb\": _3, \"cesena-forlì\": _3, \"cesenaforli\": _3, \"xn--cesenaforl-i8a\": _3, \"cesenaforlì\": _3, \"ch\": _3, \"chieti\": _3, \"ci\": _3, \"cl\": _3, \"cn\": _3, \"co\": _3, \"como\": _3, \"cosenza\": _3, \"cr\": _3, \"cremona\": _3, \"crotone\": _3, \"cs\": _3, \"ct\": _3, \"cuneo\": _3, \"cz\": _3, \"dell-ogliastra\": _3, \"dellogliastra\": _3, \"en\": _3, \"enna\": _3, \"fc\": _3, \"fe\": _3, \"fermo\": _3, \"ferrara\": _3, \"fg\": _3, \"fi\": _3, \"firenze\": _3, \"florence\": _3, \"fm\": _3, \"foggia\": _3, \"forli-cesena\": _3, \"xn--forl-cesena-fcb\": _3, \"forlì-cesena\": _3, \"forlicesena\": _3, \"xn--forlcesena-c8a\": _3, \"forlìcesena\": _3, \"fr\": _3, \"frosinone\": _3, \"ge\": _3, \"genoa\": _3, \"genova\": _3, \"go\": _3, \"gorizia\": _3, \"gr\": _3, \"grosseto\": _3, \"iglesias-carbonia\": _3, \"iglesiascarbonia\": _3, \"im\": _3, \"imperia\": _3, \"is\": _3, \"isernia\": _3, \"kr\": _3, \"la-spezia\": _3, \"laquila\": _3, \"laspezia\": _3, \"latina\": _3, \"lc\": _3, \"le\": _3, \"lecce\": _3, \"lecco\": _3, \"li\": _3, \"livorno\": _3, \"lo\": _3, \"lodi\": _3, \"lt\": _3, \"lu\": _3, \"lucca\": _3, \"macerata\": _3, \"mantova\": _3, \"massa-carrara\": _3, \"massacarrara\": _3, \"matera\": _3, \"mb\": _3, \"mc\": _3, \"me\": _3, \"medio-campidano\": _3, \"mediocampidano\": _3, \"messina\": _3, \"mi\": _3, \"milan\": _3, \"milano\": _3, \"mn\": _3, \"mo\": _3, \"modena\": _3, \"monza\": _3, \"monza-brianza\": _3, \"monza-e-della-brianza\": _3, \"monzabrianza\": _3, \"monzaebrianza\": _3, \"monzaedellabrianza\": _3, \"ms\": _3, \"mt\": _3, \"na\": _3, \"naples\": _3, \"napoli\": _3, \"no\": _3, \"novara\": _3, \"nu\": _3, \"nuoro\": _3, \"og\": _3, \"ogliastra\": _3, \"olbia-tempio\": _3, \"olbiatempio\": _3, \"or\": _3, \"oristano\": _3, \"ot\": _3, \"pa\": _3, \"padova\": _3, \"padua\": _3, \"palermo\": _3, \"parma\": _3, \"pavia\": _3, \"pc\": _3, \"pd\": _3, \"pe\": _3, \"perugia\": _3, \"pesaro-urbino\": _3, \"pesarourbino\": _3, \"pescara\": _3, \"pg\": _3, \"pi\": _3, \"piacenza\": _3, \"pisa\": _3, \"pistoia\": _3, \"pn\": _3, \"po\": _3, \"pordenone\": _3, \"potenza\": _3, \"pr\": _3, \"prato\": _3, \"pt\": _3, \"pu\": _3, \"pv\": _3, \"pz\": _3, \"ra\": _3, \"ragusa\": _3, \"ravenna\": _3, \"rc\": _3, \"re\": _3, \"reggio-calabria\": _3, \"reggio-emilia\": _3, \"reggiocalabria\": _3, \"reggioemilia\": _3, \"rg\": _3, \"ri\": _3, \"rieti\": _3, \"rimini\": _3, \"rm\": _3, \"rn\": _3, \"ro\": _3, \"roma\": _3, \"rome\": _3, \"rovigo\": _3, \"sa\": _3, \"salerno\": _3, \"sassari\": _3, \"savona\": _3, \"si\": _3, \"siena\": _3, \"siracusa\": _3, \"so\": _3, \"sondrio\": _3, \"sp\": _3, \"sr\": _3, \"ss\": _3, \"xn--sdtirol-n2a\": _3, \"südtirol\": _3, \"suedtirol\": _3, \"sv\": _3, \"ta\": _3, \"taranto\": _3, \"te\": _3, \"tempio-olbia\": _3, \"tempioolbia\": _3, \"teramo\": _3, \"terni\": _3, \"tn\": _3, \"to\": _3, \"torino\": _3, \"tp\": _3, \"tr\": _3, \"trani-andria-barletta\": _3, \"trani-barletta-andria\": _3, \"traniandriabarletta\": _3, \"tranibarlettaandria\": _3, \"trapani\": _3, \"trento\": _3, \"treviso\": _3, \"trieste\": _3, \"ts\": _3, \"turin\": _3, \"tv\": _3, \"ud\": _3, \"udine\": _3, \"urbino-pesaro\": _3, \"urbinopesaro\": _3, \"va\": _3, \"varese\": _3, \"vb\": _3, \"vc\": _3, \"ve\": _3, \"venezia\": _3, \"venice\": _3, \"verbania\": _3, \"vercelli\": _3, \"verona\": _3, \"vi\": _3, \"vibo-valentia\": _3, \"vibovalentia\": _3, \"vicenza\": _3, \"viterbo\": _3, \"vr\": _3, \"vs\": _3, \"vt\": _3, \"vv\": _3, \"12chars\": _4, \"ibxos\": _4, \"iliadboxos\": _4, \"neen\": [0, { \"jc\": _4 }], \"123homepage\": _4, \"16-b\": _4, \"32-b\": _4, \"64-b\": _4, \"myspreadshop\": _4, \"syncloud\": _4 }], \"je\": [1, { \"co\": _3, \"net\": _3, \"org\": _3, \"of\": _4 }], \"jm\": _17, \"jo\": [1, { \"agri\": _3, \"ai\": _3, \"com\": _3, \"edu\": _3, \"eng\": _3, \"fm\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"per\": _3, \"phd\": _3, \"sch\": _3, \"tv\": _3 }], \"jobs\": _3, \"jp\": [1, { \"ac\": _3, \"ad\": _3, \"co\": _3, \"ed\": _3, \"go\": _3, \"gr\": _3, \"lg\": _3, \"ne\": [1, { \"aseinet\": _48, \"gehirn\": _4, \"ivory\": _4, \"mail-box\": _4, \"mints\": _4, \"mokuren\": _4, \"opal\": _4, \"sakura\": _4, \"sumomo\": _4, \"topaz\": _4 }], \"or\": _3, \"aichi\": [1, { \"aisai\": _3, \"ama\": _3, \"anjo\": _3, \"asuke\": _3, \"chiryu\": _3, \"chita\": _3, \"fuso\": _3, \"gamagori\": _3, \"handa\": _3, \"hazu\": _3, \"hekinan\": _3, \"higashiura\": _3, \"ichinomiya\": _3, \"inazawa\": _3, \"inuyama\": _3, \"isshiki\": _3, \"iwakura\": _3, \"kanie\": _3, \"kariya\": _3, \"kasugai\": _3, \"kira\": _3, \"kiyosu\": _3, \"komaki\": _3, \"konan\": _3, \"kota\": _3, \"mihama\": _3, \"miyoshi\": _3, \"nishio\": _3, \"nisshin\": _3, \"obu\": _3, \"oguchi\": _3, \"oharu\": _3, \"okazaki\": _3, \"owariasahi\": _3, \"seto\": _3, \"shikatsu\": _3, \"shinshiro\": _3, \"shitara\": _3, \"tahara\": _3, \"takahama\": _3, \"tobishima\": _3, \"toei\": _3, \"togo\": _3, \"tokai\": _3, \"tokoname\": _3, \"toyoake\": _3, \"toyohashi\": _3, \"toyokawa\": _3, \"toyone\": _3, \"toyota\": _3, \"tsushima\": _3, \"yatomi\": _3 }], \"akita\": [1, { \"akita\": _3, \"daisen\": _3, \"fujisato\": _3, \"gojome\": _3, \"hachirogata\": _3, \"happou\": _3, \"higashinaruse\": _3, \"honjo\": _3, \"honjyo\": _3, \"ikawa\": _3, \"kamikoani\": _3, \"kamioka\": _3, \"katagami\": _3, \"kazuno\": _3, \"kitaakita\": _3, \"kosaka\": _3, \"kyowa\": _3, \"misato\": _3, \"mitane\": _3, \"moriyoshi\": _3, \"nikaho\": _3, \"noshiro\": _3, \"odate\": _3, \"oga\": _3, \"ogata\": _3, \"semboku\": _3, \"yokote\": _3, \"yurihonjo\": _3 }], \"aomori\": [1, { \"aomori\": _3, \"gonohe\": _3, \"hachinohe\": _3, \"hashikami\": _3, \"hiranai\": _3, \"hirosaki\": _3, \"itayanagi\": _3, \"kuroishi\": _3, \"misawa\": _3, \"mutsu\": _3, \"nakadomari\": _3, \"noheji\": _3, \"oirase\": _3, \"owani\": _3, \"rokunohe\": _3, \"sannohe\": _3, \"shichinohe\": _3, \"shingo\": _3, \"takko\": _3, \"towada\": _3, \"tsugaru\": _3, \"tsuruta\": _3 }], \"chiba\": [1, { \"abiko\": _3, \"asahi\": _3, \"chonan\": _3, \"chosei\": _3, \"choshi\": _3, \"chuo\": _3, \"funabashi\": _3, \"futtsu\": _3, \"hanamigawa\": _3, \"ichihara\": _3, \"ichikawa\": _3, \"ichinomiya\": _3, \"inzai\": _3, \"isumi\": _3, \"kamagaya\": _3, \"kamogawa\": _3, \"kashiwa\": _3, \"katori\": _3, \"katsuura\": _3, \"kimitsu\": _3, \"kisarazu\": _3, \"kozaki\": _3, \"kujukuri\": _3, \"kyonan\": _3, \"matsudo\": _3, \"midori\": _3, \"mihama\": _3, \"minamiboso\": _3, \"mobara\": _3, \"mutsuzawa\": _3, \"nagara\": _3, \"nagareyama\": _3, \"narashino\": _3, \"narita\": _3, \"noda\": _3, \"oamishirasato\": _3, \"omigawa\": _3, \"onjuku\": _3, \"otaki\": _3, \"sakae\": _3, \"sakura\": _3, \"shimofusa\": _3, \"shirako\": _3, \"shiroi\": _3, \"shisui\": _3, \"sodegaura\": _3, \"sosa\": _3, \"tako\": _3, \"tateyama\": _3, \"togane\": _3, \"tohnosho\": _3, \"tomisato\": _3, \"urayasu\": _3, \"yachimata\": _3, \"yachiyo\": _3, \"yokaichiba\": _3, \"yokoshibahikari\": _3, \"yotsukaido\": _3 }], \"ehime\": [1, { \"ainan\": _3, \"honai\": _3, \"ikata\": _3, \"imabari\": _3, \"iyo\": _3, \"kamijima\": _3, \"kihoku\": _3, \"kumakogen\": _3, \"masaki\": _3, \"matsuno\": _3, \"matsuyama\": _3, \"namikata\": _3, \"niihama\": _3, \"ozu\": _3, \"saijo\": _3, \"seiyo\": _3, \"shikokuchuo\": _3, \"tobe\": _3, \"toon\": _3, \"uchiko\": _3, \"uwajima\": _3, \"yawatahama\": _3 }], \"fukui\": [1, { \"echizen\": _3, \"eiheiji\": _3, \"fukui\": _3, \"ikeda\": _3, \"katsuyama\": _3, \"mihama\": _3, \"minamiechizen\": _3, \"obama\": _3, \"ohi\": _3, \"ono\": _3, \"sabae\": _3, \"sakai\": _3, \"takahama\": _3, \"tsuruga\": _3, \"wakasa\": _3 }], \"fukuoka\": [1, { \"ashiya\": _3, \"buzen\": _3, \"chikugo\": _3, \"chikuho\": _3, \"chikujo\": _3, \"chikushino\": _3, \"chikuzen\": _3, \"chuo\": _3, \"dazaifu\": _3, \"fukuchi\": _3, \"hakata\": _3, \"higashi\": _3, \"hirokawa\": _3, \"hisayama\": _3, \"iizuka\": _3, \"inatsuki\": _3, \"kaho\": _3, \"kasuga\": _3, \"kasuya\": _3, \"kawara\": _3, \"keisen\": _3, \"koga\": _3, \"kurate\": _3, \"kurogi\": _3, \"kurume\": _3, \"minami\": _3, \"miyako\": _3, \"miyama\": _3, \"miyawaka\": _3, \"mizumaki\": _3, \"munakata\": _3, \"nakagawa\": _3, \"nakama\": _3, \"nishi\": _3, \"nogata\": _3, \"ogori\": _3, \"okagaki\": _3, \"okawa\": _3, \"oki\": _3, \"omuta\": _3, \"onga\": _3, \"onojo\": _3, \"oto\": _3, \"saigawa\": _3, \"sasaguri\": _3, \"shingu\": _3, \"shinyoshitomi\": _3, \"shonai\": _3, \"soeda\": _3, \"sue\": _3, \"tachiarai\": _3, \"tagawa\": _3, \"takata\": _3, \"toho\": _3, \"toyotsu\": _3, \"tsuiki\": _3, \"ukiha\": _3, \"umi\": _3, \"usui\": _3, \"yamada\": _3, \"yame\": _3, \"yanagawa\": _3, \"yukuhashi\": _3 }], \"fukushima\": [1, { \"aizubange\": _3, \"aizumisato\": _3, \"aizuwakamatsu\": _3, \"asakawa\": _3, \"bandai\": _3, \"date\": _3, \"fukushima\": _3, \"furudono\": _3, \"futaba\": _3, \"hanawa\": _3, \"higashi\": _3, \"hirata\": _3, \"hirono\": _3, \"iitate\": _3, \"inawashiro\": _3, \"ishikawa\": _3, \"iwaki\": _3, \"izumizaki\": _3, \"kagamiishi\": _3, \"kaneyama\": _3, \"kawamata\": _3, \"kitakata\": _3, \"kitashiobara\": _3, \"koori\": _3, \"koriyama\": _3, \"kunimi\": _3, \"miharu\": _3, \"mishima\": _3, \"namie\": _3, \"nango\": _3, \"nishiaizu\": _3, \"nishigo\": _3, \"okuma\": _3, \"omotego\": _3, \"ono\": _3, \"otama\": _3, \"samegawa\": _3, \"shimogo\": _3, \"shirakawa\": _3, \"showa\": _3, \"soma\": _3, \"sukagawa\": _3, \"taishin\": _3, \"tamakawa\": _3, \"tanagura\": _3, \"tenei\": _3, \"yabuki\": _3, \"yamato\": _3, \"yamatsuri\": _3, \"yanaizu\": _3, \"yugawa\": _3 }], \"gifu\": [1, { \"anpachi\": _3, \"ena\": _3, \"gifu\": _3, \"ginan\": _3, \"godo\": _3, \"gujo\": _3, \"hashima\": _3, \"hichiso\": _3, \"hida\": _3, \"higashishirakawa\": _3, \"ibigawa\": _3, \"ikeda\": _3, \"kakamigahara\": _3, \"kani\": _3, \"kasahara\": _3, \"kasamatsu\": _3, \"kawaue\": _3, \"kitagata\": _3, \"mino\": _3, \"minokamo\": _3, \"mitake\": _3, \"mizunami\": _3, \"motosu\": _3, \"nakatsugawa\": _3, \"ogaki\": _3, \"sakahogi\": _3, \"seki\": _3, \"sekigahara\": _3, \"shirakawa\": _3, \"tajimi\": _3, \"takayama\": _3, \"tarui\": _3, \"toki\": _3, \"tomika\": _3, \"wanouchi\": _3, \"yamagata\": _3, \"yaotsu\": _3, \"yoro\": _3 }], \"gunma\": [1, { \"annaka\": _3, \"chiyoda\": _3, \"fujioka\": _3, \"higashiagatsuma\": _3, \"isesaki\": _3, \"itakura\": _3, \"kanna\": _3, \"kanra\": _3, \"katashina\": _3, \"kawaba\": _3, \"kiryu\": _3, \"kusatsu\": _3, \"maebashi\": _3, \"meiwa\": _3, \"midori\": _3, \"minakami\": _3, \"naganohara\": _3, \"nakanojo\": _3, \"nanmoku\": _3, \"numata\": _3, \"oizumi\": _3, \"ora\": _3, \"ota\": _3, \"shibukawa\": _3, \"shimonita\": _3, \"shinto\": _3, \"showa\": _3, \"takasaki\": _3, \"takayama\": _3, \"tamamura\": _3, \"tatebayashi\": _3, \"tomioka\": _3, \"tsukiyono\": _3, \"tsumagoi\": _3, \"ueno\": _3, \"yoshioka\": _3 }], \"hiroshima\": [1, { \"asaminami\": _3, \"daiwa\": _3, \"etajima\": _3, \"fuchu\": _3, \"fukuyama\": _3, \"hatsukaichi\": _3, \"higashihiroshima\": _3, \"hongo\": _3, \"jinsekikogen\": _3, \"kaita\": _3, \"kui\": _3, \"kumano\": _3, \"kure\": _3, \"mihara\": _3, \"miyoshi\": _3, \"naka\": _3, \"onomichi\": _3, \"osakikamijima\": _3, \"otake\": _3, \"saka\": _3, \"sera\": _3, \"seranishi\": _3, \"shinichi\": _3, \"shobara\": _3, \"takehara\": _3 }], \"hokkaido\": [1, { \"abashiri\": _3, \"abira\": _3, \"aibetsu\": _3, \"akabira\": _3, \"akkeshi\": _3, \"asahikawa\": _3, \"ashibetsu\": _3, \"ashoro\": _3, \"assabu\": _3, \"atsuma\": _3, \"bibai\": _3, \"biei\": _3, \"bifuka\": _3, \"bihoro\": _3, \"biratori\": _3, \"chippubetsu\": _3, \"chitose\": _3, \"date\": _3, \"ebetsu\": _3, \"embetsu\": _3, \"eniwa\": _3, \"erimo\": _3, \"esan\": _3, \"esashi\": _3, \"fukagawa\": _3, \"fukushima\": _3, \"furano\": _3, \"furubira\": _3, \"haboro\": _3, \"hakodate\": _3, \"hamatonbetsu\": _3, \"hidaka\": _3, \"higashikagura\": _3, \"higashikawa\": _3, \"hiroo\": _3, \"hokuryu\": _3, \"hokuto\": _3, \"honbetsu\": _3, \"horokanai\": _3, \"horonobe\": _3, \"ikeda\": _3, \"imakane\": _3, \"ishikari\": _3, \"iwamizawa\": _3, \"iwanai\": _3, \"kamifurano\": _3, \"kamikawa\": _3, \"kamishihoro\": _3, \"kamisunagawa\": _3, \"kamoenai\": _3, \"kayabe\": _3, \"kembuchi\": _3, \"kikonai\": _3, \"kimobetsu\": _3, \"kitahiroshima\": _3, \"kitami\": _3, \"kiyosato\": _3, \"koshimizu\": _3, \"kunneppu\": _3, \"kuriyama\": _3, \"kuromatsunai\": _3, \"kushiro\": _3, \"kutchan\": _3, \"kyowa\": _3, \"mashike\": _3, \"matsumae\": _3, \"mikasa\": _3, \"minamifurano\": _3, \"mombetsu\": _3, \"moseushi\": _3, \"mukawa\": _3, \"muroran\": _3, \"naie\": _3, \"nakagawa\": _3, \"nakasatsunai\": _3, \"nakatombetsu\": _3, \"nanae\": _3, \"nanporo\": _3, \"nayoro\": _3, \"nemuro\": _3, \"niikappu\": _3, \"niki\": _3, \"nishiokoppe\": _3, \"noboribetsu\": _3, \"numata\": _3, \"obihiro\": _3, \"obira\": _3, \"oketo\": _3, \"okoppe\": _3, \"otaru\": _3, \"otobe\": _3, \"otofuke\": _3, \"otoineppu\": _3, \"oumu\": _3, \"ozora\": _3, \"pippu\": _3, \"rankoshi\": _3, \"rebun\": _3, \"rikubetsu\": _3, \"rishiri\": _3, \"rishirifuji\": _3, \"saroma\": _3, \"sarufutsu\": _3, \"shakotan\": _3, \"shari\": _3, \"shibecha\": _3, \"shibetsu\": _3, \"shikabe\": _3, \"shikaoi\": _3, \"shimamaki\": _3, \"shimizu\": _3, \"shimokawa\": _3, \"shinshinotsu\": _3, \"shintoku\": _3, \"shiranuka\": _3, \"shiraoi\": _3, \"shiriuchi\": _3, \"sobetsu\": _3, \"sunagawa\": _3, \"taiki\": _3, \"takasu\": _3, \"takikawa\": _3, \"takinoue\": _3, \"teshikaga\": _3, \"tobetsu\": _3, \"tohma\": _3, \"tomakomai\": _3, \"tomari\": _3, \"toya\": _3, \"toyako\": _3, \"toyotomi\": _3, \"toyoura\": _3, \"tsubetsu\": _3, \"tsukigata\": _3, \"urakawa\": _3, \"urausu\": _3, \"uryu\": _3, \"utashinai\": _3, \"wakkanai\": _3, \"wassamu\": _3, \"yakumo\": _3, \"yoichi\": _3 }], \"hyogo\": [1, { \"aioi\": _3, \"akashi\": _3, \"ako\": _3, \"amagasaki\": _3, \"aogaki\": _3, \"asago\": _3, \"ashiya\": _3, \"awaji\": _3, \"fukusaki\": _3, \"goshiki\": _3, \"harima\": _3, \"himeji\": _3, \"ichikawa\": _3, \"inagawa\": _3, \"itami\": _3, \"kakogawa\": _3, \"kamigori\": _3, \"kamikawa\": _3, \"kasai\": _3, \"kasuga\": _3, \"kawanishi\": _3, \"miki\": _3, \"minamiawaji\": _3, \"nishinomiya\": _3, \"nishiwaki\": _3, \"ono\": _3, \"sanda\": _3, \"sannan\": _3, \"sasayama\": _3, \"sayo\": _3, \"shingu\": _3, \"shinonsen\": _3, \"shiso\": _3, \"sumoto\": _3, \"taishi\": _3, \"taka\": _3, \"takarazuka\": _3, \"takasago\": _3, \"takino\": _3, \"tamba\": _3, \"tatsuno\": _3, \"toyooka\": _3, \"yabu\": _3, \"yashiro\": _3, \"yoka\": _3, \"yokawa\": _3 }], \"ibaraki\": [1, { \"ami\": _3, \"asahi\": _3, \"bando\": _3, \"chikusei\": _3, \"daigo\": _3, \"fujishiro\": _3, \"hitachi\": _3, \"hitachinaka\": _3, \"hitachiomiya\": _3, \"hitachiota\": _3, \"ibaraki\": _3, \"ina\": _3, \"inashiki\": _3, \"itako\": _3, \"iwama\": _3, \"joso\": _3, \"kamisu\": _3, \"kasama\": _3, \"kashima\": _3, \"kasumigaura\": _3, \"koga\": _3, \"miho\": _3, \"mito\": _3, \"moriya\": _3, \"naka\": _3, \"namegata\": _3, \"oarai\": _3, \"ogawa\": _3, \"omitama\": _3, \"ryugasaki\": _3, \"sakai\": _3, \"sakuragawa\": _3, \"shimodate\": _3, \"shimotsuma\": _3, \"shirosato\": _3, \"sowa\": _3, \"suifu\": _3, \"takahagi\": _3, \"tamatsukuri\": _3, \"tokai\": _3, \"tomobe\": _3, \"tone\": _3, \"toride\": _3, \"tsuchiura\": _3, \"tsukuba\": _3, \"uchihara\": _3, \"ushiku\": _3, \"yachiyo\": _3, \"yamagata\": _3, \"yawara\": _3, \"yuki\": _3 }], \"ishikawa\": [1, { \"anamizu\": _3, \"hakui\": _3, \"hakusan\": _3, \"kaga\": _3, \"kahoku\": _3, \"kanazawa\": _3, \"kawakita\": _3, \"komatsu\": _3, \"nakanoto\": _3, \"nanao\": _3, \"nomi\": _3, \"nonoichi\": _3, \"noto\": _3, \"shika\": _3, \"suzu\": _3, \"tsubata\": _3, \"tsurugi\": _3, \"uchinada\": _3, \"wajima\": _3 }], \"iwate\": [1, { \"fudai\": _3, \"fujisawa\": _3, \"hanamaki\": _3, \"hiraizumi\": _3, \"hirono\": _3, \"ichinohe\": _3, \"ichinoseki\": _3, \"iwaizumi\": _3, \"iwate\": _3, \"joboji\": _3, \"kamaishi\": _3, \"kanegasaki\": _3, \"karumai\": _3, \"kawai\": _3, \"kitakami\": _3, \"kuji\": _3, \"kunohe\": _3, \"kuzumaki\": _3, \"miyako\": _3, \"mizusawa\": _3, \"morioka\": _3, \"ninohe\": _3, \"noda\": _3, \"ofunato\": _3, \"oshu\": _3, \"otsuchi\": _3, \"rikuzentakata\": _3, \"shiwa\": _3, \"shizukuishi\": _3, \"sumita\": _3, \"tanohata\": _3, \"tono\": _3, \"yahaba\": _3, \"yamada\": _3 }], \"kagawa\": [1, { \"ayagawa\": _3, \"higashikagawa\": _3, \"kanonji\": _3, \"kotohira\": _3, \"manno\": _3, \"marugame\": _3, \"mitoyo\": _3, \"naoshima\": _3, \"sanuki\": _3, \"tadotsu\": _3, \"takamatsu\": _3, \"tonosho\": _3, \"uchinomi\": _3, \"utazu\": _3, \"zentsuji\": _3 }], \"kagoshima\": [1, { \"akune\": _3, \"amami\": _3, \"hioki\": _3, \"isa\": _3, \"isen\": _3, \"izumi\": _3, \"kagoshima\": _3, \"kanoya\": _3, \"kawanabe\": _3, \"kinko\": _3, \"kouyama\": _3, \"makurazaki\": _3, \"matsumoto\": _3, \"minamitane\": _3, \"nakatane\": _3, \"nishinoomote\": _3, \"satsumasendai\": _3, \"soo\": _3, \"tarumizu\": _3, \"yusui\": _3 }], \"kanagawa\": [1, { \"aikawa\": _3, \"atsugi\": _3, \"ayase\": _3, \"chigasaki\": _3, \"ebina\": _3, \"fujisawa\": _3, \"hadano\": _3, \"hakone\": _3, \"hiratsuka\": _3, \"isehara\": _3, \"kaisei\": _3, \"kamakura\": _3, \"kiyokawa\": _3, \"matsuda\": _3, \"minamiashigara\": _3, \"miura\": _3, \"nakai\": _3, \"ninomiya\": _3, \"odawara\": _3, \"oi\": _3, \"oiso\": _3, \"sagamihara\": _3, \"samukawa\": _3, \"tsukui\": _3, \"yamakita\": _3, \"yamato\": _3, \"yokosuka\": _3, \"yugawara\": _3, \"zama\": _3, \"zushi\": _3 }], \"kochi\": [1, { \"aki\": _3, \"geisei\": _3, \"hidaka\": _3, \"higashitsuno\": _3, \"ino\": _3, \"kagami\": _3, \"kami\": _3, \"kitagawa\": _3, \"kochi\": _3, \"mihara\": _3, \"motoyama\": _3, \"muroto\": _3, \"nahari\": _3, \"nakamura\": _3, \"nankoku\": _3, \"nishitosa\": _3, \"niyodogawa\": _3, \"ochi\": _3, \"okawa\": _3, \"otoyo\": _3, \"otsuki\": _3, \"sakawa\": _3, \"sukumo\": _3, \"susaki\": _3, \"tosa\": _3, \"tosashimizu\": _3, \"toyo\": _3, \"tsuno\": _3, \"umaji\": _3, \"yasuda\": _3, \"yusuhara\": _3 }], \"kumamoto\": [1, { \"amakusa\": _3, \"arao\": _3, \"aso\": _3, \"choyo\": _3, \"gyokuto\": _3, \"kamiamakusa\": _3, \"kikuchi\": _3, \"kumamoto\": _3, \"mashiki\": _3, \"mifune\": _3, \"minamata\": _3, \"minamioguni\": _3, \"nagasu\": _3, \"nishihara\": _3, \"oguni\": _3, \"ozu\": _3, \"sumoto\": _3, \"takamori\": _3, \"uki\": _3, \"uto\": _3, \"yamaga\": _3, \"yamato\": _3, \"yatsushiro\": _3 }], \"kyoto\": [1, { \"ayabe\": _3, \"fukuchiyama\": _3, \"higashiyama\": _3, \"ide\": _3, \"ine\": _3, \"joyo\": _3, \"kameoka\": _3, \"kamo\": _3, \"kita\": _3, \"kizu\": _3, \"kumiyama\": _3, \"kyotamba\": _3, \"kyotanabe\": _3, \"kyotango\": _3, \"maizuru\": _3, \"minami\": _3, \"minamiyamashiro\": _3, \"miyazu\": _3, \"muko\": _3, \"nagaokakyo\": _3, \"nakagyo\": _3, \"nantan\": _3, \"oyamazaki\": _3, \"sakyo\": _3, \"seika\": _3, \"tanabe\": _3, \"uji\": _3, \"ujitawara\": _3, \"wazuka\": _3, \"yamashina\": _3, \"yawata\": _3 }], \"mie\": [1, { \"asahi\": _3, \"inabe\": _3, \"ise\": _3, \"kameyama\": _3, \"kawagoe\": _3, \"kiho\": _3, \"kisosaki\": _3, \"kiwa\": _3, \"komono\": _3, \"kumano\": _3, \"kuwana\": _3, \"matsusaka\": _3, \"meiwa\": _3, \"mihama\": _3, \"minamiise\": _3, \"misugi\": _3, \"miyama\": _3, \"nabari\": _3, \"shima\": _3, \"suzuka\": _3, \"tado\": _3, \"taiki\": _3, \"taki\": _3, \"tamaki\": _3, \"toba\": _3, \"tsu\": _3, \"udono\": _3, \"ureshino\": _3, \"watarai\": _3, \"yokkaichi\": _3 }], \"miyagi\": [1, { \"furukawa\": _3, \"higashimatsushima\": _3, \"ishinomaki\": _3, \"iwanuma\": _3, \"kakuda\": _3, \"kami\": _3, \"kawasaki\": _3, \"marumori\": _3, \"matsushima\": _3, \"minamisanriku\": _3, \"misato\": _3, \"murata\": _3, \"natori\": _3, \"ogawara\": _3, \"ohira\": _3, \"onagawa\": _3, \"osaki\": _3, \"rifu\": _3, \"semine\": _3, \"shibata\": _3, \"shichikashuku\": _3, \"shikama\": _3, \"shiogama\": _3, \"shiroishi\": _3, \"tagajo\": _3, \"taiwa\": _3, \"tome\": _3, \"tomiya\": _3, \"wakuya\": _3, \"watari\": _3, \"yamamoto\": _3, \"zao\": _3 }], \"miyazaki\": [1, { \"aya\": _3, \"ebino\": _3, \"gokase\": _3, \"hyuga\": _3, \"kadogawa\": _3, \"kawaminami\": _3, \"kijo\": _3, \"kitagawa\": _3, \"kitakata\": _3, \"kitaura\": _3, \"kobayashi\": _3, \"kunitomi\": _3, \"kushima\": _3, \"mimata\": _3, \"miyakonojo\": _3, \"miyazaki\": _3, \"morotsuka\": _3, \"nichinan\": _3, \"nishimera\": _3, \"nobeoka\": _3, \"saito\": _3, \"shiiba\": _3, \"shintomi\": _3, \"takaharu\": _3, \"takanabe\": _3, \"takazaki\": _3, \"tsuno\": _3 }], \"nagano\": [1, { \"achi\": _3, \"agematsu\": _3, \"anan\": _3, \"aoki\": _3, \"asahi\": _3, \"azumino\": _3, \"chikuhoku\": _3, \"chikuma\": _3, \"chino\": _3, \"fujimi\": _3, \"hakuba\": _3, \"hara\": _3, \"hiraya\": _3, \"iida\": _3, \"iijima\": _3, \"iiyama\": _3, \"iizuna\": _3, \"ikeda\": _3, \"ikusaka\": _3, \"ina\": _3, \"karuizawa\": _3, \"kawakami\": _3, \"kiso\": _3, \"kisofukushima\": _3, \"kitaaiki\": _3, \"komagane\": _3, \"komoro\": _3, \"matsukawa\": _3, \"matsumoto\": _3, \"miasa\": _3, \"minamiaiki\": _3, \"minamimaki\": _3, \"minamiminowa\": _3, \"minowa\": _3, \"miyada\": _3, \"miyota\": _3, \"mochizuki\": _3, \"nagano\": _3, \"nagawa\": _3, \"nagiso\": _3, \"nakagawa\": _3, \"nakano\": _3, \"nozawaonsen\": _3, \"obuse\": _3, \"ogawa\": _3, \"okaya\": _3, \"omachi\": _3, \"omi\": _3, \"ookuwa\": _3, \"ooshika\": _3, \"otaki\": _3, \"otari\": _3, \"sakae\": _3, \"sakaki\": _3, \"saku\": _3, \"sakuho\": _3, \"shimosuwa\": _3, \"shinanomachi\": _3, \"shiojiri\": _3, \"suwa\": _3, \"suzaka\": _3, \"takagi\": _3, \"takamori\": _3, \"takayama\": _3, \"tateshina\": _3, \"tatsuno\": _3, \"togakushi\": _3, \"togura\": _3, \"tomi\": _3, \"ueda\": _3, \"wada\": _3, \"yamagata\": _3, \"yamanouchi\": _3, \"yasaka\": _3, \"yasuoka\": _3 }], \"nagasaki\": [1, { \"chijiwa\": _3, \"futsu\": _3, \"goto\": _3, \"hasami\": _3, \"hirado\": _3, \"iki\": _3, \"isahaya\": _3, \"kawatana\": _3, \"kuchinotsu\": _3, \"matsuura\": _3, \"nagasaki\": _3, \"obama\": _3, \"omura\": _3, \"oseto\": _3, \"saikai\": _3, \"sasebo\": _3, \"seihi\": _3, \"shimabara\": _3, \"shinkamigoto\": _3, \"togitsu\": _3, \"tsushima\": _3, \"unzen\": _3 }], \"nara\": [1, { \"ando\": _3, \"gose\": _3, \"heguri\": _3, \"higashiyoshino\": _3, \"ikaruga\": _3, \"ikoma\": _3, \"kamikitayama\": _3, \"kanmaki\": _3, \"kashiba\": _3, \"kashihara\": _3, \"katsuragi\": _3, \"kawai\": _3, \"kawakami\": _3, \"kawanishi\": _3, \"koryo\": _3, \"kurotaki\": _3, \"mitsue\": _3, \"miyake\": _3, \"nara\": _3, \"nosegawa\": _3, \"oji\": _3, \"ouda\": _3, \"oyodo\": _3, \"sakurai\": _3, \"sango\": _3, \"shimoichi\": _3, \"shimokitayama\": _3, \"shinjo\": _3, \"soni\": _3, \"takatori\": _3, \"tawaramoto\": _3, \"tenkawa\": _3, \"tenri\": _3, \"uda\": _3, \"yamatokoriyama\": _3, \"yamatotakada\": _3, \"yamazoe\": _3, \"yoshino\": _3 }], \"niigata\": [1, { \"aga\": _3, \"agano\": _3, \"gosen\": _3, \"itoigawa\": _3, \"izumozaki\": _3, \"joetsu\": _3, \"kamo\": _3, \"kariwa\": _3, \"kashiwazaki\": _3, \"minamiuonuma\": _3, \"mitsuke\": _3, \"muika\": _3, \"murakami\": _3, \"myoko\": _3, \"nagaoka\": _3, \"niigata\": _3, \"ojiya\": _3, \"omi\": _3, \"sado\": _3, \"sanjo\": _3, \"seiro\": _3, \"seirou\": _3, \"sekikawa\": _3, \"shibata\": _3, \"tagami\": _3, \"tainai\": _3, \"tochio\": _3, \"tokamachi\": _3, \"tsubame\": _3, \"tsunan\": _3, \"uonuma\": _3, \"yahiko\": _3, \"yoita\": _3, \"yuzawa\": _3 }], \"oita\": [1, { \"beppu\": _3, \"bungoono\": _3, \"bungotakada\": _3, \"hasama\": _3, \"hiji\": _3, \"himeshima\": _3, \"hita\": _3, \"kamitsue\": _3, \"kokonoe\": _3, \"kuju\": _3, \"kunisaki\": _3, \"kusu\": _3, \"oita\": _3, \"saiki\": _3, \"taketa\": _3, \"tsukumi\": _3, \"usa\": _3, \"usuki\": _3, \"yufu\": _3 }], \"okayama\": [1, { \"akaiwa\": _3, \"asakuchi\": _3, \"bizen\": _3, \"hayashima\": _3, \"ibara\": _3, \"kagamino\": _3, \"kasaoka\": _3, \"kibichuo\": _3, \"kumenan\": _3, \"kurashiki\": _3, \"maniwa\": _3, \"misaki\": _3, \"nagi\": _3, \"niimi\": _3, \"nishiawakura\": _3, \"okayama\": _3, \"satosho\": _3, \"setouchi\": _3, \"shinjo\": _3, \"shoo\": _3, \"soja\": _3, \"takahashi\": _3, \"tamano\": _3, \"tsuyama\": _3, \"wake\": _3, \"yakage\": _3 }], \"okinawa\": [1, { \"aguni\": _3, \"ginowan\": _3, \"ginoza\": _3, \"gushikami\": _3, \"haebaru\": _3, \"higashi\": _3, \"hirara\": _3, \"iheya\": _3, \"ishigaki\": _3, \"ishikawa\": _3, \"itoman\": _3, \"izena\": _3, \"kadena\": _3, \"kin\": _3, \"kitadaito\": _3, \"kitanakagusuku\": _3, \"kumejima\": _3, \"kunigami\": _3, \"minamidaito\": _3, \"motobu\": _3, \"nago\": _3, \"naha\": _3, \"nakagusuku\": _3, \"nakijin\": _3, \"nanjo\": _3, \"nishihara\": _3, \"ogimi\": _3, \"okinawa\": _3, \"onna\": _3, \"shimoji\": _3, \"taketomi\": _3, \"tarama\": _3, \"tokashiki\": _3, \"tomigusuku\": _3, \"tonaki\": _3, \"urasoe\": _3, \"uruma\": _3, \"yaese\": _3, \"yomitan\": _3, \"yonabaru\": _3, \"yonaguni\": _3, \"zamami\": _3 }], \"osaka\": [1, { \"abeno\": _3, \"chihayaakasaka\": _3, \"chuo\": _3, \"daito\": _3, \"fujiidera\": _3, \"habikino\": _3, \"hannan\": _3, \"higashiosaka\": _3, \"higashisumiyoshi\": _3, \"higashiyodogawa\": _3, \"hirakata\": _3, \"ibaraki\": _3, \"ikeda\": _3, \"izumi\": _3, \"izumiotsu\": _3, \"izumisano\": _3, \"kadoma\": _3, \"kaizuka\": _3, \"kanan\": _3, \"kashiwara\": _3, \"katano\": _3, \"kawachinagano\": _3, \"kishiwada\": _3, \"kita\": _3, \"kumatori\": _3, \"matsubara\": _3, \"minato\": _3, \"minoh\": _3, \"misaki\": _3, \"moriguchi\": _3, \"neyagawa\": _3, \"nishi\": _3, \"nose\": _3, \"osakasayama\": _3, \"sakai\": _3, \"sayama\": _3, \"sennan\": _3, \"settsu\": _3, \"shijonawate\": _3, \"shimamoto\": _3, \"suita\": _3, \"tadaoka\": _3, \"taishi\": _3, \"tajiri\": _3, \"takaishi\": _3, \"takatsuki\": _3, \"tondabayashi\": _3, \"toyonaka\": _3, \"toyono\": _3, \"yao\": _3 }], \"saga\": [1, { \"ariake\": _3, \"arita\": _3, \"fukudomi\": _3, \"genkai\": _3, \"hamatama\": _3, \"hizen\": _3, \"imari\": _3, \"kamimine\": _3, \"kanzaki\": _3, \"karatsu\": _3, \"kashima\": _3, \"kitagata\": _3, \"kitahata\": _3, \"kiyama\": _3, \"kouhoku\": _3, \"kyuragi\": _3, \"nishiarita\": _3, \"ogi\": _3, \"omachi\": _3, \"ouchi\": _3, \"saga\": _3, \"shiroishi\": _3, \"taku\": _3, \"tara\": _3, \"tosu\": _3, \"yoshinogari\": _3 }], \"saitama\": [1, { \"arakawa\": _3, \"asaka\": _3, \"chichibu\": _3, \"fujimi\": _3, \"fujimino\": _3, \"fukaya\": _3, \"hanno\": _3, \"hanyu\": _3, \"hasuda\": _3, \"hatogaya\": _3, \"hatoyama\": _3, \"hidaka\": _3, \"higashichichibu\": _3, \"higashimatsuyama\": _3, \"honjo\": _3, \"ina\": _3, \"iruma\": _3, \"iwatsuki\": _3, \"kamiizumi\": _3, \"kamikawa\": _3, \"kamisato\": _3, \"kasukabe\": _3, \"kawagoe\": _3, \"kawaguchi\": _3, \"kawajima\": _3, \"kazo\": _3, \"kitamoto\": _3, \"koshigaya\": _3, \"kounosu\": _3, \"kuki\": _3, \"kumagaya\": _3, \"matsubushi\": _3, \"minano\": _3, \"misato\": _3, \"miyashiro\": _3, \"miyoshi\": _3, \"moroyama\": _3, \"nagatoro\": _3, \"namegawa\": _3, \"niiza\": _3, \"ogano\": _3, \"ogawa\": _3, \"ogose\": _3, \"okegawa\": _3, \"omiya\": _3, \"otaki\": _3, \"ranzan\": _3, \"ryokami\": _3, \"saitama\": _3, \"sakado\": _3, \"satte\": _3, \"sayama\": _3, \"shiki\": _3, \"shiraoka\": _3, \"soka\": _3, \"sugito\": _3, \"toda\": _3, \"tokigawa\": _3, \"tokorozawa\": _3, \"tsurugashima\": _3, \"urawa\": _3, \"warabi\": _3, \"yashio\": _3, \"yokoze\": _3, \"yono\": _3, \"yorii\": _3, \"yoshida\": _3, \"yoshikawa\": _3, \"yoshimi\": _3 }], \"shiga\": [1, { \"aisho\": _3, \"gamo\": _3, \"higashiomi\": _3, \"hikone\": _3, \"koka\": _3, \"konan\": _3, \"kosei\": _3, \"koto\": _3, \"kusatsu\": _3, \"maibara\": _3, \"moriyama\": _3, \"nagahama\": _3, \"nishiazai\": _3, \"notogawa\": _3, \"omihachiman\": _3, \"otsu\": _3, \"ritto\": _3, \"ryuoh\": _3, \"takashima\": _3, \"takatsuki\": _3, \"torahime\": _3, \"toyosato\": _3, \"yasu\": _3 }], \"shimane\": [1, { \"akagi\": _3, \"ama\": _3, \"gotsu\": _3, \"hamada\": _3, \"higashiizumo\": _3, \"hikawa\": _3, \"hikimi\": _3, \"izumo\": _3, \"kakinoki\": _3, \"masuda\": _3, \"matsue\": _3, \"misato\": _3, \"nishinoshima\": _3, \"ohda\": _3, \"okinoshima\": _3, \"okuizumo\": _3, \"shimane\": _3, \"tamayu\": _3, \"tsuwano\": _3, \"unnan\": _3, \"yakumo\": _3, \"yasugi\": _3, \"yatsuka\": _3 }], \"shizuoka\": [1, { \"arai\": _3, \"atami\": _3, \"fuji\": _3, \"fujieda\": _3, \"fujikawa\": _3, \"fujinomiya\": _3, \"fukuroi\": _3, \"gotemba\": _3, \"haibara\": _3, \"hamamatsu\": _3, \"higashiizu\": _3, \"ito\": _3, \"iwata\": _3, \"izu\": _3, \"izunokuni\": _3, \"kakegawa\": _3, \"kannami\": _3, \"kawanehon\": _3, \"kawazu\": _3, \"kikugawa\": _3, \"kosai\": _3, \"makinohara\": _3, \"matsuzaki\": _3, \"minamiizu\": _3, \"mishima\": _3, \"morimachi\": _3, \"nishiizu\": _3, \"numazu\": _3, \"omaezaki\": _3, \"shimada\": _3, \"shimizu\": _3, \"shimoda\": _3, \"shizuoka\": _3, \"susono\": _3, \"yaizu\": _3, \"yoshida\": _3 }], \"tochigi\": [1, { \"ashikaga\": _3, \"bato\": _3, \"haga\": _3, \"ichikai\": _3, \"iwafune\": _3, \"kaminokawa\": _3, \"kanuma\": _3, \"karasuyama\": _3, \"kuroiso\": _3, \"mashiko\": _3, \"mibu\": _3, \"moka\": _3, \"motegi\": _3, \"nasu\": _3, \"nasushiobara\": _3, \"nikko\": _3, \"nishikata\": _3, \"nogi\": _3, \"ohira\": _3, \"ohtawara\": _3, \"oyama\": _3, \"sakura\": _3, \"sano\": _3, \"shimotsuke\": _3, \"shioya\": _3, \"takanezawa\": _3, \"tochigi\": _3, \"tsuga\": _3, \"ujiie\": _3, \"utsunomiya\": _3, \"yaita\": _3 }], \"tokushima\": [1, { \"aizumi\": _3, \"anan\": _3, \"ichiba\": _3, \"itano\": _3, \"kainan\": _3, \"komatsushima\": _3, \"matsushige\": _3, \"mima\": _3, \"minami\": _3, \"miyoshi\": _3, \"mugi\": _3, \"nakagawa\": _3, \"naruto\": _3, \"sanagochi\": _3, \"shishikui\": _3, \"tokushima\": _3, \"wajiki\": _3 }], \"tokyo\": [1, { \"adachi\": _3, \"akiruno\": _3, \"akishima\": _3, \"aogashima\": _3, \"arakawa\": _3, \"bunkyo\": _3, \"chiyoda\": _3, \"chofu\": _3, \"chuo\": _3, \"edogawa\": _3, \"fuchu\": _3, \"fussa\": _3, \"hachijo\": _3, \"hachioji\": _3, \"hamura\": _3, \"higashikurume\": _3, \"higashimurayama\": _3, \"higashiyamato\": _3, \"hino\": _3, \"hinode\": _3, \"hinohara\": _3, \"inagi\": _3, \"itabashi\": _3, \"katsushika\": _3, \"kita\": _3, \"kiyose\": _3, \"kodaira\": _3, \"koganei\": _3, \"kokubunji\": _3, \"komae\": _3, \"koto\": _3, \"kouzushima\": _3, \"kunitachi\": _3, \"machida\": _3, \"meguro\": _3, \"minato\": _3, \"mitaka\": _3, \"mizuho\": _3, \"musashimurayama\": _3, \"musashino\": _3, \"nakano\": _3, \"nerima\": _3, \"ogasawara\": _3, \"okutama\": _3, \"ome\": _3, \"oshima\": _3, \"ota\": _3, \"setagaya\": _3, \"shibuya\": _3, \"shinagawa\": _3, \"shinjuku\": _3, \"suginami\": _3, \"sumida\": _3, \"tachikawa\": _3, \"taito\": _3, \"tama\": _3, \"toshima\": _3 }], \"tottori\": [1, { \"chizu\": _3, \"hino\": _3, \"kawahara\": _3, \"koge\": _3, \"kotoura\": _3, \"misasa\": _3, \"nanbu\": _3, \"nichinan\": _3, \"sakaiminato\": _3, \"tottori\": _3, \"wakasa\": _3, \"yazu\": _3, \"yonago\": _3 }], \"toyama\": [1, { \"asahi\": _3, \"fuchu\": _3, \"fukumitsu\": _3, \"funahashi\": _3, \"himi\": _3, \"imizu\": _3, \"inami\": _3, \"johana\": _3, \"kamiichi\": _3, \"kurobe\": _3, \"nakaniikawa\": _3, \"namerikawa\": _3, \"nanto\": _3, \"nyuzen\": _3, \"oyabe\": _3, \"taira\": _3, \"takaoka\": _3, \"tateyama\": _3, \"toga\": _3, \"tonami\": _3, \"toyama\": _3, \"unazuki\": _3, \"uozu\": _3, \"yamada\": _3 }], \"wakayama\": [1, { \"arida\": _3, \"aridagawa\": _3, \"gobo\": _3, \"hashimoto\": _3, \"hidaka\": _3, \"hirogawa\": _3, \"inami\": _3, \"iwade\": _3, \"kainan\": _3, \"kamitonda\": _3, \"katsuragi\": _3, \"kimino\": _3, \"kinokawa\": _3, \"kitayama\": _3, \"koya\": _3, \"koza\": _3, \"kozagawa\": _3, \"kudoyama\": _3, \"kushimoto\": _3, \"mihama\": _3, \"misato\": _3, \"nachikatsuura\": _3, \"shingu\": _3, \"shirahama\": _3, \"taiji\": _3, \"tanabe\": _3, \"wakayama\": _3, \"yuasa\": _3, \"yura\": _3 }], \"yamagata\": [1, { \"asahi\": _3, \"funagata\": _3, \"higashine\": _3, \"iide\": _3, \"kahoku\": _3, \"kaminoyama\": _3, \"kaneyama\": _3, \"kawanishi\": _3, \"mamurogawa\": _3, \"mikawa\": _3, \"murayama\": _3, \"nagai\": _3, \"nakayama\": _3, \"nanyo\": _3, \"nishikawa\": _3, \"obanazawa\": _3, \"oe\": _3, \"oguni\": _3, \"ohkura\": _3, \"oishida\": _3, \"sagae\": _3, \"sakata\": _3, \"sakegawa\": _3, \"shinjo\": _3, \"shirataka\": _3, \"shonai\": _3, \"takahata\": _3, \"tendo\": _3, \"tozawa\": _3, \"tsuruoka\": _3, \"yamagata\": _3, \"yamanobe\": _3, \"yonezawa\": _3, \"yuza\": _3 }], \"yamaguchi\": [1, { \"abu\": _3, \"hagi\": _3, \"hikari\": _3, \"hofu\": _3, \"iwakuni\": _3, \"kudamatsu\": _3, \"mitou\": _3, \"nagato\": _3, \"oshima\": _3, \"shimonoseki\": _3, \"shunan\": _3, \"tabuse\": _3, \"tokuyama\": _3, \"toyota\": _3, \"ube\": _3, \"yuu\": _3 }], \"yamanashi\": [1, { \"chuo\": _3, \"doshi\": _3, \"fuefuki\": _3, \"fujikawa\": _3, \"fujikawaguchiko\": _3, \"fujiyoshida\": _3, \"hayakawa\": _3, \"hokuto\": _3, \"ichikawamisato\": _3, \"kai\": _3, \"kofu\": _3, \"koshu\": _3, \"kosuge\": _3, \"minami-alps\": _3, \"minobu\": _3, \"nakamichi\": _3, \"nanbu\": _3, \"narusawa\": _3, \"nirasaki\": _3, \"nishikatsura\": _3, \"oshino\": _3, \"otsuki\": _3, \"showa\": _3, \"tabayama\": _3, \"tsuru\": _3, \"uenohara\": _3, \"yamanakako\": _3, \"yamanashi\": _3 }], \"xn--ehqz56n\": _3, \"三重\": _3, \"xn--1lqs03n\": _3, \"京都\": _3, \"xn--qqqt11m\": _3, \"佐賀\": _3, \"xn--f6qx53a\": _3, \"兵庫\": _3, \"xn--djrs72d6uy\": _3, \"北海道\": _3, \"xn--mkru45i\": _3, \"千葉\": _3, \"xn--0trq7p7nn\": _3, \"和歌山\": _3, \"xn--5js045d\": _3, \"埼玉\": _3, \"xn--kbrq7o\": _3, \"大分\": _3, \"xn--pssu33l\": _3, \"大阪\": _3, \"xn--ntsq17g\": _3, \"奈良\": _3, \"xn--uisz3g\": _3, \"宮城\": _3, \"xn--6btw5a\": _3, \"宮崎\": _3, \"xn--1ctwo\": _3, \"富山\": _3, \"xn--6orx2r\": _3, \"山口\": _3, \"xn--rht61e\": _3, \"山形\": _3, \"xn--rht27z\": _3, \"山梨\": _3, \"xn--nit225k\": _3, \"岐阜\": _3, \"xn--rht3d\": _3, \"岡山\": _3, \"xn--djty4k\": _3, \"岩手\": _3, \"xn--klty5x\": _3, \"島根\": _3, \"xn--kltx9a\": _3, \"広島\": _3, \"xn--kltp7d\": _3, \"徳島\": _3, \"xn--c3s14m\": _3, \"愛媛\": _3, \"xn--vgu402c\": _3, \"愛知\": _3, \"xn--efvn9s\": _3, \"新潟\": _3, \"xn--1lqs71d\": _3, \"東京\": _3, \"xn--4pvxs\": _3, \"栃木\": _3, \"xn--uuwu58a\": _3, \"沖縄\": _3, \"xn--zbx025d\": _3, \"滋賀\": _3, \"xn--8pvr4u\": _3, \"熊本\": _3, \"xn--5rtp49c\": _3, \"石川\": _3, \"xn--ntso0iqx3a\": _3, \"神奈川\": _3, \"xn--elqq16h\": _3, \"福井\": _3, \"xn--4it168d\": _3, \"福岡\": _3, \"xn--klt787d\": _3, \"福島\": _3, \"xn--rny31h\": _3, \"秋田\": _3, \"xn--7t0a264c\": _3, \"群馬\": _3, \"xn--uist22h\": _3, \"茨城\": _3, \"xn--8ltr62k\": _3, \"長崎\": _3, \"xn--2m4a15e\": _3, \"長野\": _3, \"xn--32vp30h\": _3, \"青森\": _3, \"xn--4it797k\": _3, \"静岡\": _3, \"xn--5rtq34k\": _3, \"香川\": _3, \"xn--k7yn95e\": _3, \"高知\": _3, \"xn--tor131o\": _3, \"鳥取\": _3, \"xn--d5qv7z876c\": _3, \"鹿児島\": _3, \"kawasaki\": _17, \"kitakyushu\": _17, \"kobe\": _17, \"nagoya\": _17, \"sapporo\": _17, \"sendai\": _17, \"yokohama\": _17, \"buyshop\": _4, \"fashionstore\": _4, \"handcrafted\": _4, \"kawaiishop\": _4, \"supersale\": _4, \"theshop\": _4, \"0am\": _4, \"0g0\": _4, \"0j0\": _4, \"0t0\": _4, \"mydns\": _4, \"pgw\": _4, \"wjg\": _4, \"usercontent\": _4, \"angry\": _4, \"babyblue\": _4, \"babymilk\": _4, \"backdrop\": _4, \"bambina\": _4, \"bitter\": _4, \"blush\": _4, \"boo\": _4, \"boy\": _4, \"boyfriend\": _4, \"but\": _4, \"candypop\": _4, \"capoo\": _4, \"catfood\": _4, \"cheap\": _4, \"chicappa\": _4, \"chillout\": _4, \"chips\": _4, \"chowder\": _4, \"chu\": _4, \"ciao\": _4, \"cocotte\": _4, \"coolblog\": _4, \"cranky\": _4, \"cutegirl\": _4, \"daa\": _4, \"deca\": _4, \"deci\": _4, \"digick\": _4, \"egoism\": _4, \"fakefur\": _4, \"fem\": _4, \"flier\": _4, \"floppy\": _4, \"fool\": _4, \"frenchkiss\": _4, \"girlfriend\": _4, \"girly\": _4, \"gloomy\": _4, \"gonna\": _4, \"greater\": _4, \"hacca\": _4, \"heavy\": _4, \"her\": _4, \"hiho\": _4, \"hippy\": _4, \"holy\": _4, \"hungry\": _4, \"icurus\": _4, \"itigo\": _4, \"jellybean\": _4, \"kikirara\": _4, \"kill\": _4, \"kilo\": _4, \"kuron\": _4, \"littlestar\": _4, \"lolipopmc\": _4, \"lolitapunk\": _4, \"lomo\": _4, \"lovepop\": _4, \"lovesick\": _4, \"main\": _4, \"mods\": _4, \"mond\": _4, \"mongolian\": _4, \"moo\": _4, \"namaste\": _4, \"nikita\": _4, \"nobushi\": _4, \"noor\": _4, \"oops\": _4, \"parallel\": _4, \"parasite\": _4, \"pecori\": _4, \"peewee\": _4, \"penne\": _4, \"pepper\": _4, \"perma\": _4, \"pigboat\": _4, \"pinoko\": _4, \"punyu\": _4, \"pupu\": _4, \"pussycat\": _4, \"pya\": _4, \"raindrop\": _4, \"readymade\": _4, \"sadist\": _4, \"schoolbus\": _4, \"secret\": _4, \"staba\": _4, \"stripper\": _4, \"sub\": _4, \"sunnyday\": _4, \"thick\": _4, \"tonkotsu\": _4, \"under\": _4, \"upper\": _4, \"velvet\": _4, \"verse\": _4, \"versus\": _4, \"vivian\": _4, \"watson\": _4, \"weblike\": _4, \"whitesnow\": _4, \"zombie\": _4, \"hateblo\": _4, \"hatenablog\": _4, \"hatenadiary\": _4, \"2-d\": _4, \"bona\": _4, \"crap\": _4, \"daynight\": _4, \"eek\": _4, \"flop\": _4, \"halfmoon\": _4, \"jeez\": _4, \"matrix\": _4, \"mimoza\": _4, \"netgamers\": _4, \"nyanta\": _4, \"o0o0\": _4, \"rdy\": _4, \"rgr\": _4, \"rulez\": _4, \"sakurastorage\": [0, { \"isk01\": _52, \"isk02\": _52 }], \"saloon\": _4, \"sblo\": _4, \"skr\": _4, \"tank\": _4, \"uh-oh\": _4, \"undo\": _4, \"webaccel\": [0, { \"rs\": _4, \"user\": _4 }], \"websozai\": _4, \"xii\": _4 }], \"ke\": [1, { \"ac\": _3, \"co\": _3, \"go\": _3, \"info\": _3, \"me\": _3, \"mobi\": _3, \"ne\": _3, \"or\": _3, \"sc\": _3 }], \"kg\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"us\": _4 }], \"kh\": _17, \"ki\": _53, \"km\": [1, { \"ass\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"nom\": _3, \"org\": _3, \"prd\": _3, \"tm\": _3, \"asso\": _3, \"coop\": _3, \"gouv\": _3, \"medecin\": _3, \"notaires\": _3, \"pharmaciens\": _3, \"presse\": _3, \"veterinaire\": _3 }], \"kn\": [1, { \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3 }], \"kp\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"org\": _3, \"rep\": _3, \"tra\": _3 }], \"kr\": [1, { \"ac\": _3, \"co\": _3, \"es\": _3, \"go\": _3, \"hs\": _3, \"kg\": _3, \"mil\": _3, \"ms\": _3, \"ne\": _3, \"or\": _3, \"pe\": _3, \"re\": _3, \"sc\": _3, \"busan\": _3, \"chungbuk\": _3, \"chungnam\": _3, \"daegu\": _3, \"daejeon\": _3, \"gangwon\": _3, \"gwangju\": _3, \"gyeongbuk\": _3, \"gyeonggi\": _3, \"gyeongnam\": _3, \"incheon\": _3, \"jeju\": _3, \"jeonbuk\": _3, \"jeonnam\": _3, \"seoul\": _3, \"ulsan\": _3 }], \"kw\": [1, { \"com\": _3, \"edu\": _3, \"emb\": _3, \"gov\": _3, \"ind\": _3, \"net\": _3, \"org\": _3 }], \"ky\": _43, \"kz\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"jcloud\": _4 }], \"la\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"int\": _3, \"net\": _3, \"org\": _3, \"per\": _3, \"bnr\": _4 }], \"lb\": _5, \"lc\": [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"oy\": _4 }], \"li\": _3, \"lk\": [1, { \"ac\": _3, \"assn\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"grp\": _3, \"hotel\": _3, \"int\": _3, \"ltd\": _3, \"net\": _3, \"ngo\": _3, \"org\": _3, \"sch\": _3, \"soc\": _3, \"web\": _3 }], \"lr\": _5, \"ls\": [1, { \"ac\": _3, \"biz\": _3, \"co\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"net\": _3, \"org\": _3, \"sc\": _3 }], \"lt\": _10, \"lu\": [1, { \"123website\": _4 }], \"lv\": [1, { \"asn\": _3, \"com\": _3, \"conf\": _3, \"edu\": _3, \"gov\": _3, \"id\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], \"ly\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"id\": _3, \"med\": _3, \"net\": _3, \"org\": _3, \"plc\": _3, \"sch\": _3 }], \"ma\": [1, { \"ac\": _3, \"co\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"press\": _3 }], \"mc\": [1, { \"asso\": _3, \"tm\": _3 }], \"md\": [1, { \"ir\": _4 }], \"me\": [1, { \"ac\": _3, \"co\": _3, \"edu\": _3, \"gov\": _3, \"its\": _3, \"net\": _3, \"org\": _3, \"priv\": _3, \"c66\": _4, \"craft\": _4, \"edgestack\": _4, \"filegear\": _4, \"glitch\": _4, \"filegear-sg\": _4, \"lohmus\": _4, \"barsy\": _4, \"mcdir\": _4, \"brasilia\": _4, \"ddns\": _4, \"dnsfor\": _4, \"hopto\": _4, \"loginto\": _4, \"noip\": _4, \"webhop\": _4, \"soundcast\": _4, \"tcp4\": _4, \"vp4\": _4, \"diskstation\": _4, \"dscloud\": _4, \"i234\": _4, \"myds\": _4, \"synology\": _4, \"transip\": _42, \"nohost\": _4 }], \"mg\": [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"nom\": _3, \"org\": _3, \"prd\": _3 }], \"mh\": _3, \"mil\": _3, \"mk\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"inf\": _3, \"name\": _3, \"net\": _3, \"org\": _3 }], \"ml\": [1, { \"ac\": _3, \"art\": _3, \"asso\": _3, \"com\": _3, \"edu\": _3, \"gouv\": _3, \"gov\": _3, \"info\": _3, \"inst\": _3, \"net\": _3, \"org\": _3, \"pr\": _3, \"presse\": _3 }], \"mm\": _17, \"mn\": [1, { \"edu\": _3, \"gov\": _3, \"org\": _3, \"nyc\": _4 }], \"mo\": _5, \"mobi\": [1, { \"barsy\": _4, \"dscloud\": _4 }], \"mp\": [1, { \"ju\": _4 }], \"mq\": _3, \"mr\": _10, \"ms\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"minisite\": _4 }], \"mt\": _43, \"mu\": [1, { \"ac\": _3, \"co\": _3, \"com\": _3, \"gov\": _3, \"net\": _3, \"or\": _3, \"org\": _3 }], \"museum\": _3, \"mv\": [1, { \"aero\": _3, \"biz\": _3, \"com\": _3, \"coop\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"int\": _3, \"mil\": _3, \"museum\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"pro\": _3 }], \"mw\": [1, { \"ac\": _3, \"biz\": _3, \"co\": _3, \"com\": _3, \"coop\": _3, \"edu\": _3, \"gov\": _3, \"int\": _3, \"net\": _3, \"org\": _3 }], \"mx\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"net\": _3, \"org\": _3 }], \"my\": [1, { \"biz\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"org\": _3 }], \"mz\": [1, { \"ac\": _3, \"adv\": _3, \"co\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], \"na\": [1, { \"alt\": _3, \"co\": _3, \"com\": _3, \"gov\": _3, \"net\": _3, \"org\": _3 }], \"name\": [1, { \"her\": _55, \"his\": _55 }], \"nc\": [1, { \"asso\": _3, \"nom\": _3 }], \"ne\": _3, \"net\": [1, { \"adobeaemcloud\": _4, \"adobeio-static\": _4, \"adobeioruntime\": _4, \"akadns\": _4, \"akamai\": _4, \"akamai-staging\": _4, \"akamaiedge\": _4, \"akamaiedge-staging\": _4, \"akamaihd\": _4, \"akamaihd-staging\": _4, \"akamaiorigin\": _4, \"akamaiorigin-staging\": _4, \"akamaized\": _4, \"akamaized-staging\": _4, \"edgekey\": _4, \"edgekey-staging\": _4, \"edgesuite\": _4, \"edgesuite-staging\": _4, \"alwaysdata\": _4, \"myamaze\": _4, \"cloudfront\": _4, \"appudo\": _4, \"atlassian-dev\": [0, { \"prod\": _56 }], \"myfritz\": _4, \"onavstack\": _4, \"shopselect\": _4, \"blackbaudcdn\": _4, \"boomla\": _4, \"bplaced\": _4, \"square7\": _4, \"cdn77\": [0, { \"r\": _4 }], \"cdn77-ssl\": _4, \"gb\": _4, \"hu\": _4, \"jp\": _4, \"se\": _4, \"uk\": _4, \"clickrising\": _4, \"ddns-ip\": _4, \"dns-cloud\": _4, \"dns-dynamic\": _4, \"cloudaccess\": _4, \"cloudflare\": [2, { \"cdn\": _4 }], \"cloudflareanycast\": _56, \"cloudflarecn\": _56, \"cloudflareglobal\": _56, \"ctfcloud\": _4, \"feste-ip\": _4, \"knx-server\": _4, \"static-access\": _4, \"cryptonomic\": _7, \"dattolocal\": _4, \"mydatto\": _4, \"debian\": _4, \"definima\": _4, \"at-band-camp\": _4, \"blogdns\": _4, \"broke-it\": _4, \"buyshouses\": _4, \"dnsalias\": _4, \"dnsdojo\": _4, \"does-it\": _4, \"dontexist\": _4, \"dynalias\": _4, \"dynathome\": _4, \"endofinternet\": _4, \"from-az\": _4, \"from-co\": _4, \"from-la\": _4, \"from-ny\": _4, \"gets-it\": _4, \"ham-radio-op\": _4, \"homeftp\": _4, \"homeip\": _4, \"homelinux\": _4, \"homeunix\": _4, \"in-the-band\": _4, \"is-a-chef\": _4, \"is-a-geek\": _4, \"isa-geek\": _4, \"kicks-ass\": _4, \"office-on-the\": _4, \"podzone\": _4, \"scrapper-site\": _4, \"selfip\": _4, \"sells-it\": _4, \"servebbs\": _4, \"serveftp\": _4, \"thruhere\": _4, \"webhop\": _4, \"casacam\": _4, \"dynu\": _4, \"dynv6\": _4, \"twmail\": _4, \"ru\": _4, \"channelsdvr\": [2, { \"u\": _4 }], \"fastly\": [0, { \"freetls\": _4, \"map\": _4, \"prod\": [0, { \"a\": _4, \"global\": _4 }], \"ssl\": [0, { \"a\": _4, \"b\": _4, \"global\": _4 }] }], \"fastlylb\": [2, { \"map\": _4 }], \"edgeapp\": _4, \"keyword-on\": _4, \"live-on\": _4, \"server-on\": _4, \"cdn-edges\": _4, \"heteml\": _4, \"cloudfunctions\": _4, \"grafana-dev\": _4, \"iobb\": _4, \"moonscale\": _4, \"in-dsl\": _4, \"in-vpn\": _4, \"botdash\": _4, \"apps-1and1\": _4, \"ipifony\": _4, \"cloudjiffy\": [2, { \"fra1-de\": _4, \"west1-us\": _4 }], \"elastx\": [0, { \"jls-sto1\": _4, \"jls-sto2\": _4, \"jls-sto3\": _4 }], \"massivegrid\": [0, { \"paas\": [0, { \"fr-1\": _4, \"lon-1\": _4, \"lon-2\": _4, \"ny-1\": _4, \"ny-2\": _4, \"sg-1\": _4 }] }], \"saveincloud\": [0, { \"jelastic\": _4, \"nordeste-idc\": _4 }], \"scaleforce\": _44, \"kinghost\": _4, \"uni5\": _4, \"krellian\": _4, \"ggff\": _4, \"localcert\": _4, \"localhostcert\": _4, \"barsy\": _4, \"memset\": _4, \"azure-api\": _4, \"azure-mobile\": _4, \"azureedge\": _4, \"azurefd\": _4, \"azurestaticapps\": [2, { \"1\": _4, \"2\": _4, \"3\": _4, \"4\": _4, \"5\": _4, \"6\": _4, \"7\": _4, \"centralus\": _4, \"eastasia\": _4, \"eastus2\": _4, \"westeurope\": _4, \"westus2\": _4 }], \"azurewebsites\": _4, \"cloudapp\": _4, \"trafficmanager\": _4, \"windows\": [0, { \"core\": [0, { \"blob\": _4 }], \"servicebus\": _4 }], \"mynetname\": [0, { \"sn\": _4 }], \"routingthecloud\": _4, \"bounceme\": _4, \"ddns\": _4, \"eating-organic\": _4, \"mydissent\": _4, \"myeffect\": _4, \"mymediapc\": _4, \"mypsx\": _4, \"mysecuritycamera\": _4, \"nhlfan\": _4, \"no-ip\": _4, \"pgafan\": _4, \"privatizehealthinsurance\": _4, \"redirectme\": _4, \"serveblog\": _4, \"serveminecraft\": _4, \"sytes\": _4, \"dnsup\": _4, \"hicam\": _4, \"now-dns\": _4, \"ownip\": _4, \"vpndns\": _4, \"cloudycluster\": _4, \"ovh\": [0, { \"hosting\": _7, \"webpaas\": _7 }], \"rackmaze\": _4, \"myradweb\": _4, \"in\": _4, \"subsc-pay\": _4, \"squares\": _4, \"schokokeks\": _4, \"firewall-gateway\": _4, \"seidat\": _4, \"senseering\": _4, \"siteleaf\": _4, \"mafelo\": _4, \"myspreadshop\": _4, \"vps-host\": [2, { \"jelastic\": [0, { \"atl\": _4, \"njs\": _4, \"ric\": _4 }] }], \"srcf\": [0, { \"soc\": _4, \"user\": _4 }], \"supabase\": _4, \"dsmynas\": _4, \"familyds\": _4, \"ts\": [2, { \"c\": _7 }], \"torproject\": [2, { \"pages\": _4 }], \"vusercontent\": _4, \"reserve-online\": _4, \"community-pro\": _4, \"meinforum\": _4, \"yandexcloud\": [2, { \"storage\": _4, \"website\": _4 }], \"za\": _4 }], \"nf\": [1, { \"arts\": _3, \"com\": _3, \"firm\": _3, \"info\": _3, \"net\": _3, \"other\": _3, \"per\": _3, \"rec\": _3, \"store\": _3, \"web\": _3 }], \"ng\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"i\": _3, \"mil\": _3, \"mobi\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"sch\": _3, \"biz\": [2, { \"co\": _4, \"dl\": _4, \"go\": _4, \"lg\": _4, \"on\": _4 }], \"col\": _4, \"firm\": _4, \"gen\": _4, \"ltd\": _4, \"ngo\": _4, \"plc\": _4 }], \"ni\": [1, { \"ac\": _3, \"biz\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"gob\": _3, \"in\": _3, \"info\": _3, \"int\": _3, \"mil\": _3, \"net\": _3, \"nom\": _3, \"org\": _3, \"web\": _3 }], \"nl\": [1, { \"co\": _4, \"hosting-cluster\": _4, \"gov\": _4, \"khplay\": _4, \"123website\": _4, \"myspreadshop\": _4, \"transurl\": _7, \"cistron\": _4, \"demon\": _4 }], \"no\": [1, { \"fhs\": _3, \"folkebibl\": _3, \"fylkesbibl\": _3, \"idrett\": _3, \"museum\": _3, \"priv\": _3, \"vgs\": _3, \"dep\": _3, \"herad\": _3, \"kommune\": _3, \"mil\": _3, \"stat\": _3, \"aa\": _57, \"ah\": _57, \"bu\": _57, \"fm\": _57, \"hl\": _57, \"hm\": _57, \"jan-mayen\": _57, \"mr\": _57, \"nl\": _57, \"nt\": _57, \"of\": _57, \"ol\": _57, \"oslo\": _57, \"rl\": _57, \"sf\": _57, \"st\": _57, \"svalbard\": _57, \"tm\": _57, \"tr\": _57, \"va\": _57, \"vf\": _57, \"akrehamn\": _3, \"xn--krehamn-dxa\": _3, \"åkrehamn\": _3, \"algard\": _3, \"xn--lgrd-poac\": _3, \"ålgård\": _3, \"arna\": _3, \"bronnoysund\": _3, \"xn--brnnysund-m8ac\": _3, \"brønnøysund\": _3, \"brumunddal\": _3, \"bryne\": _3, \"drobak\": _3, \"xn--drbak-wua\": _3, \"drøbak\": _3, \"egersund\": _3, \"fetsund\": _3, \"floro\": _3, \"xn--flor-jra\": _3, \"florø\": _3, \"fredrikstad\": _3, \"hokksund\": _3, \"honefoss\": _3, \"xn--hnefoss-q1a\": _3, \"hønefoss\": _3, \"jessheim\": _3, \"jorpeland\": _3, \"xn--jrpeland-54a\": _3, \"jørpeland\": _3, \"kirkenes\": _3, \"kopervik\": _3, \"krokstadelva\": _3, \"langevag\": _3, \"xn--langevg-jxa\": _3, \"langevåg\": _3, \"leirvik\": _3, \"mjondalen\": _3, \"xn--mjndalen-64a\": _3, \"mjøndalen\": _3, \"mo-i-rana\": _3, \"mosjoen\": _3, \"xn--mosjen-eya\": _3, \"mosjøen\": _3, \"nesoddtangen\": _3, \"orkanger\": _3, \"osoyro\": _3, \"xn--osyro-wua\": _3, \"osøyro\": _3, \"raholt\": _3, \"xn--rholt-mra\": _3, \"råholt\": _3, \"sandnessjoen\": _3, \"xn--sandnessjen-ogb\": _3, \"sandnessjøen\": _3, \"skedsmokorset\": _3, \"slattum\": _3, \"spjelkavik\": _3, \"stathelle\": _3, \"stavern\": _3, \"stjordalshalsen\": _3, \"xn--stjrdalshalsen-sqb\": _3, \"stjørdalshalsen\": _3, \"tananger\": _3, \"tranby\": _3, \"vossevangen\": _3, \"aarborte\": _3, \"aejrie\": _3, \"afjord\": _3, \"xn--fjord-lra\": _3, \"åfjord\": _3, \"agdenes\": _3, \"akershus\": _58, \"aknoluokta\": _3, \"xn--koluokta-7ya57h\": _3, \"ákŋoluokta\": _3, \"al\": _3, \"xn--l-1fa\": _3, \"ål\": _3, \"alaheadju\": _3, \"xn--laheadju-7ya\": _3, \"álaheadju\": _3, \"alesund\": _3, \"xn--lesund-hua\": _3, \"ålesund\": _3, \"alstahaug\": _3, \"alta\": _3, \"xn--lt-liac\": _3, \"áltá\": _3, \"alvdal\": _3, \"amli\": _3, \"xn--mli-tla\": _3, \"åmli\": _3, \"amot\": _3, \"xn--mot-tla\": _3, \"åmot\": _3, \"andasuolo\": _3, \"andebu\": _3, \"andoy\": _3, \"xn--andy-ira\": _3, \"andøy\": _3, \"ardal\": _3, \"xn--rdal-poa\": _3, \"årdal\": _3, \"aremark\": _3, \"arendal\": _3, \"xn--s-1fa\": _3, \"ås\": _3, \"aseral\": _3, \"xn--seral-lra\": _3, \"åseral\": _3, \"asker\": _3, \"askim\": _3, \"askoy\": _3, \"xn--asky-ira\": _3, \"askøy\": _3, \"askvoll\": _3, \"asnes\": _3, \"xn--snes-poa\": _3, \"åsnes\": _3, \"audnedaln\": _3, \"aukra\": _3, \"aure\": _3, \"aurland\": _3, \"aurskog-holand\": _3, \"xn--aurskog-hland-jnb\": _3, \"aurskog-høland\": _3, \"austevoll\": _3, \"austrheim\": _3, \"averoy\": _3, \"xn--avery-yua\": _3, \"averøy\": _3, \"badaddja\": _3, \"xn--bdddj-mrabd\": _3, \"bådåddjå\": _3, \"xn--brum-voa\": _3, \"bærum\": _3, \"bahcavuotna\": _3, \"xn--bhcavuotna-s4a\": _3, \"báhcavuotna\": _3, \"bahccavuotna\": _3, \"xn--bhccavuotna-k7a\": _3, \"báhccavuotna\": _3, \"baidar\": _3, \"xn--bidr-5nac\": _3, \"báidár\": _3, \"bajddar\": _3, \"xn--bjddar-pta\": _3, \"bájddar\": _3, \"balat\": _3, \"xn--blt-elab\": _3, \"bálát\": _3, \"balestrand\": _3, \"ballangen\": _3, \"balsfjord\": _3, \"bamble\": _3, \"bardu\": _3, \"barum\": _3, \"batsfjord\": _3, \"xn--btsfjord-9za\": _3, \"båtsfjord\": _3, \"bearalvahki\": _3, \"xn--bearalvhki-y4a\": _3, \"bearalváhki\": _3, \"beardu\": _3, \"beiarn\": _3, \"berg\": _3, \"bergen\": _3, \"berlevag\": _3, \"xn--berlevg-jxa\": _3, \"berlevåg\": _3, \"bievat\": _3, \"xn--bievt-0qa\": _3, \"bievát\": _3, \"bindal\": _3, \"birkenes\": _3, \"bjarkoy\": _3, \"xn--bjarky-fya\": _3, \"bjarkøy\": _3, \"bjerkreim\": _3, \"bjugn\": _3, \"bodo\": _3, \"xn--bod-2na\": _3, \"bodø\": _3, \"bokn\": _3, \"bomlo\": _3, \"xn--bmlo-gra\": _3, \"bømlo\": _3, \"bremanger\": _3, \"bronnoy\": _3, \"xn--brnny-wuac\": _3, \"brønnøy\": _3, \"budejju\": _3, \"buskerud\": _58, \"bygland\": _3, \"bykle\": _3, \"cahcesuolo\": _3, \"xn--hcesuolo-7ya35b\": _3, \"čáhcesuolo\": _3, \"davvenjarga\": _3, \"xn--davvenjrga-y4a\": _3, \"davvenjárga\": _3, \"davvesiida\": _3, \"deatnu\": _3, \"dielddanuorri\": _3, \"divtasvuodna\": _3, \"divttasvuotna\": _3, \"donna\": _3, \"xn--dnna-gra\": _3, \"dønna\": _3, \"dovre\": _3, \"drammen\": _3, \"drangedal\": _3, \"dyroy\": _3, \"xn--dyry-ira\": _3, \"dyrøy\": _3, \"eid\": _3, \"eidfjord\": _3, \"eidsberg\": _3, \"eidskog\": _3, \"eidsvoll\": _3, \"eigersund\": _3, \"elverum\": _3, \"enebakk\": _3, \"engerdal\": _3, \"etne\": _3, \"etnedal\": _3, \"evenassi\": _3, \"xn--eveni-0qa01ga\": _3, \"evenášši\": _3, \"evenes\": _3, \"evje-og-hornnes\": _3, \"farsund\": _3, \"fauske\": _3, \"fedje\": _3, \"fet\": _3, \"finnoy\": _3, \"xn--finny-yua\": _3, \"finnøy\": _3, \"fitjar\": _3, \"fjaler\": _3, \"fjell\": _3, \"fla\": _3, \"xn--fl-zia\": _3, \"flå\": _3, \"flakstad\": _3, \"flatanger\": _3, \"flekkefjord\": _3, \"flesberg\": _3, \"flora\": _3, \"folldal\": _3, \"forde\": _3, \"xn--frde-gra\": _3, \"førde\": _3, \"forsand\": _3, \"fosnes\": _3, \"xn--frna-woa\": _3, \"fræna\": _3, \"frana\": _3, \"frei\": _3, \"frogn\": _3, \"froland\": _3, \"frosta\": _3, \"froya\": _3, \"xn--frya-hra\": _3, \"frøya\": _3, \"fuoisku\": _3, \"fuossko\": _3, \"fusa\": _3, \"fyresdal\": _3, \"gaivuotna\": _3, \"xn--givuotna-8ya\": _3, \"gáivuotna\": _3, \"galsa\": _3, \"xn--gls-elac\": _3, \"gálsá\": _3, \"gamvik\": _3, \"gangaviika\": _3, \"xn--ggaviika-8ya47h\": _3, \"gáŋgaviika\": _3, \"gaular\": _3, \"gausdal\": _3, \"giehtavuoatna\": _3, \"gildeskal\": _3, \"xn--gildeskl-g0a\": _3, \"gildeskål\": _3, \"giske\": _3, \"gjemnes\": _3, \"gjerdrum\": _3, \"gjerstad\": _3, \"gjesdal\": _3, \"gjovik\": _3, \"xn--gjvik-wua\": _3, \"gjøvik\": _3, \"gloppen\": _3, \"gol\": _3, \"gran\": _3, \"grane\": _3, \"granvin\": _3, \"gratangen\": _3, \"grimstad\": _3, \"grong\": _3, \"grue\": _3, \"gulen\": _3, \"guovdageaidnu\": _3, \"ha\": _3, \"xn--h-2fa\": _3, \"hå\": _3, \"habmer\": _3, \"xn--hbmer-xqa\": _3, \"hábmer\": _3, \"hadsel\": _3, \"xn--hgebostad-g3a\": _3, \"hægebostad\": _3, \"hagebostad\": _3, \"halden\": _3, \"halsa\": _3, \"hamar\": _3, \"hamaroy\": _3, \"hammarfeasta\": _3, \"xn--hmmrfeasta-s4ac\": _3, \"hámmárfeasta\": _3, \"hammerfest\": _3, \"hapmir\": _3, \"xn--hpmir-xqa\": _3, \"hápmir\": _3, \"haram\": _3, \"hareid\": _3, \"harstad\": _3, \"hasvik\": _3, \"hattfjelldal\": _3, \"haugesund\": _3, \"hedmark\": [0, { \"os\": _3, \"valer\": _3, \"xn--vler-qoa\": _3, \"våler\": _3 }], \"hemne\": _3, \"hemnes\": _3, \"hemsedal\": _3, \"hitra\": _3, \"hjartdal\": _3, \"hjelmeland\": _3, \"hobol\": _3, \"xn--hobl-ira\": _3, \"hobøl\": _3, \"hof\": _3, \"hol\": _3, \"hole\": _3, \"holmestrand\": _3, \"holtalen\": _3, \"xn--holtlen-hxa\": _3, \"holtålen\": _3, \"hordaland\": [0, { \"os\": _3 }], \"hornindal\": _3, \"horten\": _3, \"hoyanger\": _3, \"xn--hyanger-q1a\": _3, \"høyanger\": _3, \"hoylandet\": _3, \"xn--hylandet-54a\": _3, \"høylandet\": _3, \"hurdal\": _3, \"hurum\": _3, \"hvaler\": _3, \"hyllestad\": _3, \"ibestad\": _3, \"inderoy\": _3, \"xn--indery-fya\": _3, \"inderøy\": _3, \"iveland\": _3, \"ivgu\": _3, \"jevnaker\": _3, \"jolster\": _3, \"xn--jlster-bya\": _3, \"jølster\": _3, \"jondal\": _3, \"kafjord\": _3, \"xn--kfjord-iua\": _3, \"kåfjord\": _3, \"karasjohka\": _3, \"xn--krjohka-hwab49j\": _3, \"kárášjohka\": _3, \"karasjok\": _3, \"karlsoy\": _3, \"karmoy\": _3, \"xn--karmy-yua\": _3, \"karmøy\": _3, \"kautokeino\": _3, \"klabu\": _3, \"xn--klbu-woa\": _3, \"klæbu\": _3, \"klepp\": _3, \"kongsberg\": _3, \"kongsvinger\": _3, \"kraanghke\": _3, \"xn--kranghke-b0a\": _3, \"kråanghke\": _3, \"kragero\": _3, \"xn--krager-gya\": _3, \"kragerø\": _3, \"kristiansand\": _3, \"kristiansund\": _3, \"krodsherad\": _3, \"xn--krdsherad-m8a\": _3, \"krødsherad\": _3, \"xn--kvfjord-nxa\": _3, \"kvæfjord\": _3, \"xn--kvnangen-k0a\": _3, \"kvænangen\": _3, \"kvafjord\": _3, \"kvalsund\": _3, \"kvam\": _3, \"kvanangen\": _3, \"kvinesdal\": _3, \"kvinnherad\": _3, \"kviteseid\": _3, \"kvitsoy\": _3, \"xn--kvitsy-fya\": _3, \"kvitsøy\": _3, \"laakesvuemie\": _3, \"xn--lrdal-sra\": _3, \"lærdal\": _3, \"lahppi\": _3, \"xn--lhppi-xqa\": _3, \"láhppi\": _3, \"lardal\": _3, \"larvik\": _3, \"lavagis\": _3, \"lavangen\": _3, \"leangaviika\": _3, \"xn--leagaviika-52b\": _3, \"leaŋgaviika\": _3, \"lebesby\": _3, \"leikanger\": _3, \"leirfjord\": _3, \"leka\": _3, \"leksvik\": _3, \"lenvik\": _3, \"lerdal\": _3, \"lesja\": _3, \"levanger\": _3, \"lier\": _3, \"lierne\": _3, \"lillehammer\": _3, \"lillesand\": _3, \"lindas\": _3, \"xn--linds-pra\": _3, \"lindås\": _3, \"lindesnes\": _3, \"loabat\": _3, \"xn--loabt-0qa\": _3, \"loabát\": _3, \"lodingen\": _3, \"xn--ldingen-q1a\": _3, \"lødingen\": _3, \"lom\": _3, \"loppa\": _3, \"lorenskog\": _3, \"xn--lrenskog-54a\": _3, \"lørenskog\": _3, \"loten\": _3, \"xn--lten-gra\": _3, \"løten\": _3, \"lund\": _3, \"lunner\": _3, \"luroy\": _3, \"xn--lury-ira\": _3, \"lurøy\": _3, \"luster\": _3, \"lyngdal\": _3, \"lyngen\": _3, \"malatvuopmi\": _3, \"xn--mlatvuopmi-s4a\": _3, \"málatvuopmi\": _3, \"malselv\": _3, \"xn--mlselv-iua\": _3, \"målselv\": _3, \"malvik\": _3, \"mandal\": _3, \"marker\": _3, \"marnardal\": _3, \"masfjorden\": _3, \"masoy\": _3, \"xn--msy-ula0h\": _3, \"måsøy\": _3, \"matta-varjjat\": _3, \"xn--mtta-vrjjat-k7af\": _3, \"mátta-várjjat\": _3, \"meland\": _3, \"meldal\": _3, \"melhus\": _3, \"meloy\": _3, \"xn--mely-ira\": _3, \"meløy\": _3, \"meraker\": _3, \"xn--merker-kua\": _3, \"meråker\": _3, \"midsund\": _3, \"midtre-gauldal\": _3, \"moareke\": _3, \"xn--moreke-jua\": _3, \"moåreke\": _3, \"modalen\": _3, \"modum\": _3, \"molde\": _3, \"more-og-romsdal\": [0, { \"heroy\": _3, \"sande\": _3 }], \"xn--mre-og-romsdal-qqb\": [0, { \"xn--hery-ira\": _3, \"sande\": _3 }], \"møre-og-romsdal\": [0, { \"herøy\": _3, \"sande\": _3 }], \"moskenes\": _3, \"moss\": _3, \"mosvik\": _3, \"muosat\": _3, \"xn--muost-0qa\": _3, \"muosát\": _3, \"naamesjevuemie\": _3, \"xn--nmesjevuemie-tcba\": _3, \"nååmesjevuemie\": _3, \"xn--nry-yla5g\": _3, \"nærøy\": _3, \"namdalseid\": _3, \"namsos\": _3, \"namsskogan\": _3, \"nannestad\": _3, \"naroy\": _3, \"narviika\": _3, \"narvik\": _3, \"naustdal\": _3, \"navuotna\": _3, \"xn--nvuotna-hwa\": _3, \"návuotna\": _3, \"nedre-eiker\": _3, \"nesna\": _3, \"nesodden\": _3, \"nesseby\": _3, \"nesset\": _3, \"nissedal\": _3, \"nittedal\": _3, \"nord-aurdal\": _3, \"nord-fron\": _3, \"nord-odal\": _3, \"norddal\": _3, \"nordkapp\": _3, \"nordland\": [0, { \"bo\": _3, \"xn--b-5ga\": _3, \"bø\": _3, \"heroy\": _3, \"xn--hery-ira\": _3, \"herøy\": _3 }], \"nordre-land\": _3, \"nordreisa\": _3, \"nore-og-uvdal\": _3, \"notodden\": _3, \"notteroy\": _3, \"xn--nttery-byae\": _3, \"nøtterøy\": _3, \"odda\": _3, \"oksnes\": _3, \"xn--ksnes-uua\": _3, \"øksnes\": _3, \"omasvuotna\": _3, \"oppdal\": _3, \"oppegard\": _3, \"xn--oppegrd-ixa\": _3, \"oppegård\": _3, \"orkdal\": _3, \"orland\": _3, \"xn--rland-uua\": _3, \"ørland\": _3, \"orskog\": _3, \"xn--rskog-uua\": _3, \"ørskog\": _3, \"orsta\": _3, \"xn--rsta-fra\": _3, \"ørsta\": _3, \"osen\": _3, \"osteroy\": _3, \"xn--ostery-fya\": _3, \"osterøy\": _3, \"ostfold\": [0, { \"valer\": _3 }], \"xn--stfold-9xa\": [0, { \"xn--vler-qoa\": _3 }], \"østfold\": [0, { \"våler\": _3 }], \"ostre-toten\": _3, \"xn--stre-toten-zcb\": _3, \"østre-toten\": _3, \"overhalla\": _3, \"ovre-eiker\": _3, \"xn--vre-eiker-k8a\": _3, \"øvre-eiker\": _3, \"oyer\": _3, \"xn--yer-zna\": _3, \"øyer\": _3, \"oygarden\": _3, \"xn--ygarden-p1a\": _3, \"øygarden\": _3, \"oystre-slidre\": _3, \"xn--ystre-slidre-ujb\": _3, \"øystre-slidre\": _3, \"porsanger\": _3, \"porsangu\": _3, \"xn--porsgu-sta26f\": _3, \"porsáŋgu\": _3, \"porsgrunn\": _3, \"rade\": _3, \"xn--rde-ula\": _3, \"råde\": _3, \"radoy\": _3, \"xn--rady-ira\": _3, \"radøy\": _3, \"xn--rlingen-mxa\": _3, \"rælingen\": _3, \"rahkkeravju\": _3, \"xn--rhkkervju-01af\": _3, \"ráhkkerávju\": _3, \"raisa\": _3, \"xn--risa-5na\": _3, \"ráisa\": _3, \"rakkestad\": _3, \"ralingen\": _3, \"rana\": _3, \"randaberg\": _3, \"rauma\": _3, \"rendalen\": _3, \"rennebu\": _3, \"rennesoy\": _3, \"xn--rennesy-v1a\": _3, \"rennesøy\": _3, \"rindal\": _3, \"ringebu\": _3, \"ringerike\": _3, \"ringsaker\": _3, \"risor\": _3, \"xn--risr-ira\": _3, \"risør\": _3, \"rissa\": _3, \"roan\": _3, \"rodoy\": _3, \"xn--rdy-0nab\": _3, \"rødøy\": _3, \"rollag\": _3, \"romsa\": _3, \"romskog\": _3, \"xn--rmskog-bya\": _3, \"rømskog\": _3, \"roros\": _3, \"xn--rros-gra\": _3, \"røros\": _3, \"rost\": _3, \"xn--rst-0na\": _3, \"røst\": _3, \"royken\": _3, \"xn--ryken-vua\": _3, \"røyken\": _3, \"royrvik\": _3, \"xn--ryrvik-bya\": _3, \"røyrvik\": _3, \"ruovat\": _3, \"rygge\": _3, \"salangen\": _3, \"salat\": _3, \"xn--slat-5na\": _3, \"sálat\": _3, \"xn--slt-elab\": _3, \"sálát\": _3, \"saltdal\": _3, \"samnanger\": _3, \"sandefjord\": _3, \"sandnes\": _3, \"sandoy\": _3, \"xn--sandy-yua\": _3, \"sandøy\": _3, \"sarpsborg\": _3, \"sauda\": _3, \"sauherad\": _3, \"sel\": _3, \"selbu\": _3, \"selje\": _3, \"seljord\": _3, \"siellak\": _3, \"sigdal\": _3, \"siljan\": _3, \"sirdal\": _3, \"skanit\": _3, \"xn--sknit-yqa\": _3, \"skánit\": _3, \"skanland\": _3, \"xn--sknland-fxa\": _3, \"skånland\": _3, \"skaun\": _3, \"skedsmo\": _3, \"ski\": _3, \"skien\": _3, \"skierva\": _3, \"xn--skierv-uta\": _3, \"skiervá\": _3, \"skiptvet\": _3, \"skjak\": _3, \"xn--skjk-soa\": _3, \"skjåk\": _3, \"skjervoy\": _3, \"xn--skjervy-v1a\": _3, \"skjervøy\": _3, \"skodje\": _3, \"smola\": _3, \"xn--smla-hra\": _3, \"smøla\": _3, \"snaase\": _3, \"xn--snase-nra\": _3, \"snåase\": _3, \"snasa\": _3, \"xn--snsa-roa\": _3, \"snåsa\": _3, \"snillfjord\": _3, \"snoasa\": _3, \"sogndal\": _3, \"sogne\": _3, \"xn--sgne-gra\": _3, \"søgne\": _3, \"sokndal\": _3, \"sola\": _3, \"solund\": _3, \"somna\": _3, \"xn--smna-gra\": _3, \"sømna\": _3, \"sondre-land\": _3, \"xn--sndre-land-0cb\": _3, \"søndre-land\": _3, \"songdalen\": _3, \"sor-aurdal\": _3, \"xn--sr-aurdal-l8a\": _3, \"sør-aurdal\": _3, \"sor-fron\": _3, \"xn--sr-fron-q1a\": _3, \"sør-fron\": _3, \"sor-odal\": _3, \"xn--sr-odal-q1a\": _3, \"sør-odal\": _3, \"sor-varanger\": _3, \"xn--sr-varanger-ggb\": _3, \"sør-varanger\": _3, \"sorfold\": _3, \"xn--srfold-bya\": _3, \"sørfold\": _3, \"sorreisa\": _3, \"xn--srreisa-q1a\": _3, \"sørreisa\": _3, \"sortland\": _3, \"sorum\": _3, \"xn--srum-gra\": _3, \"sørum\": _3, \"spydeberg\": _3, \"stange\": _3, \"stavanger\": _3, \"steigen\": _3, \"steinkjer\": _3, \"stjordal\": _3, \"xn--stjrdal-s1a\": _3, \"stjørdal\": _3, \"stokke\": _3, \"stor-elvdal\": _3, \"stord\": _3, \"stordal\": _3, \"storfjord\": _3, \"strand\": _3, \"stranda\": _3, \"stryn\": _3, \"sula\": _3, \"suldal\": _3, \"sund\": _3, \"sunndal\": _3, \"surnadal\": _3, \"sveio\": _3, \"svelvik\": _3, \"sykkylven\": _3, \"tana\": _3, \"telemark\": [0, { \"bo\": _3, \"xn--b-5ga\": _3, \"bø\": _3 }], \"time\": _3, \"tingvoll\": _3, \"tinn\": _3, \"tjeldsund\": _3, \"tjome\": _3, \"xn--tjme-hra\": _3, \"tjøme\": _3, \"tokke\": _3, \"tolga\": _3, \"tonsberg\": _3, \"xn--tnsberg-q1a\": _3, \"tønsberg\": _3, \"torsken\": _3, \"xn--trna-woa\": _3, \"træna\": _3, \"trana\": _3, \"tranoy\": _3, \"xn--trany-yua\": _3, \"tranøy\": _3, \"troandin\": _3, \"trogstad\": _3, \"xn--trgstad-r1a\": _3, \"trøgstad\": _3, \"tromsa\": _3, \"tromso\": _3, \"xn--troms-zua\": _3, \"tromsø\": _3, \"trondheim\": _3, \"trysil\": _3, \"tvedestrand\": _3, \"tydal\": _3, \"tynset\": _3, \"tysfjord\": _3, \"tysnes\": _3, \"xn--tysvr-vra\": _3, \"tysvær\": _3, \"tysvar\": _3, \"ullensaker\": _3, \"ullensvang\": _3, \"ulvik\": _3, \"unjarga\": _3, \"xn--unjrga-rta\": _3, \"unjárga\": _3, \"utsira\": _3, \"vaapste\": _3, \"vadso\": _3, \"xn--vads-jra\": _3, \"vadsø\": _3, \"xn--vry-yla5g\": _3, \"værøy\": _3, \"vaga\": _3, \"xn--vg-yiab\": _3, \"vågå\": _3, \"vagan\": _3, \"xn--vgan-qoa\": _3, \"vågan\": _3, \"vagsoy\": _3, \"xn--vgsy-qoa0j\": _3, \"vågsøy\": _3, \"vaksdal\": _3, \"valle\": _3, \"vang\": _3, \"vanylven\": _3, \"vardo\": _3, \"xn--vard-jra\": _3, \"vardø\": _3, \"varggat\": _3, \"xn--vrggt-xqad\": _3, \"várggát\": _3, \"varoy\": _3, \"vefsn\": _3, \"vega\": _3, \"vegarshei\": _3, \"xn--vegrshei-c0a\": _3, \"vegårshei\": _3, \"vennesla\": _3, \"verdal\": _3, \"verran\": _3, \"vestby\": _3, \"vestfold\": [0, { \"sande\": _3 }], \"vestnes\": _3, \"vestre-slidre\": _3, \"vestre-toten\": _3, \"vestvagoy\": _3, \"xn--vestvgy-ixa6o\": _3, \"vestvågøy\": _3, \"vevelstad\": _3, \"vik\": _3, \"vikna\": _3, \"vindafjord\": _3, \"voagat\": _3, \"volda\": _3, \"voss\": _3, \"co\": _4, \"123hjemmeside\": _4, \"myspreadshop\": _4 }], \"np\": _17, \"nr\": _53, \"nu\": [1, { \"merseine\": _4, \"mine\": _4, \"shacknet\": _4, \"enterprisecloud\": _4 }], \"nz\": [1, { \"ac\": _3, \"co\": _3, \"cri\": _3, \"geek\": _3, \"gen\": _3, \"govt\": _3, \"health\": _3, \"iwi\": _3, \"kiwi\": _3, \"maori\": _3, \"xn--mori-qsa\": _3, \"māori\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"parliament\": _3, \"school\": _3, \"cloudns\": _4 }], \"om\": [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"med\": _3, \"museum\": _3, \"net\": _3, \"org\": _3, \"pro\": _3 }], \"onion\": _3, \"org\": [1, { \"altervista\": _4, \"pimienta\": _4, \"poivron\": _4, \"potager\": _4, \"sweetpepper\": _4, \"cdn77\": [0, { \"c\": _4, \"rsc\": _4 }], \"cdn77-secure\": [0, { \"origin\": [0, { \"ssl\": _4 }] }], \"ae\": _4, \"cloudns\": _4, \"ip-dynamic\": _4, \"ddnss\": _4, \"duckdns\": _4, \"tunk\": _4, \"blogdns\": _4, \"blogsite\": _4, \"boldlygoingnowhere\": _4, \"dnsalias\": _4, \"dnsdojo\": _4, \"doesntexist\": _4, \"dontexist\": _4, \"doomdns\": _4, \"dvrdns\": _4, \"dynalias\": _4, \"dyndns\": [2, { \"go\": _4, \"home\": _4 }], \"endofinternet\": _4, \"endoftheinternet\": _4, \"from-me\": _4, \"game-host\": _4, \"gotdns\": _4, \"hobby-site\": _4, \"homedns\": _4, \"homeftp\": _4, \"homelinux\": _4, \"homeunix\": _4, \"is-a-bruinsfan\": _4, \"is-a-candidate\": _4, \"is-a-celticsfan\": _4, \"is-a-chef\": _4, \"is-a-geek\": _4, \"is-a-knight\": _4, \"is-a-linux-user\": _4, \"is-a-patsfan\": _4, \"is-a-soxfan\": _4, \"is-found\": _4, \"is-lost\": _4, \"is-saved\": _4, \"is-very-bad\": _4, \"is-very-evil\": _4, \"is-very-good\": _4, \"is-very-nice\": _4, \"is-very-sweet\": _4, \"isa-geek\": _4, \"kicks-ass\": _4, \"misconfused\": _4, \"podzone\": _4, \"readmyblog\": _4, \"selfip\": _4, \"sellsyourhome\": _4, \"servebbs\": _4, \"serveftp\": _4, \"servegame\": _4, \"stuff-4-sale\": _4, \"webhop\": _4, \"accesscam\": _4, \"camdvr\": _4, \"freeddns\": _4, \"mywire\": _4, \"webredirect\": _4, \"twmail\": _4, \"eu\": [2, { \"al\": _4, \"asso\": _4, \"at\": _4, \"au\": _4, \"be\": _4, \"bg\": _4, \"ca\": _4, \"cd\": _4, \"ch\": _4, \"cn\": _4, \"cy\": _4, \"cz\": _4, \"de\": _4, \"dk\": _4, \"edu\": _4, \"ee\": _4, \"es\": _4, \"fi\": _4, \"fr\": _4, \"gr\": _4, \"hr\": _4, \"hu\": _4, \"ie\": _4, \"il\": _4, \"in\": _4, \"int\": _4, \"is\": _4, \"it\": _4, \"jp\": _4, \"kr\": _4, \"lt\": _4, \"lu\": _4, \"lv\": _4, \"me\": _4, \"mk\": _4, \"mt\": _4, \"my\": _4, \"net\": _4, \"ng\": _4, \"nl\": _4, \"no\": _4, \"nz\": _4, \"pl\": _4, \"pt\": _4, \"ro\": _4, \"ru\": _4, \"se\": _4, \"si\": _4, \"sk\": _4, \"tr\": _4, \"uk\": _4, \"us\": _4 }], \"fedorainfracloud\": _4, \"fedorapeople\": _4, \"fedoraproject\": [0, { \"cloud\": _4, \"os\": _41, \"stg\": [0, { \"os\": _41 }] }], \"freedesktop\": _4, \"hatenadiary\": _4, \"hepforge\": _4, \"in-dsl\": _4, \"in-vpn\": _4, \"js\": _4, \"barsy\": _4, \"mayfirst\": _4, \"routingthecloud\": _4, \"bmoattachments\": _4, \"cable-modem\": _4, \"collegefan\": _4, \"couchpotatofries\": _4, \"hopto\": _4, \"mlbfan\": _4, \"myftp\": _4, \"mysecuritycamera\": _4, \"nflfan\": _4, \"no-ip\": _4, \"read-books\": _4, \"ufcfan\": _4, \"zapto\": _4, \"dynserv\": _4, \"now-dns\": _4, \"is-local\": _4, \"httpbin\": _4, \"pubtls\": _4, \"jpn\": _4, \"my-firewall\": _4, \"myfirewall\": _4, \"spdns\": _4, \"small-web\": _4, \"dsmynas\": _4, \"familyds\": _4, \"teckids\": _52, \"tuxfamily\": _4, \"diskstation\": _4, \"hk\": _4, \"us\": _4, \"toolforge\": _4, \"wmcloud\": _4, \"wmflabs\": _4, \"za\": _4 }], \"pa\": [1, { \"abo\": _3, \"ac\": _3, \"com\": _3, \"edu\": _3, \"gob\": _3, \"ing\": _3, \"med\": _3, \"net\": _3, \"nom\": _3, \"org\": _3, \"sld\": _3 }], \"pe\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"mil\": _3, \"net\": _3, \"nom\": _3, \"org\": _3 }], \"pf\": [1, { \"com\": _3, \"edu\": _3, \"org\": _3 }], \"pg\": _17, \"ph\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"i\": _3, \"mil\": _3, \"net\": _3, \"ngo\": _3, \"org\": _3, \"cloudns\": _4 }], \"pk\": [1, { \"ac\": _3, \"biz\": _3, \"com\": _3, \"edu\": _3, \"fam\": _3, \"gkp\": _3, \"gob\": _3, \"gog\": _3, \"gok\": _3, \"gop\": _3, \"gos\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"web\": _3 }], \"pl\": [1, { \"com\": _3, \"net\": _3, \"org\": _3, \"agro\": _3, \"aid\": _3, \"atm\": _3, \"auto\": _3, \"biz\": _3, \"edu\": _3, \"gmina\": _3, \"gsm\": _3, \"info\": _3, \"mail\": _3, \"media\": _3, \"miasta\": _3, \"mil\": _3, \"nieruchomosci\": _3, \"nom\": _3, \"pc\": _3, \"powiat\": _3, \"priv\": _3, \"realestate\": _3, \"rel\": _3, \"sex\": _3, \"shop\": _3, \"sklep\": _3, \"sos\": _3, \"szkola\": _3, \"targi\": _3, \"tm\": _3, \"tourism\": _3, \"travel\": _3, \"turystyka\": _3, \"gov\": [1, { \"ap\": _3, \"griw\": _3, \"ic\": _3, \"is\": _3, \"kmpsp\": _3, \"konsulat\": _3, \"kppsp\": _3, \"kwp\": _3, \"kwpsp\": _3, \"mup\": _3, \"mw\": _3, \"oia\": _3, \"oirm\": _3, \"oke\": _3, \"oow\": _3, \"oschr\": _3, \"oum\": _3, \"pa\": _3, \"pinb\": _3, \"piw\": _3, \"po\": _3, \"pr\": _3, \"psp\": _3, \"psse\": _3, \"pup\": _3, \"rzgw\": _3, \"sa\": _3, \"sdn\": _3, \"sko\": _3, \"so\": _3, \"sr\": _3, \"starostwo\": _3, \"ug\": _3, \"ugim\": _3, \"um\": _3, \"umig\": _3, \"upow\": _3, \"uppo\": _3, \"us\": _3, \"uw\": _3, \"uzs\": _3, \"wif\": _3, \"wiih\": _3, \"winb\": _3, \"wios\": _3, \"witd\": _3, \"wiw\": _3, \"wkz\": _3, \"wsa\": _3, \"wskr\": _3, \"wsse\": _3, \"wuoz\": _3, \"wzmiuw\": _3, \"zp\": _3, \"zpisdn\": _3 }], \"augustow\": _3, \"babia-gora\": _3, \"bedzin\": _3, \"beskidy\": _3, \"bialowieza\": _3, \"bialystok\": _3, \"bielawa\": _3, \"bieszczady\": _3, \"boleslawiec\": _3, \"bydgoszcz\": _3, \"bytom\": _3, \"cieszyn\": _3, \"czeladz\": _3, \"czest\": _3, \"dlugoleka\": _3, \"elblag\": _3, \"elk\": _3, \"glogow\": _3, \"gniezno\": _3, \"gorlice\": _3, \"grajewo\": _3, \"ilawa\": _3, \"jaworzno\": _3, \"jelenia-gora\": _3, \"jgora\": _3, \"kalisz\": _3, \"karpacz\": _3, \"kartuzy\": _3, \"kaszuby\": _3, \"katowice\": _3, \"kazimierz-dolny\": _3, \"kepno\": _3, \"ketrzyn\": _3, \"klodzko\": _3, \"kobierzyce\": _3, \"kolobrzeg\": _3, \"konin\": _3, \"konskowola\": _3, \"kutno\": _3, \"lapy\": _3, \"lebork\": _3, \"legnica\": _3, \"lezajsk\": _3, \"limanowa\": _3, \"lomza\": _3, \"lowicz\": _3, \"lubin\": _3, \"lukow\": _3, \"malbork\": _3, \"malopolska\": _3, \"mazowsze\": _3, \"mazury\": _3, \"mielec\": _3, \"mielno\": _3, \"mragowo\": _3, \"naklo\": _3, \"nowaruda\": _3, \"nysa\": _3, \"olawa\": _3, \"olecko\": _3, \"olkusz\": _3, \"olsztyn\": _3, \"opoczno\": _3, \"opole\": _3, \"ostroda\": _3, \"ostroleka\": _3, \"ostrowiec\": _3, \"ostrowwlkp\": _3, \"pila\": _3, \"pisz\": _3, \"podhale\": _3, \"podlasie\": _3, \"polkowice\": _3, \"pomorskie\": _3, \"pomorze\": _3, \"prochowice\": _3, \"pruszkow\": _3, \"przeworsk\": _3, \"pulawy\": _3, \"radom\": _3, \"rawa-maz\": _3, \"rybnik\": _3, \"rzeszow\": _3, \"sanok\": _3, \"sejny\": _3, \"skoczow\": _3, \"slask\": _3, \"slupsk\": _3, \"sosnowiec\": _3, \"stalowa-wola\": _3, \"starachowice\": _3, \"stargard\": _3, \"suwalki\": _3, \"swidnica\": _3, \"swiebodzin\": _3, \"swinoujscie\": _3, \"szczecin\": _3, \"szczytno\": _3, \"tarnobrzeg\": _3, \"tgory\": _3, \"turek\": _3, \"tychy\": _3, \"ustka\": _3, \"walbrzych\": _3, \"warmia\": _3, \"warszawa\": _3, \"waw\": _3, \"wegrow\": _3, \"wielun\": _3, \"wlocl\": _3, \"wloclawek\": _3, \"wodzislaw\": _3, \"wolomin\": _3, \"wroclaw\": _3, \"zachpomor\": _3, \"zagan\": _3, \"zarow\": _3, \"zgora\": _3, \"zgorzelec\": _3, \"art\": _4, \"gliwice\": _4, \"krakow\": _4, \"poznan\": _4, \"wroc\": _4, \"zakopane\": _4, \"beep\": _4, \"ecommerce-shop\": _4, \"cfolks\": _4, \"dfirma\": _4, \"dkonto\": _4, \"you2\": _4, \"shoparena\": _4, \"homesklep\": _4, \"sdscloud\": _4, \"unicloud\": _4, \"lodz\": _4, \"pabianice\": _4, \"plock\": _4, \"sieradz\": _4, \"skierniewice\": _4, \"zgierz\": _4, \"krasnik\": _4, \"leczna\": _4, \"lubartow\": _4, \"lublin\": _4, \"poniatowa\": _4, \"swidnik\": _4, \"co\": _4, \"torun\": _4, \"simplesite\": _4, \"myspreadshop\": _4, \"gda\": _4, \"gdansk\": _4, \"gdynia\": _4, \"med\": _4, \"sopot\": _4, \"bielsko\": _4 }], \"pm\": [1, { \"own\": _4, \"name\": _4 }], \"pn\": [1, { \"co\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3 }], \"post\": _3, \"pr\": [1, { \"biz\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"isla\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"pro\": _3, \"ac\": _3, \"est\": _3, \"prof\": _3 }], \"pro\": [1, { \"aaa\": _3, \"aca\": _3, \"acct\": _3, \"avocat\": _3, \"bar\": _3, \"cpa\": _3, \"eng\": _3, \"jur\": _3, \"law\": _3, \"med\": _3, \"recht\": _3, \"12chars\": _4, \"cloudns\": _4, \"barsy\": _4, \"ngrok\": _4 }], \"ps\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"plo\": _3, \"sec\": _3 }], \"pt\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"int\": _3, \"net\": _3, \"nome\": _3, \"org\": _3, \"publ\": _3, \"123paginaweb\": _4 }], \"pw\": [1, { \"gov\": _3, \"cloudns\": _4, \"x443\": _4 }], \"py\": [1, { \"com\": _3, \"coop\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], \"qa\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"sch\": _3 }], \"re\": [1, { \"asso\": _3, \"com\": _3, \"netlib\": _4, \"can\": _4 }], \"ro\": [1, { \"arts\": _3, \"com\": _3, \"firm\": _3, \"info\": _3, \"nom\": _3, \"nt\": _3, \"org\": _3, \"rec\": _3, \"store\": _3, \"tm\": _3, \"www\": _3, \"co\": _4, \"shop\": _4, \"barsy\": _4 }], \"rs\": [1, { \"ac\": _3, \"co\": _3, \"edu\": _3, \"gov\": _3, \"in\": _3, \"org\": _3, \"brendly\": _49, \"barsy\": _4, \"ox\": _4 }], \"ru\": [1, { \"ac\": _4, \"edu\": _4, \"gov\": _4, \"int\": _4, \"mil\": _4, \"eurodir\": _4, \"adygeya\": _4, \"bashkiria\": _4, \"bir\": _4, \"cbg\": _4, \"com\": _4, \"dagestan\": _4, \"grozny\": _4, \"kalmykia\": _4, \"kustanai\": _4, \"marine\": _4, \"mordovia\": _4, \"msk\": _4, \"mytis\": _4, \"nalchik\": _4, \"nov\": _4, \"pyatigorsk\": _4, \"spb\": _4, \"vladikavkaz\": _4, \"vladimir\": _4, \"na4u\": _4, \"mircloud\": _4, \"myjino\": [2, { \"hosting\": _7, \"landing\": _7, \"spectrum\": _7, \"vps\": _7 }], \"cldmail\": [0, { \"hb\": _4 }], \"mcdir\": [2, { \"vps\": _4 }], \"mcpre\": _4, \"net\": _4, \"org\": _4, \"pp\": _4, \"lk3\": _4, \"ras\": _4 }], \"rw\": [1, { \"ac\": _3, \"co\": _3, \"coop\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], \"sa\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"med\": _3, \"net\": _3, \"org\": _3, \"pub\": _3, \"sch\": _3 }], \"sb\": _5, \"sc\": _5, \"sd\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"med\": _3, \"net\": _3, \"org\": _3, \"tv\": _3 }], \"se\": [1, { \"a\": _3, \"ac\": _3, \"b\": _3, \"bd\": _3, \"brand\": _3, \"c\": _3, \"d\": _3, \"e\": _3, \"f\": _3, \"fh\": _3, \"fhsk\": _3, \"fhv\": _3, \"g\": _3, \"h\": _3, \"i\": _3, \"k\": _3, \"komforb\": _3, \"kommunalforbund\": _3, \"komvux\": _3, \"l\": _3, \"lanbib\": _3, \"m\": _3, \"n\": _3, \"naturbruksgymn\": _3, \"o\": _3, \"org\": _3, \"p\": _3, \"parti\": _3, \"pp\": _3, \"press\": _3, \"r\": _3, \"s\": _3, \"t\": _3, \"tm\": _3, \"u\": _3, \"w\": _3, \"x\": _3, \"y\": _3, \"z\": _3, \"com\": _4, \"iopsys\": _4, \"123minsida\": _4, \"itcouldbewor\": _4, \"myspreadshop\": _4 }], \"sg\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"enscaled\": _4 }], \"sh\": [1, { \"com\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"hashbang\": _4, \"botda\": _4, \"platform\": [0, { \"ent\": _4, \"eu\": _4, \"us\": _4 }], \"now\": _4 }], \"si\": [1, { \"f5\": _4, \"gitapp\": _4, \"gitpage\": _4 }], \"sj\": _3, \"sk\": _3, \"sl\": _5, \"sm\": _3, \"sn\": [1, { \"art\": _3, \"com\": _3, \"edu\": _3, \"gouv\": _3, \"org\": _3, \"perso\": _3, \"univ\": _3 }], \"so\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"me\": _3, \"net\": _3, \"org\": _3, \"surveys\": _4 }], \"sr\": _3, \"ss\": [1, { \"biz\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"me\": _3, \"net\": _3, \"org\": _3, \"sch\": _3 }], \"st\": [1, { \"co\": _3, \"com\": _3, \"consulado\": _3, \"edu\": _3, \"embaixada\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"principe\": _3, \"saotome\": _3, \"store\": _3, \"helioho\": _4, \"kirara\": _4, \"noho\": _4 }], \"su\": [1, { \"abkhazia\": _4, \"adygeya\": _4, \"aktyubinsk\": _4, \"arkhangelsk\": _4, \"armenia\": _4, \"ashgabad\": _4, \"azerbaijan\": _4, \"balashov\": _4, \"bashkiria\": _4, \"bryansk\": _4, \"bukhara\": _4, \"chimkent\": _4, \"dagestan\": _4, \"east-kazakhstan\": _4, \"exnet\": _4, \"georgia\": _4, \"grozny\": _4, \"ivanovo\": _4, \"jambyl\": _4, \"kalmykia\": _4, \"kaluga\": _4, \"karacol\": _4, \"karaganda\": _4, \"karelia\": _4, \"khakassia\": _4, \"krasnodar\": _4, \"kurgan\": _4, \"kustanai\": _4, \"lenug\": _4, \"mangyshlak\": _4, \"mordovia\": _4, \"msk\": _4, \"murmansk\": _4, \"nalchik\": _4, \"navoi\": _4, \"north-kazakhstan\": _4, \"nov\": _4, \"obninsk\": _4, \"penza\": _4, \"pokrovsk\": _4, \"sochi\": _4, \"spb\": _4, \"tashkent\": _4, \"termez\": _4, \"togliatti\": _4, \"troitsk\": _4, \"tselinograd\": _4, \"tula\": _4, \"tuva\": _4, \"vladikavkaz\": _4, \"vladimir\": _4, \"vologda\": _4 }], \"sv\": [1, { \"com\": _3, \"edu\": _3, \"gob\": _3, \"org\": _3, \"red\": _3 }], \"sx\": _10, \"sy\": _6, \"sz\": [1, { \"ac\": _3, \"co\": _3, \"org\": _3 }], \"tc\": _3, \"td\": _3, \"tel\": _3, \"tf\": [1, { \"sch\": _4 }], \"tg\": _3, \"th\": [1, { \"ac\": _3, \"co\": _3, \"go\": _3, \"in\": _3, \"mi\": _3, \"net\": _3, \"or\": _3, \"online\": _4, \"shop\": _4 }], \"tj\": [1, { \"ac\": _3, \"biz\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"go\": _3, \"gov\": _3, \"int\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"nic\": _3, \"org\": _3, \"test\": _3, \"web\": _3 }], \"tk\": _3, \"tl\": _10, \"tm\": [1, { \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"nom\": _3, \"org\": _3 }], \"tn\": [1, { \"com\": _3, \"ens\": _3, \"fin\": _3, \"gov\": _3, \"ind\": _3, \"info\": _3, \"intl\": _3, \"mincom\": _3, \"nat\": _3, \"net\": _3, \"org\": _3, \"perso\": _3, \"tourism\": _3, \"orangecloud\": _4 }], \"to\": [1, { \"611\": _4, \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"oya\": _4, \"x0\": _4, \"quickconnect\": _24, \"vpnplus\": _4 }], \"tr\": [1, { \"av\": _3, \"bbs\": _3, \"bel\": _3, \"biz\": _3, \"com\": _3, \"dr\": _3, \"edu\": _3, \"gen\": _3, \"gov\": _3, \"info\": _3, \"k12\": _3, \"kep\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"pol\": _3, \"tel\": _3, \"tsk\": _3, \"tv\": _3, \"web\": _3, \"nc\": _10 }], \"tt\": [1, { \"biz\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"mil\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"pro\": _3 }], \"tv\": [1, { \"better-than\": _4, \"dyndns\": _4, \"on-the-web\": _4, \"worse-than\": _4, \"from\": _4, \"sakura\": _4 }], \"tw\": [1, { \"club\": _3, \"com\": [1, { \"mymailer\": _4 }], \"ebiz\": _3, \"edu\": _3, \"game\": _3, \"gov\": _3, \"idv\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"url\": _4, \"mydns\": _4 }], \"tz\": [1, { \"ac\": _3, \"co\": _3, \"go\": _3, \"hotel\": _3, \"info\": _3, \"me\": _3, \"mil\": _3, \"mobi\": _3, \"ne\": _3, \"or\": _3, \"sc\": _3, \"tv\": _3 }], \"ua\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"in\": _3, \"net\": _3, \"org\": _3, \"cherkassy\": _3, \"cherkasy\": _3, \"chernigov\": _3, \"chernihiv\": _3, \"chernivtsi\": _3, \"chernovtsy\": _3, \"ck\": _3, \"cn\": _3, \"cr\": _3, \"crimea\": _3, \"cv\": _3, \"dn\": _3, \"dnepropetrovsk\": _3, \"dnipropetrovsk\": _3, \"donetsk\": _3, \"dp\": _3, \"if\": _3, \"ivano-frankivsk\": _3, \"kh\": _3, \"kharkiv\": _3, \"kharkov\": _3, \"kherson\": _3, \"khmelnitskiy\": _3, \"khmelnytskyi\": _3, \"kiev\": _3, \"kirovograd\": _3, \"km\": _3, \"kr\": _3, \"kropyvnytskyi\": _3, \"krym\": _3, \"ks\": _3, \"kv\": _3, \"kyiv\": _3, \"lg\": _3, \"lt\": _3, \"lugansk\": _3, \"luhansk\": _3, \"lutsk\": _3, \"lv\": _3, \"lviv\": _3, \"mk\": _3, \"mykolaiv\": _3, \"nikolaev\": _3, \"od\": _3, \"odesa\": _3, \"odessa\": _3, \"pl\": _3, \"poltava\": _3, \"rivne\": _3, \"rovno\": _3, \"rv\": _3, \"sb\": _3, \"sebastopol\": _3, \"sevastopol\": _3, \"sm\": _3, \"sumy\": _3, \"te\": _3, \"ternopil\": _3, \"uz\": _3, \"uzhgorod\": _3, \"uzhhorod\": _3, \"vinnica\": _3, \"vinnytsia\": _3, \"vn\": _3, \"volyn\": _3, \"yalta\": _3, \"zakarpattia\": _3, \"zaporizhzhe\": _3, \"zaporizhzhia\": _3, \"zhitomir\": _3, \"zhytomyr\": _3, \"zp\": _3, \"zt\": _3, \"cc\": _4, \"inf\": _4, \"ltd\": _4, \"cx\": _4, \"ie\": _4, \"biz\": _4, \"co\": _4, \"pp\": _4, \"v\": _4 }], \"ug\": [1, { \"ac\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"go\": _3, \"gov\": _3, \"mil\": _3, \"ne\": _3, \"or\": _3, \"org\": _3, \"sc\": _3, \"us\": _3 }], \"uk\": [1, { \"ac\": _3, \"co\": [1, { \"bytemark\": [0, { \"dh\": _4, \"vm\": _4 }], \"layershift\": _44, \"barsy\": _4, \"barsyonline\": _4, \"retrosnub\": _51, \"nh-serv\": _4, \"no-ip\": _4, \"adimo\": _4, \"myspreadshop\": _4 }], \"gov\": [1, { \"api\": _4, \"campaign\": _4, \"service\": _4 }], \"ltd\": _3, \"me\": _3, \"net\": _3, \"nhs\": _3, \"org\": [1, { \"glug\": _4, \"lug\": _4, \"lugs\": _4, \"affinitylottery\": _4, \"raffleentry\": _4, \"weeklylottery\": _4 }], \"plc\": _3, \"police\": _3, \"sch\": _17, \"conn\": _4, \"copro\": _4, \"hosp\": _4, \"independent-commission\": _4, \"independent-inquest\": _4, \"independent-inquiry\": _4, \"independent-panel\": _4, \"independent-review\": _4, \"public-inquiry\": _4, \"royal-commission\": _4, \"pymnt\": _4, \"barsy\": _4, \"nimsite\": _4, \"oraclegovcloudapps\": _7 }], \"us\": [1, { \"dni\": _3, \"isa\": _3, \"nsn\": _3, \"ak\": _59, \"al\": _59, \"ar\": _59, \"as\": _59, \"az\": _59, \"ca\": _59, \"co\": _59, \"ct\": _59, \"dc\": _59, \"de\": [1, { \"cc\": _3, \"lib\": _4 }], \"fl\": _59, \"ga\": _59, \"gu\": _59, \"hi\": _60, \"ia\": _59, \"id\": _59, \"il\": _59, \"in\": _59, \"ks\": _59, \"ky\": _59, \"la\": _59, \"ma\": [1, { \"k12\": [1, { \"chtr\": _3, \"paroch\": _3, \"pvt\": _3 }], \"cc\": _3, \"lib\": _3 }], \"md\": _59, \"me\": _59, \"mi\": [1, { \"k12\": _3, \"cc\": _3, \"lib\": _3, \"ann-arbor\": _3, \"cog\": _3, \"dst\": _3, \"eaton\": _3, \"gen\": _3, \"mus\": _3, \"tec\": _3, \"washtenaw\": _3 }], \"mn\": _59, \"mo\": _59, \"ms\": _59, \"mt\": _59, \"nc\": _59, \"nd\": _60, \"ne\": _59, \"nh\": _59, \"nj\": _59, \"nm\": _59, \"nv\": _59, \"ny\": _59, \"oh\": _59, \"ok\": _59, \"or\": _59, \"pa\": _59, \"pr\": _59, \"ri\": _60, \"sc\": _59, \"sd\": _60, \"tn\": _59, \"tx\": _59, \"ut\": _59, \"va\": _59, \"vi\": _59, \"vt\": _59, \"wa\": _59, \"wi\": _59, \"wv\": [1, { \"cc\": _3 }], \"wy\": _59, \"cloudns\": _4, \"is-by\": _4, \"land-4-sale\": _4, \"stuff-4-sale\": _4, \"heliohost\": _4, \"enscaled\": [0, { \"phx\": _4 }], \"mircloud\": _4, \"ngo\": _4, \"golffan\": _4, \"noip\": _4, \"pointto\": _4, \"freeddns\": _4, \"srv\": [2, { \"gh\": _4, \"gl\": _4 }], \"platterp\": _4, \"servername\": _4 }], \"uy\": [1, { \"com\": _3, \"edu\": _3, \"gub\": _3, \"mil\": _3, \"net\": _3, \"org\": _3 }], \"uz\": [1, { \"co\": _3, \"com\": _3, \"net\": _3, \"org\": _3 }], \"va\": _3, \"vc\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"gv\": [2, { \"d\": _4 }], \"0e\": _7, \"mydns\": _4 }], \"ve\": [1, { \"arts\": _3, \"bib\": _3, \"co\": _3, \"com\": _3, \"e12\": _3, \"edu\": _3, \"firm\": _3, \"gob\": _3, \"gov\": _3, \"info\": _3, \"int\": _3, \"mil\": _3, \"net\": _3, \"nom\": _3, \"org\": _3, \"rar\": _3, \"rec\": _3, \"store\": _3, \"tec\": _3, \"web\": _3 }], \"vg\": [1, { \"edu\": _3 }], \"vi\": [1, { \"co\": _3, \"com\": _3, \"k12\": _3, \"net\": _3, \"org\": _3 }], \"vn\": [1, { \"ac\": _3, \"ai\": _3, \"biz\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"health\": _3, \"id\": _3, \"info\": _3, \"int\": _3, \"io\": _3, \"name\": _3, \"net\": _3, \"org\": _3, \"pro\": _3, \"angiang\": _3, \"bacgiang\": _3, \"backan\": _3, \"baclieu\": _3, \"bacninh\": _3, \"baria-vungtau\": _3, \"bentre\": _3, \"binhdinh\": _3, \"binhduong\": _3, \"binhphuoc\": _3, \"binhthuan\": _3, \"camau\": _3, \"cantho\": _3, \"caobang\": _3, \"daklak\": _3, \"daknong\": _3, \"danang\": _3, \"dienbien\": _3, \"dongnai\": _3, \"dongthap\": _3, \"gialai\": _3, \"hagiang\": _3, \"haiduong\": _3, \"haiphong\": _3, \"hanam\": _3, \"hanoi\": _3, \"hatinh\": _3, \"haugiang\": _3, \"hoabinh\": _3, \"hungyen\": _3, \"khanhhoa\": _3, \"kiengiang\": _3, \"kontum\": _3, \"laichau\": _3, \"lamdong\": _3, \"langson\": _3, \"laocai\": _3, \"longan\": _3, \"namdinh\": _3, \"nghean\": _3, \"ninhbinh\": _3, \"ninhthuan\": _3, \"phutho\": _3, \"phuyen\": _3, \"quangbinh\": _3, \"quangnam\": _3, \"quangngai\": _3, \"quangninh\": _3, \"quangtri\": _3, \"soctrang\": _3, \"sonla\": _3, \"tayninh\": _3, \"thaibinh\": _3, \"thainguyen\": _3, \"thanhhoa\": _3, \"thanhphohochiminh\": _3, \"thuathienhue\": _3, \"tiengiang\": _3, \"travinh\": _3, \"tuyenquang\": _3, \"vinhlong\": _3, \"vinhphuc\": _3, \"yenbai\": _3 }], \"vu\": _43, \"wf\": [1, { \"biz\": _4, \"sch\": _4 }], \"ws\": [1, { \"com\": _3, \"edu\": _3, \"gov\": _3, \"net\": _3, \"org\": _3, \"advisor\": _7, \"cloud66\": _4, \"dyndns\": _4, \"mypets\": _4 }], \"yt\": [1, { \"org\": _4 }], \"xn--mgbaam7a8h\": _3, \"امارات\": _3, \"xn--y9a3aq\": _3, \"հայ\": _3, \"xn--54b7fta0cc\": _3, \"বাংলা\": _3, \"xn--90ae\": _3, \"бг\": _3, \"xn--mgbcpq6gpa1a\": _3, \"البحرين\": _3, \"xn--90ais\": _3, \"бел\": _3, \"xn--fiqs8s\": _3, \"中国\": _3, \"xn--fiqz9s\": _3, \"中國\": _3, \"xn--lgbbat1ad8j\": _3, \"الجزائر\": _3, \"xn--wgbh1c\": _3, \"مصر\": _3, \"xn--e1a4c\": _3, \"ею\": _3, \"xn--qxa6a\": _3, \"ευ\": _3, \"xn--mgbah1a3hjkrd\": _3, \"موريتانيا\": _3, \"xn--node\": _3, \"გე\": _3, \"xn--qxam\": _3, \"ελ\": _3, \"xn--j6w193g\": [1, { \"xn--gmqw5a\": _3, \"xn--55qx5d\": _3, \"xn--mxtq1m\": _3, \"xn--wcvs22d\": _3, \"xn--uc0atv\": _3, \"xn--od0alg\": _3 }], \"香港\": [1, { \"個人\": _3, \"公司\": _3, \"政府\": _3, \"教育\": _3, \"組織\": _3, \"網絡\": _3 }], \"xn--2scrj9c\": _3, \"ಭಾರತ\": _3, \"xn--3hcrj9c\": _3, \"ଭାରତ\": _3, \"xn--45br5cyl\": _3, \"ভাৰত\": _3, \"xn--h2breg3eve\": _3, \"भारतम्\": _3, \"xn--h2brj9c8c\": _3, \"भारोत\": _3, \"xn--mgbgu82a\": _3, \"ڀارت\": _3, \"xn--rvc1e0am3e\": _3, \"ഭാരതം\": _3, \"xn--h2brj9c\": _3, \"भारत\": _3, \"xn--mgbbh1a\": _3, \"بارت\": _3, \"xn--mgbbh1a71e\": _3, \"بھارت\": _3, \"xn--fpcrj9c3d\": _3, \"భారత్\": _3, \"xn--gecrj9c\": _3, \"ભારત\": _3, \"xn--s9brj9c\": _3, \"ਭਾਰਤ\": _3, \"xn--45brj9c\": _3, \"ভারত\": _3, \"xn--xkc2dl3a5ee0h\": _3, \"இந்தியா\": _3, \"xn--mgba3a4f16a\": _3, \"ایران\": _3, \"xn--mgba3a4fra\": _3, \"ايران\": _3, \"xn--mgbtx2b\": _3, \"عراق\": _3, \"xn--mgbayh7gpa\": _3, \"الاردن\": _3, \"xn--3e0b707e\": _3, \"한국\": _3, \"xn--80ao21a\": _3, \"қаз\": _3, \"xn--q7ce6a\": _3, \"ລາວ\": _3, \"xn--fzc2c9e2c\": _3, \"ලංකා\": _3, \"xn--xkc2al3hye2a\": _3, \"இலங்கை\": _3, \"xn--mgbc0a9azcg\": _3, \"المغرب\": _3, \"xn--d1alf\": _3, \"мкд\": _3, \"xn--l1acc\": _3, \"мон\": _3, \"xn--mix891f\": _3, \"澳門\": _3, \"xn--mix082f\": _3, \"澳门\": _3, \"xn--mgbx4cd0ab\": _3, \"مليسيا\": _3, \"xn--mgb9awbf\": _3, \"عمان\": _3, \"xn--mgbai9azgqp6j\": _3, \"پاکستان\": _3, \"xn--mgbai9a5eva00b\": _3, \"پاكستان\": _3, \"xn--ygbi2ammx\": _3, \"فلسطين\": _3, \"xn--90a3ac\": [1, { \"xn--80au\": _3, \"xn--90azh\": _3, \"xn--d1at\": _3, \"xn--c1avg\": _3, \"xn--o1ac\": _3, \"xn--o1ach\": _3 }], \"срб\": [1, { \"ак\": _3, \"обр\": _3, \"од\": _3, \"орг\": _3, \"пр\": _3, \"упр\": _3 }], \"xn--p1ai\": _3, \"рф\": _3, \"xn--wgbl6a\": _3, \"قطر\": _3, \"xn--mgberp4a5d4ar\": _3, \"السعودية\": _3, \"xn--mgberp4a5d4a87g\": _3, \"السعودیة\": _3, \"xn--mgbqly7c0a67fbc\": _3, \"السعودیۃ\": _3, \"xn--mgbqly7cvafr\": _3, \"السعوديه\": _3, \"xn--mgbpl2fh\": _3, \"سودان\": _3, \"xn--yfro4i67o\": _3, \"新加坡\": _3, \"xn--clchc0ea0b2g2a9gcd\": _3, \"சிங்கப்பூர்\": _3, \"xn--ogbpf8fl\": _3, \"سورية\": _3, \"xn--mgbtf8fl\": _3, \"سوريا\": _3, \"xn--o3cw4h\": [1, { \"xn--o3cyx2a\": _3, \"xn--12co0c3b4eva\": _3, \"xn--m3ch0j3a\": _3, \"xn--h3cuzk1di\": _3, \"xn--12c1fe0br\": _3, \"xn--12cfi8ixb8l\": _3 }], \"ไทย\": [1, { \"ทหาร\": _3, \"ธุรกิจ\": _3, \"เน็ต\": _3, \"รัฐบาล\": _3, \"ศึกษา\": _3, \"องค์กร\": _3 }], \"xn--pgbs0dh\": _3, \"تونس\": _3, \"xn--kpry57d\": _3, \"台灣\": _3, \"xn--kprw13d\": _3, \"台湾\": _3, \"xn--nnx388a\": _3, \"臺灣\": _3, \"xn--j1amh\": _3, \"укр\": _3, \"xn--mgb2ddes\": _3, \"اليمن\": _3, \"xxx\": _3, \"ye\": _6, \"za\": [0, { \"ac\": _3, \"agric\": _3, \"alt\": _3, \"co\": _3, \"edu\": _3, \"gov\": _3, \"grondar\": _3, \"law\": _3, \"mil\": _3, \"net\": _3, \"ngo\": _3, \"nic\": _3, \"nis\": _3, \"nom\": _3, \"org\": _3, \"school\": _3, \"tm\": _3, \"web\": _3 }], \"zm\": [1, { \"ac\": _3, \"biz\": _3, \"co\": _3, \"com\": _3, \"edu\": _3, \"gov\": _3, \"info\": _3, \"mil\": _3, \"net\": _3, \"org\": _3, \"sch\": _3 }], \"zw\": [1, { \"ac\": _3, \"co\": _3, \"gov\": _3, \"mil\": _3, \"org\": _3 }], \"aaa\": _3, \"aarp\": _3, \"abb\": _3, \"abbott\": _3, \"abbvie\": _3, \"abc\": _3, \"able\": _3, \"abogado\": _3, \"abudhabi\": _3, \"academy\": [1, { \"official\": _4 }], \"accenture\": _3, \"accountant\": _3, \"accountants\": _3, \"aco\": _3, \"actor\": _3, \"ads\": _3, \"adult\": _3, \"aeg\": _3, \"aetna\": _3, \"afl\": _3, \"africa\": _3, \"agakhan\": _3, \"agency\": _3, \"aig\": _3, \"airbus\": _3, \"airforce\": _3, \"airtel\": _3, \"akdn\": _3, \"alibaba\": _3, \"alipay\": _3, \"allfinanz\": _3, \"allstate\": _3, \"ally\": _3, \"alsace\": _3, \"alstom\": _3, \"amazon\": _3, \"americanexpress\": _3, \"americanfamily\": _3, \"amex\": _3, \"amfam\": _3, \"amica\": _3, \"amsterdam\": _3, \"analytics\": _3, \"android\": _3, \"anquan\": _3, \"anz\": _3, \"aol\": _3, \"apartments\": _3, \"app\": [1, { \"adaptable\": _4, \"aiven\": _4, \"beget\": _7, \"clerk\": _4, \"clerkstage\": _4, \"wnext\": _4, \"csb\": [2, { \"preview\": _4 }], \"deta\": _4, \"ondigitalocean\": _4, \"easypanel\": _4, \"encr\": _4, \"evervault\": _8, \"expo\": [2, { \"staging\": _4 }], \"edgecompute\": _4, \"on-fleek\": _4, \"flutterflow\": _4, \"framer\": _4, \"hosted\": _7, \"run\": _7, \"web\": _4, \"hasura\": _4, \"botdash\": _4, \"loginline\": _4, \"medusajs\": _4, \"messerli\": _4, \"netfy\": _4, \"netlify\": _4, \"ngrok\": _4, \"ngrok-free\": _4, \"developer\": _7, \"noop\": _4, \"northflank\": _7, \"upsun\": _7, \"replit\": _9, \"nyat\": _4, \"snowflake\": [0, { \"*\": _4, \"privatelink\": _7 }], \"streamlit\": _4, \"storipress\": _4, \"telebit\": _4, \"typedream\": _4, \"vercel\": _4, \"bookonline\": _4, \"wdh\": _4, \"zeabur\": _4 }], \"apple\": _3, \"aquarelle\": _3, \"arab\": _3, \"aramco\": _3, \"archi\": _3, \"army\": _3, \"art\": _3, \"arte\": _3, \"asda\": _3, \"associates\": _3, \"athleta\": _3, \"attorney\": _3, \"auction\": _3, \"audi\": _3, \"audible\": _3, \"audio\": _3, \"auspost\": _3, \"author\": _3, \"auto\": _3, \"autos\": _3, \"aws\": [1, { \"sagemaker\": [0, { \"ap-northeast-1\": _13, \"ap-northeast-2\": _13, \"ap-south-1\": _13, \"ap-southeast-1\": _13, \"ap-southeast-2\": _13, \"ca-central-1\": _15, \"eu-central-1\": _13, \"eu-west-1\": _13, \"eu-west-2\": _13, \"us-east-1\": _15, \"us-east-2\": _15, \"us-west-2\": _15, \"af-south-1\": _12, \"ap-east-1\": _12, \"ap-northeast-3\": _12, \"ap-south-2\": _14, \"ap-southeast-3\": _12, \"ap-southeast-4\": _14, \"ca-west-1\": [0, { \"notebook\": _4, \"notebook-fips\": _4 }], \"eu-central-2\": _12, \"eu-north-1\": _12, \"eu-south-1\": _12, \"eu-south-2\": _12, \"eu-west-3\": _12, \"il-central-1\": _12, \"me-central-1\": _12, \"me-south-1\": _12, \"sa-east-1\": _12, \"us-gov-east-1\": _16, \"us-gov-west-1\": _16, \"us-west-1\": [0, { \"notebook\": _4, \"notebook-fips\": _4, \"studio\": _4 }], \"experiments\": _7 }], \"repost\": [0, { \"private\": _7 }], \"on\": [0, { \"ap-northeast-1\": _11, \"ap-southeast-1\": _11, \"ap-southeast-2\": _11, \"eu-central-1\": _11, \"eu-north-1\": _11, \"eu-west-1\": _11, \"us-east-1\": _11, \"us-east-2\": _11, \"us-west-2\": _11 }] }], \"axa\": _3, \"azure\": _3, \"baby\": _3, \"baidu\": _3, \"banamex\": _3, \"band\": _3, \"bank\": _3, \"bar\": _3, \"barcelona\": _3, \"barclaycard\": _3, \"barclays\": _3, \"barefoot\": _3, \"bargains\": _3, \"baseball\": _3, \"basketball\": [1, { \"aus\": _4, \"nz\": _4 }], \"bauhaus\": _3, \"bayern\": _3, \"bbc\": _3, \"bbt\": _3, \"bbva\": _3, \"bcg\": _3, \"bcn\": _3, \"beats\": _3, \"beauty\": _3, \"beer\": _3, \"bentley\": _3, \"berlin\": _3, \"best\": _3, \"bestbuy\": _3, \"bet\": _3, \"bharti\": _3, \"bible\": _3, \"bid\": _3, \"bike\": _3, \"bing\": _3, \"bingo\": _3, \"bio\": _3, \"black\": _3, \"blackfriday\": _3, \"blockbuster\": _3, \"blog\": _3, \"bloomberg\": _3, \"blue\": _3, \"bms\": _3, \"bmw\": _3, \"bnpparibas\": _3, \"boats\": _3, \"boehringer\": _3, \"bofa\": _3, \"bom\": _3, \"bond\": _3, \"boo\": _3, \"book\": _3, \"booking\": _3, \"bosch\": _3, \"bostik\": _3, \"boston\": _3, \"bot\": _3, \"boutique\": _3, \"box\": _3, \"bradesco\": _3, \"bridgestone\": _3, \"broadway\": _3, \"broker\": _3, \"brother\": _3, \"brussels\": _3, \"build\": [1, { \"v0\": _4 }], \"builders\": [1, { \"cloudsite\": _4 }], \"business\": _18, \"buy\": _3, \"buzz\": _3, \"bzh\": _3, \"cab\": _3, \"cafe\": _3, \"cal\": _3, \"call\": _3, \"calvinklein\": _3, \"cam\": _3, \"camera\": _3, \"camp\": [1, { \"emf\": [0, { \"at\": _4 }] }], \"canon\": _3, \"capetown\": _3, \"capital\": _3, \"capitalone\": _3, \"car\": _3, \"caravan\": _3, \"cards\": _3, \"care\": _3, \"career\": _3, \"careers\": _3, \"cars\": _3, \"casa\": [1, { \"nabu\": [0, { \"ui\": _4 }] }], \"case\": _3, \"cash\": _3, \"casino\": _3, \"catering\": _3, \"catholic\": _3, \"cba\": _3, \"cbn\": _3, \"cbre\": _3, \"center\": _3, \"ceo\": _3, \"cern\": _3, \"cfa\": _3, \"cfd\": _3, \"chanel\": _3, \"channel\": _3, \"charity\": _3, \"chase\": _3, \"chat\": _3, \"cheap\": _3, \"chintai\": _3, \"christmas\": _3, \"chrome\": _3, \"church\": _3, \"cipriani\": _3, \"circle\": _3, \"cisco\": _3, \"citadel\": _3, \"citi\": _3, \"citic\": _3, \"city\": _3, \"claims\": _3, \"cleaning\": _3, \"click\": _3, \"clinic\": _3, \"clinique\": _3, \"clothing\": _3, \"cloud\": [1, { \"elementor\": _4, \"encoway\": [0, { \"eu\": _4 }], \"statics\": _7, \"ravendb\": _4, \"axarnet\": [0, { \"es-1\": _4 }], \"diadem\": _4, \"jelastic\": [0, { \"vip\": _4 }], \"jele\": _4, \"jenv-aruba\": [0, { \"aruba\": [0, { \"eur\": [0, { \"it1\": _4 }] }], \"it1\": _4 }], \"keliweb\": [2, { \"cs\": _4 }], \"oxa\": [2, { \"tn\": _4, \"uk\": _4 }], \"primetel\": [2, { \"uk\": _4 }], \"reclaim\": [0, { \"ca\": _4, \"uk\": _4, \"us\": _4 }], \"trendhosting\": [0, { \"ch\": _4, \"de\": _4 }], \"jotelulu\": _4, \"kuleuven\": _4, \"linkyard\": _4, \"magentosite\": _7, \"matlab\": _4, \"observablehq\": _4, \"perspecta\": _4, \"vapor\": _4, \"on-rancher\": _7, \"scw\": [0, { \"baremetal\": [0, { \"fr-par-1\": _4, \"fr-par-2\": _4, \"nl-ams-1\": _4 }], \"fr-par\": [0, { \"cockpit\": _4, \"fnc\": [2, { \"functions\": _4 }], \"k8s\": _20, \"s3\": _4, \"s3-website\": _4, \"whm\": _4 }], \"instances\": [0, { \"priv\": _4, \"pub\": _4 }], \"k8s\": _4, \"nl-ams\": [0, { \"cockpit\": _4, \"k8s\": _20, \"s3\": _4, \"s3-website\": _4, \"whm\": _4 }], \"pl-waw\": [0, { \"cockpit\": _4, \"k8s\": _20, \"s3\": _4, \"s3-website\": _4 }], \"scalebook\": _4, \"smartlabeling\": _4 }], \"servebolt\": _4, \"onstackit\": [0, { \"runs\": _4 }], \"trafficplex\": _4, \"unison-services\": _4, \"urown\": _4, \"voorloper\": _4, \"zap\": _4 }], \"club\": [1, { \"cloudns\": _4, \"jele\": _4, \"barsy\": _4 }], \"clubmed\": _3, \"coach\": _3, \"codes\": [1, { \"owo\": _7 }], \"coffee\": _3, \"college\": _3, \"cologne\": _3, \"commbank\": _3, \"community\": [1, { \"nog\": _4, \"ravendb\": _4, \"myforum\": _4 }], \"company\": _3, \"compare\": _3, \"computer\": _3, \"comsec\": _3, \"condos\": _3, \"construction\": _3, \"consulting\": _3, \"contact\": _3, \"contractors\": _3, \"cooking\": _3, \"cool\": [1, { \"elementor\": _4, \"de\": _4 }], \"corsica\": _3, \"country\": _3, \"coupon\": _3, \"coupons\": _3, \"courses\": _3, \"cpa\": _3, \"credit\": _3, \"creditcard\": _3, \"creditunion\": _3, \"cricket\": _3, \"crown\": _3, \"crs\": _3, \"cruise\": _3, \"cruises\": _3, \"cuisinella\": _3, \"cymru\": _3, \"cyou\": _3, \"dad\": _3, \"dance\": _3, \"data\": _3, \"date\": _3, \"dating\": _3, \"datsun\": _3, \"day\": _3, \"dclk\": _3, \"dds\": _3, \"deal\": _3, \"dealer\": _3, \"deals\": _3, \"degree\": _3, \"delivery\": _3, \"dell\": _3, \"deloitte\": _3, \"delta\": _3, \"democrat\": _3, \"dental\": _3, \"dentist\": _3, \"desi\": _3, \"design\": [1, { \"graphic\": _4, \"bss\": _4 }], \"dev\": [1, { \"12chars\": _4, \"myaddr\": _4, \"panel\": _4, \"lcl\": _7, \"lclstage\": _7, \"stg\": _7, \"stgstage\": _7, \"pages\": _4, \"r2\": _4, \"workers\": _4, \"deno\": _4, \"deno-staging\": _4, \"deta\": _4, \"evervault\": _8, \"fly\": _4, \"githubpreview\": _4, \"gateway\": _7, \"hrsn\": [2, { \"psl\": [0, { \"sub\": _4, \"wc\": [0, { \"*\": _4, \"sub\": _7 }] }] }], \"botdash\": _4, \"is-a-good\": _4, \"is-a\": _4, \"iserv\": _4, \"runcontainers\": _4, \"localcert\": [0, { \"user\": _7 }], \"loginline\": _4, \"barsy\": _4, \"mediatech\": _4, \"modx\": _4, \"ngrok\": _4, \"ngrok-free\": _4, \"is-a-fullstack\": _4, \"is-cool\": _4, \"is-not-a\": _4, \"localplayer\": _4, \"xmit\": _4, \"platter-app\": _4, \"replit\": [2, { \"archer\": _4, \"bones\": _4, \"canary\": _4, \"global\": _4, \"hacker\": _4, \"id\": _4, \"janeway\": _4, \"kim\": _4, \"kira\": _4, \"kirk\": _4, \"odo\": _4, \"paris\": _4, \"picard\": _4, \"pike\": _4, \"prerelease\": _4, \"reed\": _4, \"riker\": _4, \"sisko\": _4, \"spock\": _4, \"staging\": _4, \"sulu\": _4, \"tarpit\": _4, \"teams\": _4, \"tucker\": _4, \"wesley\": _4, \"worf\": _4 }], \"crm\": [0, { \"d\": _7, \"w\": _7, \"wa\": _7, \"wb\": _7, \"wc\": _7, \"wd\": _7, \"we\": _7, \"wf\": _7 }], \"vercel\": _4, \"webhare\": _7 }], \"dhl\": _3, \"diamonds\": _3, \"diet\": _3, \"digital\": [1, { \"cloudapps\": [2, { \"london\": _4 }] }], \"direct\": [1, { \"libp2p\": _4 }], \"directory\": _3, \"discount\": _3, \"discover\": _3, \"dish\": _3, \"diy\": _3, \"dnp\": _3, \"docs\": _3, \"doctor\": _3, \"dog\": _3, \"domains\": _3, \"dot\": _3, \"download\": _3, \"drive\": _3, \"dtv\": _3, \"dubai\": _3, \"dunlop\": _3, \"dupont\": _3, \"durban\": _3, \"dvag\": _3, \"dvr\": _3, \"earth\": _3, \"eat\": _3, \"eco\": _3, \"edeka\": _3, \"education\": _18, \"email\": [1, { \"crisp\": [0, { \"on\": _4 }], \"tawk\": _47, \"tawkto\": _47 }], \"emerck\": _3, \"energy\": _3, \"engineer\": _3, \"engineering\": _3, \"enterprises\": _3, \"epson\": _3, \"equipment\": _3, \"ericsson\": _3, \"erni\": _3, \"esq\": _3, \"estate\": [1, { \"compute\": _7 }], \"eurovision\": _3, \"eus\": [1, { \"party\": _48 }], \"events\": [1, { \"koobin\": _4, \"co\": _4 }], \"exchange\": _3, \"expert\": _3, \"exposed\": _3, \"express\": _3, \"extraspace\": _3, \"fage\": _3, \"fail\": _3, \"fairwinds\": _3, \"faith\": _3, \"family\": _3, \"fan\": _3, \"fans\": _3, \"farm\": [1, { \"storj\": _4 }], \"farmers\": _3, \"fashion\": _3, \"fast\": _3, \"fedex\": _3, \"feedback\": _3, \"ferrari\": _3, \"ferrero\": _3, \"fidelity\": _3, \"fido\": _3, \"film\": _3, \"final\": _3, \"finance\": _3, \"financial\": _18, \"fire\": _3, \"firestone\": _3, \"firmdale\": _3, \"fish\": _3, \"fishing\": _3, \"fit\": _3, \"fitness\": _3, \"flickr\": _3, \"flights\": _3, \"flir\": _3, \"florist\": _3, \"flowers\": _3, \"fly\": _3, \"foo\": _3, \"food\": _3, \"football\": _3, \"ford\": _3, \"forex\": _3, \"forsale\": _3, \"forum\": _3, \"foundation\": _3, \"fox\": _3, \"free\": _3, \"fresenius\": _3, \"frl\": _3, \"frogans\": _3, \"frontier\": _3, \"ftr\": _3, \"fujitsu\": _3, \"fun\": _3, \"fund\": _3, \"furniture\": _3, \"futbol\": _3, \"fyi\": _3, \"gal\": _3, \"gallery\": _3, \"gallo\": _3, \"gallup\": _3, \"game\": _3, \"games\": [1, { \"pley\": _4, \"sheezy\": _4 }], \"gap\": _3, \"garden\": _3, \"gay\": [1, { \"pages\": _4 }], \"gbiz\": _3, \"gdn\": [1, { \"cnpy\": _4 }], \"gea\": _3, \"gent\": _3, \"genting\": _3, \"george\": _3, \"ggee\": _3, \"gift\": _3, \"gifts\": _3, \"gives\": _3, \"giving\": _3, \"glass\": _3, \"gle\": _3, \"global\": _3, \"globo\": _3, \"gmail\": _3, \"gmbh\": _3, \"gmo\": _3, \"gmx\": _3, \"godaddy\": _3, \"gold\": _3, \"goldpoint\": _3, \"golf\": _3, \"goo\": _3, \"goodyear\": _3, \"goog\": [1, { \"cloud\": _4, \"translate\": _4, \"usercontent\": _7 }], \"google\": _3, \"gop\": _3, \"got\": _3, \"grainger\": _3, \"graphics\": _3, \"gratis\": _3, \"green\": _3, \"gripe\": _3, \"grocery\": _3, \"group\": [1, { \"discourse\": _4 }], \"gucci\": _3, \"guge\": _3, \"guide\": _3, \"guitars\": _3, \"guru\": _3, \"hair\": _3, \"hamburg\": _3, \"hangout\": _3, \"haus\": _3, \"hbo\": _3, \"hdfc\": _3, \"hdfcbank\": _3, \"health\": [1, { \"hra\": _4 }], \"healthcare\": _3, \"help\": _3, \"helsinki\": _3, \"here\": _3, \"hermes\": _3, \"hiphop\": _3, \"hisamitsu\": _3, \"hitachi\": _3, \"hiv\": _3, \"hkt\": _3, \"hockey\": _3, \"holdings\": _3, \"holiday\": _3, \"homedepot\": _3, \"homegoods\": _3, \"homes\": _3, \"homesense\": _3, \"honda\": _3, \"horse\": _3, \"hospital\": _3, \"host\": [1, { \"cloudaccess\": _4, \"freesite\": _4, \"easypanel\": _4, \"fastvps\": _4, \"myfast\": _4, \"tempurl\": _4, \"wpmudev\": _4, \"jele\": _4, \"mircloud\": _4, \"wp2\": _4, \"half\": _4 }], \"hosting\": [1, { \"opencraft\": _4 }], \"hot\": _3, \"hotels\": _3, \"hotmail\": _3, \"house\": _3, \"how\": _3, \"hsbc\": _3, \"hughes\": _3, \"hyatt\": _3, \"hyundai\": _3, \"ibm\": _3, \"icbc\": _3, \"ice\": _3, \"icu\": _3, \"ieee\": _3, \"ifm\": _3, \"ikano\": _3, \"imamat\": _3, \"imdb\": _3, \"immo\": _3, \"immobilien\": _3, \"inc\": _3, \"industries\": _3, \"infiniti\": _3, \"ing\": _3, \"ink\": _3, \"institute\": _3, \"insurance\": _3, \"insure\": _3, \"international\": _3, \"intuit\": _3, \"investments\": _3, \"ipiranga\": _3, \"irish\": _3, \"ismaili\": _3, \"ist\": _3, \"istanbul\": _3, \"itau\": _3, \"itv\": _3, \"jaguar\": _3, \"java\": _3, \"jcb\": _3, \"jeep\": _3, \"jetzt\": _3, \"jewelry\": _3, \"jio\": _3, \"jll\": _3, \"jmp\": _3, \"jnj\": _3, \"joburg\": _3, \"jot\": _3, \"joy\": _3, \"jpmorgan\": _3, \"jprs\": _3, \"juegos\": _3, \"juniper\": _3, \"kaufen\": _3, \"kddi\": _3, \"kerryhotels\": _3, \"kerrylogistics\": _3, \"kerryproperties\": _3, \"kfh\": _3, \"kia\": _3, \"kids\": _3, \"kim\": _3, \"kindle\": _3, \"kitchen\": _3, \"kiwi\": _3, \"koeln\": _3, \"komatsu\": _3, \"kosher\": _3, \"kpmg\": _3, \"kpn\": _3, \"krd\": [1, { \"co\": _4, \"edu\": _4 }], \"kred\": _3, \"kuokgroup\": _3, \"kyoto\": _3, \"lacaixa\": _3, \"lamborghini\": _3, \"lamer\": _3, \"lancaster\": _3, \"land\": _3, \"landrover\": _3, \"lanxess\": _3, \"lasalle\": _3, \"lat\": _3, \"latino\": _3, \"latrobe\": _3, \"law\": _3, \"lawyer\": _3, \"lds\": _3, \"lease\": _3, \"leclerc\": _3, \"lefrak\": _3, \"legal\": _3, \"lego\": _3, \"lexus\": _3, \"lgbt\": _3, \"lidl\": _3, \"life\": _3, \"lifeinsurance\": _3, \"lifestyle\": _3, \"lighting\": _3, \"like\": _3, \"lilly\": _3, \"limited\": _3, \"limo\": _3, \"lincoln\": _3, \"link\": [1, { \"myfritz\": _4, \"cyon\": _4, \"dweb\": _7, \"nftstorage\": [0, { \"ipfs\": _4 }], \"mypep\": _4 }], \"lipsy\": _3, \"live\": [1, { \"aem\": _4, \"hlx\": _4, \"ewp\": _7 }], \"living\": _3, \"llc\": _3, \"llp\": _3, \"loan\": _3, \"loans\": _3, \"locker\": _3, \"locus\": _3, \"lol\": [1, { \"omg\": _4 }], \"london\": _3, \"lotte\": _3, \"lotto\": _3, \"love\": _3, \"lpl\": _3, \"lplfinancial\": _3, \"ltd\": _3, \"ltda\": _3, \"lundbeck\": _3, \"luxe\": _3, \"luxury\": _3, \"madrid\": _3, \"maif\": _3, \"maison\": _3, \"makeup\": _3, \"man\": _3, \"management\": [1, { \"router\": _4 }], \"mango\": _3, \"map\": _3, \"market\": _3, \"marketing\": _3, \"markets\": _3, \"marriott\": _3, \"marshalls\": _3, \"mattel\": _3, \"mba\": _3, \"mckinsey\": _3, \"med\": _3, \"media\": _54, \"meet\": _3, \"melbourne\": _3, \"meme\": _3, \"memorial\": _3, \"men\": _3, \"menu\": [1, { \"barsy\": _4, \"barsyonline\": _4 }], \"merck\": _3, \"merckmsd\": _3, \"miami\": _3, \"microsoft\": _3, \"mini\": _3, \"mint\": _3, \"mit\": _3, \"mitsubishi\": _3, \"mlb\": _3, \"mls\": _3, \"mma\": _3, \"mobile\": _3, \"moda\": _3, \"moe\": _3, \"moi\": _3, \"mom\": [1, { \"ind\": _4 }], \"monash\": _3, \"money\": _3, \"monster\": _3, \"mormon\": _3, \"mortgage\": _3, \"moscow\": _3, \"moto\": _3, \"motorcycles\": _3, \"mov\": _3, \"movie\": _3, \"msd\": _3, \"mtn\": _3, \"mtr\": _3, \"music\": _3, \"nab\": _3, \"nagoya\": _3, \"navy\": _3, \"nba\": _3, \"nec\": _3, \"netbank\": _3, \"netflix\": _3, \"network\": [1, { \"alces\": _7, \"co\": _4, \"arvo\": _4, \"azimuth\": _4, \"tlon\": _4 }], \"neustar\": _3, \"new\": _3, \"news\": [1, { \"noticeable\": _4 }], \"next\": _3, \"nextdirect\": _3, \"nexus\": _3, \"nfl\": _3, \"ngo\": _3, \"nhk\": _3, \"nico\": _3, \"nike\": _3, \"nikon\": _3, \"ninja\": _3, \"nissan\": _3, \"nissay\": _3, \"nokia\": _3, \"norton\": _3, \"now\": _3, \"nowruz\": _3, \"nowtv\": _3, \"nra\": _3, \"nrw\": _3, \"ntt\": _3, \"nyc\": _3, \"obi\": _3, \"observer\": _3, \"office\": _3, \"okinawa\": _3, \"olayan\": _3, \"olayangroup\": _3, \"ollo\": _3, \"omega\": _3, \"one\": [1, { \"kin\": _7, \"service\": _4 }], \"ong\": [1, { \"obl\": _4 }], \"onl\": _3, \"online\": [1, { \"eero\": _4, \"eero-stage\": _4, \"websitebuilder\": _4, \"barsy\": _4 }], \"ooo\": _3, \"open\": _3, \"oracle\": _3, \"orange\": [1, { \"tech\": _4 }], \"organic\": _3, \"origins\": _3, \"osaka\": _3, \"otsuka\": _3, \"ott\": _3, \"ovh\": [1, { \"nerdpol\": _4 }], \"page\": [1, { \"aem\": _4, \"hlx\": _4, \"hlx3\": _4, \"translated\": _4, \"codeberg\": _4, \"heyflow\": _4, \"prvcy\": _4, \"rocky\": _4, \"pdns\": _4, \"plesk\": _4 }], \"panasonic\": _3, \"paris\": _3, \"pars\": _3, \"partners\": _3, \"parts\": _3, \"party\": _3, \"pay\": _3, \"pccw\": _3, \"pet\": _3, \"pfizer\": _3, \"pharmacy\": _3, \"phd\": _3, \"philips\": _3, \"phone\": _3, \"photo\": _3, \"photography\": _3, \"photos\": _54, \"physio\": _3, \"pics\": _3, \"pictet\": _3, \"pictures\": [1, { \"1337\": _4 }], \"pid\": _3, \"pin\": _3, \"ping\": _3, \"pink\": _3, \"pioneer\": _3, \"pizza\": [1, { \"ngrok\": _4 }], \"place\": _18, \"play\": _3, \"playstation\": _3, \"plumbing\": _3, \"plus\": _3, \"pnc\": _3, \"pohl\": _3, \"poker\": _3, \"politie\": _3, \"porn\": _3, \"pramerica\": _3, \"praxi\": _3, \"press\": _3, \"prime\": _3, \"prod\": _3, \"productions\": _3, \"prof\": _3, \"progressive\": _3, \"promo\": _3, \"properties\": _3, \"property\": _3, \"protection\": _3, \"pru\": _3, \"prudential\": _3, \"pub\": [1, { \"id\": _7, \"kin\": _7, \"barsy\": _4 }], \"pwc\": _3, \"qpon\": _3, \"quebec\": _3, \"quest\": _3, \"racing\": _3, \"radio\": _3, \"read\": _3, \"realestate\": _3, \"realtor\": _3, \"realty\": _3, \"recipes\": _3, \"red\": _3, \"redstone\": _3, \"redumbrella\": _3, \"rehab\": _3, \"reise\": _3, \"reisen\": _3, \"reit\": _3, \"reliance\": _3, \"ren\": _3, \"rent\": _3, \"rentals\": _3, \"repair\": _3, \"report\": _3, \"republican\": _3, \"rest\": _3, \"restaurant\": _3, \"review\": _3, \"reviews\": _3, \"rexroth\": _3, \"rich\": _3, \"richardli\": _3, \"ricoh\": _3, \"ril\": _3, \"rio\": _3, \"rip\": [1, { \"clan\": _4 }], \"rocks\": [1, { \"myddns\": _4, \"stackit\": _4, \"lima-city\": _4, \"webspace\": _4 }], \"rodeo\": _3, \"rogers\": _3, \"room\": _3, \"rsvp\": _3, \"rugby\": _3, \"ruhr\": _3, \"run\": [1, { \"development\": _4, \"ravendb\": _4, \"liara\": [2, { \"iran\": _4 }], \"servers\": _4, \"build\": _7, \"code\": _7, \"database\": _7, \"migration\": _7, \"onporter\": _4, \"repl\": _4, \"stackit\": _4, \"val\": [0, { \"express\": _4, \"web\": _4 }], \"wix\": _4 }], \"rwe\": _3, \"ryukyu\": _3, \"saarland\": _3, \"safe\": _3, \"safety\": _3, \"sakura\": _3, \"sale\": _3, \"salon\": _3, \"samsclub\": _3, \"samsung\": _3, \"sandvik\": _3, \"sandvikcoromant\": _3, \"sanofi\": _3, \"sap\": _3, \"sarl\": _3, \"sas\": _3, \"save\": _3, \"saxo\": _3, \"sbi\": _3, \"sbs\": _3, \"scb\": _3, \"schaeffler\": _3, \"schmidt\": _3, \"scholarships\": _3, \"school\": _3, \"schule\": _3, \"schwarz\": _3, \"science\": _3, \"scot\": [1, { \"gov\": [2, { \"service\": _4 }] }], \"search\": _3, \"seat\": _3, \"secure\": _3, \"security\": _3, \"seek\": _3, \"select\": _3, \"sener\": _3, \"services\": [1, { \"loginline\": _4 }], \"seven\": _3, \"sew\": _3, \"sex\": _3, \"sexy\": _3, \"sfr\": _3, \"shangrila\": _3, \"sharp\": _3, \"shell\": _3, \"shia\": _3, \"shiksha\": _3, \"shoes\": _3, \"shop\": [1, { \"base\": _4, \"hoplix\": _4, \"barsy\": _4, \"barsyonline\": _4, \"shopware\": _4 }], \"shopping\": _3, \"shouji\": _3, \"show\": _3, \"silk\": _3, \"sina\": _3, \"singles\": _3, \"site\": [1, { \"canva\": _21, \"cloudera\": _7, \"convex\": _4, \"cyon\": _4, \"fastvps\": _4, \"heyflow\": _4, \"jele\": _4, \"jouwweb\": _4, \"loginline\": _4, \"barsy\": _4, \"notion\": _4, \"omniwe\": _4, \"opensocial\": _4, \"madethis\": _4, \"platformsh\": _7, \"tst\": _7, \"byen\": _4, \"srht\": _4, \"novecore\": _4, \"wpsquared\": _4 }], \"ski\": _3, \"skin\": _3, \"sky\": _3, \"skype\": _3, \"sling\": _3, \"smart\": _3, \"smile\": _3, \"sncf\": _3, \"soccer\": _3, \"social\": _3, \"softbank\": _3, \"software\": _3, \"sohu\": _3, \"solar\": _3, \"solutions\": _3, \"song\": _3, \"sony\": _3, \"soy\": _3, \"spa\": _3, \"space\": [1, { \"myfast\": _4, \"heiyu\": _4, \"hf\": [2, { \"static\": _4 }], \"app-ionos\": _4, \"project\": _4, \"uber\": _4, \"xs4all\": _4 }], \"sport\": _3, \"spot\": _3, \"srl\": _3, \"stada\": _3, \"staples\": _3, \"star\": _3, \"statebank\": _3, \"statefarm\": _3, \"stc\": _3, \"stcgroup\": _3, \"stockholm\": _3, \"storage\": _3, \"store\": [1, { \"barsy\": _4, \"sellfy\": _4, \"shopware\": _4, \"storebase\": _4 }], \"stream\": _3, \"studio\": _3, \"study\": _3, \"style\": _3, \"sucks\": _3, \"supplies\": _3, \"supply\": _3, \"support\": [1, { \"barsy\": _4 }], \"surf\": _3, \"surgery\": _3, \"suzuki\": _3, \"swatch\": _3, \"swiss\": _3, \"sydney\": _3, \"systems\": [1, { \"knightpoint\": _4 }], \"tab\": _3, \"taipei\": _3, \"talk\": _3, \"taobao\": _3, \"target\": _3, \"tatamotors\": _3, \"tatar\": _3, \"tattoo\": _3, \"tax\": _3, \"taxi\": _3, \"tci\": _3, \"tdk\": _3, \"team\": [1, { \"discourse\": _4, \"jelastic\": _4 }], \"tech\": [1, { \"cleverapps\": _4 }], \"technology\": _18, \"temasek\": _3, \"tennis\": _3, \"teva\": _3, \"thd\": _3, \"theater\": _3, \"theatre\": _3, \"tiaa\": _3, \"tickets\": _3, \"tienda\": _3, \"tips\": _3, \"tires\": _3, \"tirol\": _3, \"tjmaxx\": _3, \"tjx\": _3, \"tkmaxx\": _3, \"tmall\": _3, \"today\": [1, { \"prequalifyme\": _4 }], \"tokyo\": _3, \"tools\": [1, { \"addr\": _45, \"myaddr\": _4 }], \"top\": [1, { \"ntdll\": _4, \"wadl\": _7 }], \"toray\": _3, \"toshiba\": _3, \"total\": _3, \"tours\": _3, \"town\": _3, \"toyota\": _3, \"toys\": _3, \"trade\": _3, \"trading\": _3, \"training\": _3, \"travel\": _3, \"travelers\": _3, \"travelersinsurance\": _3, \"trust\": _3, \"trv\": _3, \"tube\": _3, \"tui\": _3, \"tunes\": _3, \"tushu\": _3, \"tvs\": _3, \"ubank\": _3, \"ubs\": _3, \"unicom\": _3, \"university\": _3, \"uno\": _3, \"uol\": _3, \"ups\": _3, \"vacations\": _3, \"vana\": _3, \"vanguard\": _3, \"vegas\": _3, \"ventures\": _3, \"verisign\": _3, \"versicherung\": _3, \"vet\": _3, \"viajes\": _3, \"video\": _3, \"vig\": _3, \"viking\": _3, \"villas\": _3, \"vin\": _3, \"vip\": _3, \"virgin\": _3, \"visa\": _3, \"vision\": _3, \"viva\": _3, \"vivo\": _3, \"vlaanderen\": _3, \"vodka\": _3, \"volvo\": _3, \"vote\": _3, \"voting\": _3, \"voto\": _3, \"voyage\": _3, \"wales\": _3, \"walmart\": _3, \"walter\": _3, \"wang\": _3, \"wanggou\": _3, \"watch\": _3, \"watches\": _3, \"weather\": _3, \"weatherchannel\": _3, \"webcam\": _3, \"weber\": _3, \"website\": _54, \"wed\": _3, \"wedding\": _3, \"weibo\": _3, \"weir\": _3, \"whoswho\": _3, \"wien\": _3, \"wiki\": _54, \"williamhill\": _3, \"win\": _3, \"windows\": _3, \"wine\": _3, \"winners\": _3, \"wme\": _3, \"wolterskluwer\": _3, \"woodside\": _3, \"work\": _3, \"works\": _3, \"world\": _3, \"wow\": _3, \"wtc\": _3, \"wtf\": _3, \"xbox\": _3, \"xerox\": _3, \"xihuan\": _3, \"xin\": _3, \"xn--11b4c3d\": _3, \"कॉम\": _3, \"xn--1ck2e1b\": _3, \"セール\": _3, \"xn--1qqw23a\": _3, \"佛山\": _3, \"xn--30rr7y\": _3, \"慈善\": _3, \"xn--3bst00m\": _3, \"集团\": _3, \"xn--3ds443g\": _3, \"在线\": _3, \"xn--3pxu8k\": _3, \"点看\": _3, \"xn--42c2d9a\": _3, \"คอม\": _3, \"xn--45q11c\": _3, \"八卦\": _3, \"xn--4gbrim\": _3, \"موقع\": _3, \"xn--55qw42g\": _3, \"公益\": _3, \"xn--55qx5d\": _3, \"公司\": _3, \"xn--5su34j936bgsg\": _3, \"香格里拉\": _3, \"xn--5tzm5g\": _3, \"网站\": _3, \"xn--6frz82g\": _3, \"移动\": _3, \"xn--6qq986b3xl\": _3, \"我爱你\": _3, \"xn--80adxhks\": _3, \"москва\": _3, \"xn--80aqecdr1a\": _3, \"католик\": _3, \"xn--80asehdb\": _3, \"онлайн\": _3, \"xn--80aswg\": _3, \"сайт\": _3, \"xn--8y0a063a\": _3, \"联通\": _3, \"xn--9dbq2a\": _3, \"קום\": _3, \"xn--9et52u\": _3, \"时尚\": _3, \"xn--9krt00a\": _3, \"微博\": _3, \"xn--b4w605ferd\": _3, \"淡马锡\": _3, \"xn--bck1b9a5dre4c\": _3, \"ファッション\": _3, \"xn--c1avg\": _3, \"орг\": _3, \"xn--c2br7g\": _3, \"नेट\": _3, \"xn--cck2b3b\": _3, \"ストア\": _3, \"xn--cckwcxetd\": _3, \"アマゾン\": _3, \"xn--cg4bki\": _3, \"삼성\": _3, \"xn--czr694b\": _3, \"商标\": _3, \"xn--czrs0t\": _3, \"商店\": _3, \"xn--czru2d\": _3, \"商城\": _3, \"xn--d1acj3b\": _3, \"дети\": _3, \"xn--eckvdtc9d\": _3, \"ポイント\": _3, \"xn--efvy88h\": _3, \"新闻\": _3, \"xn--fct429k\": _3, \"家電\": _3, \"xn--fhbei\": _3, \"كوم\": _3, \"xn--fiq228c5hs\": _3, \"中文网\": _3, \"xn--fiq64b\": _3, \"中信\": _3, \"xn--fjq720a\": _3, \"娱乐\": _3, \"xn--flw351e\": _3, \"谷歌\": _3, \"xn--fzys8d69uvgm\": _3, \"電訊盈科\": _3, \"xn--g2xx48c\": _3, \"购物\": _3, \"xn--gckr3f0f\": _3, \"クラウド\": _3, \"xn--gk3at1e\": _3, \"通販\": _3, \"xn--hxt814e\": _3, \"网店\": _3, \"xn--i1b6b1a6a2e\": _3, \"संगठन\": _3, \"xn--imr513n\": _3, \"餐厅\": _3, \"xn--io0a7i\": _3, \"网络\": _3, \"xn--j1aef\": _3, \"ком\": _3, \"xn--jlq480n2rg\": _3, \"亚马逊\": _3, \"xn--jvr189m\": _3, \"食品\": _3, \"xn--kcrx77d1x4a\": _3, \"飞利浦\": _3, \"xn--kput3i\": _3, \"手机\": _3, \"xn--mgba3a3ejt\": _3, \"ارامكو\": _3, \"xn--mgba7c0bbn0a\": _3, \"العليان\": _3, \"xn--mgbab2bd\": _3, \"بازار\": _3, \"xn--mgbca7dzdo\": _3, \"ابوظبي\": _3, \"xn--mgbi4ecexp\": _3, \"كاثوليك\": _3, \"xn--mgbt3dhd\": _3, \"همراه\": _3, \"xn--mk1bu44c\": _3, \"닷컴\": _3, \"xn--mxtq1m\": _3, \"政府\": _3, \"xn--ngbc5azd\": _3, \"شبكة\": _3, \"xn--ngbe9e0a\": _3, \"بيتك\": _3, \"xn--ngbrx\": _3, \"عرب\": _3, \"xn--nqv7f\": _3, \"机构\": _3, \"xn--nqv7fs00ema\": _3, \"组织机构\": _3, \"xn--nyqy26a\": _3, \"健康\": _3, \"xn--otu796d\": _3, \"招聘\": _3, \"xn--p1acf\": [1, { \"xn--90amc\": _4, \"xn--j1aef\": _4, \"xn--j1ael8b\": _4, \"xn--h1ahn\": _4, \"xn--j1adp\": _4, \"xn--c1avg\": _4, \"xn--80aaa0cvac\": _4, \"xn--h1aliz\": _4, \"xn--90a1af\": _4, \"xn--41a\": _4 }], \"рус\": [1, { \"биз\": _4, \"ком\": _4, \"крым\": _4, \"мир\": _4, \"мск\": _4, \"орг\": _4, \"самара\": _4, \"сочи\": _4, \"спб\": _4, \"я\": _4 }], \"xn--pssy2u\": _3, \"大拿\": _3, \"xn--q9jyb4c\": _3, \"みんな\": _3, \"xn--qcka1pmc\": _3, \"グーグル\": _3, \"xn--rhqv96g\": _3, \"世界\": _3, \"xn--rovu88b\": _3, \"書籍\": _3, \"xn--ses554g\": _3, \"网址\": _3, \"xn--t60b56a\": _3, \"닷넷\": _3, \"xn--tckwe\": _3, \"コム\": _3, \"xn--tiq49xqyj\": _3, \"天主教\": _3, \"xn--unup4y\": _3, \"游戏\": _3, \"xn--vermgensberater-ctb\": _3, \"vermögensberater\": _3, \"xn--vermgensberatung-pwb\": _3, \"vermögensberatung\": _3, \"xn--vhquv\": _3, \"企业\": _3, \"xn--vuq861b\": _3, \"信息\": _3, \"xn--w4r85el8fhu5dnra\": _3, \"嘉里大酒店\": _3, \"xn--w4rs40l\": _3, \"嘉里\": _3, \"xn--xhq521b\": _3, \"广东\": _3, \"xn--zfr164b\": _3, \"政务\": _3, \"xyz\": [1, { \"botdash\": _4, \"telebit\": _7 }], \"yachts\": _3, \"yahoo\": _3, \"yamaxun\": _3, \"yandex\": _3, \"yodobashi\": _3, \"yoga\": _3, \"yokohama\": _3, \"you\": _3, \"youtube\": _3, \"yun\": _3, \"zappos\": _3, \"zara\": _3, \"zero\": _3, \"zip\": _3, \"zone\": [1, { \"cloud66\": _4, \"triton\": _7, \"stackit\": _4, \"lima\": _4 }], \"zuerich\": _3 }];\n    return rules;\n})();\n//# sourceMappingURL=trie.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy9kaXN0L2VzNi9zcmMvZGF0YS90cmllLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUCxxQkFBcUIsY0FBYyxjQUFjLFlBQVk7QUFDN0QsNkJBQTZCLFlBQVksV0FBVyxlQUFlLHlHQUF5RyxnQkFBZ0IsY0FBYyxhQUFhLFlBQVksNEJBQTRCLGVBQWUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQzdSO0FBQ0EsQ0FBQztBQUNNO0FBQ1AscUJBQXFCLGNBQWMsY0FBYyx1REFBdUQsY0FBYyxrRUFBa0UsY0FBYyxTQUFTLGNBQWMsYUFBYSxjQUFjLFVBQVUsZUFBZSxXQUFXLGVBQWUsdUJBQXVCLGVBQWUsOEJBQThCLGVBQWUsOENBQThDLGVBQWUsZ0JBQWdCLGVBQWUsbUVBQW1FLGVBQWUsc0VBQXNFLGVBQWUsU0FBUyxlQUFlLFVBQVUsZUFBZSxlQUFlLGVBQWUsYUFBYSxlQUFlLFVBQVUsZUFBZSxrREFBa0QsZUFBZSxnQ0FBZ0MsZUFBZSxjQUFjLGVBQWUsc0JBQXNCLGVBQWUsaUNBQWlDLGVBQWUscU5BQXFOLGVBQWUscU5BQXFOLGVBQWUsOE9BQThPLGVBQWUsbUxBQW1MLGVBQWUsNEZBQTRGLGVBQWUsK1BBQStQLGVBQWUsNlNBQTZTLGVBQWUsMEVBQTBFLGVBQWUsNk5BQTZOLGVBQWUsWUFBWSxlQUFlLDZCQUE2QixlQUFlLFlBQVksZUFBZSxZQUFZLGVBQWUsVUFBVSxlQUFlLFdBQVcsZUFBZSxZQUFZLGVBQWUsNENBQTRDLGVBQWUsU0FBUyxlQUFlLFdBQVcsZUFBZSxpRUFBaUUsZUFBZSxTQUFTLGVBQWUsWUFBWSxlQUFlLFlBQVksZUFBZSwyQkFBMkIsZUFBZSxZQUFZLGVBQWUsVUFBVSxlQUFlLDhFQUE4RSxlQUFlLGNBQWMsZUFBZSxjQUFjLGVBQWUsV0FBVyxlQUFlLFVBQVUsZUFBZSxXQUFXLGVBQWUsZ0NBQWdDLGVBQWUscUJBQXFCO0FBQ3BzSCx3QkFBd0IsWUFBWSwwR0FBMEcseUJBQXlCLDJFQUEyRSxpQkFBaUIsdzdDQUF3N0MseUJBQXlCLHNEQUFzRCxlQUFlLHFFQUFxRSx5QkFBeUIsdUVBQXVFLGVBQWUsNkZBQTZGLHlCQUF5QixvS0FBb0ssaUJBQWlCLG9GQUFvRiw0QkFBNEIsd0NBQXdDLGVBQWUsWUFBWSxXQUFXLG9EQUFvRCxZQUFZLHNCQUFzQiw2QkFBNkIsK0RBQStELHdCQUF3QixrSUFBa0ksZUFBZSx3QkFBd0IsbUJBQW1CLFdBQVcsdUJBQXVCLGdCQUFnQix3Q0FBd0MsZUFBZSxrRUFBa0UsZ0JBQWdCLHFEQUFxRCw4SUFBOEksZUFBZSxXQUFXLHlCQUF5QiwrSUFBK0ksZUFBZSw0RUFBNEUsZUFBZSwrR0FBK0csMEJBQTBCLHVFQUF1RSxhQUFhLHFCQUFxQixlQUFlLHlEQUF5RCwwQkFBMEIsaVZBQWlWLHlCQUF5QixxREFBcUQsZ0JBQWdCLDJPQUEyTyxlQUFlLG9RQUFvUSx5QkFBeUIsaUVBQWlFLGVBQWUsOGtCQUE4a0IsZUFBZSw2WEFBNlgsa0JBQWtCLHNaQUFzWiw4UUFBOFEsc0lBQXNJLDhRQUE4USxxMEJBQXEwQixlQUFlLGlFQUFpRSxtQ0FBbUMscURBQXFELGVBQWUsNERBQTRELGVBQWUsbUdBQW1HLGVBQWUsc09BQXNPLDBCQUEwQixtS0FBbUssaUJBQWlCLEdBQUcsOENBQThDLGtEQUFrRCxvQ0FBb0MsaUJBQWlCLFlBQVksWUFBWSxvQkFBb0IsNkdBQTZHLG9CQUFvQix3REFBd0QsZUFBZSx3S0FBd0ssMEJBQTBCLDBEQUEwRCxlQUFlLDJDQUEyQyxlQUFlLHVCQUF1QixtQkFBbUIsb0JBQW9CLHdNQUF3TSwyQkFBMkIsbUxBQW1MLG1DQUFtQyx3Q0FBd0MsZUFBZSx3Q0FBd0MsY0FBYyxzQkFBc0IsMENBQTBDLEdBQUcsb1pBQW9aLFVBQVUsK0pBQStKLGVBQWUsNE5BQTROLGdCQUFnQix1REFBdUQsV0FBVyw4R0FBOEcsb1FBQW9RLG9JQUFvSSwyQ0FBMkMsNk5BQTZOLHlIQUF5SCxtUUFBbVEsNkRBQTZELHNOQUFzTixXQUFXLEdBQUcsZ0ZBQWdGLDZTQUE2UyxzSkFBc0osc2lCQUFzaUIsZ2FBQWdhLHFCQUFxQixZQUFZLEdBQUcsa2JBQWtiLDBCQUEwQixzakJBQXNqQixpQkFBaUIsdUNBQXVDLGtGQUFrRiw2ZEFBNmQsK1dBQStXLGdCQUFnQixpTEFBaUwsNEJBQTRCLDJrR0FBMmtHLGdHQUFnRywyVUFBMlUsU0FBUywrWEFBK1gscUNBQXFDLHNCQUFzQixvQ0FBb0MscUJBQXFCLFlBQVksMkNBQTJDLHNCQUFzQixzQ0FBc0MsV0FBVyx3Q0FBd0MsbUNBQW1DLG1EQUFtRCxVQUFVLGtRQUFrUSxpSkFBaUosd0JBQXdCLGVBQWUsWUFBWSxHQUFHLG93QkFBb3dCLGNBQWMsNEVBQTRFLDBDQUEwQyw2UUFBNlEsV0FBVywyWUFBMlkscURBQXFELHVCQUF1QixrQkFBa0IsMEJBQTBCLGNBQWMsV0FBVyxHQUFHLEdBQUcsR0FBRyw4WUFBOFksV0FBVyxzQkFBc0IsYUFBYSx3UEFBd1AsV0FBVywwS0FBMEssYUFBYSxtR0FBbUcsVUFBVSxrQkFBa0IsMEJBQTBCLG1CQUFtQiwyQkFBMkIsc0VBQXNFLGVBQWUsNkVBQTZFLGVBQWUseUZBQXlGLDBCQUEwQixrS0FBa0ssZUFBZSxrQ0FBa0MsbUJBQW1CLDJHQUEyRyxlQUFlLHVCQUF1QixXQUFXLHlEQUF5RCwyQkFBMkIsaUJBQWlCLGVBQWUsc0JBQXNCLEdBQUcsR0FBRyxlQUFlLHNKQUFzSix5QkFBeUIsMERBQTBELFdBQVcsa1RBQWtULFlBQVksbUNBQW1DLEdBQUcsbVdBQW1XLGFBQWEsVUFBVSxHQUFHLCtHQUErRyxnQkFBZ0IsNlhBQTZYLHlCQUF5QixrR0FBa0csMEJBQTBCLDhHQUE4RyxlQUFlLDhHQUE4RyxlQUFlLGlLQUFpSyxnQkFBZ0IsYUFBYSxpQkFBaUIsR0FBRyxlQUFlLCtHQUErRyxlQUFlLDJKQUEySiwwQkFBMEIsMkZBQTJGLGVBQWUsMEZBQTBGLGVBQWUsaURBQWlELGdCQUFnQixnRUFBZ0UsZUFBZSxnR0FBZ0csVUFBVSx1QkFBdUIsd0JBQXdCLHVEQUF1RCxlQUFlLCtHQUErRywwQkFBMEIscUVBQXFFLHlCQUF5Qix3Z0JBQXdnQixtQ0FBbUMsc0JBQXNCLGVBQWUsZ0ZBQWdGLHlCQUF5Qix5RkFBeUYsY0FBYyxHQUFHLGVBQWUsdURBQXVELGVBQWUsa0VBQWtFLGVBQWUsaUVBQWlFLHlCQUF5QixpRUFBaUUsMEJBQTBCLG9FQUFvRSx5QkFBeUIsc0ZBQXNGLHlCQUF5Qiw2RUFBNkUsZUFBZSwwRkFBMEYsb0NBQW9DLCtmQUErZix5QkFBeUIsa0VBQWtFLGVBQWUsNkRBQTZELGVBQWUsK01BQStNLGVBQWUsOFlBQThZLGVBQWUsbUlBQW1JLGVBQWUsK0JBQStCLGVBQWUsc0JBQXNCLGdEQUFnRCxzRUFBc0UseUJBQXlCLDZFQUE2RSxrQkFBa0IsaURBQWlELGVBQWUsc0JBQXNCLHNCQUFzQix3REFBd0QsZUFBZSxpZ0JBQWlnQixpQkFBaUIsOFpBQThaLGdCQUFnQixVQUFVLGVBQWUsK09BQStPLFNBQVMsMENBQTBDLFdBQVcsbUVBQW1FLGNBQWMsaUdBQWlHLFVBQVUsMEpBQTBKLGFBQWEsbUdBQW1HLHNFQUFzRSxvQkFBb0IsYUFBYSxzQ0FBc0MsWUFBWSxnQ0FBZ0MsV0FBVywwSkFBMEosZUFBZSxnREFBZ0QsY0FBYywrSEFBK0gsd0RBQXdELDRIQUE0SCx5QkFBeUIsa0tBQWtLLHlCQUF5Qiw4Nk5BQTg2TixVQUFVLDhGQUE4RixlQUFlLDBDQUEwQywwQkFBMEIsd0pBQXdKLDJCQUEyQixrRkFBa0YsNElBQTRJLDRCQUE0QixzdUJBQXN1QixrQkFBa0IsOFpBQThaLG1CQUFtQiw0VUFBNFUsa0JBQWtCLG0zQkFBbTNCLGtCQUFrQiw0VEFBNFQsa0JBQWtCLHNOQUFzTixvQkFBb0IsODNCQUE4M0Isc0JBQXNCLGt3QkFBa3dCLGlCQUFpQiw4aUJBQThpQixrQkFBa0IsZ2lCQUFnaUIsc0JBQXNCLDJYQUEyWCxxQkFBcUIsdW9FQUF1b0Usa0JBQWtCLHdwQkFBd3BCLG9CQUFvQiw0dUJBQTR1QixxQkFBcUIsOFFBQThRLGtCQUFrQiw2ZkFBNmYsbUJBQW1CLHdPQUF3TyxzQkFBc0IsNFNBQTRTLHFCQUFxQiw0YkFBNGIsa0JBQWtCLDBiQUEwYixxQkFBcUIsNlVBQTZVLGtCQUFrQix3Y0FBd2MsZ0JBQWdCLCtaQUErWixtQkFBbUIsdWVBQXVlLHFCQUFxQix5WkFBeVosbUJBQW1CLHdrQ0FBd2tDLHFCQUFxQixpVUFBaVUsaUJBQWlCLGdrQkFBZ2tCLG9CQUFvQixzZUFBc2UsaUJBQWlCLHdRQUF3USxvQkFBb0IsNlhBQTZYLG9CQUFvQixrbkJBQWtuQixrQkFBa0IsNHdCQUE0d0IsaUJBQWlCLHdYQUF3WCxvQkFBb0IsbWdDQUFtZ0Msa0JBQWtCLGlWQUFpVixvQkFBb0IsZ1ZBQWdWLHFCQUFxQiw4aEJBQThoQixvQkFBb0Isb2NBQW9jLHNCQUFzQiw2UEFBNlAsa0JBQWtCLDgxQkFBODFCLG9CQUFvQix5TEFBeUwsbUJBQW1CLHdWQUF3VixxQkFBcUIsOGFBQThhLHFCQUFxQiwwZkFBMGYsc0JBQXNCLDZOQUE2TixzQkFBc0Isb2JBQW9iLHMyR0FBczJHLDRCQUE0QiwrRkFBK0Ysc0JBQXNCLDhCQUE4QixlQUFlLDhGQUE4RixlQUFlLDRFQUE0RSxxQ0FBcUMseU5BQXlOLGVBQWUsNENBQTRDLGVBQWUsa0VBQWtFLGVBQWUsK1dBQStXLGVBQWUsNkVBQTZFLDBCQUEwQixnRkFBZ0YsZUFBZSxvR0FBb0cseUJBQXlCLDJFQUEyRSx5QkFBeUIsdUtBQXVLLHlCQUF5QixpR0FBaUcsMEJBQTBCLGtCQUFrQixlQUFlLG1HQUFtRyxlQUFlLGtHQUFrRyxlQUFlLGtFQUFrRSxlQUFlLHNCQUFzQixlQUFlLFVBQVUsZUFBZSx5Y0FBeWMsZUFBZSx1RkFBdUYsb0NBQW9DLDhFQUE4RSxlQUFlLG9KQUFvSiwwQkFBMEIsNENBQTRDLDJCQUEyQiw0QkFBNEIsZUFBZSxVQUFVLG9DQUFvQyx1RUFBdUUsMEJBQTBCLDBFQUEwRSw2QkFBNkIsaUtBQWlLLGVBQWUsNkdBQTZHLGVBQWUsdURBQXVELGVBQWUseUZBQXlGLGVBQWUsc0ZBQXNGLGVBQWUsaUVBQWlFLGlCQUFpQix3QkFBd0IsZUFBZSx1QkFBdUIsMEJBQTBCLHljQUF5YyxhQUFhLG9JQUFvSSxTQUFTLG1MQUFtTCxXQUFXLDIzQkFBMjNCLFNBQVMsbUJBQW1CLHdDQUF3Qyx1QkFBdUIsZ0JBQWdCLGdDQUFnQyxHQUFHLHFCQUFxQixXQUFXLHlRQUF5USwrQkFBK0IsbUJBQW1CLGdEQUFnRCx3QkFBd0IsY0FBYywwRUFBMEUsR0FBRyx3QkFBd0Isb0NBQW9DLDZPQUE2TyxnSkFBZ0osK0VBQStFLGNBQWMsWUFBWSxxQkFBcUIsc0JBQXNCLFVBQVUsd1pBQXdaLDhCQUE4QiwyTkFBMk4sa0JBQWtCLGlDQUFpQyxHQUFHLGlCQUFpQix1QkFBdUIsOERBQThELFNBQVMsdUJBQXVCLGFBQWEsd0dBQXdHLDhCQUE4QixhQUFhLGVBQWUscUhBQXFILGVBQWUsMkhBQTJILGtEQUFrRCxzRUFBc0UsZUFBZSx3SkFBd0osZUFBZSw0SUFBNEksZUFBZSxveExBQW94TCx3REFBd0QsMFFBQTBRLFVBQVUseWhGQUF5aEYsMEJBQTBCLG1DQUFtQyxpQ0FBaUMsNEJBQTRCLDBCQUEwQixpbEJBQWlsQixtRkFBbUYsc2dCQUFzZ0IsYUFBYSwyQkFBMkIsb0JBQW9CLG9CQUFvQixhQUFhLHNuR0FBc25HLHFDQUFxQyw4dUNBQTh1QyxhQUFhLDJRQUEyUSxxQ0FBcUMsbUVBQW1FLGVBQWUscU9BQXFPLGVBQWUscUdBQXFHLDZCQUE2QixrR0FBa0csb0JBQW9CLHlCQUF5QixnQkFBZ0IsV0FBVyxHQUFHLCtRQUErUSxzQkFBc0IsNnlCQUE2eUIsNmdCQUE2Z0Isc0VBQXNFLHFDQUFxQyxXQUFXLEdBQUcsdXFCQUF1cUIsZUFBZSx3SEFBd0gsZUFBZSw2RUFBNkUsZUFBZSxpQ0FBaUMsMEJBQTBCLHFHQUFxRyxlQUFlLG9LQUFvSyxlQUFlLDJhQUEyYSx1bkJBQXVuQiwyekVBQTJ6RSxlQUFlLHVCQUF1QixlQUFlLHNEQUFzRCwyQkFBMkIsa0pBQWtKLGdCQUFnQix1TEFBdUwsZUFBZSw2RUFBNkUsZUFBZSw4R0FBOEcsZUFBZSxzQ0FBc0MsZUFBZSw4RUFBOEUsZUFBZSx5RkFBeUYsZUFBZSxnREFBZ0QsZUFBZSwrSkFBK0osZUFBZSxzR0FBc0csZUFBZSxnWUFBZ1kseURBQXlELG9CQUFvQixVQUFVLGtCQUFrQixXQUFXLHNFQUFzRSxlQUFlLDRFQUE0RSxlQUFlLHdGQUF3RixtQ0FBbUMsd0ZBQXdGLGVBQWUscWZBQXFmLGVBQWUsdUVBQXVFLGVBQWUsc0dBQXNHLCtCQUErQixjQUFjLGVBQWUsdUNBQXVDLHVEQUF1RCxpRkFBaUYsZUFBZSxnRkFBZ0YseUJBQXlCLGlHQUFpRyxlQUFlLHdMQUF3TCxlQUFlLHV5QkFBdXlCLGVBQWUsdURBQXVELG9DQUFvQywrQkFBK0IsOENBQThDLFdBQVcseUJBQXlCLGlHQUFpRyxlQUFlLG9LQUFvSyxvQ0FBb0MsdUZBQXVGLGVBQWUsNktBQTZLLGVBQWUsc0lBQXNJLGVBQWUsaVBBQWlQLGVBQWUsMEhBQTBILGVBQWUsK0ZBQStGLGVBQWUseUJBQXlCLGdCQUFnQixxSEFBcUgsZUFBZSxnSUFBZ0ksZUFBZSx1cENBQXVwQyxlQUFlLDZIQUE2SCxlQUFlLHNCQUFzQixrQkFBa0Isb0JBQW9CLHFJQUFxSSxnQkFBZ0IsMENBQTBDLDJEQUEyRCxrR0FBa0cscVVBQXFVLGVBQWUsZ0pBQWdKLHFCQUFxQix3SUFBd0ksYUFBYSxxQ0FBcUMsd0JBQXdCLHFDQUFxQyxzSUFBc0ksbVVBQW1VLFVBQVUsb0hBQW9ILFdBQVcscUdBQXFHLG9CQUFvQixxQ0FBcUMsZUFBZSxrRUFBa0UsZUFBZSwyQ0FBMkMseUJBQXlCLDhFQUE4RSxTQUFTLDBCQUEwQixlQUFlLGdPQUFnTyxlQUFlLFdBQVcsZUFBZSxzREFBc0QsZUFBZSw4bkNBQThuQywwQkFBMEIsc0JBQXNCLGVBQWUsaUhBQWlILGVBQWUsV0FBVyx3ZUFBd2UsNkdBQTZHLGVBQWUsNERBQTRELCtuQ0FBK25DLG1HQUFtRyxnQkFBZ0IsK0RBQStELHlhQUF5YSxnSUFBZ0ksZ0JBQWdCLCtFQUErRSx1TkFBdU4sNE1BQTRNLGVBQWUsd0hBQXdILGVBQWUscURBQXFELHdJQUF3SSxnQkFBZ0IscWpCQUFxakIsb0dBQW9HLGVBQWUsaUdBQWlHLGVBQWUsNlZBQTZWLDRCQUE0QiwrSEFBK0gsa1NBQWtTLG1CQUFtQixtWUFBbVkscUNBQXFDLGlQQUFpUCxtREFBbUQsc0JBQXNCLG1CQUFtQixlQUFlLGVBQWUscUxBQXFMLEdBQUcsOE5BQThOLHFCQUFxQixrc0JBQWtzQixVQUFVLHFCQUFxQixpQkFBaUIsOEpBQThKLGFBQWEsVUFBVSxHQUFHLDJLQUEySyxjQUFjLFVBQVUsR0FBRywyZkFBMmYsa0NBQWtDLFVBQVUsa0RBQWtELFlBQVksbUNBQW1DLFdBQVcsbUNBQW1DLGVBQWUsYUFBYSxXQUFXLEdBQUcsY0FBYyxvQkFBb0IsVUFBVSxnQkFBZ0Isb0JBQW9CLHFCQUFxQixVQUFVLG9CQUFvQiw4QkFBOEIseUJBQXlCLG9CQUFvQixxS0FBcUssbUJBQW1CLGdEQUFnRCxtQkFBbUIsNEJBQTRCLGlCQUFpQixzREFBc0Qsc0JBQXNCLHVCQUF1Qiw4QkFBOEIsa0VBQWtFLG1CQUFtQix1REFBdUQseUNBQXlDLHVDQUF1QyxZQUFZLHNGQUFzRixpQkFBaUIsd0NBQXdDLDhDQUE4QyxXQUFXLGtGQUFrRix5Q0FBeUMsa0xBQWtMLDJCQUEyQiwraEJBQStoQiwwQkFBMEIsZ0JBQWdCLGdRQUFnUSxhQUFhLHVCQUF1QixvQkFBb0IsR0FBRyxHQUFHLG9HQUFvRyxZQUFZLG9OQUFvTixzVkFBc1YsZ0JBQWdCLDhFQUE4RSxnQ0FBZ0MsMkRBQTJELG1CQUFtQixjQUFjLEdBQUcsbUJBQW1CLGNBQWMsNFZBQTRWLGVBQWUsVUFBVSwrQkFBK0IsMEtBQTBLLGVBQWUsa0NBQWtDLGNBQWMsbUJBQW1CLHdCQUF3QiwwTEFBMEwsYUFBYSw2dEJBQTZ0QiwwQkFBMEIseUNBQXlDLGFBQWEsNEJBQTRCLFlBQVksMFRBQTBULGlEQUFpRCw2SUFBNkksaUJBQWlCLGlMQUFpTCxXQUFXLG9UQUFvVCxrS0FBa0ssb0JBQW9CLGlCQUFpQiw2OUJBQTY5QixxQkFBcUIsK2VBQStlLDJEQUEyRCxZQUFZLGdCQUFnQiw4QkFBOEIsaUNBQWlDLHdHQUF3RyxXQUFXLDRPQUE0TyxjQUFjLDhQQUE4UCxnQ0FBZ0MsaU5BQWlOLFdBQVcsd1NBQXdTLDhEQUE4RCwyQ0FBMkMsa0JBQWtCLHlZQUF5WSwwQkFBMEIsZ0JBQWdCLFdBQVcsOEJBQThCLGlFQUFpRSx3REFBd0QsWUFBWSxvRkFBb0YsZUFBZSxpQkFBaUIsc0lBQXNJLHVTQUF1UyxZQUFZLCtFQUErRSxhQUFhLDRXQUE0VyxrQ0FBa0MsdWZBQXVmLFlBQVksa0JBQWtCLDhEQUE4RCw0RkFBNEYsaURBQWlELFlBQVksb0lBQW9JLDBCQUEwQixjQUFjLHdaQUF3WixhQUFhLGVBQWUsR0FBRyxvSEFBb0gsaUJBQWlCLDhKQUE4SiwwRUFBMEUsa0dBQWtHLG1TQUFtUyx3UUFBd1EsdUNBQXVDLGNBQWMsNkRBQTZELDJMQUEyTCw0REFBNEQscUhBQXFILGFBQWEsc0dBQXNHLG1CQUFtQiw0S0FBNEssaUNBQWlDLGlCQUFpQixrQkFBa0IsMFBBQTBQLG9CQUFvQiwrQkFBK0IsMkJBQTJCLGdCQUFnQix5QkFBeUIsMDNHQUEwM0csaUxBQWlMLGdCQUFnQixpSEFBaUgsNmxCQUE2bEIsOEJBQThCLDRNQUE0TSx3REFBd0Qsa0JBQWtCO0FBQ3h0eUk7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMvZGlzdC9lczYvc3JjL2RhdGEvdHJpZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZXhjZXB0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgXzAgPSBbMSwge31dLCBfMSA9IFsyLCB7fV0sIF8yID0gWzAsIHsgXCJjaXR5XCI6IF8wIH1dO1xuICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSBbMCwgeyBcImNrXCI6IFswLCB7IFwid3d3XCI6IF8wIH1dLCBcImpwXCI6IFswLCB7IFwia2F3YXNha2lcIjogXzIsIFwia2l0YWt5dXNodVwiOiBfMiwgXCJrb2JlXCI6IF8yLCBcIm5hZ295YVwiOiBfMiwgXCJzYXBwb3JvXCI6IF8yLCBcInNlbmRhaVwiOiBfMiwgXCJ5b2tvaGFtYVwiOiBfMiB9XSwgXCJkZXZcIjogWzAsIHsgXCJocnNuXCI6IFswLCB7IFwicHNsXCI6IFswLCB7IFwid2NcIjogWzAsIHsgXCJpZ25vcmVkXCI6IF8xLCBcInN1YlwiOiBbMCwgeyBcImlnbm9yZWRcIjogXzEgfV0gfV0gfV0gfV0gfV0gfV07XG4gICAgcmV0dXJuIGV4Y2VwdGlvbnM7XG59KSgpO1xuZXhwb3J0IGNvbnN0IHJ1bGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfMyA9IFsxLCB7fV0sIF80ID0gWzIsIHt9XSwgXzUgPSBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIF82ID0gWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXzcgPSBbMCwgeyBcIipcIjogXzQgfV0sIF84ID0gWzAsIHsgXCJyZWxheVwiOiBfNCB9XSwgXzkgPSBbMiwgeyBcImlkXCI6IF80IH1dLCBfMTAgPSBbMSwgeyBcImdvdlwiOiBfMyB9XSwgXzExID0gWzAsIHsgXCJ0cmFuc2Zlci13ZWJhcHBcIjogXzQgfV0sIF8xMiA9IFswLCB7IFwibm90ZWJvb2tcIjogXzQsIFwic3R1ZGlvXCI6IF80IH1dLCBfMTMgPSBbMCwgeyBcImxhYmVsaW5nXCI6IF80LCBcIm5vdGVib29rXCI6IF80LCBcInN0dWRpb1wiOiBfNCB9XSwgXzE0ID0gWzAsIHsgXCJub3RlYm9va1wiOiBfNCB9XSwgXzE1ID0gWzAsIHsgXCJsYWJlbGluZ1wiOiBfNCwgXCJub3RlYm9va1wiOiBfNCwgXCJub3RlYm9vay1maXBzXCI6IF80LCBcInN0dWRpb1wiOiBfNCB9XSwgXzE2ID0gWzAsIHsgXCJub3RlYm9va1wiOiBfNCwgXCJub3RlYm9vay1maXBzXCI6IF80LCBcInN0dWRpb1wiOiBfNCwgXCJzdHVkaW8tZmlwc1wiOiBfNCB9XSwgXzE3ID0gWzAsIHsgXCIqXCI6IF8zIH1dLCBfMTggPSBbMSwgeyBcImNvXCI6IF80IH1dLCBfMTkgPSBbMCwgeyBcIm9iamVjdHNcIjogXzQgfV0sIF8yMCA9IFsyLCB7IFwibm9kZXNcIjogXzQgfV0sIF8yMSA9IFswLCB7IFwibXlcIjogXzcgfV0sIF8yMiA9IFswLCB7IFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtd2Vic2l0ZVwiOiBfNCB9XSwgXzIzID0gWzAsIHsgXCJzM1wiOiBfNCwgXCJzMy1hY2Nlc3Nwb2ludFwiOiBfNCB9XSwgXzI0ID0gWzAsIHsgXCJkaXJlY3RcIjogXzQgfV0sIF8yNSA9IFswLCB7IFwid2Vidmlldy1hc3NldHNcIjogXzQgfV0sIF8yNiA9IFswLCB7IFwidmZzXCI6IF80LCBcIndlYnZpZXctYXNzZXRzXCI6IF80IH1dLCBfMjcgPSBbMCwgeyBcImV4ZWN1dGUtYXBpXCI6IF80LCBcImVtcmFwcHVpLXByb2RcIjogXzQsIFwiZW1ybm90ZWJvb2tzLXByb2RcIjogXzQsIFwiZW1yc3R1ZGlvLXByb2RcIjogXzQsIFwiZHVhbHN0YWNrXCI6IF8yMiwgXCJzM1wiOiBfNCwgXCJzMy1hY2Nlc3Nwb2ludFwiOiBfNCwgXCJzMy1vYmplY3QtbGFtYmRhXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQsIFwiYXdzLWNsb3VkOVwiOiBfMjUsIFwiY2xvdWQ5XCI6IF8yNiB9XSwgXzI4ID0gWzAsIHsgXCJleGVjdXRlLWFwaVwiOiBfNCwgXCJlbXJhcHB1aS1wcm9kXCI6IF80LCBcImVtcm5vdGVib29rcy1wcm9kXCI6IF80LCBcImVtcnN0dWRpby1wcm9kXCI6IF80LCBcImR1YWxzdGFja1wiOiBfMjMsIFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtb2JqZWN0LWxhbWJkYVwiOiBfNCwgXCJzMy13ZWJzaXRlXCI6IF80LCBcImF3cy1jbG91ZDlcIjogXzI1LCBcImNsb3VkOVwiOiBfMjYgfV0sIF8yOSA9IFswLCB7IFwiZXhlY3V0ZS1hcGlcIjogXzQsIFwiZW1yYXBwdWktcHJvZFwiOiBfNCwgXCJlbXJub3RlYm9va3MtcHJvZFwiOiBfNCwgXCJlbXJzdHVkaW8tcHJvZFwiOiBfNCwgXCJkdWFsc3RhY2tcIjogXzIyLCBcInMzXCI6IF80LCBcInMzLWFjY2Vzc3BvaW50XCI6IF80LCBcInMzLW9iamVjdC1sYW1iZGFcIjogXzQsIFwiczMtd2Vic2l0ZVwiOiBfNCwgXCJhbmFseXRpY3MtZ2F0ZXdheVwiOiBfNCwgXCJhd3MtY2xvdWQ5XCI6IF8yNSwgXCJjbG91ZDlcIjogXzI2IH1dLCBfMzAgPSBbMCwgeyBcImV4ZWN1dGUtYXBpXCI6IF80LCBcImVtcmFwcHVpLXByb2RcIjogXzQsIFwiZW1ybm90ZWJvb2tzLXByb2RcIjogXzQsIFwiZW1yc3R1ZGlvLXByb2RcIjogXzQsIFwiZHVhbHN0YWNrXCI6IF8yMiwgXCJzM1wiOiBfNCwgXCJzMy1hY2Nlc3Nwb2ludFwiOiBfNCwgXCJzMy1vYmplY3QtbGFtYmRhXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQgfV0sIF8zMSA9IFswLCB7IFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtYWNjZXNzcG9pbnQtZmlwc1wiOiBfNCwgXCJzMy1maXBzXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQgfV0sIF8zMiA9IFswLCB7IFwiZXhlY3V0ZS1hcGlcIjogXzQsIFwiZW1yYXBwdWktcHJvZFwiOiBfNCwgXCJlbXJub3RlYm9va3MtcHJvZFwiOiBfNCwgXCJlbXJzdHVkaW8tcHJvZFwiOiBfNCwgXCJkdWFsc3RhY2tcIjogXzMxLCBcInMzXCI6IF80LCBcInMzLWFjY2Vzc3BvaW50XCI6IF80LCBcInMzLWFjY2Vzc3BvaW50LWZpcHNcIjogXzQsIFwiczMtZmlwc1wiOiBfNCwgXCJzMy1vYmplY3QtbGFtYmRhXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQsIFwiYXdzLWNsb3VkOVwiOiBfMjUsIFwiY2xvdWQ5XCI6IF8yNiB9XSwgXzMzID0gWzAsIHsgXCJleGVjdXRlLWFwaVwiOiBfNCwgXCJlbXJhcHB1aS1wcm9kXCI6IF80LCBcImVtcm5vdGVib29rcy1wcm9kXCI6IF80LCBcImVtcnN0dWRpby1wcm9kXCI6IF80LCBcImR1YWxzdGFja1wiOiBfMzEsIFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtYWNjZXNzcG9pbnQtZmlwc1wiOiBfNCwgXCJzMy1kZXByZWNhdGVkXCI6IF80LCBcInMzLWZpcHNcIjogXzQsIFwiczMtb2JqZWN0LWxhbWJkYVwiOiBfNCwgXCJzMy13ZWJzaXRlXCI6IF80LCBcImFuYWx5dGljcy1nYXRld2F5XCI6IF80LCBcImF3cy1jbG91ZDlcIjogXzI1LCBcImNsb3VkOVwiOiBfMjYgfV0sIF8zNCA9IFswLCB7IFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtYWNjZXNzcG9pbnQtZmlwc1wiOiBfNCwgXCJzMy1maXBzXCI6IF80IH1dLCBfMzUgPSBbMCwgeyBcImV4ZWN1dGUtYXBpXCI6IF80LCBcImVtcmFwcHVpLXByb2RcIjogXzQsIFwiZW1ybm90ZWJvb2tzLXByb2RcIjogXzQsIFwiZW1yc3R1ZGlvLXByb2RcIjogXzQsIFwiZHVhbHN0YWNrXCI6IF8zNCwgXCJzM1wiOiBfNCwgXCJzMy1hY2Nlc3Nwb2ludFwiOiBfNCwgXCJzMy1hY2Nlc3Nwb2ludC1maXBzXCI6IF80LCBcInMzLWZpcHNcIjogXzQsIFwiczMtb2JqZWN0LWxhbWJkYVwiOiBfNCwgXCJzMy13ZWJzaXRlXCI6IF80IH1dLCBfMzYgPSBbMCwgeyBcImF1dGhcIjogXzQgfV0sIF8zNyA9IFswLCB7IFwiYXV0aFwiOiBfNCwgXCJhdXRoLWZpcHNcIjogXzQgfV0sIF8zOCA9IFswLCB7IFwiYXBwc1wiOiBfNCB9XSwgXzM5ID0gWzAsIHsgXCJwYWFzXCI6IF80IH1dLCBfNDAgPSBbMiwgeyBcImV1XCI6IF80IH1dLCBfNDEgPSBbMCwgeyBcImFwcFwiOiBfNCB9XSwgXzQyID0gWzAsIHsgXCJzaXRlXCI6IF80IH1dLCBfNDMgPSBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXzQ0ID0gWzAsIHsgXCJqXCI6IF80IH1dLCBfNDUgPSBbMCwgeyBcImR5blwiOiBfNCB9XSwgXzQ2ID0gWzEsIHsgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBfNDcgPSBbMCwgeyBcInBcIjogXzQgfV0sIF80OCA9IFswLCB7IFwidXNlclwiOiBfNCB9XSwgXzQ5ID0gWzAsIHsgXCJzaG9wXCI6IF80IH1dLCBfNTAgPSBbMCwgeyBcImN1c3RcIjogXzQsIFwicmVzZXJ2ZFwiOiBfNCB9XSwgXzUxID0gWzAsIHsgXCJjdXN0XCI6IF80IH1dLCBfNTIgPSBbMCwgeyBcInMzXCI6IF80IH1dLCBfNTMgPSBbMSwgeyBcImJpelwiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJpbmZvXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIF81NCA9IFsxLCB7IFwiZnJhbWVyXCI6IF80IH1dLCBfNTUgPSBbMCwgeyBcImZvcmdvdFwiOiBfNCB9XSwgXzU2ID0gWzAsIHsgXCJjZG5cIjogXzQgfV0sIF81NyA9IFsxLCB7IFwiZ3NcIjogXzMgfV0sIF81OCA9IFswLCB7IFwibmVzXCI6IF8zIH1dLCBfNTkgPSBbMSwgeyBcImsxMlwiOiBfMywgXCJjY1wiOiBfMywgXCJsaWJcIjogXzMgfV0sIF82MCA9IFsxLCB7IFwiY2NcIjogXzMsIFwibGliXCI6IF8zIH1dO1xuICAgIGNvbnN0IHJ1bGVzID0gWzAsIHsgXCJhY1wiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImRyclwiOiBfNCwgXCJmZWVkYmFja1wiOiBfNCwgXCJmb3Jtc1wiOiBfNCB9XSwgXCJhZFwiOiBfMywgXCJhZVwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IF8zLCBcImdvdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJzY2hcIjogXzMgfV0sIFwiYWVyb1wiOiBbMSwgeyBcImFpcmxpbmVcIjogXzMsIFwiYWlycG9ydFwiOiBfMywgXCJhY2NpZGVudC1pbnZlc3RpZ2F0aW9uXCI6IF8zLCBcImFjY2lkZW50LXByZXZlbnRpb25cIjogXzMsIFwiYWVyb2JhdGljXCI6IF8zLCBcImFlcm9jbHViXCI6IF8zLCBcImFlcm9kcm9tZVwiOiBfMywgXCJhZ2VudHNcIjogXzMsIFwiYWlyLXN1cnZlaWxsYW5jZVwiOiBfMywgXCJhaXItdHJhZmZpYy1jb250cm9sXCI6IF8zLCBcImFpcmNyYWZ0XCI6IF8zLCBcImFpcnRyYWZmaWNcIjogXzMsIFwiYW1idWxhbmNlXCI6IF8zLCBcImFzc29jaWF0aW9uXCI6IF8zLCBcImF1dGhvclwiOiBfMywgXCJiYWxsb29uaW5nXCI6IF8zLCBcImJyb2tlclwiOiBfMywgXCJjYWFcIjogXzMsIFwiY2FyZ29cIjogXzMsIFwiY2F0ZXJpbmdcIjogXzMsIFwiY2VydGlmaWNhdGlvblwiOiBfMywgXCJjaGFtcGlvbnNoaXBcIjogXzMsIFwiY2hhcnRlclwiOiBfMywgXCJjaXZpbGF2aWF0aW9uXCI6IF8zLCBcImNsdWJcIjogXzMsIFwiY29uZmVyZW5jZVwiOiBfMywgXCJjb25zdWx0YW50XCI6IF8zLCBcImNvbnN1bHRpbmdcIjogXzMsIFwiY29udHJvbFwiOiBfMywgXCJjb3VuY2lsXCI6IF8zLCBcImNyZXdcIjogXzMsIFwiZGVzaWduXCI6IF8zLCBcImRnY2FcIjogXzMsIFwiZWR1Y2F0b3JcIjogXzMsIFwiZW1lcmdlbmN5XCI6IF8zLCBcImVuZ2luZVwiOiBfMywgXCJlbmdpbmVlclwiOiBfMywgXCJlbnRlcnRhaW5tZW50XCI6IF8zLCBcImVxdWlwbWVudFwiOiBfMywgXCJleGNoYW5nZVwiOiBfMywgXCJleHByZXNzXCI6IF8zLCBcImZlZGVyYXRpb25cIjogXzMsIFwiZmxpZ2h0XCI6IF8zLCBcImZyZWlnaHRcIjogXzMsIFwiZnVlbFwiOiBfMywgXCJnbGlkaW5nXCI6IF8zLCBcImdvdmVybm1lbnRcIjogXzMsIFwiZ3JvdW5kaGFuZGxpbmdcIjogXzMsIFwiZ3JvdXBcIjogXzMsIFwiaGFuZ2dsaWRpbmdcIjogXzMsIFwiaG9tZWJ1aWx0XCI6IF8zLCBcImluc3VyYW5jZVwiOiBfMywgXCJqb3VybmFsXCI6IF8zLCBcImpvdXJuYWxpc3RcIjogXzMsIFwibGVhc2luZ1wiOiBfMywgXCJsb2dpc3RpY3NcIjogXzMsIFwibWFnYXppbmVcIjogXzMsIFwibWFpbnRlbmFuY2VcIjogXzMsIFwibWFya2V0cGxhY2VcIjogXzMsIFwibWVkaWFcIjogXzMsIFwibWljcm9saWdodFwiOiBfMywgXCJtb2RlbGxpbmdcIjogXzMsIFwibmF2aWdhdGlvblwiOiBfMywgXCJwYXJhY2h1dGluZ1wiOiBfMywgXCJwYXJhZ2xpZGluZ1wiOiBfMywgXCJwYXNzZW5nZXItYXNzb2NpYXRpb25cIjogXzMsIFwicGlsb3RcIjogXzMsIFwicHJlc3NcIjogXzMsIFwicHJvZHVjdGlvblwiOiBfMywgXCJyZWNyZWF0aW9uXCI6IF8zLCBcInJlcGJvZHlcIjogXzMsIFwicmVzXCI6IF8zLCBcInJlc2VhcmNoXCI6IF8zLCBcInJvdG9yY3JhZnRcIjogXzMsIFwic2FmZXR5XCI6IF8zLCBcInNjaWVudGlzdFwiOiBfMywgXCJzZXJ2aWNlc1wiOiBfMywgXCJzaG93XCI6IF8zLCBcInNreWRpdmluZ1wiOiBfMywgXCJzb2Z0d2FyZVwiOiBfMywgXCJzdHVkZW50XCI6IF8zLCBcInRheGlcIjogXzMsIFwidHJhZGVyXCI6IF8zLCBcInRyYWRpbmdcIjogXzMsIFwidHJhaW5lclwiOiBfMywgXCJ1bmlvblwiOiBfMywgXCJ3b3JraW5nZ3JvdXBcIjogXzMsIFwid29ya3NcIjogXzMgfV0sIFwiYWZcIjogXzUsIFwiYWdcIjogWzEsIHsgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwibmV0XCI6IF8zLCBcIm5vbVwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwiYWlcIjogWzEsIHsgXCJjb21cIjogXzMsIFwibmV0XCI6IF8zLCBcIm9mZlwiOiBfMywgXCJvcmdcIjogXzMsIFwidXd1XCI6IF80LCBcImZyYW1lclwiOiBfNCB9XSwgXCJhbFwiOiBfNiwgXCJhbVwiOiBbMSwgeyBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJjb21tdW5lXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicmFkaW9cIjogXzQgfV0sIFwiYW9cIjogWzEsIHsgXCJjb1wiOiBfMywgXCJlZFwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImd2XCI6IF8zLCBcIml0XCI6IF8zLCBcIm9nXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwYlwiOiBfMyB9XSwgXCJhcVwiOiBfMywgXCJhclwiOiBbMSwgeyBcImJldFwiOiBfMywgXCJjb21cIjogXzMsIFwiY29vcFwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ29iXCI6IF8zLCBcImdvdlwiOiBfMywgXCJpbnRcIjogXzMsIFwibWlsXCI6IF8zLCBcIm11c2ljYVwiOiBfMywgXCJtdXR1YWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJzZW5hc2FcIjogXzMsIFwidHVyXCI6IF8zIH1dLCBcImFycGFcIjogWzEsIHsgXCJlMTY0XCI6IF8zLCBcImhvbWVcIjogXzMsIFwiaW4tYWRkclwiOiBfMywgXCJpcDZcIjogXzMsIFwiaXJpc1wiOiBfMywgXCJ1cmlcIjogXzMsIFwidXJuXCI6IF8zIH1dLCBcImFzXCI6IF8xMCwgXCJhc2lhXCI6IFsxLCB7IFwiY2xvdWRuc1wiOiBfNCwgXCJkYWVtb25cIjogXzQsIFwiZGl4XCI6IF80IH1dLCBcImF0XCI6IFsxLCB7IFwiYWNcIjogWzEsIHsgXCJzdGhcIjogXzMgfV0sIFwiY29cIjogXzMsIFwiZ3ZcIjogXzMsIFwib3JcIjogXzMsIFwiZnVua2ZldWVyXCI6IFswLCB7IFwid2llblwiOiBfNCB9XSwgXCJmdXR1cmVjbXNcIjogWzAsIHsgXCIqXCI6IF80LCBcImV4XCI6IF83LCBcImluXCI6IF83IH1dLCBcImZ1dHVyZWhvc3RpbmdcIjogXzQsIFwiZnV0dXJlbWFpbGluZ1wiOiBfNCwgXCJvcnRzaW5mb1wiOiBbMCwgeyBcImV4XCI6IF83LCBcImt1bmRlblwiOiBfNyB9XSwgXCJiaXpcIjogXzQsIFwiaW5mb1wiOiBfNCwgXCIxMjN3ZWJzZWl0ZVwiOiBfNCwgXCJwcml2XCI6IF80LCBcIm15c3ByZWFkc2hvcFwiOiBfNCwgXCIxMmhwXCI6IF80LCBcIjJpeFwiOiBfNCwgXCI0bGltYVwiOiBfNCwgXCJsaW1hLWNpdHlcIjogXzQgfV0sIFwiYXVcIjogWzEsIHsgXCJhc25cIjogXzMsIFwiY29tXCI6IFsxLCB7IFwiY2xvdWRsZXRzXCI6IFswLCB7IFwibWVsXCI6IF80IH1dLCBcIm15c3ByZWFkc2hvcFwiOiBfNCB9XSwgXCJlZHVcIjogWzEsIHsgXCJhY3RcIjogXzMsIFwiY2F0aG9saWNcIjogXzMsIFwibnN3XCI6IFsxLCB7IFwic2Nob29sc1wiOiBfMyB9XSwgXCJudFwiOiBfMywgXCJxbGRcIjogXzMsIFwic2FcIjogXzMsIFwidGFzXCI6IF8zLCBcInZpY1wiOiBfMywgXCJ3YVwiOiBfMyB9XSwgXCJnb3ZcIjogWzEsIHsgXCJxbGRcIjogXzMsIFwic2FcIjogXzMsIFwidGFzXCI6IF8zLCBcInZpY1wiOiBfMywgXCJ3YVwiOiBfMyB9XSwgXCJpZFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImNvbmZcIjogXzMsIFwib3pcIjogXzMsIFwiYWN0XCI6IF8zLCBcIm5zd1wiOiBfMywgXCJudFwiOiBfMywgXCJxbGRcIjogXzMsIFwic2FcIjogXzMsIFwidGFzXCI6IF8zLCBcInZpY1wiOiBfMywgXCJ3YVwiOiBfMyB9XSwgXCJhd1wiOiBbMSwgeyBcImNvbVwiOiBfMyB9XSwgXCJheFwiOiBfMywgXCJhelwiOiBbMSwgeyBcImJpelwiOiBfMywgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJpbmZvXCI6IF8zLCBcImludFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInBwXCI6IF8zLCBcInByb1wiOiBfMyB9XSwgXCJiYVwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInJzXCI6IF80IH1dLCBcImJiXCI6IFsxLCB7IFwiYml6XCI6IF8zLCBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJzdG9yZVwiOiBfMywgXCJ0dlwiOiBfMyB9XSwgXCJiZFwiOiBfMTcsIFwiYmVcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJjbG91ZG5zXCI6IF80LCBcIndlYmhvc3RpbmdcIjogXzQsIFwiaW50ZXJob3N0c29sdXRpb25zXCI6IFswLCB7IFwiY2xvdWRcIjogXzQgfV0sIFwia3VsZXV2ZW5cIjogWzAsIHsgXCJlenByb3h5XCI6IF80IH1dLCBcIjEyM3dlYnNpdGVcIjogXzQsIFwibXlzcHJlYWRzaG9wXCI6IF80LCBcInRyYW5zdXJsXCI6IF83IH1dLCBcImJmXCI6IF8xMCwgXCJiZ1wiOiBbMSwgeyBcIjBcIjogXzMsIFwiMVwiOiBfMywgXCIyXCI6IF8zLCBcIjNcIjogXzMsIFwiNFwiOiBfMywgXCI1XCI6IF8zLCBcIjZcIjogXzMsIFwiN1wiOiBfMywgXCI4XCI6IF8zLCBcIjlcIjogXzMsIFwiYVwiOiBfMywgXCJiXCI6IF8zLCBcImNcIjogXzMsIFwiZFwiOiBfMywgXCJlXCI6IF8zLCBcImZcIjogXzMsIFwiZ1wiOiBfMywgXCJoXCI6IF8zLCBcImlcIjogXzMsIFwialwiOiBfMywgXCJrXCI6IF8zLCBcImxcIjogXzMsIFwibVwiOiBfMywgXCJuXCI6IF8zLCBcIm9cIjogXzMsIFwicFwiOiBfMywgXCJxXCI6IF8zLCBcInJcIjogXzMsIFwic1wiOiBfMywgXCJ0XCI6IF8zLCBcInVcIjogXzMsIFwidlwiOiBfMywgXCJ3XCI6IF8zLCBcInhcIjogXzMsIFwieVwiOiBfMywgXCJ6XCI6IF8zLCBcImJhcnN5XCI6IF80IH1dLCBcImJoXCI6IF81LCBcImJpXCI6IFsxLCB7IFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJvclwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwiYml6XCI6IFsxLCB7IFwiYWN0aXZldHJhaWxcIjogXzQsIFwiY2xvdWQtaXBcIjogXzQsIFwiY2xvdWRuc1wiOiBfNCwgXCJqb3ppXCI6IF80LCBcImR5bmRuc1wiOiBfNCwgXCJmb3ItYmV0dGVyXCI6IF80LCBcImZvci1tb3JlXCI6IF80LCBcImZvci1zb21lXCI6IF80LCBcImZvci10aGVcIjogXzQsIFwic2VsZmlwXCI6IF80LCBcIndlYmhvcFwiOiBfNCwgXCJvcnhcIjogXzQsIFwibW1hZmFuXCI6IF80LCBcIm15ZnRwXCI6IF80LCBcIm5vLWlwXCI6IF80LCBcImRzY2xvdWRcIjogXzQgfV0sIFwiYmpcIjogWzEsIHsgXCJhZnJpY2FcIjogXzMsIFwiYWdyb1wiOiBfMywgXCJhcmNoaXRlY3Rlc1wiOiBfMywgXCJhc3N1clwiOiBfMywgXCJhdm9jYXRzXCI6IF8zLCBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlY29cIjogXzMsIFwiZWNvbm9cIjogXzMsIFwiZWR1XCI6IF8zLCBcImluZm9cIjogXzMsIFwibG9pc2lyc1wiOiBfMywgXCJtb25leVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcIm90ZVwiOiBfMywgXCJyZXN0YXVyYW50XCI6IF8zLCBcInJlc3RvXCI6IF8zLCBcInRvdXJpc21cIjogXzMsIFwidW5pdlwiOiBfMyB9XSwgXCJibVwiOiBfNSwgXCJiblwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwiY29cIjogXzQgfV0sIFwiYm9cIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvYlwiOiBfMywgXCJpbnRcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwidHZcIjogXzMsIFwid2ViXCI6IF8zLCBcImFjYWRlbWlhXCI6IF8zLCBcImFncm9cIjogXzMsIFwiYXJ0ZVwiOiBfMywgXCJibG9nXCI6IF8zLCBcImJvbGl2aWFcIjogXzMsIFwiY2llbmNpYVwiOiBfMywgXCJjb29wZXJhdGl2YVwiOiBfMywgXCJkZW1vY3JhY2lhXCI6IF8zLCBcImRlcG9ydGVcIjogXzMsIFwiZWNvbG9naWFcIjogXzMsIFwiZWNvbm9taWFcIjogXzMsIFwiZW1wcmVzYVwiOiBfMywgXCJpbmRpZ2VuYVwiOiBfMywgXCJpbmR1c3RyaWFcIjogXzMsIFwiaW5mb1wiOiBfMywgXCJtZWRpY2luYVwiOiBfMywgXCJtb3ZpbWllbnRvXCI6IF8zLCBcIm11c2ljYVwiOiBfMywgXCJuYXR1cmFsXCI6IF8zLCBcIm5vbWJyZVwiOiBfMywgXCJub3RpY2lhc1wiOiBfMywgXCJwYXRyaWFcIjogXzMsIFwicGx1cmluYWNpb25hbFwiOiBfMywgXCJwb2xpdGljYVwiOiBfMywgXCJwcm9mZXNpb25hbFwiOiBfMywgXCJwdWVibG9cIjogXzMsIFwicmV2aXN0YVwiOiBfMywgXCJzYWx1ZFwiOiBfMywgXCJ0ZWNub2xvZ2lhXCI6IF8zLCBcInRrc2F0XCI6IF8zLCBcInRyYW5zcG9ydGVcIjogXzMsIFwid2lraVwiOiBfMyB9XSwgXCJiclwiOiBbMSwgeyBcIjlndWFjdVwiOiBfMywgXCJhYmNcIjogXzMsIFwiYWRtXCI6IF8zLCBcImFkdlwiOiBfMywgXCJhZ3JcIjogXzMsIFwiYWp1XCI6IF8zLCBcImFtXCI6IF8zLCBcImFuYW5pXCI6IF8zLCBcImFwYXJlY2lkYVwiOiBfMywgXCJhcHBcIjogXzMsIFwiYXJxXCI6IF8zLCBcImFydFwiOiBfMywgXCJhdG9cIjogXzMsIFwiYlwiOiBfMywgXCJiYXJ1ZXJpXCI6IF8zLCBcImJlbGVtXCI6IF8zLCBcImJldFwiOiBfMywgXCJiaHpcIjogXzMsIFwiYmliXCI6IF8zLCBcImJpb1wiOiBfMywgXCJibG9nXCI6IF8zLCBcImJtZFwiOiBfMywgXCJib2F2aXN0YVwiOiBfMywgXCJic2JcIjogXzMsIFwiY2FtcGluYWdyYW5kZVwiOiBfMywgXCJjYW1waW5hc1wiOiBfMywgXCJjYXhpYXNcIjogXzMsIFwiY2ltXCI6IF8zLCBcImNuZ1wiOiBfMywgXCJjbnRcIjogXzMsIFwiY29tXCI6IFsxLCB7IFwic2ltcGxlc2l0ZVwiOiBfNCB9XSwgXCJjb250YWdlbVwiOiBfMywgXCJjb29wXCI6IF8zLCBcImNvelwiOiBfMywgXCJjcmlcIjogXzMsIFwiY3VpYWJhXCI6IF8zLCBcImN1cml0aWJhXCI6IF8zLCBcImRlZlwiOiBfMywgXCJkZXNcIjogXzMsIFwiZGV0XCI6IF8zLCBcImRldlwiOiBfMywgXCJlY25cIjogXzMsIFwiZWNvXCI6IF8zLCBcImVkdVwiOiBfMywgXCJlbXBcIjogXzMsIFwiZW5mXCI6IF8zLCBcImVuZ1wiOiBfMywgXCJlc3BcIjogXzMsIFwiZXRjXCI6IF8zLCBcImV0aVwiOiBfMywgXCJmYXJcIjogXzMsIFwiZmVpcmFcIjogXzMsIFwiZmxvZ1wiOiBfMywgXCJmbG9yaXBhXCI6IF8zLCBcImZtXCI6IF8zLCBcImZuZFwiOiBfMywgXCJmb3J0YWxcIjogXzMsIFwiZm90XCI6IF8zLCBcImZvelwiOiBfMywgXCJmc3RcIjogXzMsIFwiZzEyXCI6IF8zLCBcImdlb1wiOiBfMywgXCJnZ2ZcIjogXzMsIFwiZ29pYW5pYVwiOiBfMywgXCJnb3ZcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJhbFwiOiBfMywgXCJhbVwiOiBfMywgXCJhcFwiOiBfMywgXCJiYVwiOiBfMywgXCJjZVwiOiBfMywgXCJkZlwiOiBfMywgXCJlc1wiOiBfMywgXCJnb1wiOiBfMywgXCJtYVwiOiBfMywgXCJtZ1wiOiBfMywgXCJtc1wiOiBfMywgXCJtdFwiOiBfMywgXCJwYVwiOiBfMywgXCJwYlwiOiBfMywgXCJwZVwiOiBfMywgXCJwaVwiOiBfMywgXCJwclwiOiBfMywgXCJyalwiOiBfMywgXCJyblwiOiBfMywgXCJyb1wiOiBfMywgXCJyclwiOiBfMywgXCJyc1wiOiBfMywgXCJzY1wiOiBfMywgXCJzZVwiOiBfMywgXCJzcFwiOiBfMywgXCJ0b1wiOiBfMyB9XSwgXCJncnVcIjogXzMsIFwiaW1iXCI6IF8zLCBcImluZFwiOiBfMywgXCJpbmZcIjogXzMsIFwiamFiXCI6IF8zLCBcImphbXBhXCI6IF8zLCBcImpkZlwiOiBfMywgXCJqb2ludmlsbGVcIjogXzMsIFwiam9yXCI6IF8zLCBcImp1c1wiOiBfMywgXCJsZWdcIjogWzEsIHsgXCJhY1wiOiBfNCwgXCJhbFwiOiBfNCwgXCJhbVwiOiBfNCwgXCJhcFwiOiBfNCwgXCJiYVwiOiBfNCwgXCJjZVwiOiBfNCwgXCJkZlwiOiBfNCwgXCJlc1wiOiBfNCwgXCJnb1wiOiBfNCwgXCJtYVwiOiBfNCwgXCJtZ1wiOiBfNCwgXCJtc1wiOiBfNCwgXCJtdFwiOiBfNCwgXCJwYVwiOiBfNCwgXCJwYlwiOiBfNCwgXCJwZVwiOiBfNCwgXCJwaVwiOiBfNCwgXCJwclwiOiBfNCwgXCJyalwiOiBfNCwgXCJyblwiOiBfNCwgXCJyb1wiOiBfNCwgXCJyclwiOiBfNCwgXCJyc1wiOiBfNCwgXCJzY1wiOiBfNCwgXCJzZVwiOiBfNCwgXCJzcFwiOiBfNCwgXCJ0b1wiOiBfNCB9XSwgXCJsZWlsYW9cIjogXzMsIFwibGVsXCI6IF8zLCBcImxvZ1wiOiBfMywgXCJsb25kcmluYVwiOiBfMywgXCJtYWNhcGFcIjogXzMsIFwibWFjZWlvXCI6IF8zLCBcIm1hbmF1c1wiOiBfMywgXCJtYXJpbmdhXCI6IF8zLCBcIm1hdFwiOiBfMywgXCJtZWRcIjogXzMsIFwibWlsXCI6IF8zLCBcIm1vcmVuYVwiOiBfMywgXCJtcFwiOiBfMywgXCJtdXNcIjogXzMsIFwibmF0YWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm5pdGVyb2lcIjogXzMsIFwibm9tXCI6IF8xNywgXCJub3RcIjogXzMsIFwibnRyXCI6IF8zLCBcIm9kb1wiOiBfMywgXCJvbmdcIjogXzMsIFwib3JnXCI6IF8zLCBcIm9zYXNjb1wiOiBfMywgXCJwYWxtYXNcIjogXzMsIFwicG9hXCI6IF8zLCBcInBwZ1wiOiBfMywgXCJwcm9cIjogXzMsIFwicHNjXCI6IF8zLCBcInBzaVwiOiBfMywgXCJwdmhcIjogXzMsIFwicXNsXCI6IF8zLCBcInJhZGlvXCI6IF8zLCBcInJlY1wiOiBfMywgXCJyZWNpZmVcIjogXzMsIFwicmVwXCI6IF8zLCBcInJpYmVpcmFvXCI6IF8zLCBcInJpb1wiOiBfMywgXCJyaW9icmFuY29cIjogXzMsIFwicmlvcHJldG9cIjogXzMsIFwic2FsdmFkb3JcIjogXzMsIFwic2FtcGFcIjogXzMsIFwic2FudGFtYXJpYVwiOiBfMywgXCJzYW50b2FuZHJlXCI6IF8zLCBcInNhb2Jlcm5hcmRvXCI6IF8zLCBcInNhb2dvbmNhXCI6IF8zLCBcInNlZ1wiOiBfMywgXCJzamNcIjogXzMsIFwic2xnXCI6IF8zLCBcInNselwiOiBfMywgXCJzb3JvY2FiYVwiOiBfMywgXCJzcnZcIjogXzMsIFwidGF4aVwiOiBfMywgXCJ0Y1wiOiBfMywgXCJ0ZWNcIjogXzMsIFwidGVvXCI6IF8zLCBcInRoZVwiOiBfMywgXCJ0bXBcIjogXzMsIFwidHJkXCI6IF8zLCBcInR1clwiOiBfMywgXCJ0dlwiOiBfMywgXCJ1ZGlcIjogXzMsIFwidmV0XCI6IF8zLCBcInZpeFwiOiBfMywgXCJ2bG9nXCI6IF8zLCBcIndpa2lcIjogXzMsIFwiemxnXCI6IF8zIH1dLCBcImJzXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ3ZVwiOiBfNCB9XSwgXCJidFwiOiBfNSwgXCJidlwiOiBfMywgXCJid1wiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcImJ5XCI6IFsxLCB7IFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJjb21cIjogXzMsIFwib2ZcIjogXzMsIFwibWVkaWF0ZWNoXCI6IF80IH1dLCBcImJ6XCI6IFsxLCB7IFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ6YVwiOiBfNCwgXCJteWRuc1wiOiBfNCwgXCJnc2pcIjogXzQgfV0sIFwiY2FcIjogWzEsIHsgXCJhYlwiOiBfMywgXCJiY1wiOiBfMywgXCJtYlwiOiBfMywgXCJuYlwiOiBfMywgXCJuZlwiOiBfMywgXCJubFwiOiBfMywgXCJuc1wiOiBfMywgXCJudFwiOiBfMywgXCJudVwiOiBfMywgXCJvblwiOiBfMywgXCJwZVwiOiBfMywgXCJxY1wiOiBfMywgXCJza1wiOiBfMywgXCJ5a1wiOiBfMywgXCJnY1wiOiBfMywgXCJiYXJzeVwiOiBfNCwgXCJhd2RldlwiOiBfNywgXCJjb1wiOiBfNCwgXCJuby1pcFwiOiBfNCwgXCJteXNwcmVhZHNob3BcIjogXzQsIFwiYm94XCI6IF80IH1dLCBcImNhdFwiOiBfMywgXCJjY1wiOiBbMSwgeyBcImNsZXZlcmFwcHNcIjogXzQsIFwiY2xvdWRuc1wiOiBfNCwgXCJmdHBhY2Nlc3NcIjogXzQsIFwiZ2FtZS1zZXJ2ZXJcIjogXzQsIFwibXlwaG90b3NcIjogXzQsIFwic2NyYXBwaW5nXCI6IF80LCBcInR3bWFpbFwiOiBfNCwgXCJjc3hcIjogXzQsIFwiZmFudGFzeWxlYWd1ZVwiOiBfNCwgXCJzcGF3blwiOiBbMCwgeyBcImluc3RhbmNlc1wiOiBfNCB9XSB9XSwgXCJjZFwiOiBfMTAsIFwiY2ZcIjogXzMsIFwiY2dcIjogXzMsIFwiY2hcIjogWzEsIHsgXCJzcXVhcmU3XCI6IF80LCBcImNsb3VkbnNcIjogXzQsIFwiY2xvdWRzY2FsZVwiOiBbMCwgeyBcImN1c3RcIjogXzQsIFwibHBnXCI6IF8xOSwgXCJybWFcIjogXzE5IH1dLCBcImZsb3dcIjogWzAsIHsgXCJhZVwiOiBbMCwgeyBcImFscDFcIjogXzQgfV0sIFwiYXBwZW5naW5lXCI6IF80IH1dLCBcImxpbmt5YXJkLWNsb3VkXCI6IF80LCBcImdvdGRuc1wiOiBfNCwgXCJkbnNraW5nXCI6IF80LCBcIjEyM3dlYnNpdGVcIjogXzQsIFwibXlzcHJlYWRzaG9wXCI6IF80LCBcImZpcmVuZXRcIjogWzAsIHsgXCIqXCI6IF80LCBcInN2Y1wiOiBfNyB9XSwgXCIxMmhwXCI6IF80LCBcIjJpeFwiOiBfNCwgXCI0bGltYVwiOiBfNCwgXCJsaW1hLWNpdHlcIjogXzQgfV0sIFwiY2lcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJ4bi0tYXJvcG9ydC1ieWFcIjogXzMsIFwiYcOpcm9wb3J0XCI6IF8zLCBcImFzc29cIjogXzMsIFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb1wiOiBfMywgXCJnb3V2XCI6IF8zLCBcImludFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcImNrXCI6IF8xNywgXCJjbFwiOiBbMSwgeyBcImNvXCI6IF8zLCBcImdvYlwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcImNsb3VkbnNcIjogXzQgfV0sIFwiY21cIjogWzEsIHsgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZ292XCI6IF8zLCBcIm5ldFwiOiBfMyB9XSwgXCJjblwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvbVwiOiBbMSwgeyBcImFtYXpvbmF3c1wiOiBbMCwgeyBcImNuLW5vcnRoLTFcIjogWzAsIHsgXCJleGVjdXRlLWFwaVwiOiBfNCwgXCJlbXJhcHB1aS1wcm9kXCI6IF80LCBcImVtcm5vdGVib29rcy1wcm9kXCI6IF80LCBcImVtcnN0dWRpby1wcm9kXCI6IF80LCBcImR1YWxzdGFja1wiOiBfMjIsIFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtZGVwcmVjYXRlZFwiOiBfNCwgXCJzMy1vYmplY3QtbGFtYmRhXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQgfV0sIFwiY24tbm9ydGh3ZXN0LTFcIjogWzAsIHsgXCJleGVjdXRlLWFwaVwiOiBfNCwgXCJlbXJhcHB1aS1wcm9kXCI6IF80LCBcImVtcm5vdGVib29rcy1wcm9kXCI6IF80LCBcImVtcnN0dWRpby1wcm9kXCI6IF80LCBcImR1YWxzdGFja1wiOiBfMjMsIFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtb2JqZWN0LWxhbWJkYVwiOiBfNCwgXCJzMy13ZWJzaXRlXCI6IF80IH1dLCBcImNvbXB1dGVcIjogXzcsIFwiYWlyZmxvd1wiOiBbMCwgeyBcImNuLW5vcnRoLTFcIjogXzcsIFwiY24tbm9ydGh3ZXN0LTFcIjogXzcgfV0sIFwiZWJcIjogWzAsIHsgXCJjbi1ub3J0aC0xXCI6IF80LCBcImNuLW5vcnRod2VzdC0xXCI6IF80IH1dLCBcImVsYlwiOiBfNyB9XSwgXCJzYWdlbWFrZXJcIjogWzAsIHsgXCJjbi1ub3J0aC0xXCI6IF8xMiwgXCJjbi1ub3J0aHdlc3QtMVwiOiBfMTIgfV0gfV0sIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ4bi0tNTVxeDVkXCI6IF8zLCBcIuWFrOWPuFwiOiBfMywgXCJ4bi0tb2QwYWxnXCI6IF8zLCBcIue2sue1oVwiOiBfMywgXCJ4bi0taW8wYTdpXCI6IF8zLCBcIue9kee7nFwiOiBfMywgXCJhaFwiOiBfMywgXCJialwiOiBfMywgXCJjcVwiOiBfMywgXCJmalwiOiBfMywgXCJnZFwiOiBfMywgXCJnc1wiOiBfMywgXCJneFwiOiBfMywgXCJnelwiOiBfMywgXCJoYVwiOiBfMywgXCJoYlwiOiBfMywgXCJoZVwiOiBfMywgXCJoaVwiOiBfMywgXCJoa1wiOiBfMywgXCJobFwiOiBfMywgXCJoblwiOiBfMywgXCJqbFwiOiBfMywgXCJqc1wiOiBfMywgXCJqeFwiOiBfMywgXCJsblwiOiBfMywgXCJtb1wiOiBfMywgXCJubVwiOiBfMywgXCJueFwiOiBfMywgXCJxaFwiOiBfMywgXCJzY1wiOiBfMywgXCJzZFwiOiBfMywgXCJzaFwiOiBbMSwgeyBcImFzXCI6IF80IH1dLCBcInNuXCI6IF8zLCBcInN4XCI6IF8zLCBcInRqXCI6IF8zLCBcInR3XCI6IF8zLCBcInhqXCI6IF8zLCBcInh6XCI6IF8zLCBcInluXCI6IF8zLCBcInpqXCI6IF8zLCBcImNhbnZhLWFwcHNcIjogXzQsIFwiY2FudmFzaXRlXCI6IF8yMSwgXCJteXFuYXBjbG91ZFwiOiBfNCwgXCJxdWlja2Nvbm5lY3RcIjogXzI0IH1dLCBcImNvXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJub21cIjogXzMsIFwib3JnXCI6IF8zLCBcImNhcnJkXCI6IF80LCBcImNyZFwiOiBfNCwgXCJvdGFwXCI6IF83LCBcImxlYWRwYWdlc1wiOiBfNCwgXCJscGFnZXNcIjogXzQsIFwibXlwaVwiOiBfNCwgXCJ4bWl0XCI6IF83LCBcImZpcmV3YWxsZWRyZXBsaXRcIjogXzksIFwicmVwbFwiOiBfOSwgXCJzdXBhYmFzZVwiOiBfNCB9XSwgXCJjb21cIjogWzEsIHsgXCJhMmhvc3RlZFwiOiBfNCwgXCJjcHNlcnZlclwiOiBfNCwgXCJhZG9iZWFlbWNsb3VkXCI6IFsyLCB7IFwiZGV2XCI6IF83IH1dLCBcImFmcmljYVwiOiBfNCwgXCJhaXJraXRhcHBzXCI6IF80LCBcImFpcmtpdGFwcHMtYXVcIjogXzQsIFwiYWl2ZW5jbG91ZFwiOiBfNCwgXCJrYXNzZXJ2ZXJcIjogXzQsIFwiYW1hem9uYXdzXCI6IFswLCB7IFwiYWYtc291dGgtMVwiOiBfMjcsIFwiYXAtZWFzdC0xXCI6IF8yOCwgXCJhcC1ub3J0aGVhc3QtMVwiOiBfMjksIFwiYXAtbm9ydGhlYXN0LTJcIjogXzI5LCBcImFwLW5vcnRoZWFzdC0zXCI6IF8yNywgXCJhcC1zb3V0aC0xXCI6IF8yOSwgXCJhcC1zb3V0aC0yXCI6IF8zMCwgXCJhcC1zb3V0aGVhc3QtMVwiOiBfMjksIFwiYXAtc291dGhlYXN0LTJcIjogXzI5LCBcImFwLXNvdXRoZWFzdC0zXCI6IF8zMCwgXCJhcC1zb3V0aGVhc3QtNFwiOiBfMzAsIFwiYXAtc291dGhlYXN0LTVcIjogWzAsIHsgXCJleGVjdXRlLWFwaVwiOiBfNCwgXCJkdWFsc3RhY2tcIjogXzIyLCBcInMzXCI6IF80LCBcInMzLWFjY2Vzc3BvaW50XCI6IF80LCBcInMzLWRlcHJlY2F0ZWRcIjogXzQsIFwiczMtb2JqZWN0LWxhbWJkYVwiOiBfNCwgXCJzMy13ZWJzaXRlXCI6IF80IH1dLCBcImNhLWNlbnRyYWwtMVwiOiBfMzIsIFwiY2Etd2VzdC0xXCI6IFswLCB7IFwiZXhlY3V0ZS1hcGlcIjogXzQsIFwiZW1yYXBwdWktcHJvZFwiOiBfNCwgXCJlbXJub3RlYm9va3MtcHJvZFwiOiBfNCwgXCJlbXJzdHVkaW8tcHJvZFwiOiBfNCwgXCJkdWFsc3RhY2tcIjogXzMxLCBcInMzXCI6IF80LCBcInMzLWFjY2Vzc3BvaW50XCI6IF80LCBcInMzLWFjY2Vzc3BvaW50LWZpcHNcIjogXzQsIFwiczMtZmlwc1wiOiBfNCwgXCJzMy1vYmplY3QtbGFtYmRhXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQgfV0sIFwiZXUtY2VudHJhbC0xXCI6IF8yOSwgXCJldS1jZW50cmFsLTJcIjogXzMwLCBcImV1LW5vcnRoLTFcIjogXzI4LCBcImV1LXNvdXRoLTFcIjogXzI3LCBcImV1LXNvdXRoLTJcIjogXzMwLCBcImV1LXdlc3QtMVwiOiBbMCwgeyBcImV4ZWN1dGUtYXBpXCI6IF80LCBcImVtcmFwcHVpLXByb2RcIjogXzQsIFwiZW1ybm90ZWJvb2tzLXByb2RcIjogXzQsIFwiZW1yc3R1ZGlvLXByb2RcIjogXzQsIFwiZHVhbHN0YWNrXCI6IF8yMiwgXCJzM1wiOiBfNCwgXCJzMy1hY2Nlc3Nwb2ludFwiOiBfNCwgXCJzMy1kZXByZWNhdGVkXCI6IF80LCBcInMzLW9iamVjdC1sYW1iZGFcIjogXzQsIFwiczMtd2Vic2l0ZVwiOiBfNCwgXCJhbmFseXRpY3MtZ2F0ZXdheVwiOiBfNCwgXCJhd3MtY2xvdWQ5XCI6IF8yNSwgXCJjbG91ZDlcIjogXzI2IH1dLCBcImV1LXdlc3QtMlwiOiBfMjgsIFwiZXUtd2VzdC0zXCI6IF8yNywgXCJpbC1jZW50cmFsLTFcIjogWzAsIHsgXCJleGVjdXRlLWFwaVwiOiBfNCwgXCJlbXJhcHB1aS1wcm9kXCI6IF80LCBcImVtcm5vdGVib29rcy1wcm9kXCI6IF80LCBcImVtcnN0dWRpby1wcm9kXCI6IF80LCBcImR1YWxzdGFja1wiOiBfMjIsIFwiczNcIjogXzQsIFwiczMtYWNjZXNzcG9pbnRcIjogXzQsIFwiczMtb2JqZWN0LWxhbWJkYVwiOiBfNCwgXCJzMy13ZWJzaXRlXCI6IF80LCBcImF3cy1jbG91ZDlcIjogXzI1LCBcImNsb3VkOVwiOiBbMCwgeyBcInZmc1wiOiBfNCB9XSB9XSwgXCJtZS1jZW50cmFsLTFcIjogXzMwLCBcIm1lLXNvdXRoLTFcIjogXzI4LCBcInNhLWVhc3QtMVwiOiBfMjcsIFwidXMtZWFzdC0xXCI6IFsyLCB7IFwiZXhlY3V0ZS1hcGlcIjogXzQsIFwiZW1yYXBwdWktcHJvZFwiOiBfNCwgXCJlbXJub3RlYm9va3MtcHJvZFwiOiBfNCwgXCJlbXJzdHVkaW8tcHJvZFwiOiBfNCwgXCJkdWFsc3RhY2tcIjogXzMxLCBcInMzXCI6IF80LCBcInMzLWFjY2Vzc3BvaW50XCI6IF80LCBcInMzLWFjY2Vzc3BvaW50LWZpcHNcIjogXzQsIFwiczMtZGVwcmVjYXRlZFwiOiBfNCwgXCJzMy1maXBzXCI6IF80LCBcInMzLW9iamVjdC1sYW1iZGFcIjogXzQsIFwiczMtd2Vic2l0ZVwiOiBfNCwgXCJhbmFseXRpY3MtZ2F0ZXdheVwiOiBfNCwgXCJhd3MtY2xvdWQ5XCI6IF8yNSwgXCJjbG91ZDlcIjogXzI2IH1dLCBcInVzLWVhc3QtMlwiOiBfMzMsIFwidXMtZ292LWVhc3QtMVwiOiBfMzUsIFwidXMtZ292LXdlc3QtMVwiOiBfMzUsIFwidXMtd2VzdC0xXCI6IF8zMiwgXCJ1cy13ZXN0LTJcIjogXzMzLCBcImNvbXB1dGVcIjogXzcsIFwiY29tcHV0ZS0xXCI6IF83LCBcImFpcmZsb3dcIjogWzAsIHsgXCJhZi1zb3V0aC0xXCI6IF83LCBcImFwLWVhc3QtMVwiOiBfNywgXCJhcC1ub3J0aGVhc3QtMVwiOiBfNywgXCJhcC1ub3J0aGVhc3QtMlwiOiBfNywgXCJhcC1ub3J0aGVhc3QtM1wiOiBfNywgXCJhcC1zb3V0aC0xXCI6IF83LCBcImFwLXNvdXRoLTJcIjogXzcsIFwiYXAtc291dGhlYXN0LTFcIjogXzcsIFwiYXAtc291dGhlYXN0LTJcIjogXzcsIFwiYXAtc291dGhlYXN0LTNcIjogXzcsIFwiYXAtc291dGhlYXN0LTRcIjogXzcsIFwiY2EtY2VudHJhbC0xXCI6IF83LCBcImNhLXdlc3QtMVwiOiBfNywgXCJldS1jZW50cmFsLTFcIjogXzcsIFwiZXUtY2VudHJhbC0yXCI6IF83LCBcImV1LW5vcnRoLTFcIjogXzcsIFwiZXUtc291dGgtMVwiOiBfNywgXCJldS1zb3V0aC0yXCI6IF83LCBcImV1LXdlc3QtMVwiOiBfNywgXCJldS13ZXN0LTJcIjogXzcsIFwiZXUtd2VzdC0zXCI6IF83LCBcImlsLWNlbnRyYWwtMVwiOiBfNywgXCJtZS1jZW50cmFsLTFcIjogXzcsIFwibWUtc291dGgtMVwiOiBfNywgXCJzYS1lYXN0LTFcIjogXzcsIFwidXMtZWFzdC0xXCI6IF83LCBcInVzLWVhc3QtMlwiOiBfNywgXCJ1cy13ZXN0LTFcIjogXzcsIFwidXMtd2VzdC0yXCI6IF83IH1dLCBcInMzXCI6IF80LCBcInMzLTFcIjogXzQsIFwiczMtYXAtZWFzdC0xXCI6IF80LCBcInMzLWFwLW5vcnRoZWFzdC0xXCI6IF80LCBcInMzLWFwLW5vcnRoZWFzdC0yXCI6IF80LCBcInMzLWFwLW5vcnRoZWFzdC0zXCI6IF80LCBcInMzLWFwLXNvdXRoLTFcIjogXzQsIFwiczMtYXAtc291dGhlYXN0LTFcIjogXzQsIFwiczMtYXAtc291dGhlYXN0LTJcIjogXzQsIFwiczMtY2EtY2VudHJhbC0xXCI6IF80LCBcInMzLWV1LWNlbnRyYWwtMVwiOiBfNCwgXCJzMy1ldS1ub3J0aC0xXCI6IF80LCBcInMzLWV1LXdlc3QtMVwiOiBfNCwgXCJzMy1ldS13ZXN0LTJcIjogXzQsIFwiczMtZXUtd2VzdC0zXCI6IF80LCBcInMzLWV4dGVybmFsLTFcIjogXzQsIFwiczMtZmlwcy11cy1nb3YtZWFzdC0xXCI6IF80LCBcInMzLWZpcHMtdXMtZ292LXdlc3QtMVwiOiBfNCwgXCJzMy1nbG9iYWxcIjogWzAsIHsgXCJhY2Nlc3Nwb2ludFwiOiBbMCwgeyBcIm1yYXBcIjogXzQgfV0gfV0sIFwiczMtbWUtc291dGgtMVwiOiBfNCwgXCJzMy1zYS1lYXN0LTFcIjogXzQsIFwiczMtdXMtZWFzdC0yXCI6IF80LCBcInMzLXVzLWdvdi1lYXN0LTFcIjogXzQsIFwiczMtdXMtZ292LXdlc3QtMVwiOiBfNCwgXCJzMy11cy13ZXN0LTFcIjogXzQsIFwiczMtdXMtd2VzdC0yXCI6IF80LCBcInMzLXdlYnNpdGUtYXAtbm9ydGhlYXN0LTFcIjogXzQsIFwiczMtd2Vic2l0ZS1hcC1zb3V0aGVhc3QtMVwiOiBfNCwgXCJzMy13ZWJzaXRlLWFwLXNvdXRoZWFzdC0yXCI6IF80LCBcInMzLXdlYnNpdGUtZXUtd2VzdC0xXCI6IF80LCBcInMzLXdlYnNpdGUtc2EtZWFzdC0xXCI6IF80LCBcInMzLXdlYnNpdGUtdXMtZWFzdC0xXCI6IF80LCBcInMzLXdlYnNpdGUtdXMtZ292LXdlc3QtMVwiOiBfNCwgXCJzMy13ZWJzaXRlLXVzLXdlc3QtMVwiOiBfNCwgXCJzMy13ZWJzaXRlLXVzLXdlc3QtMlwiOiBfNCwgXCJlbGJcIjogXzcgfV0sIFwiYW1hem9uY29nbml0b1wiOiBbMCwgeyBcImFmLXNvdXRoLTFcIjogXzM2LCBcImFwLWVhc3QtMVwiOiBfMzYsIFwiYXAtbm9ydGhlYXN0LTFcIjogXzM2LCBcImFwLW5vcnRoZWFzdC0yXCI6IF8zNiwgXCJhcC1ub3J0aGVhc3QtM1wiOiBfMzYsIFwiYXAtc291dGgtMVwiOiBfMzYsIFwiYXAtc291dGgtMlwiOiBfMzYsIFwiYXAtc291dGhlYXN0LTFcIjogXzM2LCBcImFwLXNvdXRoZWFzdC0yXCI6IF8zNiwgXCJhcC1zb3V0aGVhc3QtM1wiOiBfMzYsIFwiYXAtc291dGhlYXN0LTRcIjogXzM2LCBcImNhLWNlbnRyYWwtMVwiOiBfMzYsIFwiY2Etd2VzdC0xXCI6IF8zNiwgXCJldS1jZW50cmFsLTFcIjogXzM2LCBcImV1LWNlbnRyYWwtMlwiOiBfMzYsIFwiZXUtbm9ydGgtMVwiOiBfMzYsIFwiZXUtc291dGgtMVwiOiBfMzYsIFwiZXUtc291dGgtMlwiOiBfMzYsIFwiZXUtd2VzdC0xXCI6IF8zNiwgXCJldS13ZXN0LTJcIjogXzM2LCBcImV1LXdlc3QtM1wiOiBfMzYsIFwiaWwtY2VudHJhbC0xXCI6IF8zNiwgXCJtZS1jZW50cmFsLTFcIjogXzM2LCBcIm1lLXNvdXRoLTFcIjogXzM2LCBcInNhLWVhc3QtMVwiOiBfMzYsIFwidXMtZWFzdC0xXCI6IF8zNywgXCJ1cy1lYXN0LTJcIjogXzM3LCBcInVzLWdvdi13ZXN0LTFcIjogWzAsIHsgXCJhdXRoLWZpcHNcIjogXzQgfV0sIFwidXMtd2VzdC0xXCI6IF8zNywgXCJ1cy13ZXN0LTJcIjogXzM3IH1dLCBcImFtcGxpZnlhcHBcIjogXzQsIFwiYXdzYXBwcnVubmVyXCI6IF83LCBcImF3c2FwcHNcIjogXzQsIFwiZWxhc3RpY2JlYW5zdGFsa1wiOiBbMiwgeyBcImFmLXNvdXRoLTFcIjogXzQsIFwiYXAtZWFzdC0xXCI6IF80LCBcImFwLW5vcnRoZWFzdC0xXCI6IF80LCBcImFwLW5vcnRoZWFzdC0yXCI6IF80LCBcImFwLW5vcnRoZWFzdC0zXCI6IF80LCBcImFwLXNvdXRoLTFcIjogXzQsIFwiYXAtc291dGhlYXN0LTFcIjogXzQsIFwiYXAtc291dGhlYXN0LTJcIjogXzQsIFwiYXAtc291dGhlYXN0LTNcIjogXzQsIFwiY2EtY2VudHJhbC0xXCI6IF80LCBcImV1LWNlbnRyYWwtMVwiOiBfNCwgXCJldS1ub3J0aC0xXCI6IF80LCBcImV1LXNvdXRoLTFcIjogXzQsIFwiZXUtd2VzdC0xXCI6IF80LCBcImV1LXdlc3QtMlwiOiBfNCwgXCJldS13ZXN0LTNcIjogXzQsIFwiaWwtY2VudHJhbC0xXCI6IF80LCBcIm1lLXNvdXRoLTFcIjogXzQsIFwic2EtZWFzdC0xXCI6IF80LCBcInVzLWVhc3QtMVwiOiBfNCwgXCJ1cy1lYXN0LTJcIjogXzQsIFwidXMtZ292LWVhc3QtMVwiOiBfNCwgXCJ1cy1nb3Ytd2VzdC0xXCI6IF80LCBcInVzLXdlc3QtMVwiOiBfNCwgXCJ1cy13ZXN0LTJcIjogXzQgfV0sIFwiYXdzZ2xvYmFsYWNjZWxlcmF0b3JcIjogXzQsIFwic2lpaXRlc1wiOiBfNCwgXCJhcHBzcGFjZWhvc3RlZFwiOiBfNCwgXCJhcHBzcGFjZXVzZXJjb250ZW50XCI6IF80LCBcIm9uLWFwdGlibGVcIjogXzQsIFwibXlhc3VzdG9yXCI6IF80LCBcImJhbGVuYS1kZXZpY2VzXCI6IF80LCBcImJvdXRpclwiOiBfNCwgXCJicGxhY2VkXCI6IF80LCBcImNhZmpzXCI6IF80LCBcImNhbnZhLWFwcHNcIjogXzQsIFwiY2RuNzctc3RvcmFnZVwiOiBfNCwgXCJiclwiOiBfNCwgXCJjblwiOiBfNCwgXCJkZVwiOiBfNCwgXCJldVwiOiBfNCwgXCJqcG5cIjogXzQsIFwibWV4XCI6IF80LCBcInJ1XCI6IF80LCBcInNhXCI6IF80LCBcInVrXCI6IF80LCBcInVzXCI6IF80LCBcInphXCI6IF80LCBcImNsZXZlci1jbG91ZFwiOiBbMCwgeyBcInNlcnZpY2VzXCI6IF83IH1dLCBcImRuc2FiclwiOiBfNCwgXCJpcC1kZG5zXCI6IF80LCBcImpkZXZjbG91ZFwiOiBfNCwgXCJ3cGRldmNsb3VkXCI6IF80LCBcImNmLWlwZnNcIjogXzQsIFwiY2xvdWRmbGFyZS1pcGZzXCI6IF80LCBcInRyeWNsb3VkZmxhcmVcIjogXzQsIFwiY29cIjogXzQsIFwiYnVpbHR3aXRoZGFya1wiOiBfNCwgXCJkYXRhZGV0ZWN0XCI6IFswLCB7IFwiZGVtb1wiOiBfNCwgXCJpbnN0YW5jZVwiOiBfNCB9XSwgXCJkYXR0b2xvY2FsXCI6IF80LCBcImRhdHRvcmVsYXlcIjogXzQsIFwiZGF0dG93ZWJcIjogXzQsIFwibXlkYXR0b1wiOiBfNCwgXCJkaWdpdGFsb2NlYW5zcGFjZXNcIjogXzcsIFwiZGlzY29yZHNheXNcIjogXzQsIFwiZGlzY29yZHNlelwiOiBfNCwgXCJkcmF5ZGRuc1wiOiBfNCwgXCJkcmVhbWhvc3RlcnNcIjogXzQsIFwiZHVydW1pc1wiOiBfNCwgXCJteWRyb2JvXCI6IF80LCBcImJsb2dkbnNcIjogXzQsIFwiY2VjaGlyZVwiOiBfNCwgXCJkbnNhbGlhc1wiOiBfNCwgXCJkbnNkb2pvXCI6IF80LCBcImRvZXNudGV4aXN0XCI6IF80LCBcImRvbnRleGlzdFwiOiBfNCwgXCJkb29tZG5zXCI6IF80LCBcImR5bi1vLXNhdXJcIjogXzQsIFwiZHluYWxpYXNcIjogXzQsIFwiZHluZG5zLWF0LWhvbWVcIjogXzQsIFwiZHluZG5zLWF0LXdvcmtcIjogXzQsIFwiZHluZG5zLWJsb2dcIjogXzQsIFwiZHluZG5zLWZyZWVcIjogXzQsIFwiZHluZG5zLWhvbWVcIjogXzQsIFwiZHluZG5zLWlwXCI6IF80LCBcImR5bmRucy1tYWlsXCI6IF80LCBcImR5bmRucy1vZmZpY2VcIjogXzQsIFwiZHluZG5zLXBpY3NcIjogXzQsIFwiZHluZG5zLXJlbW90ZVwiOiBfNCwgXCJkeW5kbnMtc2VydmVyXCI6IF80LCBcImR5bmRucy13ZWJcIjogXzQsIFwiZHluZG5zLXdpa2lcIjogXzQsIFwiZHluZG5zLXdvcmtcIjogXzQsIFwiZXN0LWEtbGEtbWFpc29uXCI6IF80LCBcImVzdC1hLWxhLW1hc2lvblwiOiBfNCwgXCJlc3QtbGUtcGF0cm9uXCI6IF80LCBcImVzdC1tb24tYmxvZ3VldXJcIjogXzQsIFwiZnJvbS1ha1wiOiBfNCwgXCJmcm9tLWFsXCI6IF80LCBcImZyb20tYXJcIjogXzQsIFwiZnJvbS1jYVwiOiBfNCwgXCJmcm9tLWN0XCI6IF80LCBcImZyb20tZGNcIjogXzQsIFwiZnJvbS1kZVwiOiBfNCwgXCJmcm9tLWZsXCI6IF80LCBcImZyb20tZ2FcIjogXzQsIFwiZnJvbS1oaVwiOiBfNCwgXCJmcm9tLWlhXCI6IF80LCBcImZyb20taWRcIjogXzQsIFwiZnJvbS1pbFwiOiBfNCwgXCJmcm9tLWluXCI6IF80LCBcImZyb20ta3NcIjogXzQsIFwiZnJvbS1reVwiOiBfNCwgXCJmcm9tLW1hXCI6IF80LCBcImZyb20tbWRcIjogXzQsIFwiZnJvbS1taVwiOiBfNCwgXCJmcm9tLW1uXCI6IF80LCBcImZyb20tbW9cIjogXzQsIFwiZnJvbS1tc1wiOiBfNCwgXCJmcm9tLW10XCI6IF80LCBcImZyb20tbmNcIjogXzQsIFwiZnJvbS1uZFwiOiBfNCwgXCJmcm9tLW5lXCI6IF80LCBcImZyb20tbmhcIjogXzQsIFwiZnJvbS1ualwiOiBfNCwgXCJmcm9tLW5tXCI6IF80LCBcImZyb20tbnZcIjogXzQsIFwiZnJvbS1vaFwiOiBfNCwgXCJmcm9tLW9rXCI6IF80LCBcImZyb20tb3JcIjogXzQsIFwiZnJvbS1wYVwiOiBfNCwgXCJmcm9tLXByXCI6IF80LCBcImZyb20tcmlcIjogXzQsIFwiZnJvbS1zY1wiOiBfNCwgXCJmcm9tLXNkXCI6IF80LCBcImZyb20tdG5cIjogXzQsIFwiZnJvbS10eFwiOiBfNCwgXCJmcm9tLXV0XCI6IF80LCBcImZyb20tdmFcIjogXzQsIFwiZnJvbS12dFwiOiBfNCwgXCJmcm9tLXdhXCI6IF80LCBcImZyb20td2lcIjogXzQsIFwiZnJvbS13dlwiOiBfNCwgXCJmcm9tLXd5XCI6IF80LCBcImdldG15aXBcIjogXzQsIFwiZ290ZG5zXCI6IF80LCBcImhvYmJ5LXNpdGVcIjogXzQsIFwiaG9tZWxpbnV4XCI6IF80LCBcImhvbWV1bml4XCI6IF80LCBcImlhbWFsbGFtYVwiOiBfNCwgXCJpcy1hLWFuYXJjaGlzdFwiOiBfNCwgXCJpcy1hLWJsb2dnZXJcIjogXzQsIFwiaXMtYS1ib29ra2VlcGVyXCI6IF80LCBcImlzLWEtYnVsbHMtZmFuXCI6IF80LCBcImlzLWEtY2F0ZXJlclwiOiBfNCwgXCJpcy1hLWNoZWZcIjogXzQsIFwiaXMtYS1jb25zZXJ2YXRpdmVcIjogXzQsIFwiaXMtYS1jcGFcIjogXzQsIFwiaXMtYS1jdWJpY2xlLXNsYXZlXCI6IF80LCBcImlzLWEtZGVtb2NyYXRcIjogXzQsIFwiaXMtYS1kZXNpZ25lclwiOiBfNCwgXCJpcy1hLWRvY3RvclwiOiBfNCwgXCJpcy1hLWZpbmFuY2lhbGFkdmlzb3JcIjogXzQsIFwiaXMtYS1nZWVrXCI6IF80LCBcImlzLWEtZ3JlZW5cIjogXzQsIFwiaXMtYS1ndXJ1XCI6IF80LCBcImlzLWEtaGFyZC13b3JrZXJcIjogXzQsIFwiaXMtYS1odW50ZXJcIjogXzQsIFwiaXMtYS1sYW5kc2NhcGVyXCI6IF80LCBcImlzLWEtbGF3eWVyXCI6IF80LCBcImlzLWEtbGliZXJhbFwiOiBfNCwgXCJpcy1hLWxpYmVydGFyaWFuXCI6IF80LCBcImlzLWEtbGxhbWFcIjogXzQsIFwiaXMtYS1tdXNpY2lhblwiOiBfNCwgXCJpcy1hLW5hc2NhcmZhblwiOiBfNCwgXCJpcy1hLW51cnNlXCI6IF80LCBcImlzLWEtcGFpbnRlclwiOiBfNCwgXCJpcy1hLXBlcnNvbmFsdHJhaW5lclwiOiBfNCwgXCJpcy1hLXBob3RvZ3JhcGhlclwiOiBfNCwgXCJpcy1hLXBsYXllclwiOiBfNCwgXCJpcy1hLXJlcHVibGljYW5cIjogXzQsIFwiaXMtYS1yb2Nrc3RhclwiOiBfNCwgXCJpcy1hLXNvY2lhbGlzdFwiOiBfNCwgXCJpcy1hLXN0dWRlbnRcIjogXzQsIFwiaXMtYS10ZWFjaGVyXCI6IF80LCBcImlzLWEtdGVjaGllXCI6IF80LCBcImlzLWEtdGhlcmFwaXN0XCI6IF80LCBcImlzLWFuLWFjY291bnRhbnRcIjogXzQsIFwiaXMtYW4tYWN0b3JcIjogXzQsIFwiaXMtYW4tYWN0cmVzc1wiOiBfNCwgXCJpcy1hbi1hbmFyY2hpc3RcIjogXzQsIFwiaXMtYW4tYXJ0aXN0XCI6IF80LCBcImlzLWFuLWVuZ2luZWVyXCI6IF80LCBcImlzLWFuLWVudGVydGFpbmVyXCI6IF80LCBcImlzLWNlcnRpZmllZFwiOiBfNCwgXCJpcy1nb25lXCI6IF80LCBcImlzLWludG8tYW5pbWVcIjogXzQsIFwiaXMtaW50by1jYXJzXCI6IF80LCBcImlzLWludG8tY2FydG9vbnNcIjogXzQsIFwiaXMtaW50by1nYW1lc1wiOiBfNCwgXCJpcy1sZWV0XCI6IF80LCBcImlzLW5vdC1jZXJ0aWZpZWRcIjogXzQsIFwiaXMtc2xpY2tcIjogXzQsIFwiaXMtdWJlcmxlZXRcIjogXzQsIFwiaXMtd2l0aC10aGViYW5kXCI6IF80LCBcImlzYS1nZWVrXCI6IF80LCBcImlzYS1ob2NrZXludXRcIjogXzQsIFwiaXNzbWFydGVydGhhbnlvdVwiOiBfNCwgXCJsaWtlcy1waWVcIjogXzQsIFwibGlrZXNjYW5keVwiOiBfNCwgXCJuZWF0LXVybFwiOiBfNCwgXCJzYXZlcy10aGUtd2hhbGVzXCI6IF80LCBcInNlbGZpcFwiOiBfNCwgXCJzZWxscy1mb3ItbGVzc1wiOiBfNCwgXCJzZWxscy1mb3ItdVwiOiBfNCwgXCJzZXJ2ZWJic1wiOiBfNCwgXCJzaW1wbGUtdXJsXCI6IF80LCBcInNwYWNlLXRvLXJlbnRcIjogXzQsIFwidGVhY2hlcy15b2dhXCI6IF80LCBcIndyaXRlc3RoaXNibG9nXCI6IF80LCBcImRkbnNmcmVlXCI6IF80LCBcImRkbnNnZWVrXCI6IF80LCBcImdpaXplXCI6IF80LCBcImdsZWV6ZVwiOiBfNCwgXCJrb3pvd1wiOiBfNCwgXCJsb3NleW91cmlwXCI6IF80LCBcIm9vZ3V5XCI6IF80LCBcInRoZXdvcmtwY1wiOiBfNCwgXCJteXR1bGVhcFwiOiBfNCwgXCJ0dWxlYXAtcGFydG5lcnNcIjogXzQsIFwiZW5jb3JlYXBpXCI6IF80LCBcImV2ZW5ub2RlXCI6IFswLCB7IFwiZXUtMVwiOiBfNCwgXCJldS0yXCI6IF80LCBcImV1LTNcIjogXzQsIFwiZXUtNFwiOiBfNCwgXCJ1cy0xXCI6IF80LCBcInVzLTJcIjogXzQsIFwidXMtM1wiOiBfNCwgXCJ1cy00XCI6IF80IH1dLCBcIm9uZmFicmljYVwiOiBfNCwgXCJmYXN0bHktZWRnZVwiOiBfNCwgXCJmYXN0bHktdGVycmFyaXVtXCI6IF80LCBcImZhc3R2cHMtc2VydmVyXCI6IF80LCBcIm15ZG9iaXNzXCI6IF80LCBcImZpcmViYXNlYXBwXCI6IF80LCBcImZsZHJ2XCI6IF80LCBcImZvcmdlYmxvY2tzXCI6IF80LCBcImZyYW1lcmNhbnZhc1wiOiBfNCwgXCJmcmVlYm94LW9zXCI6IF80LCBcImZyZWVib3hvc1wiOiBfNCwgXCJmcmVlbXlpcFwiOiBfNCwgXCJhbGlhc2VzMTIxXCI6IF80LCBcImdlbnRhcHBzXCI6IF80LCBcImdlbnRsZW50YXBpc1wiOiBfNCwgXCJnaXRodWJ1c2VyY29udGVudFwiOiBfNCwgXCIwZW1tXCI6IF83LCBcImFwcHNwb3RcIjogWzIsIHsgXCJyXCI6IF83IH1dLCBcImJsb2dzcG90XCI6IF80LCBcImNvZGVzcG90XCI6IF80LCBcImdvb2dsZWFwaXNcIjogXzQsIFwiZ29vZ2xlY29kZVwiOiBfNCwgXCJwYWdlc3BlZWRtb2JpbGl6ZXJcIjogXzQsIFwid2l0aGdvb2dsZVwiOiBfNCwgXCJ3aXRoeW91dHViZVwiOiBfNCwgXCJncmF5amF5bGVhZ3Vlc1wiOiBfNCwgXCJoYXRlbmFibG9nXCI6IF80LCBcImhhdGVuYWRpYXJ5XCI6IF80LCBcImhlcm9rdWFwcFwiOiBfNCwgXCJnclwiOiBfNCwgXCJzbXVzaGNkblwiOiBfNCwgXCJ3cGhvc3RlZG1haWxcIjogXzQsIFwid3BtdWNkblwiOiBfNCwgXCJwaXhvbGlub1wiOiBfNCwgXCJhcHBzLTFhbmQxXCI6IF80LCBcImxpdmUtd2Vic2l0ZVwiOiBfNCwgXCJkb3BhYXNcIjogXzQsIFwiaG9zdGVkLWJ5LXByZXZpZGVyXCI6IF8zOSwgXCJob3N0ZXVyXCI6IFswLCB7IFwicmFnLWNsb3VkXCI6IF80LCBcInJhZy1jbG91ZC1jaFwiOiBfNCB9XSwgXCJpay1zZXJ2ZXJcIjogWzAsIHsgXCJqY2xvdWRcIjogXzQsIFwiamNsb3VkLXZlci1qcGNcIjogXzQgfV0sIFwiamVsYXN0aWNcIjogWzAsIHsgXCJkZW1vXCI6IF80IH1dLCBcIm1hc3NpdmVncmlkXCI6IF8zOSwgXCJ3YWZhaWNsb3VkXCI6IFswLCB7IFwiamVkXCI6IF80LCBcInJ5ZFwiOiBfNCB9XSwgXCJ3ZWJhZG9yc2l0ZVwiOiBfNCwgXCJqb3llbnRcIjogWzAsIHsgXCJjbnNcIjogXzcgfV0sIFwibHB1c2VyY29udGVudFwiOiBfNCwgXCJsaW5vZGVcIjogWzAsIHsgXCJtZW1iZXJzXCI6IF80LCBcIm5vZGViYWxhbmNlclwiOiBfNyB9XSwgXCJsaW5vZGVvYmplY3RzXCI6IF83LCBcImxpbm9kZXVzZXJjb250ZW50XCI6IFswLCB7IFwiaXBcIjogXzQgfV0sIFwiYmFyc3ljZW50ZXJcIjogXzQsIFwiYmFyc3lvbmxpbmVcIjogXzQsIFwibW9kZWxzY2FwZVwiOiBfNCwgXCJtd2Nsb3Vkbm9ucHJvZFwiOiBfNCwgXCJwb2x5c3BhY2VcIjogXzQsIFwibWF6ZXBsYXlcIjogXzQsIFwibWluaXNlcnZlclwiOiBfNCwgXCJhdG1ldGFcIjogXzQsIFwiZmJzYnhcIjogXzM4LCBcIm1ldGVvcmFwcFwiOiBfNDAsIFwicm91dGluZ3RoZWNsb3VkXCI6IF80LCBcIm15ZGJzZXJ2ZXJcIjogXzQsIFwiaG9zdGVkcGlcIjogXzQsIFwibXl0aGljLWJlYXN0c1wiOiBbMCwgeyBcImNhcmFjYWxcIjogXzQsIFwiY3VzdG9tZXJcIjogXzQsIFwiZmVudGlnZXJcIjogXzQsIFwibHlueFwiOiBfNCwgXCJvY2Vsb3RcIjogXzQsIFwib25jaWxsYVwiOiBfNCwgXCJvbnphXCI6IF80LCBcInNwaGlueFwiOiBfNCwgXCJ2c1wiOiBfNCwgXCJ4XCI6IF80LCBcInlhbGlcIjogXzQgfV0sIFwibm9zcGFtcHJveHlcIjogWzAsIHsgXCJjbG91ZFwiOiBbMiwgeyBcIm8zNjVcIjogXzQgfV0gfV0sIFwiNHVcIjogXzQsIFwibmZzaG9zdFwiOiBfNCwgXCIzdXRpbGl0aWVzXCI6IF80LCBcImJsb2dzeXRlXCI6IF80LCBcImNpc2NvZnJlYWtcIjogXzQsIFwiZGFtbnNlcnZlclwiOiBfNCwgXCJkZG5za2luZ1wiOiBfNCwgXCJkaXRjaHlvdXJpcFwiOiBfNCwgXCJkbnNpc2tpbmt5XCI6IF80LCBcImR5bm5zXCI6IF80LCBcImdlZWtnYWxheHlcIjogXzQsIFwiaGVhbHRoLWNhcmVyZWZvcm1cIjogXzQsIFwiaG9tZXNlY3VyaXR5bWFjXCI6IF80LCBcImhvbWVzZWN1cml0eXBjXCI6IF80LCBcIm15YWN0aXZlZGlyZWN0b3J5XCI6IF80LCBcIm15c2VjdXJpdHljYW1lcmFcIjogXzQsIFwibXl2bmNcIjogXzQsIFwibmV0LWZyZWFrc1wiOiBfNCwgXCJvbnRoZXdpZmlcIjogXzQsIFwicG9pbnQydGhpc1wiOiBfNCwgXCJxdWlja3N5dGVzXCI6IF80LCBcInNlY3VyaXR5dGFjdGljc1wiOiBfNCwgXCJzZXJ2ZWJlZXJcIjogXzQsIFwic2VydmVjb3VudGVyc3RyaWtlXCI6IF80LCBcInNlcnZlZXhjaGFuZ2VcIjogXzQsIFwic2VydmVmdHBcIjogXzQsIFwic2VydmVnYW1lXCI6IF80LCBcInNlcnZlaGFsZmxpZmVcIjogXzQsIFwic2VydmVodHRwXCI6IF80LCBcInNlcnZlaHVtb3VyXCI6IF80LCBcInNlcnZlaXJjXCI6IF80LCBcInNlcnZlbXAzXCI6IF80LCBcInNlcnZlcDJwXCI6IF80LCBcInNlcnZlcGljc1wiOiBfNCwgXCJzZXJ2ZXF1YWtlXCI6IF80LCBcInNlcnZlc2FyY2FzbVwiOiBfNCwgXCJzdHVmZnRvcmVhZFwiOiBfNCwgXCJ1bnVzdWFscGVyc29uXCI6IF80LCBcIndvcmtpc2JvcmluZ1wiOiBfNCwgXCJteWlwaG9zdFwiOiBfNCwgXCJvYnNlcnZhYmxldXNlcmNvbnRlbnRcIjogWzAsIHsgXCJzdGF0aWNcIjogXzQgfV0sIFwic2ltcGxlc2l0ZVwiOiBfNCwgXCJvcnNpdGVzXCI6IF80LCBcIm9wZXJhdW5pdGVcIjogXzQsIFwiY3VzdG9tZXItb2NpXCI6IFswLCB7IFwiKlwiOiBfNCwgXCJvY2lcIjogXzcsIFwib2NwXCI6IF83LCBcIm9jc1wiOiBfNyB9XSwgXCJvcmFjbGVjbG91ZGFwcHNcIjogXzcsIFwib3JhY2xlZ292Y2xvdWRhcHBzXCI6IF83LCBcImF1dGhnZWFyLXN0YWdpbmdcIjogXzQsIFwiYXV0aGdlYXJhcHBzXCI6IF80LCBcInNreWdlYXJhcHBcIjogXzQsIFwib3V0c3lzdGVtc2Nsb3VkXCI6IF80LCBcIm93bnByb3ZpZGVyXCI6IF80LCBcInBnZm9nXCI6IF80LCBcInBhZ2V4bFwiOiBfNCwgXCJnb3RwYW50aGVvblwiOiBfNCwgXCJwYXl3aGlybFwiOiBfNywgXCJ1cHN1bmFwcFwiOiBfNCwgXCJwb3N0bWFuLWVjaG9cIjogXzQsIFwicHJnbXJcIjogWzAsIHsgXCJ4ZW5cIjogXzQgfV0sIFwicHl0aG9uYW55d2hlcmVcIjogXzQwLCBcInFhMlwiOiBfNCwgXCJhbHBoYS1teXFuYXBjbG91ZFwiOiBfNCwgXCJkZXYtbXlxbmFwY2xvdWRcIjogXzQsIFwibXljbG91ZG5hc1wiOiBfNCwgXCJteW5hc2Nsb3VkXCI6IF80LCBcIm15cW5hcGNsb3VkXCI6IF80LCBcInF1YWxpZmlvYXBwXCI6IF80LCBcImxhZGVza1wiOiBfNCwgXCJxYnVzZXJcIjogXzQsIFwicXVpcGVsZW1lbnRzXCI6IF83LCBcInJhY2ttYXplXCI6IF80LCBcInJlYWR0aGVkb2NzLWhvc3RlZFwiOiBfNCwgXCJyaGNsb3VkXCI6IF80LCBcIm9ucmVuZGVyXCI6IF80LCBcInJlbmRlclwiOiBfNDEsIFwic3Vic2MtcGF5XCI6IF80LCBcIjE4MHJcIjogXzQsIFwiZG9qaW5cIjogXzQsIFwic2FrdXJhdGFuXCI6IF80LCBcInNha3VyYXdlYlwiOiBfNCwgXCJ4MFwiOiBfNCwgXCJjb2RlXCI6IFswLCB7IFwiYnVpbGRlclwiOiBfNywgXCJkZXYtYnVpbGRlclwiOiBfNywgXCJzdGctYnVpbGRlclwiOiBfNyB9XSwgXCJzYWxlc2ZvcmNlXCI6IFswLCB7IFwicGxhdGZvcm1cIjogWzAsIHsgXCJjb2RlLWJ1aWxkZXItc3RnXCI6IFswLCB7IFwidGVzdFwiOiBbMCwgeyBcIjAwMVwiOiBfNyB9XSB9XSB9XSB9XSwgXCJsb2dvaXBcIjogXzQsIFwic2NyeXNlY1wiOiBfNCwgXCJmaXJld2FsbC1nYXRld2F5XCI6IF80LCBcIm15c2hvcGJsb2Nrc1wiOiBfNCwgXCJteXNob3BpZnlcIjogXzQsIFwic2hvcGl0c2l0ZVwiOiBfNCwgXCIxa2FwcFwiOiBfNCwgXCJhcHBjaGl6aVwiOiBfNCwgXCJhcHBsaW56aVwiOiBfNCwgXCJzaW5hYXBwXCI6IF80LCBcInZpcHNpbmFhcHBcIjogXzQsIFwic3RyZWFtbGl0YXBwXCI6IF80LCBcInRyeS1zbm93cGxvd1wiOiBfNCwgXCJwbGF5c3RhdGlvbi1jbG91ZFwiOiBfNCwgXCJteXNwcmVhZHNob3BcIjogXzQsIFwidy1jb3JwLXN0YXRpY2JsaXR6XCI6IF80LCBcInctY3JlZGVudGlhbGxlc3Mtc3RhdGljYmxpdHpcIjogXzQsIFwidy1zdGF0aWNibGl0elwiOiBfNCwgXCJzdGFja2hlcm8tbmV0d29ya1wiOiBfNCwgXCJzdGRsaWJcIjogWzAsIHsgXCJhcGlcIjogXzQgfV0sIFwic3RyYXBpYXBwXCI6IFsyLCB7IFwibWVkaWFcIjogXzQgfV0sIFwic3RyZWFrLWxpbmtcIjogXzQsIFwic3RyZWFrbGlua3NcIjogXzQsIFwic3RyZWFrdXNlcmNvbnRlbnRcIjogXzQsIFwidGVtcC1kbnNcIjogXzQsIFwiZHNteW5hc1wiOiBfNCwgXCJmYW1pbHlkc1wiOiBfNCwgXCJteXRhYml0XCI6IF80LCBcInRhdmV1c2VyY29udGVudFwiOiBfNCwgXCJ0Yi1ob3N0aW5nXCI6IF80MiwgXCJyZXNlcnZkXCI6IF80LCBcInRoaW5nZHVzdGRhdGFcIjogXzQsIFwidG93bm5ld3Mtc3RhZ2luZ1wiOiBfNCwgXCJ0eXBlZm9ybVwiOiBbMCwgeyBcInByb1wiOiBfNCB9XSwgXCJoa1wiOiBfNCwgXCJpdFwiOiBfNCwgXCJ2dWx0cm9iamVjdHNcIjogXzcsIFwid2FmZmxlY2VsbFwiOiBfNCwgXCJob3RlbHdpdGhmbGlnaHRcIjogXzQsIFwicmVzZXJ2ZS1vbmxpbmVcIjogXzQsIFwiY3ByYXBpZFwiOiBfNCwgXCJwbGVza25zXCI6IF80LCBcInJlbW90ZXdkXCI6IF80LCBcIndpYXJkd2ViXCI6IFswLCB7IFwicGFnZXNcIjogXzQgfV0sIFwid2l4c2l0ZVwiOiBfNCwgXCJ3aXhzdHVkaW9cIjogXzQsIFwibWVzc3dpdGhkbnNcIjogXzQsIFwid29sdGxhYi1kZW1vXCI6IF80LCBcIndwZW5naW5lcG93ZXJlZFwiOiBbMiwgeyBcImpzXCI6IF80IH1dLCBcInhuYmF5XCI6IFsyLCB7IFwidTJcIjogXzQsIFwidTItbG9jYWxcIjogXzQgfV0sIFwieW9sYXNpdGVcIjogXzQgfV0sIFwiY29vcFwiOiBfMywgXCJjclwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IF8zLCBcImVkXCI6IF8zLCBcImZpXCI6IF8zLCBcImdvXCI6IF8zLCBcIm9yXCI6IF8zLCBcInNhXCI6IF8zIH1dLCBcImN1XCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwiaW5mXCI6IF8zLCBcIm5hdFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcImN2XCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJpZFwiOiBfMywgXCJpbnRcIjogXzMsIFwibmV0XCI6IF8zLCBcIm5vbWVcIjogXzMsIFwib3JnXCI6IF8zLCBcInB1YmxcIjogXzMgfV0sIFwiY3dcIjogXzQzLCBcImN4XCI6IFsxLCB7IFwiZ292XCI6IF8zLCBcImNsb3VkbnNcIjogXzQsIFwiYXRoXCI6IF80LCBcImluZm9cIjogXzQsIFwiYXNzZXNzbWVudHNcIjogXzQsIFwiY2FsY3VsYXRvcnNcIjogXzQsIFwiZnVubmVsc1wiOiBfNCwgXCJwYXlub3dcIjogXzQsIFwicXVpenplc1wiOiBfNCwgXCJyZXNlYXJjaGVkXCI6IF80LCBcInRlc3RzXCI6IF80IH1dLCBcImN5XCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiYml6XCI6IF8zLCBcImNvbVwiOiBbMSwgeyBcInNjYWxlZm9yY2VcIjogXzQ0IH1dLCBcImVrbG9nZXNcIjogXzMsIFwiZ292XCI6IF8zLCBcImx0ZFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwcmVzc1wiOiBfMywgXCJwcm9cIjogXzMsIFwidG1cIjogXzMgfV0sIFwiY3pcIjogWzEsIHsgXCJjb250ZW50cHJveHk5XCI6IFswLCB7IFwicnNjXCI6IF80IH1dLCBcInJlYWxtXCI6IF80LCBcImU0XCI6IF80LCBcImNvXCI6IF80LCBcIm1ldGFjZW50cnVtXCI6IFswLCB7IFwiY2xvdWRcIjogXzcsIFwiY3VzdG9tXCI6IF80IH1dLCBcIm11bmlcIjogWzAsIHsgXCJjbG91ZFwiOiBbMCwgeyBcImZsdFwiOiBfNCwgXCJ1c3JcIjogXzQgfV0gfV0gfV0sIFwiZGVcIjogWzEsIHsgXCJicGxhY2VkXCI6IF80LCBcInNxdWFyZTdcIjogXzQsIFwiY29tXCI6IF80LCBcImNvc2lkbnNcIjogXzQ1LCBcImRuc3VwZGF0ZXJcIjogXzQsIFwiZHluYW1pc2NoZXMtZG5zXCI6IF80LCBcImludGVybmV0LWRuc1wiOiBfNCwgXCJsLW8tZy1pLW5cIjogXzQsIFwiZGRuc3NcIjogWzIsIHsgXCJkeW5cIjogXzQsIFwiZHluZG5zXCI6IF80IH1dLCBcImR5bi1pcDI0XCI6IF80LCBcImR5bmRuczFcIjogXzQsIFwiaG9tZS13ZWJzZXJ2ZXJcIjogWzIsIHsgXCJkeW5cIjogXzQgfV0sIFwibXlob21lLXNlcnZlclwiOiBfNCwgXCJkbnNob21lXCI6IF80LCBcImZ1ZXR0ZXJ0ZGFzbmV0elwiOiBfNCwgXCJpc3RlaW5nZWVrXCI6IF80LCBcImlzdG1laW5cIjogXzQsIFwibGVidGltbmV0elwiOiBfNCwgXCJsZWl0dW5nc2VuXCI6IF80LCBcInRyYWV1bXRnZXJhZGVcIjogXzQsIFwiZnJ1c2t5XCI6IF83LCBcImdvaXBcIjogXzQsIFwieG4tLWduc3RpZ2Jlc3RlbGxlbi16dmJcIjogXzQsIFwiZ8O8bnN0aWdiZXN0ZWxsZW5cIjogXzQsIFwieG4tLWduc3RpZ2xpZWZlcm4td29iXCI6IF80LCBcImfDvG5zdGlnbGllZmVyblwiOiBfNCwgXCJocy1oZWlsYnJvbm5cIjogWzAsIHsgXCJpdFwiOiBbMCwgeyBcInBhZ2VzXCI6IF80LCBcInBhZ2VzLXJlc2VhcmNoXCI6IF80IH1dIH1dLCBcImR5bi1iZXJsaW5cIjogXzQsIFwiaW4tYmVybGluXCI6IF80LCBcImluLWJyYlwiOiBfNCwgXCJpbi1idXR0ZXJcIjogXzQsIFwiaW4tZHNsXCI6IF80LCBcImluLXZwblwiOiBfNCwgXCJpc2VydnNjaHVsZVwiOiBfNCwgXCJtZWluLWlzZXJ2XCI6IF80LCBcInNjaHVscGxhdHRmb3JtXCI6IF80LCBcInNjaHVsc2VydmVyXCI6IF80LCBcInRlc3QtaXNlcnZcIjogXzQsIFwia2V5bWFjaGluZVwiOiBfNCwgXCJnaXQtcmVwb3NcIjogXzQsIFwibGN1YmUtc2VydmVyXCI6IF80LCBcInN2bi1yZXBvc1wiOiBfNCwgXCJiYXJzeVwiOiBfNCwgXCJ3ZWJzcGFjZWNvbmZpZ1wiOiBfNCwgXCIxMjN3ZWJzZWl0ZVwiOiBfNCwgXCJydWJcIjogXzQsIFwicnVoci11bmktYm9jaHVtXCI6IFsyLCB7IFwibm9jXCI6IFswLCB7IFwiaW9cIjogXzQgfV0gfV0sIFwibG9nb2lwXCI6IF80LCBcImZpcmV3YWxsLWdhdGV3YXlcIjogXzQsIFwibXktZ2F0ZXdheVwiOiBfNCwgXCJteS1yb3V0ZXJcIjogXzQsIFwic3BkbnNcIjogXzQsIFwic3BlZWRwYXJ0bmVyXCI6IFswLCB7IFwiY3VzdG9tZXJcIjogXzQgfV0sIFwibXlzcHJlYWRzaG9wXCI6IF80LCBcInRhaWZ1bi1kbnNcIjogXzQsIFwiMTJocFwiOiBfNCwgXCIyaXhcIjogXzQsIFwiNGxpbWFcIjogXzQsIFwibGltYS1jaXR5XCI6IF80LCBcImRkLWRuc1wiOiBfNCwgXCJkcmF5LWRuc1wiOiBfNCwgXCJkcmF5ZG5zXCI6IF80LCBcImR5bi12cG5cIjogXzQsIFwiZHludnBuXCI6IF80LCBcIm1laW4tdmlnb3JcIjogXzQsIFwibXktdmlnb3JcIjogXzQsIFwibXktd2FuXCI6IF80LCBcInN5bm8tZHNcIjogXzQsIFwic3lub2xvZ3ktZGlza3N0YXRpb25cIjogXzQsIFwic3lub2xvZ3ktZHNcIjogXzQsIFwidWJlcnNwYWNlXCI6IF83LCBcInZpcnR1YWwtdXNlclwiOiBfNCwgXCJ2aXJ0dWFsdXNlclwiOiBfNCwgXCJjb21tdW5pdHktcHJvXCI6IF80LCBcImRpc2t1c3Npb25zYmVyZWljaFwiOiBfNCB9XSwgXCJkalwiOiBfMywgXCJka1wiOiBbMSwgeyBcImJpelwiOiBfNCwgXCJjb1wiOiBfNCwgXCJmaXJtXCI6IF80LCBcInJlZ1wiOiBfNCwgXCJzdG9yZVwiOiBfNCwgXCIxMjNoamVtbWVzaWRlXCI6IF80LCBcIm15c3ByZWFkc2hvcFwiOiBfNCB9XSwgXCJkbVwiOiBfNDYsIFwiZG9cIjogWzEsIHsgXCJhcnRcIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInNsZFwiOiBfMywgXCJ3ZWJcIjogXzMgfV0sIFwiZHpcIjogWzEsIHsgXCJhcnRcIjogXzMsIFwiYXNzb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInBvbFwiOiBfMywgXCJzb2NcIjogXzMsIFwidG1cIjogXzMgfV0sIFwiZWNcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImZpblwiOiBfMywgXCJnb2JcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwiazEyXCI6IF8zLCBcIm1lZFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwcm9cIjogXzMsIFwiYmFzZVwiOiBfNCwgXCJvZmZpY2lhbFwiOiBfNCB9XSwgXCJlZHVcIjogWzEsIHsgXCJyaXRcIjogWzAsIHsgXCJnaXQtcGFnZXNcIjogXzQgfV0gfV0sIFwiZWVcIjogWzEsIHsgXCJhaXBcIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJmaWVcIjogXzMsIFwiZ292XCI6IF8zLCBcImxpYlwiOiBfMywgXCJtZWRcIjogXzMsIFwib3JnXCI6IF8zLCBcInByaVwiOiBfMywgXCJyaWlrXCI6IF8zIH1dLCBcImVnXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJldW5cIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwibWVcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5hbWVcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJzY2lcIjogXzMsIFwic3BvcnRcIjogXzMsIFwidHZcIjogXzMgfV0sIFwiZXJcIjogXzE3LCBcImVzXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwibm9tXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCIxMjNtaXdlYlwiOiBfNCwgXCJteXNwcmVhZHNob3BcIjogXzQgfV0sIFwiZXRcIjogWzEsIHsgXCJiaXpcIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaW5mb1wiOiBfMywgXCJuYW1lXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwiZXVcIjogWzEsIHsgXCJhaXJraXRhcHBzXCI6IF80LCBcImNsb3VkbnNcIjogXzQsIFwiZG9nYWRvXCI6IFswLCB7IFwiamVsYXN0aWNcIjogXzQgfV0sIFwiYmFyc3lcIjogXzQsIFwic3BkbnNcIjogXzQsIFwidHJhbnN1cmxcIjogXzcsIFwiZGlza3N0YXRpb25cIjogXzQgfV0sIFwiZmlcIjogWzEsIHsgXCJhbGFuZFwiOiBfMywgXCJkeVwiOiBfNCwgXCJ4bi0taGtraW5lbi01d2FcIjogXzQsIFwiaMOka2tpbmVuXCI6IF80LCBcImlraVwiOiBfNCwgXCJjbG91ZHBsYXRmb3JtXCI6IFswLCB7IFwiZmlcIjogXzQgfV0sIFwiZGF0YWNlbnRlclwiOiBbMCwgeyBcImRlbW9cIjogXzQsIFwicGFhc1wiOiBfNCB9XSwgXCJrYXBzaVwiOiBfNCwgXCIxMjNrb3Rpc2l2dVwiOiBfNCwgXCJteXNwcmVhZHNob3BcIjogXzQgfV0sIFwiZmpcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJiaXpcIjogXzMsIFwiY29tXCI6IF8zLCBcImdvdlwiOiBfMywgXCJpbmZvXCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuYW1lXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicHJvXCI6IF8zIH1dLCBcImZrXCI6IF8xNywgXCJmbVwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJyYWRpb1wiOiBfNCwgXCJ1c2VyXCI6IF83IH1dLCBcImZvXCI6IF8zLCBcImZyXCI6IFsxLCB7IFwiYXNzb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZ291dlwiOiBfMywgXCJub21cIjogXzMsIFwicHJkXCI6IF8zLCBcInRtXCI6IF8zLCBcImF2b3Vlc1wiOiBfMywgXCJjY2lcIjogXzMsIFwiZ3JldGFcIjogXzMsIFwiaHVpc3NpZXItanVzdGljZVwiOiBfMywgXCJlbi1yb290XCI6IF80LCBcImZieC1vc1wiOiBfNCwgXCJmYnhvc1wiOiBfNCwgXCJmcmVlYm94LW9zXCI6IF80LCBcImZyZWVib3hvc1wiOiBfNCwgXCJnb3VwaWxlXCI6IF80LCBcIjEyM3NpdGV3ZWJcIjogXzQsIFwib24td2ViXCI6IF80LCBcImNoaXJ1cmdpZW5zLWRlbnRpc3Rlcy1lbi1mcmFuY2VcIjogXzQsIFwiZGVkaWJveFwiOiBfNCwgXCJhZXJvcG9ydFwiOiBfNCwgXCJhdm9jYXRcIjogXzQsIFwiY2hhbWJhZ3JpXCI6IF80LCBcImNoaXJ1cmdpZW5zLWRlbnRpc3Rlc1wiOiBfNCwgXCJleHBlcnRzLWNvbXB0YWJsZXNcIjogXzQsIFwibWVkZWNpblwiOiBfNCwgXCJub3RhaXJlc1wiOiBfNCwgXCJwaGFybWFjaWVuXCI6IF80LCBcInBvcnRcIjogXzQsIFwidmV0ZXJpbmFpcmVcIjogXzQsIFwibXlzcHJlYWRzaG9wXCI6IF80LCBcInluaFwiOiBfNCB9XSwgXCJnYVwiOiBfMywgXCJnYlwiOiBfMywgXCJnZFwiOiBbMSwgeyBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMgfV0sIFwiZ2VcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInB2dFwiOiBfMywgXCJzY2hvb2xcIjogXzMgfV0sIFwiZ2ZcIjogXzMsIFwiZ2dcIjogWzEsIHsgXCJjb1wiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImJvdGRhc2hcIjogXzQsIFwia2Fhc1wiOiBfNCwgXCJzdGFja2l0XCI6IF80LCBcInBhbmVsXCI6IFsyLCB7IFwiZGFlbW9uXCI6IF80IH1dIH1dLCBcImdoXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJnaVwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImx0ZFwiOiBfMywgXCJtb2RcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcImdsXCI6IFsxLCB7IFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImJpelwiOiBfNCB9XSwgXCJnbVwiOiBfMywgXCJnblwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwiZ292XCI6IF8zLCBcImdwXCI6IFsxLCB7IFwiYXNzb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcIm1vYmlcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJncVwiOiBfMywgXCJnclwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwiYmFyc3lcIjogXzQsIFwic2ltcGxlc2l0ZVwiOiBfNCB9XSwgXCJnc1wiOiBfMywgXCJndFwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ29iXCI6IF8zLCBcImluZFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJndVwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImd1YW1cIjogXzMsIFwiaW5mb1wiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcIndlYlwiOiBfMyB9XSwgXCJnd1wiOiBfMywgXCJneVwiOiBfNDYsIFwiaGtcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJpZHZcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ4bi0tY2lxcG5cIjogXzMsIFwi5Liq5Lq6XCI6IF8zLCBcInhuLS1nbXF3NWFcIjogXzMsIFwi5YCL5Lq6XCI6IF8zLCBcInhuLS01NXF4NWRcIjogXzMsIFwi5YWs5Y+4XCI6IF8zLCBcInhuLS1teHRxMW1cIjogXzMsIFwi5pS/5bqcXCI6IF8zLCBcInhuLS1sY3ZyMzJkXCI6IF8zLCBcIuaVjuiCslwiOiBfMywgXCJ4bi0td2N2czIyZFwiOiBfMywgXCLmlZnogrJcIjogXzMsIFwieG4tLWdtcTA1MGlcIjogXzMsIFwi566H5Lq6XCI6IF8zLCBcInhuLS11YzBhdHZcIjogXzMsIFwi57WE57mUXCI6IF8zLCBcInhuLS11YzBheTRhXCI6IF8zLCBcIue1hOe7h1wiOiBfMywgXCJ4bi0tb2QwYWxnXCI6IF8zLCBcIue2sue1oVwiOiBfMywgXCJ4bi0temYwYXZ4XCI6IF8zLCBcIue2sue7nFwiOiBfMywgXCJ4bi0tbWswYXhpXCI6IF8zLCBcIue7hOe5lFwiOiBfMywgXCJ4bi0tdG4wYWdcIjogXzMsIFwi57uE57uHXCI6IF8zLCBcInhuLS1vZDBhcTNiXCI6IF8zLCBcIue9kee1oVwiOiBfMywgXCJ4bi0taW8wYTdpXCI6IF8zLCBcIue9kee7nFwiOiBfMywgXCJpbmNcIjogXzQsIFwibHRkXCI6IF80IH1dLCBcImhtXCI6IF8zLCBcImhuXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwiaHJcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZnJvbVwiOiBfMywgXCJpelwiOiBfMywgXCJuYW1lXCI6IF8zLCBcImJyZW5kbHlcIjogXzQ5IH1dLCBcImh0XCI6IFsxLCB7IFwiYWR1bHRcIjogXzMsIFwiYXJ0XCI6IF8zLCBcImFzc29cIjogXzMsIFwiY29tXCI6IF8zLCBcImNvb3BcIjogXzMsIFwiZWR1XCI6IF8zLCBcImZpcm1cIjogXzMsIFwiZ291dlwiOiBfMywgXCJpbmZvXCI6IF8zLCBcIm1lZFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInBlcnNvXCI6IF8zLCBcInBvbFwiOiBfMywgXCJwcm9cIjogXzMsIFwicmVsXCI6IF8zLCBcInNob3BcIjogXzMsIFwicnRcIjogXzQgfV0sIFwiaHVcIjogWzEsIHsgXCIyMDAwXCI6IF8zLCBcImFncmFyXCI6IF8zLCBcImJvbHRcIjogXzMsIFwiY2FzaW5vXCI6IF8zLCBcImNpdHlcIjogXzMsIFwiY29cIjogXzMsIFwiZXJvdGljYVwiOiBfMywgXCJlcm90aWthXCI6IF8zLCBcImZpbG1cIjogXzMsIFwiZm9ydW1cIjogXzMsIFwiZ2FtZXNcIjogXzMsIFwiaG90ZWxcIjogXzMsIFwiaW5mb1wiOiBfMywgXCJpbmdhdGxhblwiOiBfMywgXCJqb2dhc3pcIjogXzMsIFwia29ueXZlbG9cIjogXzMsIFwibGFrYXNcIjogXzMsIFwibWVkaWFcIjogXzMsIFwibmV3c1wiOiBfMywgXCJvcmdcIjogXzMsIFwicHJpdlwiOiBfMywgXCJyZWtsYW1cIjogXzMsIFwic2V4XCI6IF8zLCBcInNob3BcIjogXzMsIFwic3BvcnRcIjogXzMsIFwic3VsaVwiOiBfMywgXCJzemV4XCI6IF8zLCBcInRtXCI6IF8zLCBcInRvenNkZVwiOiBfMywgXCJ1dGF6YXNcIjogXzMsIFwidmlkZW9cIjogXzMgfV0sIFwiaWRcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJiaXpcIjogXzMsIFwiY29cIjogXzMsIFwiZGVzYVwiOiBfMywgXCJnb1wiOiBfMywgXCJtaWxcIjogXzMsIFwibXlcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yXCI6IF8zLCBcInBvbnBlc1wiOiBfMywgXCJzY2hcIjogXzMsIFwid2ViXCI6IF8zIH1dLCBcImllXCI6IFsxLCB7IFwiZ292XCI6IF8zLCBcIm15c3ByZWFkc2hvcFwiOiBfNCB9XSwgXCJpbFwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IFsxLCB7IFwicmF2cGFnZVwiOiBfNCwgXCJteXRhYml0XCI6IF80LCBcInRhYml0b3JkZXJcIjogXzQgfV0sIFwiZ292XCI6IF8zLCBcImlkZlwiOiBfMywgXCJrMTJcIjogXzMsIFwibXVuaVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcInhuLS00ZGJyazBjZVwiOiBbMSwgeyBcInhuLS00ZGJnZHR5NmNcIjogXzMsIFwieG4tLTVkYmhsOGRcIjogXzMsIFwieG4tLThkYnEyYVwiOiBfMywgXCJ4bi0taGViZGE4YlwiOiBfMyB9XSwgXCLXmdep16jXkNecXCI6IFsxLCB7IFwi15DXp9eT157XmdeUXCI6IF8zLCBcIteZ16nXldeRXCI6IF8zLCBcItem15TXnFwiOiBfMywgXCLXntee16nXnFwiOiBfMyB9XSwgXCJpbVwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IFsxLCB7IFwibHRkXCI6IF8zLCBcInBsY1wiOiBfMyB9XSwgXCJjb21cIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ0dFwiOiBfMywgXCJ0dlwiOiBfMyB9XSwgXCJpblwiOiBbMSwgeyBcIjVnXCI6IF8zLCBcIjZnXCI6IF8zLCBcImFjXCI6IF8zLCBcImFpXCI6IF8zLCBcImFtXCI6IF8zLCBcImJpaGFyXCI6IF8zLCBcImJpelwiOiBfMywgXCJidXNpbmVzc1wiOiBfMywgXCJjYVwiOiBfMywgXCJjblwiOiBfMywgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiY29vcFwiOiBfMywgXCJjc1wiOiBfMywgXCJkZWxoaVwiOiBfMywgXCJkclwiOiBfMywgXCJlZHVcIjogXzMsIFwiZXJcIjogXzMsIFwiZmlybVwiOiBfMywgXCJnZW5cIjogXzMsIFwiZ292XCI6IF8zLCBcImd1amFyYXRcIjogXzMsIFwiaW5kXCI6IF8zLCBcImluZm9cIjogXzMsIFwiaW50XCI6IF8zLCBcImludGVybmV0XCI6IF8zLCBcImlvXCI6IF8zLCBcIm1lXCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwibmljXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwZ1wiOiBfMywgXCJwb3N0XCI6IF8zLCBcInByb1wiOiBfMywgXCJyZXNcIjogXzMsIFwidHJhdmVsXCI6IF8zLCBcInR2XCI6IF8zLCBcInVrXCI6IF8zLCBcInVwXCI6IF8zLCBcInVzXCI6IF8zLCBcImNsb3VkbnNcIjogXzQsIFwiYmFyc3lcIjogXzQsIFwid2ViXCI6IF80LCBcInN1cGFiYXNlXCI6IF80IH1dLCBcImluZm9cIjogWzEsIHsgXCJjbG91ZG5zXCI6IF80LCBcImR5bmFtaWMtZG5zXCI6IF80LCBcImJhcnJlbC1vZi1rbm93bGVkZ2VcIjogXzQsIFwiYmFycmVsbC1vZi1rbm93bGVkZ2VcIjogXzQsIFwiZHluZG5zXCI6IF80LCBcImZvci1vdXJcIjogXzQsIFwiZ3Jva3MtdGhlXCI6IF80LCBcImdyb2tzLXRoaXNcIjogXzQsIFwiaGVyZS1mb3ItbW9yZVwiOiBfNCwgXCJrbm93c2l0YWxsXCI6IF80LCBcInNlbGZpcFwiOiBfNCwgXCJ3ZWJob3BcIjogXzQsIFwiYmFyc3lcIjogXzQsIFwibWF5Zmlyc3RcIjogXzQsIFwibWl0dHdhbGRcIjogXzQsIFwibWl0dHdhbGRzZXJ2ZXJcIjogXzQsIFwidHlwbzNzZXJ2ZXJcIjogXzQsIFwiZHZyY2FtXCI6IF80LCBcImlsb3ZlY29sbGVnZVwiOiBfNCwgXCJuby1pcFwiOiBfNCwgXCJmb3J1bXpcIjogXzQsIFwibnN1cGRhdGVcIjogXzQsIFwiZG5zdXBkYXRlXCI6IF80LCBcInYtaW5mb1wiOiBfNCB9XSwgXCJpbnRcIjogWzEsIHsgXCJldVwiOiBfMyB9XSwgXCJpb1wiOiBbMSwgeyBcIjIwMzhcIjogXzQsIFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJub21cIjogXzMsIFwib3JnXCI6IF8zLCBcIm9uLWFjb3JuXCI6IF83LCBcIm15YWRkclwiOiBfNCwgXCJhcGlnZWVcIjogXzQsIFwiYi1kYXRhXCI6IF80LCBcImJlYWdsZWJvYXJkXCI6IF80LCBcImJpdGJ1Y2tldFwiOiBfNCwgXCJibHVlYml0ZVwiOiBfNCwgXCJib3hmdXNlXCI6IF80LCBcImJyYXZlXCI6IFswLCB7IFwic1wiOiBfNyB9XSwgXCJicm93c2Vyc2FmZXR5bWFya1wiOiBfNCwgXCJiaWd2XCI6IFswLCB7IFwidWswXCI6IF80IH1dLCBcImNsZXZlcmFwcHNcIjogXzQsIFwiY2xvdWRiZWVzdXNlcmNvbnRlbnRcIjogXzQsIFwiZGFwcG5vZGVcIjogWzAsIHsgXCJkeW5kbnNcIjogXzQgfV0sIFwiZGFya2xhbmdcIjogXzQsIFwiZGVmaW5pbWFcIjogXzQsIFwiZGVkeW5cIjogXzQsIFwiZmgtbXVlbnN0ZXJcIjogXzQsIFwic2h3XCI6IF80LCBcImZvcmdlcm9ja1wiOiBbMCwgeyBcImlkXCI6IF80IH1dLCBcImdpdGh1YlwiOiBfNCwgXCJnaXRsYWJcIjogXzQsIFwibG9saXBvcFwiOiBfNCwgXCJoYXN1cmEtYXBwXCI6IF80LCBcImhvc3R5aG9zdGluZ1wiOiBfNCwgXCJoeXBlcm5vZGVcIjogXzQsIFwibW9vbnNjYWxlXCI6IF83LCBcImJlZWJ5dGVcIjogXzM5LCBcImJlZWJ5dGVhcHBcIjogWzAsIHsgXCJzZWtkMVwiOiBfNCB9XSwgXCJqZWxlXCI6IF80LCBcIndlYnRoaW5nc1wiOiBfNCwgXCJsb2dpbmxpbmVcIjogXzQsIFwiYmFyc3lcIjogXzQsIFwiYXp1cmVjb250YWluZXJcIjogXzcsIFwibmdyb2tcIjogWzIsIHsgXCJhcFwiOiBfNCwgXCJhdVwiOiBfNCwgXCJldVwiOiBfNCwgXCJpblwiOiBfNCwgXCJqcFwiOiBfNCwgXCJzYVwiOiBfNCwgXCJ1c1wiOiBfNCB9XSwgXCJub2RlYXJ0XCI6IFswLCB7IFwic3RhZ2VcIjogXzQgfV0sIFwicGFudGhlb25zaXRlXCI6IF80LCBcInBzdG1uXCI6IFsyLCB7IFwibW9ja1wiOiBfNCB9XSwgXCJwcm90b25ldFwiOiBfNCwgXCJxY3hcIjogWzIsIHsgXCJzeXNcIjogXzcgfV0sIFwicW90b1wiOiBfNCwgXCJ2YXBvcmNsb3VkXCI6IF80LCBcIm15cmRieFwiOiBfNCwgXCJyYi1ob3N0aW5nXCI6IF80MiwgXCJvbi1rM3NcIjogXzcsIFwib24tcmlvXCI6IF83LCBcInJlYWR0aGVkb2NzXCI6IF80LCBcInJlc2luZGV2aWNlXCI6IF80LCBcInJlc2luc3RhZ2luZ1wiOiBbMCwgeyBcImRldmljZXNcIjogXzQgfV0sIFwiaHpjXCI6IF80LCBcInNhbmRjYXRzXCI6IF80LCBcInNjcnlwdGVkXCI6IFswLCB7IFwiY2xpZW50XCI6IF80IH1dLCBcIm1vLXNpZW1lbnNcIjogXzQsIFwibGFpclwiOiBfMzgsIFwic3RvbG9zXCI6IF83LCBcIm11c2ljaWFuXCI6IF80LCBcInV0d2VudGVcIjogXzQsIFwiZWR1Z2l0XCI6IF80LCBcInRlbGViaXRcIjogXzQsIFwidGhpbmdkdXN0XCI6IFswLCB7IFwiZGV2XCI6IF81MCwgXCJkaXNyZWNcIjogXzUwLCBcInByb2RcIjogXzUxLCBcInRlc3RpbmdcIjogXzUwIH1dLCBcInRpY2tldHNcIjogXzQsIFwid2ViZmxvd1wiOiBfNCwgXCJ3ZWJmbG93dGVzdFwiOiBfNCwgXCJlZGl0b3J4XCI6IF80LCBcIndpeHN0dWRpb1wiOiBfNCwgXCJiYXNpY3NlcnZlclwiOiBfNCwgXCJ2aXJ0dWFsc2VydmVyXCI6IF80IH1dLCBcImlxXCI6IF82LCBcImlyXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiY29cIjogXzMsIFwiZ292XCI6IF8zLCBcImlkXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwic2NoXCI6IF8zLCBcInhuLS1tZ2JhM2E0ZjE2YVwiOiBfMywgXCLYp9uM2LHYp9mGXCI6IF8zLCBcInhuLS1tZ2JhM2E0ZnJhXCI6IF8zLCBcItin2YrYsdin2YZcIjogXzMsIFwiYXJ2YW5lZGdlXCI6IF80IH1dLCBcImlzXCI6IF8zLCBcIml0XCI6IFsxLCB7IFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJhYnJcIjogXzMsIFwiYWJydXp6b1wiOiBfMywgXCJhb3N0YS12YWxsZXlcIjogXzMsIFwiYW9zdGF2YWxsZXlcIjogXzMsIFwiYmFzXCI6IF8zLCBcImJhc2lsaWNhdGFcIjogXzMsIFwiY2FsXCI6IF8zLCBcImNhbGFicmlhXCI6IF8zLCBcImNhbVwiOiBfMywgXCJjYW1wYW5pYVwiOiBfMywgXCJlbWlsaWEtcm9tYWduYVwiOiBfMywgXCJlbWlsaWFyb21hZ25hXCI6IF8zLCBcImVtclwiOiBfMywgXCJmcml1bGktdi1naXVsaWFcIjogXzMsIFwiZnJpdWxpLXZlLWdpdWxpYVwiOiBfMywgXCJmcml1bGktdmVnaXVsaWFcIjogXzMsIFwiZnJpdWxpLXZlbmV6aWEtZ2l1bGlhXCI6IF8zLCBcImZyaXVsaS12ZW5lemlhZ2l1bGlhXCI6IF8zLCBcImZyaXVsaS12Z2l1bGlhXCI6IF8zLCBcImZyaXVsaXYtZ2l1bGlhXCI6IF8zLCBcImZyaXVsaXZlLWdpdWxpYVwiOiBfMywgXCJmcml1bGl2ZWdpdWxpYVwiOiBfMywgXCJmcml1bGl2ZW5lemlhLWdpdWxpYVwiOiBfMywgXCJmcml1bGl2ZW5lemlhZ2l1bGlhXCI6IF8zLCBcImZyaXVsaXZnaXVsaWFcIjogXzMsIFwiZnZnXCI6IF8zLCBcImxhelwiOiBfMywgXCJsYXppb1wiOiBfMywgXCJsaWdcIjogXzMsIFwibGlndXJpYVwiOiBfMywgXCJsb21cIjogXzMsIFwibG9tYmFyZGlhXCI6IF8zLCBcImxvbWJhcmR5XCI6IF8zLCBcImx1Y2FuaWFcIjogXzMsIFwibWFyXCI6IF8zLCBcIm1hcmNoZVwiOiBfMywgXCJtb2xcIjogXzMsIFwibW9saXNlXCI6IF8zLCBcInBpZWRtb250XCI6IF8zLCBcInBpZW1vbnRlXCI6IF8zLCBcInBtblwiOiBfMywgXCJwdWdcIjogXzMsIFwicHVnbGlhXCI6IF8zLCBcInNhclwiOiBfMywgXCJzYXJkZWduYVwiOiBfMywgXCJzYXJkaW5pYVwiOiBfMywgXCJzaWNcIjogXzMsIFwic2ljaWxpYVwiOiBfMywgXCJzaWNpbHlcIjogXzMsIFwidGFhXCI6IF8zLCBcInRvc1wiOiBfMywgXCJ0b3NjYW5hXCI6IF8zLCBcInRyZW50aW4tc3VkLXRpcm9sXCI6IF8zLCBcInhuLS10cmVudGluLXNkLXRpcm9sLXJ6YlwiOiBfMywgXCJ0cmVudGluLXPDvGQtdGlyb2xcIjogXzMsIFwidHJlbnRpbi1zdWR0aXJvbFwiOiBfMywgXCJ4bi0tdHJlbnRpbi1zZHRpcm9sLTd2YlwiOiBfMywgXCJ0cmVudGluLXPDvGR0aXJvbFwiOiBfMywgXCJ0cmVudGluLXN1ZWQtdGlyb2xcIjogXzMsIFwidHJlbnRpbi1zdWVkdGlyb2xcIjogXzMsIFwidHJlbnRpbm9cIjogXzMsIFwidHJlbnRpbm8tYS1hZGlnZVwiOiBfMywgXCJ0cmVudGluby1hYWRpZ2VcIjogXzMsIFwidHJlbnRpbm8tYWx0by1hZGlnZVwiOiBfMywgXCJ0cmVudGluby1hbHRvYWRpZ2VcIjogXzMsIFwidHJlbnRpbm8tcy10aXJvbFwiOiBfMywgXCJ0cmVudGluby1zdGlyb2xcIjogXzMsIFwidHJlbnRpbm8tc3VkLXRpcm9sXCI6IF8zLCBcInhuLS10cmVudGluby1zZC10aXJvbC1jM2JcIjogXzMsIFwidHJlbnRpbm8tc8O8ZC10aXJvbFwiOiBfMywgXCJ0cmVudGluby1zdWR0aXJvbFwiOiBfMywgXCJ4bi0tdHJlbnRpbm8tc2R0aXJvbC1zemJcIjogXzMsIFwidHJlbnRpbm8tc8O8ZHRpcm9sXCI6IF8zLCBcInRyZW50aW5vLXN1ZWQtdGlyb2xcIjogXzMsIFwidHJlbnRpbm8tc3VlZHRpcm9sXCI6IF8zLCBcInRyZW50aW5vYS1hZGlnZVwiOiBfMywgXCJ0cmVudGlub2FhZGlnZVwiOiBfMywgXCJ0cmVudGlub2FsdG8tYWRpZ2VcIjogXzMsIFwidHJlbnRpbm9hbHRvYWRpZ2VcIjogXzMsIFwidHJlbnRpbm9zLXRpcm9sXCI6IF8zLCBcInRyZW50aW5vc3Rpcm9sXCI6IF8zLCBcInRyZW50aW5vc3VkLXRpcm9sXCI6IF8zLCBcInhuLS10cmVudGlub3NkLXRpcm9sLXJ6YlwiOiBfMywgXCJ0cmVudGlub3PDvGQtdGlyb2xcIjogXzMsIFwidHJlbnRpbm9zdWR0aXJvbFwiOiBfMywgXCJ4bi0tdHJlbnRpbm9zZHRpcm9sLTd2YlwiOiBfMywgXCJ0cmVudGlub3PDvGR0aXJvbFwiOiBfMywgXCJ0cmVudGlub3N1ZWQtdGlyb2xcIjogXzMsIFwidHJlbnRpbm9zdWVkdGlyb2xcIjogXzMsIFwidHJlbnRpbnN1ZC10aXJvbFwiOiBfMywgXCJ4bi0tdHJlbnRpbnNkLXRpcm9sLTZ2YlwiOiBfMywgXCJ0cmVudGluc8O8ZC10aXJvbFwiOiBfMywgXCJ0cmVudGluc3VkdGlyb2xcIjogXzMsIFwieG4tLXRyZW50aW5zZHRpcm9sLW5zYlwiOiBfMywgXCJ0cmVudGluc8O8ZHRpcm9sXCI6IF8zLCBcInRyZW50aW5zdWVkLXRpcm9sXCI6IF8zLCBcInRyZW50aW5zdWVkdGlyb2xcIjogXzMsIFwidHVzY2FueVwiOiBfMywgXCJ1bWJcIjogXzMsIFwidW1icmlhXCI6IF8zLCBcInZhbC1kLWFvc3RhXCI6IF8zLCBcInZhbC1kYW9zdGFcIjogXzMsIFwidmFsZC1hb3N0YVwiOiBfMywgXCJ2YWxkYW9zdGFcIjogXzMsIFwidmFsbGUtYW9zdGFcIjogXzMsIFwidmFsbGUtZC1hb3N0YVwiOiBfMywgXCJ2YWxsZS1kYW9zdGFcIjogXzMsIFwidmFsbGVhb3N0YVwiOiBfMywgXCJ2YWxsZWQtYW9zdGFcIjogXzMsIFwidmFsbGVkYW9zdGFcIjogXzMsIFwidmFsbGVlLWFvc3RlXCI6IF8zLCBcInhuLS12YWxsZS1hb3N0ZS1lYmJcIjogXzMsIFwidmFsbMOpZS1hb3N0ZVwiOiBfMywgXCJ2YWxsZWUtZC1hb3N0ZVwiOiBfMywgXCJ4bi0tdmFsbGUtZC1hb3N0ZS1laGJcIjogXzMsIFwidmFsbMOpZS1kLWFvc3RlXCI6IF8zLCBcInZhbGxlZWFvc3RlXCI6IF8zLCBcInhuLS12YWxsZWFvc3RlLWU3YVwiOiBfMywgXCJ2YWxsw6llYW9zdGVcIjogXzMsIFwidmFsbGVlZGFvc3RlXCI6IF8zLCBcInhuLS12YWxsZWRhb3N0ZS1lYmJcIjogXzMsIFwidmFsbMOpZWRhb3N0ZVwiOiBfMywgXCJ2YW9cIjogXzMsIFwidmRhXCI6IF8zLCBcInZlblwiOiBfMywgXCJ2ZW5ldG9cIjogXzMsIFwiYWdcIjogXzMsIFwiYWdyaWdlbnRvXCI6IF8zLCBcImFsXCI6IF8zLCBcImFsZXNzYW5kcmlhXCI6IF8zLCBcImFsdG8tYWRpZ2VcIjogXzMsIFwiYWx0b2FkaWdlXCI6IF8zLCBcImFuXCI6IF8zLCBcImFuY29uYVwiOiBfMywgXCJhbmRyaWEtYmFybGV0dGEtdHJhbmlcIjogXzMsIFwiYW5kcmlhLXRyYW5pLWJhcmxldHRhXCI6IF8zLCBcImFuZHJpYWJhcmxldHRhdHJhbmlcIjogXzMsIFwiYW5kcmlhdHJhbmliYXJsZXR0YVwiOiBfMywgXCJhb1wiOiBfMywgXCJhb3N0YVwiOiBfMywgXCJhb3N0ZVwiOiBfMywgXCJhcFwiOiBfMywgXCJhcVwiOiBfMywgXCJhcXVpbGFcIjogXzMsIFwiYXJcIjogXzMsIFwiYXJlenpvXCI6IF8zLCBcImFzY29saS1waWNlbm9cIjogXzMsIFwiYXNjb2xpcGljZW5vXCI6IF8zLCBcImFzdGlcIjogXzMsIFwiYXRcIjogXzMsIFwiYXZcIjogXzMsIFwiYXZlbGxpbm9cIjogXzMsIFwiYmFcIjogXzMsIFwiYmFsc2FuXCI6IF8zLCBcImJhbHNhbi1zdWR0aXJvbFwiOiBfMywgXCJ4bi0tYmFsc2FuLXNkdGlyb2wtbnNiXCI6IF8zLCBcImJhbHNhbi1zw7xkdGlyb2xcIjogXzMsIFwiYmFsc2FuLXN1ZWR0aXJvbFwiOiBfMywgXCJiYXJpXCI6IF8zLCBcImJhcmxldHRhLXRyYW5pLWFuZHJpYVwiOiBfMywgXCJiYXJsZXR0YXRyYW5pYW5kcmlhXCI6IF8zLCBcImJlbGx1bm9cIjogXzMsIFwiYmVuZXZlbnRvXCI6IF8zLCBcImJlcmdhbW9cIjogXzMsIFwiYmdcIjogXzMsIFwiYmlcIjogXzMsIFwiYmllbGxhXCI6IF8zLCBcImJsXCI6IF8zLCBcImJuXCI6IF8zLCBcImJvXCI6IF8zLCBcImJvbG9nbmFcIjogXzMsIFwiYm9semFub1wiOiBfMywgXCJib2x6YW5vLWFsdG9hZGlnZVwiOiBfMywgXCJib3plblwiOiBfMywgXCJib3plbi1zdWR0aXJvbFwiOiBfMywgXCJ4bi0tYm96ZW4tc2R0aXJvbC0yb2JcIjogXzMsIFwiYm96ZW4tc8O8ZHRpcm9sXCI6IF8zLCBcImJvemVuLXN1ZWR0aXJvbFwiOiBfMywgXCJiclwiOiBfMywgXCJicmVzY2lhXCI6IF8zLCBcImJyaW5kaXNpXCI6IF8zLCBcImJzXCI6IF8zLCBcImJ0XCI6IF8zLCBcImJ1bHNhblwiOiBfMywgXCJidWxzYW4tc3VkdGlyb2xcIjogXzMsIFwieG4tLWJ1bHNhbi1zZHRpcm9sLW5zYlwiOiBfMywgXCJidWxzYW4tc8O8ZHRpcm9sXCI6IF8zLCBcImJ1bHNhbi1zdWVkdGlyb2xcIjogXzMsIFwiYnpcIjogXzMsIFwiY2FcIjogXzMsIFwiY2FnbGlhcmlcIjogXzMsIFwiY2FsdGFuaXNzZXR0YVwiOiBfMywgXCJjYW1waWRhbm8tbWVkaW9cIjogXzMsIFwiY2FtcGlkYW5vbWVkaW9cIjogXzMsIFwiY2FtcG9iYXNzb1wiOiBfMywgXCJjYXJib25pYS1pZ2xlc2lhc1wiOiBfMywgXCJjYXJib25pYWlnbGVzaWFzXCI6IF8zLCBcImNhcnJhcmEtbWFzc2FcIjogXzMsIFwiY2FycmFyYW1hc3NhXCI6IF8zLCBcImNhc2VydGFcIjogXzMsIFwiY2F0YW5pYVwiOiBfMywgXCJjYXRhbnphcm9cIjogXzMsIFwiY2JcIjogXzMsIFwiY2VcIjogXzMsIFwiY2VzZW5hLWZvcmxpXCI6IF8zLCBcInhuLS1jZXNlbmEtZm9ybC1tY2JcIjogXzMsIFwiY2VzZW5hLWZvcmzDrFwiOiBfMywgXCJjZXNlbmFmb3JsaVwiOiBfMywgXCJ4bi0tY2VzZW5hZm9ybC1pOGFcIjogXzMsIFwiY2VzZW5hZm9ybMOsXCI6IF8zLCBcImNoXCI6IF8zLCBcImNoaWV0aVwiOiBfMywgXCJjaVwiOiBfMywgXCJjbFwiOiBfMywgXCJjblwiOiBfMywgXCJjb1wiOiBfMywgXCJjb21vXCI6IF8zLCBcImNvc2VuemFcIjogXzMsIFwiY3JcIjogXzMsIFwiY3JlbW9uYVwiOiBfMywgXCJjcm90b25lXCI6IF8zLCBcImNzXCI6IF8zLCBcImN0XCI6IF8zLCBcImN1bmVvXCI6IF8zLCBcImN6XCI6IF8zLCBcImRlbGwtb2dsaWFzdHJhXCI6IF8zLCBcImRlbGxvZ2xpYXN0cmFcIjogXzMsIFwiZW5cIjogXzMsIFwiZW5uYVwiOiBfMywgXCJmY1wiOiBfMywgXCJmZVwiOiBfMywgXCJmZXJtb1wiOiBfMywgXCJmZXJyYXJhXCI6IF8zLCBcImZnXCI6IF8zLCBcImZpXCI6IF8zLCBcImZpcmVuemVcIjogXzMsIFwiZmxvcmVuY2VcIjogXzMsIFwiZm1cIjogXzMsIFwiZm9nZ2lhXCI6IF8zLCBcImZvcmxpLWNlc2VuYVwiOiBfMywgXCJ4bi0tZm9ybC1jZXNlbmEtZmNiXCI6IF8zLCBcImZvcmzDrC1jZXNlbmFcIjogXzMsIFwiZm9ybGljZXNlbmFcIjogXzMsIFwieG4tLWZvcmxjZXNlbmEtYzhhXCI6IF8zLCBcImZvcmzDrGNlc2VuYVwiOiBfMywgXCJmclwiOiBfMywgXCJmcm9zaW5vbmVcIjogXzMsIFwiZ2VcIjogXzMsIFwiZ2Vub2FcIjogXzMsIFwiZ2Vub3ZhXCI6IF8zLCBcImdvXCI6IF8zLCBcImdvcml6aWFcIjogXzMsIFwiZ3JcIjogXzMsIFwiZ3Jvc3NldG9cIjogXzMsIFwiaWdsZXNpYXMtY2FyYm9uaWFcIjogXzMsIFwiaWdsZXNpYXNjYXJib25pYVwiOiBfMywgXCJpbVwiOiBfMywgXCJpbXBlcmlhXCI6IF8zLCBcImlzXCI6IF8zLCBcImlzZXJuaWFcIjogXzMsIFwia3JcIjogXzMsIFwibGEtc3BlemlhXCI6IF8zLCBcImxhcXVpbGFcIjogXzMsIFwibGFzcGV6aWFcIjogXzMsIFwibGF0aW5hXCI6IF8zLCBcImxjXCI6IF8zLCBcImxlXCI6IF8zLCBcImxlY2NlXCI6IF8zLCBcImxlY2NvXCI6IF8zLCBcImxpXCI6IF8zLCBcImxpdm9ybm9cIjogXzMsIFwibG9cIjogXzMsIFwibG9kaVwiOiBfMywgXCJsdFwiOiBfMywgXCJsdVwiOiBfMywgXCJsdWNjYVwiOiBfMywgXCJtYWNlcmF0YVwiOiBfMywgXCJtYW50b3ZhXCI6IF8zLCBcIm1hc3NhLWNhcnJhcmFcIjogXzMsIFwibWFzc2FjYXJyYXJhXCI6IF8zLCBcIm1hdGVyYVwiOiBfMywgXCJtYlwiOiBfMywgXCJtY1wiOiBfMywgXCJtZVwiOiBfMywgXCJtZWRpby1jYW1waWRhbm9cIjogXzMsIFwibWVkaW9jYW1waWRhbm9cIjogXzMsIFwibWVzc2luYVwiOiBfMywgXCJtaVwiOiBfMywgXCJtaWxhblwiOiBfMywgXCJtaWxhbm9cIjogXzMsIFwibW5cIjogXzMsIFwibW9cIjogXzMsIFwibW9kZW5hXCI6IF8zLCBcIm1vbnphXCI6IF8zLCBcIm1vbnphLWJyaWFuemFcIjogXzMsIFwibW9uemEtZS1kZWxsYS1icmlhbnphXCI6IF8zLCBcIm1vbnphYnJpYW56YVwiOiBfMywgXCJtb256YWVicmlhbnphXCI6IF8zLCBcIm1vbnphZWRlbGxhYnJpYW56YVwiOiBfMywgXCJtc1wiOiBfMywgXCJtdFwiOiBfMywgXCJuYVwiOiBfMywgXCJuYXBsZXNcIjogXzMsIFwibmFwb2xpXCI6IF8zLCBcIm5vXCI6IF8zLCBcIm5vdmFyYVwiOiBfMywgXCJudVwiOiBfMywgXCJudW9yb1wiOiBfMywgXCJvZ1wiOiBfMywgXCJvZ2xpYXN0cmFcIjogXzMsIFwib2xiaWEtdGVtcGlvXCI6IF8zLCBcIm9sYmlhdGVtcGlvXCI6IF8zLCBcIm9yXCI6IF8zLCBcIm9yaXN0YW5vXCI6IF8zLCBcIm90XCI6IF8zLCBcInBhXCI6IF8zLCBcInBhZG92YVwiOiBfMywgXCJwYWR1YVwiOiBfMywgXCJwYWxlcm1vXCI6IF8zLCBcInBhcm1hXCI6IF8zLCBcInBhdmlhXCI6IF8zLCBcInBjXCI6IF8zLCBcInBkXCI6IF8zLCBcInBlXCI6IF8zLCBcInBlcnVnaWFcIjogXzMsIFwicGVzYXJvLXVyYmlub1wiOiBfMywgXCJwZXNhcm91cmJpbm9cIjogXzMsIFwicGVzY2FyYVwiOiBfMywgXCJwZ1wiOiBfMywgXCJwaVwiOiBfMywgXCJwaWFjZW56YVwiOiBfMywgXCJwaXNhXCI6IF8zLCBcInBpc3RvaWFcIjogXzMsIFwicG5cIjogXzMsIFwicG9cIjogXzMsIFwicG9yZGVub25lXCI6IF8zLCBcInBvdGVuemFcIjogXzMsIFwicHJcIjogXzMsIFwicHJhdG9cIjogXzMsIFwicHRcIjogXzMsIFwicHVcIjogXzMsIFwicHZcIjogXzMsIFwicHpcIjogXzMsIFwicmFcIjogXzMsIFwicmFndXNhXCI6IF8zLCBcInJhdmVubmFcIjogXzMsIFwicmNcIjogXzMsIFwicmVcIjogXzMsIFwicmVnZ2lvLWNhbGFicmlhXCI6IF8zLCBcInJlZ2dpby1lbWlsaWFcIjogXzMsIFwicmVnZ2lvY2FsYWJyaWFcIjogXzMsIFwicmVnZ2lvZW1pbGlhXCI6IF8zLCBcInJnXCI6IF8zLCBcInJpXCI6IF8zLCBcInJpZXRpXCI6IF8zLCBcInJpbWluaVwiOiBfMywgXCJybVwiOiBfMywgXCJyblwiOiBfMywgXCJyb1wiOiBfMywgXCJyb21hXCI6IF8zLCBcInJvbWVcIjogXzMsIFwicm92aWdvXCI6IF8zLCBcInNhXCI6IF8zLCBcInNhbGVybm9cIjogXzMsIFwic2Fzc2FyaVwiOiBfMywgXCJzYXZvbmFcIjogXzMsIFwic2lcIjogXzMsIFwic2llbmFcIjogXzMsIFwic2lyYWN1c2FcIjogXzMsIFwic29cIjogXzMsIFwic29uZHJpb1wiOiBfMywgXCJzcFwiOiBfMywgXCJzclwiOiBfMywgXCJzc1wiOiBfMywgXCJ4bi0tc2R0aXJvbC1uMmFcIjogXzMsIFwic8O8ZHRpcm9sXCI6IF8zLCBcInN1ZWR0aXJvbFwiOiBfMywgXCJzdlwiOiBfMywgXCJ0YVwiOiBfMywgXCJ0YXJhbnRvXCI6IF8zLCBcInRlXCI6IF8zLCBcInRlbXBpby1vbGJpYVwiOiBfMywgXCJ0ZW1waW9vbGJpYVwiOiBfMywgXCJ0ZXJhbW9cIjogXzMsIFwidGVybmlcIjogXzMsIFwidG5cIjogXzMsIFwidG9cIjogXzMsIFwidG9yaW5vXCI6IF8zLCBcInRwXCI6IF8zLCBcInRyXCI6IF8zLCBcInRyYW5pLWFuZHJpYS1iYXJsZXR0YVwiOiBfMywgXCJ0cmFuaS1iYXJsZXR0YS1hbmRyaWFcIjogXzMsIFwidHJhbmlhbmRyaWFiYXJsZXR0YVwiOiBfMywgXCJ0cmFuaWJhcmxldHRhYW5kcmlhXCI6IF8zLCBcInRyYXBhbmlcIjogXzMsIFwidHJlbnRvXCI6IF8zLCBcInRyZXZpc29cIjogXzMsIFwidHJpZXN0ZVwiOiBfMywgXCJ0c1wiOiBfMywgXCJ0dXJpblwiOiBfMywgXCJ0dlwiOiBfMywgXCJ1ZFwiOiBfMywgXCJ1ZGluZVwiOiBfMywgXCJ1cmJpbm8tcGVzYXJvXCI6IF8zLCBcInVyYmlub3Blc2Fyb1wiOiBfMywgXCJ2YVwiOiBfMywgXCJ2YXJlc2VcIjogXzMsIFwidmJcIjogXzMsIFwidmNcIjogXzMsIFwidmVcIjogXzMsIFwidmVuZXppYVwiOiBfMywgXCJ2ZW5pY2VcIjogXzMsIFwidmVyYmFuaWFcIjogXzMsIFwidmVyY2VsbGlcIjogXzMsIFwidmVyb25hXCI6IF8zLCBcInZpXCI6IF8zLCBcInZpYm8tdmFsZW50aWFcIjogXzMsIFwidmlib3ZhbGVudGlhXCI6IF8zLCBcInZpY2VuemFcIjogXzMsIFwidml0ZXJib1wiOiBfMywgXCJ2clwiOiBfMywgXCJ2c1wiOiBfMywgXCJ2dFwiOiBfMywgXCJ2dlwiOiBfMywgXCIxMmNoYXJzXCI6IF80LCBcImlieG9zXCI6IF80LCBcImlsaWFkYm94b3NcIjogXzQsIFwibmVlblwiOiBbMCwgeyBcImpjXCI6IF80IH1dLCBcIjEyM2hvbWVwYWdlXCI6IF80LCBcIjE2LWJcIjogXzQsIFwiMzItYlwiOiBfNCwgXCI2NC1iXCI6IF80LCBcIm15c3ByZWFkc2hvcFwiOiBfNCwgXCJzeW5jbG91ZFwiOiBfNCB9XSwgXCJqZVwiOiBbMSwgeyBcImNvXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwib2ZcIjogXzQgfV0sIFwiam1cIjogXzE3LCBcImpvXCI6IFsxLCB7IFwiYWdyaVwiOiBfMywgXCJhaVwiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImVuZ1wiOiBfMywgXCJmbVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicGVyXCI6IF8zLCBcInBoZFwiOiBfMywgXCJzY2hcIjogXzMsIFwidHZcIjogXzMgfV0sIFwiam9ic1wiOiBfMywgXCJqcFwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImFkXCI6IF8zLCBcImNvXCI6IF8zLCBcImVkXCI6IF8zLCBcImdvXCI6IF8zLCBcImdyXCI6IF8zLCBcImxnXCI6IF8zLCBcIm5lXCI6IFsxLCB7IFwiYXNlaW5ldFwiOiBfNDgsIFwiZ2VoaXJuXCI6IF80LCBcIml2b3J5XCI6IF80LCBcIm1haWwtYm94XCI6IF80LCBcIm1pbnRzXCI6IF80LCBcIm1va3VyZW5cIjogXzQsIFwib3BhbFwiOiBfNCwgXCJzYWt1cmFcIjogXzQsIFwic3Vtb21vXCI6IF80LCBcInRvcGF6XCI6IF80IH1dLCBcIm9yXCI6IF8zLCBcImFpY2hpXCI6IFsxLCB7IFwiYWlzYWlcIjogXzMsIFwiYW1hXCI6IF8zLCBcImFuam9cIjogXzMsIFwiYXN1a2VcIjogXzMsIFwiY2hpcnl1XCI6IF8zLCBcImNoaXRhXCI6IF8zLCBcImZ1c29cIjogXzMsIFwiZ2FtYWdvcmlcIjogXzMsIFwiaGFuZGFcIjogXzMsIFwiaGF6dVwiOiBfMywgXCJoZWtpbmFuXCI6IF8zLCBcImhpZ2FzaGl1cmFcIjogXzMsIFwiaWNoaW5vbWl5YVwiOiBfMywgXCJpbmF6YXdhXCI6IF8zLCBcImludXlhbWFcIjogXzMsIFwiaXNzaGlraVwiOiBfMywgXCJpd2FrdXJhXCI6IF8zLCBcImthbmllXCI6IF8zLCBcImthcml5YVwiOiBfMywgXCJrYXN1Z2FpXCI6IF8zLCBcImtpcmFcIjogXzMsIFwia2l5b3N1XCI6IF8zLCBcImtvbWFraVwiOiBfMywgXCJrb25hblwiOiBfMywgXCJrb3RhXCI6IF8zLCBcIm1paGFtYVwiOiBfMywgXCJtaXlvc2hpXCI6IF8zLCBcIm5pc2hpb1wiOiBfMywgXCJuaXNzaGluXCI6IF8zLCBcIm9idVwiOiBfMywgXCJvZ3VjaGlcIjogXzMsIFwib2hhcnVcIjogXzMsIFwib2themFraVwiOiBfMywgXCJvd2FyaWFzYWhpXCI6IF8zLCBcInNldG9cIjogXzMsIFwic2hpa2F0c3VcIjogXzMsIFwic2hpbnNoaXJvXCI6IF8zLCBcInNoaXRhcmFcIjogXzMsIFwidGFoYXJhXCI6IF8zLCBcInRha2FoYW1hXCI6IF8zLCBcInRvYmlzaGltYVwiOiBfMywgXCJ0b2VpXCI6IF8zLCBcInRvZ29cIjogXzMsIFwidG9rYWlcIjogXzMsIFwidG9rb25hbWVcIjogXzMsIFwidG95b2FrZVwiOiBfMywgXCJ0b3lvaGFzaGlcIjogXzMsIFwidG95b2thd2FcIjogXzMsIFwidG95b25lXCI6IF8zLCBcInRveW90YVwiOiBfMywgXCJ0c3VzaGltYVwiOiBfMywgXCJ5YXRvbWlcIjogXzMgfV0sIFwiYWtpdGFcIjogWzEsIHsgXCJha2l0YVwiOiBfMywgXCJkYWlzZW5cIjogXzMsIFwiZnVqaXNhdG9cIjogXzMsIFwiZ29qb21lXCI6IF8zLCBcImhhY2hpcm9nYXRhXCI6IF8zLCBcImhhcHBvdVwiOiBfMywgXCJoaWdhc2hpbmFydXNlXCI6IF8zLCBcImhvbmpvXCI6IF8zLCBcImhvbmp5b1wiOiBfMywgXCJpa2F3YVwiOiBfMywgXCJrYW1pa29hbmlcIjogXzMsIFwia2FtaW9rYVwiOiBfMywgXCJrYXRhZ2FtaVwiOiBfMywgXCJrYXp1bm9cIjogXzMsIFwia2l0YWFraXRhXCI6IF8zLCBcImtvc2FrYVwiOiBfMywgXCJreW93YVwiOiBfMywgXCJtaXNhdG9cIjogXzMsIFwibWl0YW5lXCI6IF8zLCBcIm1vcml5b3NoaVwiOiBfMywgXCJuaWthaG9cIjogXzMsIFwibm9zaGlyb1wiOiBfMywgXCJvZGF0ZVwiOiBfMywgXCJvZ2FcIjogXzMsIFwib2dhdGFcIjogXzMsIFwic2VtYm9rdVwiOiBfMywgXCJ5b2tvdGVcIjogXzMsIFwieXVyaWhvbmpvXCI6IF8zIH1dLCBcImFvbW9yaVwiOiBbMSwgeyBcImFvbW9yaVwiOiBfMywgXCJnb25vaGVcIjogXzMsIFwiaGFjaGlub2hlXCI6IF8zLCBcImhhc2hpa2FtaVwiOiBfMywgXCJoaXJhbmFpXCI6IF8zLCBcImhpcm9zYWtpXCI6IF8zLCBcIml0YXlhbmFnaVwiOiBfMywgXCJrdXJvaXNoaVwiOiBfMywgXCJtaXNhd2FcIjogXzMsIFwibXV0c3VcIjogXzMsIFwibmFrYWRvbWFyaVwiOiBfMywgXCJub2hlamlcIjogXzMsIFwib2lyYXNlXCI6IF8zLCBcIm93YW5pXCI6IF8zLCBcInJva3Vub2hlXCI6IF8zLCBcInNhbm5vaGVcIjogXzMsIFwic2hpY2hpbm9oZVwiOiBfMywgXCJzaGluZ29cIjogXzMsIFwidGFra29cIjogXzMsIFwidG93YWRhXCI6IF8zLCBcInRzdWdhcnVcIjogXzMsIFwidHN1cnV0YVwiOiBfMyB9XSwgXCJjaGliYVwiOiBbMSwgeyBcImFiaWtvXCI6IF8zLCBcImFzYWhpXCI6IF8zLCBcImNob25hblwiOiBfMywgXCJjaG9zZWlcIjogXzMsIFwiY2hvc2hpXCI6IF8zLCBcImNodW9cIjogXzMsIFwiZnVuYWJhc2hpXCI6IF8zLCBcImZ1dHRzdVwiOiBfMywgXCJoYW5hbWlnYXdhXCI6IF8zLCBcImljaGloYXJhXCI6IF8zLCBcImljaGlrYXdhXCI6IF8zLCBcImljaGlub21peWFcIjogXzMsIFwiaW56YWlcIjogXzMsIFwiaXN1bWlcIjogXzMsIFwia2FtYWdheWFcIjogXzMsIFwia2Ftb2dhd2FcIjogXzMsIFwia2FzaGl3YVwiOiBfMywgXCJrYXRvcmlcIjogXzMsIFwia2F0c3V1cmFcIjogXzMsIFwia2ltaXRzdVwiOiBfMywgXCJraXNhcmF6dVwiOiBfMywgXCJrb3pha2lcIjogXzMsIFwia3VqdWt1cmlcIjogXzMsIFwia3lvbmFuXCI6IF8zLCBcIm1hdHN1ZG9cIjogXzMsIFwibWlkb3JpXCI6IF8zLCBcIm1paGFtYVwiOiBfMywgXCJtaW5hbWlib3NvXCI6IF8zLCBcIm1vYmFyYVwiOiBfMywgXCJtdXRzdXphd2FcIjogXzMsIFwibmFnYXJhXCI6IF8zLCBcIm5hZ2FyZXlhbWFcIjogXzMsIFwibmFyYXNoaW5vXCI6IF8zLCBcIm5hcml0YVwiOiBfMywgXCJub2RhXCI6IF8zLCBcIm9hbWlzaGlyYXNhdG9cIjogXzMsIFwib21pZ2F3YVwiOiBfMywgXCJvbmp1a3VcIjogXzMsIFwib3Rha2lcIjogXzMsIFwic2FrYWVcIjogXzMsIFwic2FrdXJhXCI6IF8zLCBcInNoaW1vZnVzYVwiOiBfMywgXCJzaGlyYWtvXCI6IF8zLCBcInNoaXJvaVwiOiBfMywgXCJzaGlzdWlcIjogXzMsIFwic29kZWdhdXJhXCI6IF8zLCBcInNvc2FcIjogXzMsIFwidGFrb1wiOiBfMywgXCJ0YXRleWFtYVwiOiBfMywgXCJ0b2dhbmVcIjogXzMsIFwidG9obm9zaG9cIjogXzMsIFwidG9taXNhdG9cIjogXzMsIFwidXJheWFzdVwiOiBfMywgXCJ5YWNoaW1hdGFcIjogXzMsIFwieWFjaGl5b1wiOiBfMywgXCJ5b2thaWNoaWJhXCI6IF8zLCBcInlva29zaGliYWhpa2FyaVwiOiBfMywgXCJ5b3RzdWthaWRvXCI6IF8zIH1dLCBcImVoaW1lXCI6IFsxLCB7IFwiYWluYW5cIjogXzMsIFwiaG9uYWlcIjogXzMsIFwiaWthdGFcIjogXzMsIFwiaW1hYmFyaVwiOiBfMywgXCJpeW9cIjogXzMsIFwia2FtaWppbWFcIjogXzMsIFwia2lob2t1XCI6IF8zLCBcImt1bWFrb2dlblwiOiBfMywgXCJtYXNha2lcIjogXzMsIFwibWF0c3Vub1wiOiBfMywgXCJtYXRzdXlhbWFcIjogXzMsIFwibmFtaWthdGFcIjogXzMsIFwibmlpaGFtYVwiOiBfMywgXCJvenVcIjogXzMsIFwic2Fpam9cIjogXzMsIFwic2VpeW9cIjogXzMsIFwic2hpa29rdWNodW9cIjogXzMsIFwidG9iZVwiOiBfMywgXCJ0b29uXCI6IF8zLCBcInVjaGlrb1wiOiBfMywgXCJ1d2FqaW1hXCI6IF8zLCBcInlhd2F0YWhhbWFcIjogXzMgfV0sIFwiZnVrdWlcIjogWzEsIHsgXCJlY2hpemVuXCI6IF8zLCBcImVpaGVpamlcIjogXzMsIFwiZnVrdWlcIjogXzMsIFwiaWtlZGFcIjogXzMsIFwia2F0c3V5YW1hXCI6IF8zLCBcIm1paGFtYVwiOiBfMywgXCJtaW5hbWllY2hpemVuXCI6IF8zLCBcIm9iYW1hXCI6IF8zLCBcIm9oaVwiOiBfMywgXCJvbm9cIjogXzMsIFwic2FiYWVcIjogXzMsIFwic2FrYWlcIjogXzMsIFwidGFrYWhhbWFcIjogXzMsIFwidHN1cnVnYVwiOiBfMywgXCJ3YWthc2FcIjogXzMgfV0sIFwiZnVrdW9rYVwiOiBbMSwgeyBcImFzaGl5YVwiOiBfMywgXCJidXplblwiOiBfMywgXCJjaGlrdWdvXCI6IF8zLCBcImNoaWt1aG9cIjogXzMsIFwiY2hpa3Vqb1wiOiBfMywgXCJjaGlrdXNoaW5vXCI6IF8zLCBcImNoaWt1emVuXCI6IF8zLCBcImNodW9cIjogXzMsIFwiZGF6YWlmdVwiOiBfMywgXCJmdWt1Y2hpXCI6IF8zLCBcImhha2F0YVwiOiBfMywgXCJoaWdhc2hpXCI6IF8zLCBcImhpcm9rYXdhXCI6IF8zLCBcImhpc2F5YW1hXCI6IF8zLCBcImlpenVrYVwiOiBfMywgXCJpbmF0c3VraVwiOiBfMywgXCJrYWhvXCI6IF8zLCBcImthc3VnYVwiOiBfMywgXCJrYXN1eWFcIjogXzMsIFwia2F3YXJhXCI6IF8zLCBcImtlaXNlblwiOiBfMywgXCJrb2dhXCI6IF8zLCBcImt1cmF0ZVwiOiBfMywgXCJrdXJvZ2lcIjogXzMsIFwia3VydW1lXCI6IF8zLCBcIm1pbmFtaVwiOiBfMywgXCJtaXlha29cIjogXzMsIFwibWl5YW1hXCI6IF8zLCBcIm1peWF3YWthXCI6IF8zLCBcIm1penVtYWtpXCI6IF8zLCBcIm11bmFrYXRhXCI6IF8zLCBcIm5ha2FnYXdhXCI6IF8zLCBcIm5ha2FtYVwiOiBfMywgXCJuaXNoaVwiOiBfMywgXCJub2dhdGFcIjogXzMsIFwib2dvcmlcIjogXzMsIFwib2thZ2FraVwiOiBfMywgXCJva2F3YVwiOiBfMywgXCJva2lcIjogXzMsIFwib211dGFcIjogXzMsIFwib25nYVwiOiBfMywgXCJvbm9qb1wiOiBfMywgXCJvdG9cIjogXzMsIFwic2FpZ2F3YVwiOiBfMywgXCJzYXNhZ3VyaVwiOiBfMywgXCJzaGluZ3VcIjogXzMsIFwic2hpbnlvc2hpdG9taVwiOiBfMywgXCJzaG9uYWlcIjogXzMsIFwic29lZGFcIjogXzMsIFwic3VlXCI6IF8zLCBcInRhY2hpYXJhaVwiOiBfMywgXCJ0YWdhd2FcIjogXzMsIFwidGFrYXRhXCI6IF8zLCBcInRvaG9cIjogXzMsIFwidG95b3RzdVwiOiBfMywgXCJ0c3Vpa2lcIjogXzMsIFwidWtpaGFcIjogXzMsIFwidW1pXCI6IF8zLCBcInVzdWlcIjogXzMsIFwieWFtYWRhXCI6IF8zLCBcInlhbWVcIjogXzMsIFwieWFuYWdhd2FcIjogXzMsIFwieXVrdWhhc2hpXCI6IF8zIH1dLCBcImZ1a3VzaGltYVwiOiBbMSwgeyBcImFpenViYW5nZVwiOiBfMywgXCJhaXp1bWlzYXRvXCI6IF8zLCBcImFpenV3YWthbWF0c3VcIjogXzMsIFwiYXNha2F3YVwiOiBfMywgXCJiYW5kYWlcIjogXzMsIFwiZGF0ZVwiOiBfMywgXCJmdWt1c2hpbWFcIjogXzMsIFwiZnVydWRvbm9cIjogXzMsIFwiZnV0YWJhXCI6IF8zLCBcImhhbmF3YVwiOiBfMywgXCJoaWdhc2hpXCI6IF8zLCBcImhpcmF0YVwiOiBfMywgXCJoaXJvbm9cIjogXzMsIFwiaWl0YXRlXCI6IF8zLCBcImluYXdhc2hpcm9cIjogXzMsIFwiaXNoaWthd2FcIjogXzMsIFwiaXdha2lcIjogXzMsIFwiaXp1bWl6YWtpXCI6IF8zLCBcImthZ2FtaWlzaGlcIjogXzMsIFwia2FuZXlhbWFcIjogXzMsIFwia2F3YW1hdGFcIjogXzMsIFwia2l0YWthdGFcIjogXzMsIFwia2l0YXNoaW9iYXJhXCI6IF8zLCBcImtvb3JpXCI6IF8zLCBcImtvcml5YW1hXCI6IF8zLCBcImt1bmltaVwiOiBfMywgXCJtaWhhcnVcIjogXzMsIFwibWlzaGltYVwiOiBfMywgXCJuYW1pZVwiOiBfMywgXCJuYW5nb1wiOiBfMywgXCJuaXNoaWFpenVcIjogXzMsIFwibmlzaGlnb1wiOiBfMywgXCJva3VtYVwiOiBfMywgXCJvbW90ZWdvXCI6IF8zLCBcIm9ub1wiOiBfMywgXCJvdGFtYVwiOiBfMywgXCJzYW1lZ2F3YVwiOiBfMywgXCJzaGltb2dvXCI6IF8zLCBcInNoaXJha2F3YVwiOiBfMywgXCJzaG93YVwiOiBfMywgXCJzb21hXCI6IF8zLCBcInN1a2FnYXdhXCI6IF8zLCBcInRhaXNoaW5cIjogXzMsIFwidGFtYWthd2FcIjogXzMsIFwidGFuYWd1cmFcIjogXzMsIFwidGVuZWlcIjogXzMsIFwieWFidWtpXCI6IF8zLCBcInlhbWF0b1wiOiBfMywgXCJ5YW1hdHN1cmlcIjogXzMsIFwieWFuYWl6dVwiOiBfMywgXCJ5dWdhd2FcIjogXzMgfV0sIFwiZ2lmdVwiOiBbMSwgeyBcImFucGFjaGlcIjogXzMsIFwiZW5hXCI6IF8zLCBcImdpZnVcIjogXzMsIFwiZ2luYW5cIjogXzMsIFwiZ29kb1wiOiBfMywgXCJndWpvXCI6IF8zLCBcImhhc2hpbWFcIjogXzMsIFwiaGljaGlzb1wiOiBfMywgXCJoaWRhXCI6IF8zLCBcImhpZ2FzaGlzaGlyYWthd2FcIjogXzMsIFwiaWJpZ2F3YVwiOiBfMywgXCJpa2VkYVwiOiBfMywgXCJrYWthbWlnYWhhcmFcIjogXzMsIFwia2FuaVwiOiBfMywgXCJrYXNhaGFyYVwiOiBfMywgXCJrYXNhbWF0c3VcIjogXzMsIFwia2F3YXVlXCI6IF8zLCBcImtpdGFnYXRhXCI6IF8zLCBcIm1pbm9cIjogXzMsIFwibWlub2thbW9cIjogXzMsIFwibWl0YWtlXCI6IF8zLCBcIm1penVuYW1pXCI6IF8zLCBcIm1vdG9zdVwiOiBfMywgXCJuYWthdHN1Z2F3YVwiOiBfMywgXCJvZ2FraVwiOiBfMywgXCJzYWthaG9naVwiOiBfMywgXCJzZWtpXCI6IF8zLCBcInNla2lnYWhhcmFcIjogXzMsIFwic2hpcmFrYXdhXCI6IF8zLCBcInRhamltaVwiOiBfMywgXCJ0YWtheWFtYVwiOiBfMywgXCJ0YXJ1aVwiOiBfMywgXCJ0b2tpXCI6IF8zLCBcInRvbWlrYVwiOiBfMywgXCJ3YW5vdWNoaVwiOiBfMywgXCJ5YW1hZ2F0YVwiOiBfMywgXCJ5YW90c3VcIjogXzMsIFwieW9yb1wiOiBfMyB9XSwgXCJndW5tYVwiOiBbMSwgeyBcImFubmFrYVwiOiBfMywgXCJjaGl5b2RhXCI6IF8zLCBcImZ1amlva2FcIjogXzMsIFwiaGlnYXNoaWFnYXRzdW1hXCI6IF8zLCBcImlzZXNha2lcIjogXzMsIFwiaXRha3VyYVwiOiBfMywgXCJrYW5uYVwiOiBfMywgXCJrYW5yYVwiOiBfMywgXCJrYXRhc2hpbmFcIjogXzMsIFwia2F3YWJhXCI6IF8zLCBcImtpcnl1XCI6IF8zLCBcImt1c2F0c3VcIjogXzMsIFwibWFlYmFzaGlcIjogXzMsIFwibWVpd2FcIjogXzMsIFwibWlkb3JpXCI6IF8zLCBcIm1pbmFrYW1pXCI6IF8zLCBcIm5hZ2Fub2hhcmFcIjogXzMsIFwibmFrYW5vam9cIjogXzMsIFwibmFubW9rdVwiOiBfMywgXCJudW1hdGFcIjogXzMsIFwib2l6dW1pXCI6IF8zLCBcIm9yYVwiOiBfMywgXCJvdGFcIjogXzMsIFwic2hpYnVrYXdhXCI6IF8zLCBcInNoaW1vbml0YVwiOiBfMywgXCJzaGludG9cIjogXzMsIFwic2hvd2FcIjogXzMsIFwidGFrYXNha2lcIjogXzMsIFwidGFrYXlhbWFcIjogXzMsIFwidGFtYW11cmFcIjogXzMsIFwidGF0ZWJheWFzaGlcIjogXzMsIFwidG9taW9rYVwiOiBfMywgXCJ0c3VraXlvbm9cIjogXzMsIFwidHN1bWFnb2lcIjogXzMsIFwidWVub1wiOiBfMywgXCJ5b3NoaW9rYVwiOiBfMyB9XSwgXCJoaXJvc2hpbWFcIjogWzEsIHsgXCJhc2FtaW5hbWlcIjogXzMsIFwiZGFpd2FcIjogXzMsIFwiZXRhamltYVwiOiBfMywgXCJmdWNodVwiOiBfMywgXCJmdWt1eWFtYVwiOiBfMywgXCJoYXRzdWthaWNoaVwiOiBfMywgXCJoaWdhc2hpaGlyb3NoaW1hXCI6IF8zLCBcImhvbmdvXCI6IF8zLCBcImppbnNla2lrb2dlblwiOiBfMywgXCJrYWl0YVwiOiBfMywgXCJrdWlcIjogXzMsIFwia3VtYW5vXCI6IF8zLCBcImt1cmVcIjogXzMsIFwibWloYXJhXCI6IF8zLCBcIm1peW9zaGlcIjogXzMsIFwibmFrYVwiOiBfMywgXCJvbm9taWNoaVwiOiBfMywgXCJvc2FraWthbWlqaW1hXCI6IF8zLCBcIm90YWtlXCI6IF8zLCBcInNha2FcIjogXzMsIFwic2VyYVwiOiBfMywgXCJzZXJhbmlzaGlcIjogXzMsIFwic2hpbmljaGlcIjogXzMsIFwic2hvYmFyYVwiOiBfMywgXCJ0YWtlaGFyYVwiOiBfMyB9XSwgXCJob2trYWlkb1wiOiBbMSwgeyBcImFiYXNoaXJpXCI6IF8zLCBcImFiaXJhXCI6IF8zLCBcImFpYmV0c3VcIjogXzMsIFwiYWthYmlyYVwiOiBfMywgXCJha2tlc2hpXCI6IF8zLCBcImFzYWhpa2F3YVwiOiBfMywgXCJhc2hpYmV0c3VcIjogXzMsIFwiYXNob3JvXCI6IF8zLCBcImFzc2FidVwiOiBfMywgXCJhdHN1bWFcIjogXzMsIFwiYmliYWlcIjogXzMsIFwiYmllaVwiOiBfMywgXCJiaWZ1a2FcIjogXzMsIFwiYmlob3JvXCI6IF8zLCBcImJpcmF0b3JpXCI6IF8zLCBcImNoaXBwdWJldHN1XCI6IF8zLCBcImNoaXRvc2VcIjogXzMsIFwiZGF0ZVwiOiBfMywgXCJlYmV0c3VcIjogXzMsIFwiZW1iZXRzdVwiOiBfMywgXCJlbml3YVwiOiBfMywgXCJlcmltb1wiOiBfMywgXCJlc2FuXCI6IF8zLCBcImVzYXNoaVwiOiBfMywgXCJmdWthZ2F3YVwiOiBfMywgXCJmdWt1c2hpbWFcIjogXzMsIFwiZnVyYW5vXCI6IF8zLCBcImZ1cnViaXJhXCI6IF8zLCBcImhhYm9yb1wiOiBfMywgXCJoYWtvZGF0ZVwiOiBfMywgXCJoYW1hdG9uYmV0c3VcIjogXzMsIFwiaGlkYWthXCI6IF8zLCBcImhpZ2FzaGlrYWd1cmFcIjogXzMsIFwiaGlnYXNoaWthd2FcIjogXzMsIFwiaGlyb29cIjogXzMsIFwiaG9rdXJ5dVwiOiBfMywgXCJob2t1dG9cIjogXzMsIFwiaG9uYmV0c3VcIjogXzMsIFwiaG9yb2thbmFpXCI6IF8zLCBcImhvcm9ub2JlXCI6IF8zLCBcImlrZWRhXCI6IF8zLCBcImltYWthbmVcIjogXzMsIFwiaXNoaWthcmlcIjogXzMsIFwiaXdhbWl6YXdhXCI6IF8zLCBcIml3YW5haVwiOiBfMywgXCJrYW1pZnVyYW5vXCI6IF8zLCBcImthbWlrYXdhXCI6IF8zLCBcImthbWlzaGlob3JvXCI6IF8zLCBcImthbWlzdW5hZ2F3YVwiOiBfMywgXCJrYW1vZW5haVwiOiBfMywgXCJrYXlhYmVcIjogXzMsIFwia2VtYnVjaGlcIjogXzMsIFwia2lrb25haVwiOiBfMywgXCJraW1vYmV0c3VcIjogXzMsIFwia2l0YWhpcm9zaGltYVwiOiBfMywgXCJraXRhbWlcIjogXzMsIFwia2l5b3NhdG9cIjogXzMsIFwia29zaGltaXp1XCI6IF8zLCBcImt1bm5lcHB1XCI6IF8zLCBcImt1cml5YW1hXCI6IF8zLCBcImt1cm9tYXRzdW5haVwiOiBfMywgXCJrdXNoaXJvXCI6IF8zLCBcImt1dGNoYW5cIjogXzMsIFwia3lvd2FcIjogXzMsIFwibWFzaGlrZVwiOiBfMywgXCJtYXRzdW1hZVwiOiBfMywgXCJtaWthc2FcIjogXzMsIFwibWluYW1pZnVyYW5vXCI6IF8zLCBcIm1vbWJldHN1XCI6IF8zLCBcIm1vc2V1c2hpXCI6IF8zLCBcIm11a2F3YVwiOiBfMywgXCJtdXJvcmFuXCI6IF8zLCBcIm5haWVcIjogXzMsIFwibmFrYWdhd2FcIjogXzMsIFwibmFrYXNhdHN1bmFpXCI6IF8zLCBcIm5ha2F0b21iZXRzdVwiOiBfMywgXCJuYW5hZVwiOiBfMywgXCJuYW5wb3JvXCI6IF8zLCBcIm5heW9yb1wiOiBfMywgXCJuZW11cm9cIjogXzMsIFwibmlpa2FwcHVcIjogXzMsIFwibmlraVwiOiBfMywgXCJuaXNoaW9rb3BwZVwiOiBfMywgXCJub2JvcmliZXRzdVwiOiBfMywgXCJudW1hdGFcIjogXzMsIFwib2JpaGlyb1wiOiBfMywgXCJvYmlyYVwiOiBfMywgXCJva2V0b1wiOiBfMywgXCJva29wcGVcIjogXzMsIFwib3RhcnVcIjogXzMsIFwib3RvYmVcIjogXzMsIFwib3RvZnVrZVwiOiBfMywgXCJvdG9pbmVwcHVcIjogXzMsIFwib3VtdVwiOiBfMywgXCJvem9yYVwiOiBfMywgXCJwaXBwdVwiOiBfMywgXCJyYW5rb3NoaVwiOiBfMywgXCJyZWJ1blwiOiBfMywgXCJyaWt1YmV0c3VcIjogXzMsIFwicmlzaGlyaVwiOiBfMywgXCJyaXNoaXJpZnVqaVwiOiBfMywgXCJzYXJvbWFcIjogXzMsIFwic2FydWZ1dHN1XCI6IF8zLCBcInNoYWtvdGFuXCI6IF8zLCBcInNoYXJpXCI6IF8zLCBcInNoaWJlY2hhXCI6IF8zLCBcInNoaWJldHN1XCI6IF8zLCBcInNoaWthYmVcIjogXzMsIFwic2hpa2FvaVwiOiBfMywgXCJzaGltYW1ha2lcIjogXzMsIFwic2hpbWl6dVwiOiBfMywgXCJzaGltb2thd2FcIjogXzMsIFwic2hpbnNoaW5vdHN1XCI6IF8zLCBcInNoaW50b2t1XCI6IF8zLCBcInNoaXJhbnVrYVwiOiBfMywgXCJzaGlyYW9pXCI6IF8zLCBcInNoaXJpdWNoaVwiOiBfMywgXCJzb2JldHN1XCI6IF8zLCBcInN1bmFnYXdhXCI6IF8zLCBcInRhaWtpXCI6IF8zLCBcInRha2FzdVwiOiBfMywgXCJ0YWtpa2F3YVwiOiBfMywgXCJ0YWtpbm91ZVwiOiBfMywgXCJ0ZXNoaWthZ2FcIjogXzMsIFwidG9iZXRzdVwiOiBfMywgXCJ0b2htYVwiOiBfMywgXCJ0b21ha29tYWlcIjogXzMsIFwidG9tYXJpXCI6IF8zLCBcInRveWFcIjogXzMsIFwidG95YWtvXCI6IF8zLCBcInRveW90b21pXCI6IF8zLCBcInRveW91cmFcIjogXzMsIFwidHN1YmV0c3VcIjogXzMsIFwidHN1a2lnYXRhXCI6IF8zLCBcInVyYWthd2FcIjogXzMsIFwidXJhdXN1XCI6IF8zLCBcInVyeXVcIjogXzMsIFwidXRhc2hpbmFpXCI6IF8zLCBcIndha2thbmFpXCI6IF8zLCBcIndhc3NhbXVcIjogXzMsIFwieWFrdW1vXCI6IF8zLCBcInlvaWNoaVwiOiBfMyB9XSwgXCJoeW9nb1wiOiBbMSwgeyBcImFpb2lcIjogXzMsIFwiYWthc2hpXCI6IF8zLCBcImFrb1wiOiBfMywgXCJhbWFnYXNha2lcIjogXzMsIFwiYW9nYWtpXCI6IF8zLCBcImFzYWdvXCI6IF8zLCBcImFzaGl5YVwiOiBfMywgXCJhd2FqaVwiOiBfMywgXCJmdWt1c2FraVwiOiBfMywgXCJnb3NoaWtpXCI6IF8zLCBcImhhcmltYVwiOiBfMywgXCJoaW1lamlcIjogXzMsIFwiaWNoaWthd2FcIjogXzMsIFwiaW5hZ2F3YVwiOiBfMywgXCJpdGFtaVwiOiBfMywgXCJrYWtvZ2F3YVwiOiBfMywgXCJrYW1pZ29yaVwiOiBfMywgXCJrYW1pa2F3YVwiOiBfMywgXCJrYXNhaVwiOiBfMywgXCJrYXN1Z2FcIjogXzMsIFwia2F3YW5pc2hpXCI6IF8zLCBcIm1pa2lcIjogXzMsIFwibWluYW1pYXdhamlcIjogXzMsIFwibmlzaGlub21peWFcIjogXzMsIFwibmlzaGl3YWtpXCI6IF8zLCBcIm9ub1wiOiBfMywgXCJzYW5kYVwiOiBfMywgXCJzYW5uYW5cIjogXzMsIFwic2FzYXlhbWFcIjogXzMsIFwic2F5b1wiOiBfMywgXCJzaGluZ3VcIjogXzMsIFwic2hpbm9uc2VuXCI6IF8zLCBcInNoaXNvXCI6IF8zLCBcInN1bW90b1wiOiBfMywgXCJ0YWlzaGlcIjogXzMsIFwidGFrYVwiOiBfMywgXCJ0YWthcmF6dWthXCI6IF8zLCBcInRha2FzYWdvXCI6IF8zLCBcInRha2lub1wiOiBfMywgXCJ0YW1iYVwiOiBfMywgXCJ0YXRzdW5vXCI6IF8zLCBcInRveW9va2FcIjogXzMsIFwieWFidVwiOiBfMywgXCJ5YXNoaXJvXCI6IF8zLCBcInlva2FcIjogXzMsIFwieW9rYXdhXCI6IF8zIH1dLCBcImliYXJha2lcIjogWzEsIHsgXCJhbWlcIjogXzMsIFwiYXNhaGlcIjogXzMsIFwiYmFuZG9cIjogXzMsIFwiY2hpa3VzZWlcIjogXzMsIFwiZGFpZ29cIjogXzMsIFwiZnVqaXNoaXJvXCI6IF8zLCBcImhpdGFjaGlcIjogXzMsIFwiaGl0YWNoaW5ha2FcIjogXzMsIFwiaGl0YWNoaW9taXlhXCI6IF8zLCBcImhpdGFjaGlvdGFcIjogXzMsIFwiaWJhcmFraVwiOiBfMywgXCJpbmFcIjogXzMsIFwiaW5hc2hpa2lcIjogXzMsIFwiaXRha29cIjogXzMsIFwiaXdhbWFcIjogXzMsIFwiam9zb1wiOiBfMywgXCJrYW1pc3VcIjogXzMsIFwia2FzYW1hXCI6IF8zLCBcImthc2hpbWFcIjogXzMsIFwia2FzdW1pZ2F1cmFcIjogXzMsIFwia29nYVwiOiBfMywgXCJtaWhvXCI6IF8zLCBcIm1pdG9cIjogXzMsIFwibW9yaXlhXCI6IF8zLCBcIm5ha2FcIjogXzMsIFwibmFtZWdhdGFcIjogXzMsIFwib2FyYWlcIjogXzMsIFwib2dhd2FcIjogXzMsIFwib21pdGFtYVwiOiBfMywgXCJyeXVnYXNha2lcIjogXzMsIFwic2FrYWlcIjogXzMsIFwic2FrdXJhZ2F3YVwiOiBfMywgXCJzaGltb2RhdGVcIjogXzMsIFwic2hpbW90c3VtYVwiOiBfMywgXCJzaGlyb3NhdG9cIjogXzMsIFwic293YVwiOiBfMywgXCJzdWlmdVwiOiBfMywgXCJ0YWthaGFnaVwiOiBfMywgXCJ0YW1hdHN1a3VyaVwiOiBfMywgXCJ0b2thaVwiOiBfMywgXCJ0b21vYmVcIjogXzMsIFwidG9uZVwiOiBfMywgXCJ0b3JpZGVcIjogXzMsIFwidHN1Y2hpdXJhXCI6IF8zLCBcInRzdWt1YmFcIjogXzMsIFwidWNoaWhhcmFcIjogXzMsIFwidXNoaWt1XCI6IF8zLCBcInlhY2hpeW9cIjogXzMsIFwieWFtYWdhdGFcIjogXzMsIFwieWF3YXJhXCI6IF8zLCBcInl1a2lcIjogXzMgfV0sIFwiaXNoaWthd2FcIjogWzEsIHsgXCJhbmFtaXp1XCI6IF8zLCBcImhha3VpXCI6IF8zLCBcImhha3VzYW5cIjogXzMsIFwia2FnYVwiOiBfMywgXCJrYWhva3VcIjogXzMsIFwia2FuYXphd2FcIjogXzMsIFwia2F3YWtpdGFcIjogXzMsIFwia29tYXRzdVwiOiBfMywgXCJuYWthbm90b1wiOiBfMywgXCJuYW5hb1wiOiBfMywgXCJub21pXCI6IF8zLCBcIm5vbm9pY2hpXCI6IF8zLCBcIm5vdG9cIjogXzMsIFwic2hpa2FcIjogXzMsIFwic3V6dVwiOiBfMywgXCJ0c3ViYXRhXCI6IF8zLCBcInRzdXJ1Z2lcIjogXzMsIFwidWNoaW5hZGFcIjogXzMsIFwid2FqaW1hXCI6IF8zIH1dLCBcIml3YXRlXCI6IFsxLCB7IFwiZnVkYWlcIjogXzMsIFwiZnVqaXNhd2FcIjogXzMsIFwiaGFuYW1ha2lcIjogXzMsIFwiaGlyYWl6dW1pXCI6IF8zLCBcImhpcm9ub1wiOiBfMywgXCJpY2hpbm9oZVwiOiBfMywgXCJpY2hpbm9zZWtpXCI6IF8zLCBcIml3YWl6dW1pXCI6IF8zLCBcIml3YXRlXCI6IF8zLCBcImpvYm9qaVwiOiBfMywgXCJrYW1haXNoaVwiOiBfMywgXCJrYW5lZ2FzYWtpXCI6IF8zLCBcImthcnVtYWlcIjogXzMsIFwia2F3YWlcIjogXzMsIFwia2l0YWthbWlcIjogXzMsIFwia3VqaVwiOiBfMywgXCJrdW5vaGVcIjogXzMsIFwia3V6dW1ha2lcIjogXzMsIFwibWl5YWtvXCI6IF8zLCBcIm1penVzYXdhXCI6IF8zLCBcIm1vcmlva2FcIjogXzMsIFwibmlub2hlXCI6IF8zLCBcIm5vZGFcIjogXzMsIFwib2Z1bmF0b1wiOiBfMywgXCJvc2h1XCI6IF8zLCBcIm90c3VjaGlcIjogXzMsIFwicmlrdXplbnRha2F0YVwiOiBfMywgXCJzaGl3YVwiOiBfMywgXCJzaGl6dWt1aXNoaVwiOiBfMywgXCJzdW1pdGFcIjogXzMsIFwidGFub2hhdGFcIjogXzMsIFwidG9ub1wiOiBfMywgXCJ5YWhhYmFcIjogXzMsIFwieWFtYWRhXCI6IF8zIH1dLCBcImthZ2F3YVwiOiBbMSwgeyBcImF5YWdhd2FcIjogXzMsIFwiaGlnYXNoaWthZ2F3YVwiOiBfMywgXCJrYW5vbmppXCI6IF8zLCBcImtvdG9oaXJhXCI6IF8zLCBcIm1hbm5vXCI6IF8zLCBcIm1hcnVnYW1lXCI6IF8zLCBcIm1pdG95b1wiOiBfMywgXCJuYW9zaGltYVwiOiBfMywgXCJzYW51a2lcIjogXzMsIFwidGFkb3RzdVwiOiBfMywgXCJ0YWthbWF0c3VcIjogXzMsIFwidG9ub3Nob1wiOiBfMywgXCJ1Y2hpbm9taVwiOiBfMywgXCJ1dGF6dVwiOiBfMywgXCJ6ZW50c3VqaVwiOiBfMyB9XSwgXCJrYWdvc2hpbWFcIjogWzEsIHsgXCJha3VuZVwiOiBfMywgXCJhbWFtaVwiOiBfMywgXCJoaW9raVwiOiBfMywgXCJpc2FcIjogXzMsIFwiaXNlblwiOiBfMywgXCJpenVtaVwiOiBfMywgXCJrYWdvc2hpbWFcIjogXzMsIFwia2Fub3lhXCI6IF8zLCBcImthd2FuYWJlXCI6IF8zLCBcImtpbmtvXCI6IF8zLCBcImtvdXlhbWFcIjogXzMsIFwibWFrdXJhemFraVwiOiBfMywgXCJtYXRzdW1vdG9cIjogXzMsIFwibWluYW1pdGFuZVwiOiBfMywgXCJuYWthdGFuZVwiOiBfMywgXCJuaXNoaW5vb21vdGVcIjogXzMsIFwic2F0c3VtYXNlbmRhaVwiOiBfMywgXCJzb29cIjogXzMsIFwidGFydW1penVcIjogXzMsIFwieXVzdWlcIjogXzMgfV0sIFwia2FuYWdhd2FcIjogWzEsIHsgXCJhaWthd2FcIjogXzMsIFwiYXRzdWdpXCI6IF8zLCBcImF5YXNlXCI6IF8zLCBcImNoaWdhc2FraVwiOiBfMywgXCJlYmluYVwiOiBfMywgXCJmdWppc2F3YVwiOiBfMywgXCJoYWRhbm9cIjogXzMsIFwiaGFrb25lXCI6IF8zLCBcImhpcmF0c3VrYVwiOiBfMywgXCJpc2VoYXJhXCI6IF8zLCBcImthaXNlaVwiOiBfMywgXCJrYW1ha3VyYVwiOiBfMywgXCJraXlva2F3YVwiOiBfMywgXCJtYXRzdWRhXCI6IF8zLCBcIm1pbmFtaWFzaGlnYXJhXCI6IF8zLCBcIm1pdXJhXCI6IF8zLCBcIm5ha2FpXCI6IF8zLCBcIm5pbm9taXlhXCI6IF8zLCBcIm9kYXdhcmFcIjogXzMsIFwib2lcIjogXzMsIFwib2lzb1wiOiBfMywgXCJzYWdhbWloYXJhXCI6IF8zLCBcInNhbXVrYXdhXCI6IF8zLCBcInRzdWt1aVwiOiBfMywgXCJ5YW1ha2l0YVwiOiBfMywgXCJ5YW1hdG9cIjogXzMsIFwieW9rb3N1a2FcIjogXzMsIFwieXVnYXdhcmFcIjogXzMsIFwiemFtYVwiOiBfMywgXCJ6dXNoaVwiOiBfMyB9XSwgXCJrb2NoaVwiOiBbMSwgeyBcImFraVwiOiBfMywgXCJnZWlzZWlcIjogXzMsIFwiaGlkYWthXCI6IF8zLCBcImhpZ2FzaGl0c3Vub1wiOiBfMywgXCJpbm9cIjogXzMsIFwia2FnYW1pXCI6IF8zLCBcImthbWlcIjogXzMsIFwia2l0YWdhd2FcIjogXzMsIFwia29jaGlcIjogXzMsIFwibWloYXJhXCI6IF8zLCBcIm1vdG95YW1hXCI6IF8zLCBcIm11cm90b1wiOiBfMywgXCJuYWhhcmlcIjogXzMsIFwibmFrYW11cmFcIjogXzMsIFwibmFua29rdVwiOiBfMywgXCJuaXNoaXRvc2FcIjogXzMsIFwibml5b2RvZ2F3YVwiOiBfMywgXCJvY2hpXCI6IF8zLCBcIm9rYXdhXCI6IF8zLCBcIm90b3lvXCI6IF8zLCBcIm90c3VraVwiOiBfMywgXCJzYWthd2FcIjogXzMsIFwic3VrdW1vXCI6IF8zLCBcInN1c2FraVwiOiBfMywgXCJ0b3NhXCI6IF8zLCBcInRvc2FzaGltaXp1XCI6IF8zLCBcInRveW9cIjogXzMsIFwidHN1bm9cIjogXzMsIFwidW1hamlcIjogXzMsIFwieWFzdWRhXCI6IF8zLCBcInl1c3VoYXJhXCI6IF8zIH1dLCBcImt1bWFtb3RvXCI6IFsxLCB7IFwiYW1ha3VzYVwiOiBfMywgXCJhcmFvXCI6IF8zLCBcImFzb1wiOiBfMywgXCJjaG95b1wiOiBfMywgXCJneW9rdXRvXCI6IF8zLCBcImthbWlhbWFrdXNhXCI6IF8zLCBcImtpa3VjaGlcIjogXzMsIFwia3VtYW1vdG9cIjogXzMsIFwibWFzaGlraVwiOiBfMywgXCJtaWZ1bmVcIjogXzMsIFwibWluYW1hdGFcIjogXzMsIFwibWluYW1pb2d1bmlcIjogXzMsIFwibmFnYXN1XCI6IF8zLCBcIm5pc2hpaGFyYVwiOiBfMywgXCJvZ3VuaVwiOiBfMywgXCJvenVcIjogXzMsIFwic3Vtb3RvXCI6IF8zLCBcInRha2Ftb3JpXCI6IF8zLCBcInVraVwiOiBfMywgXCJ1dG9cIjogXzMsIFwieWFtYWdhXCI6IF8zLCBcInlhbWF0b1wiOiBfMywgXCJ5YXRzdXNoaXJvXCI6IF8zIH1dLCBcImt5b3RvXCI6IFsxLCB7IFwiYXlhYmVcIjogXzMsIFwiZnVrdWNoaXlhbWFcIjogXzMsIFwiaGlnYXNoaXlhbWFcIjogXzMsIFwiaWRlXCI6IF8zLCBcImluZVwiOiBfMywgXCJqb3lvXCI6IF8zLCBcImthbWVva2FcIjogXzMsIFwia2Ftb1wiOiBfMywgXCJraXRhXCI6IF8zLCBcImtpenVcIjogXzMsIFwia3VtaXlhbWFcIjogXzMsIFwia3lvdGFtYmFcIjogXzMsIFwia3lvdGFuYWJlXCI6IF8zLCBcImt5b3RhbmdvXCI6IF8zLCBcIm1haXp1cnVcIjogXzMsIFwibWluYW1pXCI6IF8zLCBcIm1pbmFtaXlhbWFzaGlyb1wiOiBfMywgXCJtaXlhenVcIjogXzMsIFwibXVrb1wiOiBfMywgXCJuYWdhb2tha3lvXCI6IF8zLCBcIm5ha2FneW9cIjogXzMsIFwibmFudGFuXCI6IF8zLCBcIm95YW1hemFraVwiOiBfMywgXCJzYWt5b1wiOiBfMywgXCJzZWlrYVwiOiBfMywgXCJ0YW5hYmVcIjogXzMsIFwidWppXCI6IF8zLCBcInVqaXRhd2FyYVwiOiBfMywgXCJ3YXp1a2FcIjogXzMsIFwieWFtYXNoaW5hXCI6IF8zLCBcInlhd2F0YVwiOiBfMyB9XSwgXCJtaWVcIjogWzEsIHsgXCJhc2FoaVwiOiBfMywgXCJpbmFiZVwiOiBfMywgXCJpc2VcIjogXzMsIFwia2FtZXlhbWFcIjogXzMsIFwia2F3YWdvZVwiOiBfMywgXCJraWhvXCI6IF8zLCBcImtpc29zYWtpXCI6IF8zLCBcImtpd2FcIjogXzMsIFwia29tb25vXCI6IF8zLCBcImt1bWFub1wiOiBfMywgXCJrdXdhbmFcIjogXzMsIFwibWF0c3VzYWthXCI6IF8zLCBcIm1laXdhXCI6IF8zLCBcIm1paGFtYVwiOiBfMywgXCJtaW5hbWlpc2VcIjogXzMsIFwibWlzdWdpXCI6IF8zLCBcIm1peWFtYVwiOiBfMywgXCJuYWJhcmlcIjogXzMsIFwic2hpbWFcIjogXzMsIFwic3V6dWthXCI6IF8zLCBcInRhZG9cIjogXzMsIFwidGFpa2lcIjogXzMsIFwidGFraVwiOiBfMywgXCJ0YW1ha2lcIjogXzMsIFwidG9iYVwiOiBfMywgXCJ0c3VcIjogXzMsIFwidWRvbm9cIjogXzMsIFwidXJlc2hpbm9cIjogXzMsIFwid2F0YXJhaVwiOiBfMywgXCJ5b2trYWljaGlcIjogXzMgfV0sIFwibWl5YWdpXCI6IFsxLCB7IFwiZnVydWthd2FcIjogXzMsIFwiaGlnYXNoaW1hdHN1c2hpbWFcIjogXzMsIFwiaXNoaW5vbWFraVwiOiBfMywgXCJpd2FudW1hXCI6IF8zLCBcImtha3VkYVwiOiBfMywgXCJrYW1pXCI6IF8zLCBcImthd2FzYWtpXCI6IF8zLCBcIm1hcnVtb3JpXCI6IF8zLCBcIm1hdHN1c2hpbWFcIjogXzMsIFwibWluYW1pc2FucmlrdVwiOiBfMywgXCJtaXNhdG9cIjogXzMsIFwibXVyYXRhXCI6IF8zLCBcIm5hdG9yaVwiOiBfMywgXCJvZ2F3YXJhXCI6IF8zLCBcIm9oaXJhXCI6IF8zLCBcIm9uYWdhd2FcIjogXzMsIFwib3Nha2lcIjogXzMsIFwicmlmdVwiOiBfMywgXCJzZW1pbmVcIjogXzMsIFwic2hpYmF0YVwiOiBfMywgXCJzaGljaGlrYXNodWt1XCI6IF8zLCBcInNoaWthbWFcIjogXzMsIFwic2hpb2dhbWFcIjogXzMsIFwic2hpcm9pc2hpXCI6IF8zLCBcInRhZ2Fqb1wiOiBfMywgXCJ0YWl3YVwiOiBfMywgXCJ0b21lXCI6IF8zLCBcInRvbWl5YVwiOiBfMywgXCJ3YWt1eWFcIjogXzMsIFwid2F0YXJpXCI6IF8zLCBcInlhbWFtb3RvXCI6IF8zLCBcInphb1wiOiBfMyB9XSwgXCJtaXlhemFraVwiOiBbMSwgeyBcImF5YVwiOiBfMywgXCJlYmlub1wiOiBfMywgXCJnb2thc2VcIjogXzMsIFwiaHl1Z2FcIjogXzMsIFwia2Fkb2dhd2FcIjogXzMsIFwia2F3YW1pbmFtaVwiOiBfMywgXCJraWpvXCI6IF8zLCBcImtpdGFnYXdhXCI6IF8zLCBcImtpdGFrYXRhXCI6IF8zLCBcImtpdGF1cmFcIjogXzMsIFwia29iYXlhc2hpXCI6IF8zLCBcImt1bml0b21pXCI6IF8zLCBcImt1c2hpbWFcIjogXzMsIFwibWltYXRhXCI6IF8zLCBcIm1peWFrb25vam9cIjogXzMsIFwibWl5YXpha2lcIjogXzMsIFwibW9yb3RzdWthXCI6IF8zLCBcIm5pY2hpbmFuXCI6IF8zLCBcIm5pc2hpbWVyYVwiOiBfMywgXCJub2Jlb2thXCI6IF8zLCBcInNhaXRvXCI6IF8zLCBcInNoaWliYVwiOiBfMywgXCJzaGludG9taVwiOiBfMywgXCJ0YWthaGFydVwiOiBfMywgXCJ0YWthbmFiZVwiOiBfMywgXCJ0YWthemFraVwiOiBfMywgXCJ0c3Vub1wiOiBfMyB9XSwgXCJuYWdhbm9cIjogWzEsIHsgXCJhY2hpXCI6IF8zLCBcImFnZW1hdHN1XCI6IF8zLCBcImFuYW5cIjogXzMsIFwiYW9raVwiOiBfMywgXCJhc2FoaVwiOiBfMywgXCJhenVtaW5vXCI6IF8zLCBcImNoaWt1aG9rdVwiOiBfMywgXCJjaGlrdW1hXCI6IF8zLCBcImNoaW5vXCI6IF8zLCBcImZ1amltaVwiOiBfMywgXCJoYWt1YmFcIjogXzMsIFwiaGFyYVwiOiBfMywgXCJoaXJheWFcIjogXzMsIFwiaWlkYVwiOiBfMywgXCJpaWppbWFcIjogXzMsIFwiaWl5YW1hXCI6IF8zLCBcImlpenVuYVwiOiBfMywgXCJpa2VkYVwiOiBfMywgXCJpa3VzYWthXCI6IF8zLCBcImluYVwiOiBfMywgXCJrYXJ1aXphd2FcIjogXzMsIFwia2F3YWthbWlcIjogXzMsIFwia2lzb1wiOiBfMywgXCJraXNvZnVrdXNoaW1hXCI6IF8zLCBcImtpdGFhaWtpXCI6IF8zLCBcImtvbWFnYW5lXCI6IF8zLCBcImtvbW9yb1wiOiBfMywgXCJtYXRzdWthd2FcIjogXzMsIFwibWF0c3Vtb3RvXCI6IF8zLCBcIm1pYXNhXCI6IF8zLCBcIm1pbmFtaWFpa2lcIjogXzMsIFwibWluYW1pbWFraVwiOiBfMywgXCJtaW5hbWltaW5vd2FcIjogXzMsIFwibWlub3dhXCI6IF8zLCBcIm1peWFkYVwiOiBfMywgXCJtaXlvdGFcIjogXzMsIFwibW9jaGl6dWtpXCI6IF8zLCBcIm5hZ2Fub1wiOiBfMywgXCJuYWdhd2FcIjogXzMsIFwibmFnaXNvXCI6IF8zLCBcIm5ha2FnYXdhXCI6IF8zLCBcIm5ha2Fub1wiOiBfMywgXCJub3phd2FvbnNlblwiOiBfMywgXCJvYnVzZVwiOiBfMywgXCJvZ2F3YVwiOiBfMywgXCJva2F5YVwiOiBfMywgXCJvbWFjaGlcIjogXzMsIFwib21pXCI6IF8zLCBcIm9va3V3YVwiOiBfMywgXCJvb3NoaWthXCI6IF8zLCBcIm90YWtpXCI6IF8zLCBcIm90YXJpXCI6IF8zLCBcInNha2FlXCI6IF8zLCBcInNha2FraVwiOiBfMywgXCJzYWt1XCI6IF8zLCBcInNha3Vob1wiOiBfMywgXCJzaGltb3N1d2FcIjogXzMsIFwic2hpbmFub21hY2hpXCI6IF8zLCBcInNoaW9qaXJpXCI6IF8zLCBcInN1d2FcIjogXzMsIFwic3V6YWthXCI6IF8zLCBcInRha2FnaVwiOiBfMywgXCJ0YWthbW9yaVwiOiBfMywgXCJ0YWtheWFtYVwiOiBfMywgXCJ0YXRlc2hpbmFcIjogXzMsIFwidGF0c3Vub1wiOiBfMywgXCJ0b2dha3VzaGlcIjogXzMsIFwidG9ndXJhXCI6IF8zLCBcInRvbWlcIjogXzMsIFwidWVkYVwiOiBfMywgXCJ3YWRhXCI6IF8zLCBcInlhbWFnYXRhXCI6IF8zLCBcInlhbWFub3VjaGlcIjogXzMsIFwieWFzYWthXCI6IF8zLCBcInlhc3Vva2FcIjogXzMgfV0sIFwibmFnYXNha2lcIjogWzEsIHsgXCJjaGlqaXdhXCI6IF8zLCBcImZ1dHN1XCI6IF8zLCBcImdvdG9cIjogXzMsIFwiaGFzYW1pXCI6IF8zLCBcImhpcmFkb1wiOiBfMywgXCJpa2lcIjogXzMsIFwiaXNhaGF5YVwiOiBfMywgXCJrYXdhdGFuYVwiOiBfMywgXCJrdWNoaW5vdHN1XCI6IF8zLCBcIm1hdHN1dXJhXCI6IF8zLCBcIm5hZ2FzYWtpXCI6IF8zLCBcIm9iYW1hXCI6IF8zLCBcIm9tdXJhXCI6IF8zLCBcIm9zZXRvXCI6IF8zLCBcInNhaWthaVwiOiBfMywgXCJzYXNlYm9cIjogXzMsIFwic2VpaGlcIjogXzMsIFwic2hpbWFiYXJhXCI6IF8zLCBcInNoaW5rYW1pZ290b1wiOiBfMywgXCJ0b2dpdHN1XCI6IF8zLCBcInRzdXNoaW1hXCI6IF8zLCBcInVuemVuXCI6IF8zIH1dLCBcIm5hcmFcIjogWzEsIHsgXCJhbmRvXCI6IF8zLCBcImdvc2VcIjogXzMsIFwiaGVndXJpXCI6IF8zLCBcImhpZ2FzaGl5b3NoaW5vXCI6IF8zLCBcImlrYXJ1Z2FcIjogXzMsIFwiaWtvbWFcIjogXzMsIFwia2FtaWtpdGF5YW1hXCI6IF8zLCBcImthbm1ha2lcIjogXzMsIFwia2FzaGliYVwiOiBfMywgXCJrYXNoaWhhcmFcIjogXzMsIFwia2F0c3VyYWdpXCI6IF8zLCBcImthd2FpXCI6IF8zLCBcImthd2FrYW1pXCI6IF8zLCBcImthd2FuaXNoaVwiOiBfMywgXCJrb3J5b1wiOiBfMywgXCJrdXJvdGFraVwiOiBfMywgXCJtaXRzdWVcIjogXzMsIFwibWl5YWtlXCI6IF8zLCBcIm5hcmFcIjogXzMsIFwibm9zZWdhd2FcIjogXzMsIFwib2ppXCI6IF8zLCBcIm91ZGFcIjogXzMsIFwib3lvZG9cIjogXzMsIFwic2FrdXJhaVwiOiBfMywgXCJzYW5nb1wiOiBfMywgXCJzaGltb2ljaGlcIjogXzMsIFwic2hpbW9raXRheWFtYVwiOiBfMywgXCJzaGluam9cIjogXzMsIFwic29uaVwiOiBfMywgXCJ0YWthdG9yaVwiOiBfMywgXCJ0YXdhcmFtb3RvXCI6IF8zLCBcInRlbmthd2FcIjogXzMsIFwidGVucmlcIjogXzMsIFwidWRhXCI6IF8zLCBcInlhbWF0b2tvcml5YW1hXCI6IF8zLCBcInlhbWF0b3Rha2FkYVwiOiBfMywgXCJ5YW1hem9lXCI6IF8zLCBcInlvc2hpbm9cIjogXzMgfV0sIFwibmlpZ2F0YVwiOiBbMSwgeyBcImFnYVwiOiBfMywgXCJhZ2Fub1wiOiBfMywgXCJnb3NlblwiOiBfMywgXCJpdG9pZ2F3YVwiOiBfMywgXCJpenVtb3pha2lcIjogXzMsIFwiam9ldHN1XCI6IF8zLCBcImthbW9cIjogXzMsIFwia2FyaXdhXCI6IF8zLCBcImthc2hpd2F6YWtpXCI6IF8zLCBcIm1pbmFtaXVvbnVtYVwiOiBfMywgXCJtaXRzdWtlXCI6IF8zLCBcIm11aWthXCI6IF8zLCBcIm11cmFrYW1pXCI6IF8zLCBcIm15b2tvXCI6IF8zLCBcIm5hZ2Fva2FcIjogXzMsIFwibmlpZ2F0YVwiOiBfMywgXCJvaml5YVwiOiBfMywgXCJvbWlcIjogXzMsIFwic2Fkb1wiOiBfMywgXCJzYW5qb1wiOiBfMywgXCJzZWlyb1wiOiBfMywgXCJzZWlyb3VcIjogXzMsIFwic2VraWthd2FcIjogXzMsIFwic2hpYmF0YVwiOiBfMywgXCJ0YWdhbWlcIjogXzMsIFwidGFpbmFpXCI6IF8zLCBcInRvY2hpb1wiOiBfMywgXCJ0b2thbWFjaGlcIjogXzMsIFwidHN1YmFtZVwiOiBfMywgXCJ0c3VuYW5cIjogXzMsIFwidW9udW1hXCI6IF8zLCBcInlhaGlrb1wiOiBfMywgXCJ5b2l0YVwiOiBfMywgXCJ5dXphd2FcIjogXzMgfV0sIFwib2l0YVwiOiBbMSwgeyBcImJlcHB1XCI6IF8zLCBcImJ1bmdvb25vXCI6IF8zLCBcImJ1bmdvdGFrYWRhXCI6IF8zLCBcImhhc2FtYVwiOiBfMywgXCJoaWppXCI6IF8zLCBcImhpbWVzaGltYVwiOiBfMywgXCJoaXRhXCI6IF8zLCBcImthbWl0c3VlXCI6IF8zLCBcImtva29ub2VcIjogXzMsIFwia3VqdVwiOiBfMywgXCJrdW5pc2FraVwiOiBfMywgXCJrdXN1XCI6IF8zLCBcIm9pdGFcIjogXzMsIFwic2Fpa2lcIjogXzMsIFwidGFrZXRhXCI6IF8zLCBcInRzdWt1bWlcIjogXzMsIFwidXNhXCI6IF8zLCBcInVzdWtpXCI6IF8zLCBcInl1ZnVcIjogXzMgfV0sIFwib2theWFtYVwiOiBbMSwgeyBcImFrYWl3YVwiOiBfMywgXCJhc2FrdWNoaVwiOiBfMywgXCJiaXplblwiOiBfMywgXCJoYXlhc2hpbWFcIjogXzMsIFwiaWJhcmFcIjogXzMsIFwia2FnYW1pbm9cIjogXzMsIFwia2FzYW9rYVwiOiBfMywgXCJraWJpY2h1b1wiOiBfMywgXCJrdW1lbmFuXCI6IF8zLCBcImt1cmFzaGlraVwiOiBfMywgXCJtYW5pd2FcIjogXzMsIFwibWlzYWtpXCI6IF8zLCBcIm5hZ2lcIjogXzMsIFwibmlpbWlcIjogXzMsIFwibmlzaGlhd2FrdXJhXCI6IF8zLCBcIm9rYXlhbWFcIjogXzMsIFwic2F0b3Nob1wiOiBfMywgXCJzZXRvdWNoaVwiOiBfMywgXCJzaGluam9cIjogXzMsIFwic2hvb1wiOiBfMywgXCJzb2phXCI6IF8zLCBcInRha2FoYXNoaVwiOiBfMywgXCJ0YW1hbm9cIjogXzMsIFwidHN1eWFtYVwiOiBfMywgXCJ3YWtlXCI6IF8zLCBcInlha2FnZVwiOiBfMyB9XSwgXCJva2luYXdhXCI6IFsxLCB7IFwiYWd1bmlcIjogXzMsIFwiZ2lub3dhblwiOiBfMywgXCJnaW5vemFcIjogXzMsIFwiZ3VzaGlrYW1pXCI6IF8zLCBcImhhZWJhcnVcIjogXzMsIFwiaGlnYXNoaVwiOiBfMywgXCJoaXJhcmFcIjogXzMsIFwiaWhleWFcIjogXzMsIFwiaXNoaWdha2lcIjogXzMsIFwiaXNoaWthd2FcIjogXzMsIFwiaXRvbWFuXCI6IF8zLCBcIml6ZW5hXCI6IF8zLCBcImthZGVuYVwiOiBfMywgXCJraW5cIjogXzMsIFwia2l0YWRhaXRvXCI6IF8zLCBcImtpdGFuYWthZ3VzdWt1XCI6IF8zLCBcImt1bWVqaW1hXCI6IF8zLCBcImt1bmlnYW1pXCI6IF8zLCBcIm1pbmFtaWRhaXRvXCI6IF8zLCBcIm1vdG9idVwiOiBfMywgXCJuYWdvXCI6IF8zLCBcIm5haGFcIjogXzMsIFwibmFrYWd1c3VrdVwiOiBfMywgXCJuYWtpamluXCI6IF8zLCBcIm5hbmpvXCI6IF8zLCBcIm5pc2hpaGFyYVwiOiBfMywgXCJvZ2ltaVwiOiBfMywgXCJva2luYXdhXCI6IF8zLCBcIm9ubmFcIjogXzMsIFwic2hpbW9qaVwiOiBfMywgXCJ0YWtldG9taVwiOiBfMywgXCJ0YXJhbWFcIjogXzMsIFwidG9rYXNoaWtpXCI6IF8zLCBcInRvbWlndXN1a3VcIjogXzMsIFwidG9uYWtpXCI6IF8zLCBcInVyYXNvZVwiOiBfMywgXCJ1cnVtYVwiOiBfMywgXCJ5YWVzZVwiOiBfMywgXCJ5b21pdGFuXCI6IF8zLCBcInlvbmFiYXJ1XCI6IF8zLCBcInlvbmFndW5pXCI6IF8zLCBcInphbWFtaVwiOiBfMyB9XSwgXCJvc2FrYVwiOiBbMSwgeyBcImFiZW5vXCI6IF8zLCBcImNoaWhheWFha2FzYWthXCI6IF8zLCBcImNodW9cIjogXzMsIFwiZGFpdG9cIjogXzMsIFwiZnVqaWlkZXJhXCI6IF8zLCBcImhhYmlraW5vXCI6IF8zLCBcImhhbm5hblwiOiBfMywgXCJoaWdhc2hpb3Nha2FcIjogXzMsIFwiaGlnYXNoaXN1bWl5b3NoaVwiOiBfMywgXCJoaWdhc2hpeW9kb2dhd2FcIjogXzMsIFwiaGlyYWthdGFcIjogXzMsIFwiaWJhcmFraVwiOiBfMywgXCJpa2VkYVwiOiBfMywgXCJpenVtaVwiOiBfMywgXCJpenVtaW90c3VcIjogXzMsIFwiaXp1bWlzYW5vXCI6IF8zLCBcImthZG9tYVwiOiBfMywgXCJrYWl6dWthXCI6IF8zLCBcImthbmFuXCI6IF8zLCBcImthc2hpd2FyYVwiOiBfMywgXCJrYXRhbm9cIjogXzMsIFwia2F3YWNoaW5hZ2Fub1wiOiBfMywgXCJraXNoaXdhZGFcIjogXzMsIFwia2l0YVwiOiBfMywgXCJrdW1hdG9yaVwiOiBfMywgXCJtYXRzdWJhcmFcIjogXzMsIFwibWluYXRvXCI6IF8zLCBcIm1pbm9oXCI6IF8zLCBcIm1pc2FraVwiOiBfMywgXCJtb3JpZ3VjaGlcIjogXzMsIFwibmV5YWdhd2FcIjogXzMsIFwibmlzaGlcIjogXzMsIFwibm9zZVwiOiBfMywgXCJvc2FrYXNheWFtYVwiOiBfMywgXCJzYWthaVwiOiBfMywgXCJzYXlhbWFcIjogXzMsIFwic2VubmFuXCI6IF8zLCBcInNldHRzdVwiOiBfMywgXCJzaGlqb25hd2F0ZVwiOiBfMywgXCJzaGltYW1vdG9cIjogXzMsIFwic3VpdGFcIjogXzMsIFwidGFkYW9rYVwiOiBfMywgXCJ0YWlzaGlcIjogXzMsIFwidGFqaXJpXCI6IF8zLCBcInRha2Fpc2hpXCI6IF8zLCBcInRha2F0c3VraVwiOiBfMywgXCJ0b25kYWJheWFzaGlcIjogXzMsIFwidG95b25ha2FcIjogXzMsIFwidG95b25vXCI6IF8zLCBcInlhb1wiOiBfMyB9XSwgXCJzYWdhXCI6IFsxLCB7IFwiYXJpYWtlXCI6IF8zLCBcImFyaXRhXCI6IF8zLCBcImZ1a3Vkb21pXCI6IF8zLCBcImdlbmthaVwiOiBfMywgXCJoYW1hdGFtYVwiOiBfMywgXCJoaXplblwiOiBfMywgXCJpbWFyaVwiOiBfMywgXCJrYW1pbWluZVwiOiBfMywgXCJrYW56YWtpXCI6IF8zLCBcImthcmF0c3VcIjogXzMsIFwia2FzaGltYVwiOiBfMywgXCJraXRhZ2F0YVwiOiBfMywgXCJraXRhaGF0YVwiOiBfMywgXCJraXlhbWFcIjogXzMsIFwia291aG9rdVwiOiBfMywgXCJreXVyYWdpXCI6IF8zLCBcIm5pc2hpYXJpdGFcIjogXzMsIFwib2dpXCI6IF8zLCBcIm9tYWNoaVwiOiBfMywgXCJvdWNoaVwiOiBfMywgXCJzYWdhXCI6IF8zLCBcInNoaXJvaXNoaVwiOiBfMywgXCJ0YWt1XCI6IF8zLCBcInRhcmFcIjogXzMsIFwidG9zdVwiOiBfMywgXCJ5b3NoaW5vZ2FyaVwiOiBfMyB9XSwgXCJzYWl0YW1hXCI6IFsxLCB7IFwiYXJha2F3YVwiOiBfMywgXCJhc2FrYVwiOiBfMywgXCJjaGljaGlidVwiOiBfMywgXCJmdWppbWlcIjogXzMsIFwiZnVqaW1pbm9cIjogXzMsIFwiZnVrYXlhXCI6IF8zLCBcImhhbm5vXCI6IF8zLCBcImhhbnl1XCI6IF8zLCBcImhhc3VkYVwiOiBfMywgXCJoYXRvZ2F5YVwiOiBfMywgXCJoYXRveWFtYVwiOiBfMywgXCJoaWRha2FcIjogXzMsIFwiaGlnYXNoaWNoaWNoaWJ1XCI6IF8zLCBcImhpZ2FzaGltYXRzdXlhbWFcIjogXzMsIFwiaG9uam9cIjogXzMsIFwiaW5hXCI6IF8zLCBcImlydW1hXCI6IF8zLCBcIml3YXRzdWtpXCI6IF8zLCBcImthbWlpenVtaVwiOiBfMywgXCJrYW1pa2F3YVwiOiBfMywgXCJrYW1pc2F0b1wiOiBfMywgXCJrYXN1a2FiZVwiOiBfMywgXCJrYXdhZ29lXCI6IF8zLCBcImthd2FndWNoaVwiOiBfMywgXCJrYXdhamltYVwiOiBfMywgXCJrYXpvXCI6IF8zLCBcImtpdGFtb3RvXCI6IF8zLCBcImtvc2hpZ2F5YVwiOiBfMywgXCJrb3Vub3N1XCI6IF8zLCBcImt1a2lcIjogXzMsIFwia3VtYWdheWFcIjogXzMsIFwibWF0c3VidXNoaVwiOiBfMywgXCJtaW5hbm9cIjogXzMsIFwibWlzYXRvXCI6IF8zLCBcIm1peWFzaGlyb1wiOiBfMywgXCJtaXlvc2hpXCI6IF8zLCBcIm1vcm95YW1hXCI6IF8zLCBcIm5hZ2F0b3JvXCI6IF8zLCBcIm5hbWVnYXdhXCI6IF8zLCBcIm5paXphXCI6IF8zLCBcIm9nYW5vXCI6IF8zLCBcIm9nYXdhXCI6IF8zLCBcIm9nb3NlXCI6IF8zLCBcIm9rZWdhd2FcIjogXzMsIFwib21peWFcIjogXzMsIFwib3Rha2lcIjogXzMsIFwicmFuemFuXCI6IF8zLCBcInJ5b2thbWlcIjogXzMsIFwic2FpdGFtYVwiOiBfMywgXCJzYWthZG9cIjogXzMsIFwic2F0dGVcIjogXzMsIFwic2F5YW1hXCI6IF8zLCBcInNoaWtpXCI6IF8zLCBcInNoaXJhb2thXCI6IF8zLCBcInNva2FcIjogXzMsIFwic3VnaXRvXCI6IF8zLCBcInRvZGFcIjogXzMsIFwidG9raWdhd2FcIjogXzMsIFwidG9rb3JvemF3YVwiOiBfMywgXCJ0c3VydWdhc2hpbWFcIjogXzMsIFwidXJhd2FcIjogXzMsIFwid2FyYWJpXCI6IF8zLCBcInlhc2hpb1wiOiBfMywgXCJ5b2tvemVcIjogXzMsIFwieW9ub1wiOiBfMywgXCJ5b3JpaVwiOiBfMywgXCJ5b3NoaWRhXCI6IF8zLCBcInlvc2hpa2F3YVwiOiBfMywgXCJ5b3NoaW1pXCI6IF8zIH1dLCBcInNoaWdhXCI6IFsxLCB7IFwiYWlzaG9cIjogXzMsIFwiZ2Ftb1wiOiBfMywgXCJoaWdhc2hpb21pXCI6IF8zLCBcImhpa29uZVwiOiBfMywgXCJrb2thXCI6IF8zLCBcImtvbmFuXCI6IF8zLCBcImtvc2VpXCI6IF8zLCBcImtvdG9cIjogXzMsIFwia3VzYXRzdVwiOiBfMywgXCJtYWliYXJhXCI6IF8zLCBcIm1vcml5YW1hXCI6IF8zLCBcIm5hZ2FoYW1hXCI6IF8zLCBcIm5pc2hpYXphaVwiOiBfMywgXCJub3RvZ2F3YVwiOiBfMywgXCJvbWloYWNoaW1hblwiOiBfMywgXCJvdHN1XCI6IF8zLCBcInJpdHRvXCI6IF8zLCBcInJ5dW9oXCI6IF8zLCBcInRha2FzaGltYVwiOiBfMywgXCJ0YWthdHN1a2lcIjogXzMsIFwidG9yYWhpbWVcIjogXzMsIFwidG95b3NhdG9cIjogXzMsIFwieWFzdVwiOiBfMyB9XSwgXCJzaGltYW5lXCI6IFsxLCB7IFwiYWthZ2lcIjogXzMsIFwiYW1hXCI6IF8zLCBcImdvdHN1XCI6IF8zLCBcImhhbWFkYVwiOiBfMywgXCJoaWdhc2hpaXp1bW9cIjogXzMsIFwiaGlrYXdhXCI6IF8zLCBcImhpa2ltaVwiOiBfMywgXCJpenVtb1wiOiBfMywgXCJrYWtpbm9raVwiOiBfMywgXCJtYXN1ZGFcIjogXzMsIFwibWF0c3VlXCI6IF8zLCBcIm1pc2F0b1wiOiBfMywgXCJuaXNoaW5vc2hpbWFcIjogXzMsIFwib2hkYVwiOiBfMywgXCJva2lub3NoaW1hXCI6IF8zLCBcIm9rdWl6dW1vXCI6IF8zLCBcInNoaW1hbmVcIjogXzMsIFwidGFtYXl1XCI6IF8zLCBcInRzdXdhbm9cIjogXzMsIFwidW5uYW5cIjogXzMsIFwieWFrdW1vXCI6IF8zLCBcInlhc3VnaVwiOiBfMywgXCJ5YXRzdWthXCI6IF8zIH1dLCBcInNoaXp1b2thXCI6IFsxLCB7IFwiYXJhaVwiOiBfMywgXCJhdGFtaVwiOiBfMywgXCJmdWppXCI6IF8zLCBcImZ1amllZGFcIjogXzMsIFwiZnVqaWthd2FcIjogXzMsIFwiZnVqaW5vbWl5YVwiOiBfMywgXCJmdWt1cm9pXCI6IF8zLCBcImdvdGVtYmFcIjogXzMsIFwiaGFpYmFyYVwiOiBfMywgXCJoYW1hbWF0c3VcIjogXzMsIFwiaGlnYXNoaWl6dVwiOiBfMywgXCJpdG9cIjogXzMsIFwiaXdhdGFcIjogXzMsIFwiaXp1XCI6IF8zLCBcIml6dW5va3VuaVwiOiBfMywgXCJrYWtlZ2F3YVwiOiBfMywgXCJrYW5uYW1pXCI6IF8zLCBcImthd2FuZWhvblwiOiBfMywgXCJrYXdhenVcIjogXzMsIFwia2lrdWdhd2FcIjogXzMsIFwia29zYWlcIjogXzMsIFwibWFraW5vaGFyYVwiOiBfMywgXCJtYXRzdXpha2lcIjogXzMsIFwibWluYW1paXp1XCI6IF8zLCBcIm1pc2hpbWFcIjogXzMsIFwibW9yaW1hY2hpXCI6IF8zLCBcIm5pc2hpaXp1XCI6IF8zLCBcIm51bWF6dVwiOiBfMywgXCJvbWFlemFraVwiOiBfMywgXCJzaGltYWRhXCI6IF8zLCBcInNoaW1penVcIjogXzMsIFwic2hpbW9kYVwiOiBfMywgXCJzaGl6dW9rYVwiOiBfMywgXCJzdXNvbm9cIjogXzMsIFwieWFpenVcIjogXzMsIFwieW9zaGlkYVwiOiBfMyB9XSwgXCJ0b2NoaWdpXCI6IFsxLCB7IFwiYXNoaWthZ2FcIjogXzMsIFwiYmF0b1wiOiBfMywgXCJoYWdhXCI6IF8zLCBcImljaGlrYWlcIjogXzMsIFwiaXdhZnVuZVwiOiBfMywgXCJrYW1pbm9rYXdhXCI6IF8zLCBcImthbnVtYVwiOiBfMywgXCJrYXJhc3V5YW1hXCI6IF8zLCBcImt1cm9pc29cIjogXzMsIFwibWFzaGlrb1wiOiBfMywgXCJtaWJ1XCI6IF8zLCBcIm1va2FcIjogXzMsIFwibW90ZWdpXCI6IF8zLCBcIm5hc3VcIjogXzMsIFwibmFzdXNoaW9iYXJhXCI6IF8zLCBcIm5pa2tvXCI6IF8zLCBcIm5pc2hpa2F0YVwiOiBfMywgXCJub2dpXCI6IF8zLCBcIm9oaXJhXCI6IF8zLCBcIm9odGF3YXJhXCI6IF8zLCBcIm95YW1hXCI6IF8zLCBcInNha3VyYVwiOiBfMywgXCJzYW5vXCI6IF8zLCBcInNoaW1vdHN1a2VcIjogXzMsIFwic2hpb3lhXCI6IF8zLCBcInRha2FuZXphd2FcIjogXzMsIFwidG9jaGlnaVwiOiBfMywgXCJ0c3VnYVwiOiBfMywgXCJ1amlpZVwiOiBfMywgXCJ1dHN1bm9taXlhXCI6IF8zLCBcInlhaXRhXCI6IF8zIH1dLCBcInRva3VzaGltYVwiOiBbMSwgeyBcImFpenVtaVwiOiBfMywgXCJhbmFuXCI6IF8zLCBcImljaGliYVwiOiBfMywgXCJpdGFub1wiOiBfMywgXCJrYWluYW5cIjogXzMsIFwia29tYXRzdXNoaW1hXCI6IF8zLCBcIm1hdHN1c2hpZ2VcIjogXzMsIFwibWltYVwiOiBfMywgXCJtaW5hbWlcIjogXzMsIFwibWl5b3NoaVwiOiBfMywgXCJtdWdpXCI6IF8zLCBcIm5ha2FnYXdhXCI6IF8zLCBcIm5hcnV0b1wiOiBfMywgXCJzYW5hZ29jaGlcIjogXzMsIFwic2hpc2hpa3VpXCI6IF8zLCBcInRva3VzaGltYVwiOiBfMywgXCJ3YWppa2lcIjogXzMgfV0sIFwidG9reW9cIjogWzEsIHsgXCJhZGFjaGlcIjogXzMsIFwiYWtpcnVub1wiOiBfMywgXCJha2lzaGltYVwiOiBfMywgXCJhb2dhc2hpbWFcIjogXzMsIFwiYXJha2F3YVwiOiBfMywgXCJidW5reW9cIjogXzMsIFwiY2hpeW9kYVwiOiBfMywgXCJjaG9mdVwiOiBfMywgXCJjaHVvXCI6IF8zLCBcImVkb2dhd2FcIjogXzMsIFwiZnVjaHVcIjogXzMsIFwiZnVzc2FcIjogXzMsIFwiaGFjaGlqb1wiOiBfMywgXCJoYWNoaW9qaVwiOiBfMywgXCJoYW11cmFcIjogXzMsIFwiaGlnYXNoaWt1cnVtZVwiOiBfMywgXCJoaWdhc2hpbXVyYXlhbWFcIjogXzMsIFwiaGlnYXNoaXlhbWF0b1wiOiBfMywgXCJoaW5vXCI6IF8zLCBcImhpbm9kZVwiOiBfMywgXCJoaW5vaGFyYVwiOiBfMywgXCJpbmFnaVwiOiBfMywgXCJpdGFiYXNoaVwiOiBfMywgXCJrYXRzdXNoaWthXCI6IF8zLCBcImtpdGFcIjogXzMsIFwia2l5b3NlXCI6IF8zLCBcImtvZGFpcmFcIjogXzMsIFwia29nYW5laVwiOiBfMywgXCJrb2t1YnVuamlcIjogXzMsIFwia29tYWVcIjogXzMsIFwia290b1wiOiBfMywgXCJrb3V6dXNoaW1hXCI6IF8zLCBcImt1bml0YWNoaVwiOiBfMywgXCJtYWNoaWRhXCI6IF8zLCBcIm1lZ3Vyb1wiOiBfMywgXCJtaW5hdG9cIjogXzMsIFwibWl0YWthXCI6IF8zLCBcIm1penVob1wiOiBfMywgXCJtdXNhc2hpbXVyYXlhbWFcIjogXzMsIFwibXVzYXNoaW5vXCI6IF8zLCBcIm5ha2Fub1wiOiBfMywgXCJuZXJpbWFcIjogXzMsIFwib2dhc2F3YXJhXCI6IF8zLCBcIm9rdXRhbWFcIjogXzMsIFwib21lXCI6IF8zLCBcIm9zaGltYVwiOiBfMywgXCJvdGFcIjogXzMsIFwic2V0YWdheWFcIjogXzMsIFwic2hpYnV5YVwiOiBfMywgXCJzaGluYWdhd2FcIjogXzMsIFwic2hpbmp1a3VcIjogXzMsIFwic3VnaW5hbWlcIjogXzMsIFwic3VtaWRhXCI6IF8zLCBcInRhY2hpa2F3YVwiOiBfMywgXCJ0YWl0b1wiOiBfMywgXCJ0YW1hXCI6IF8zLCBcInRvc2hpbWFcIjogXzMgfV0sIFwidG90dG9yaVwiOiBbMSwgeyBcImNoaXp1XCI6IF8zLCBcImhpbm9cIjogXzMsIFwia2F3YWhhcmFcIjogXzMsIFwia29nZVwiOiBfMywgXCJrb3RvdXJhXCI6IF8zLCBcIm1pc2FzYVwiOiBfMywgXCJuYW5idVwiOiBfMywgXCJuaWNoaW5hblwiOiBfMywgXCJzYWthaW1pbmF0b1wiOiBfMywgXCJ0b3R0b3JpXCI6IF8zLCBcIndha2FzYVwiOiBfMywgXCJ5YXp1XCI6IF8zLCBcInlvbmFnb1wiOiBfMyB9XSwgXCJ0b3lhbWFcIjogWzEsIHsgXCJhc2FoaVwiOiBfMywgXCJmdWNodVwiOiBfMywgXCJmdWt1bWl0c3VcIjogXzMsIFwiZnVuYWhhc2hpXCI6IF8zLCBcImhpbWlcIjogXzMsIFwiaW1penVcIjogXzMsIFwiaW5hbWlcIjogXzMsIFwiam9oYW5hXCI6IF8zLCBcImthbWlpY2hpXCI6IF8zLCBcImt1cm9iZVwiOiBfMywgXCJuYWthbmlpa2F3YVwiOiBfMywgXCJuYW1lcmlrYXdhXCI6IF8zLCBcIm5hbnRvXCI6IF8zLCBcIm55dXplblwiOiBfMywgXCJveWFiZVwiOiBfMywgXCJ0YWlyYVwiOiBfMywgXCJ0YWthb2thXCI6IF8zLCBcInRhdGV5YW1hXCI6IF8zLCBcInRvZ2FcIjogXzMsIFwidG9uYW1pXCI6IF8zLCBcInRveWFtYVwiOiBfMywgXCJ1bmF6dWtpXCI6IF8zLCBcInVvenVcIjogXzMsIFwieWFtYWRhXCI6IF8zIH1dLCBcIndha2F5YW1hXCI6IFsxLCB7IFwiYXJpZGFcIjogXzMsIFwiYXJpZGFnYXdhXCI6IF8zLCBcImdvYm9cIjogXzMsIFwiaGFzaGltb3RvXCI6IF8zLCBcImhpZGFrYVwiOiBfMywgXCJoaXJvZ2F3YVwiOiBfMywgXCJpbmFtaVwiOiBfMywgXCJpd2FkZVwiOiBfMywgXCJrYWluYW5cIjogXzMsIFwia2FtaXRvbmRhXCI6IF8zLCBcImthdHN1cmFnaVwiOiBfMywgXCJraW1pbm9cIjogXzMsIFwia2lub2thd2FcIjogXzMsIFwia2l0YXlhbWFcIjogXzMsIFwia295YVwiOiBfMywgXCJrb3phXCI6IF8zLCBcImtvemFnYXdhXCI6IF8zLCBcImt1ZG95YW1hXCI6IF8zLCBcImt1c2hpbW90b1wiOiBfMywgXCJtaWhhbWFcIjogXzMsIFwibWlzYXRvXCI6IF8zLCBcIm5hY2hpa2F0c3V1cmFcIjogXzMsIFwic2hpbmd1XCI6IF8zLCBcInNoaXJhaGFtYVwiOiBfMywgXCJ0YWlqaVwiOiBfMywgXCJ0YW5hYmVcIjogXzMsIFwid2FrYXlhbWFcIjogXzMsIFwieXVhc2FcIjogXzMsIFwieXVyYVwiOiBfMyB9XSwgXCJ5YW1hZ2F0YVwiOiBbMSwgeyBcImFzYWhpXCI6IF8zLCBcImZ1bmFnYXRhXCI6IF8zLCBcImhpZ2FzaGluZVwiOiBfMywgXCJpaWRlXCI6IF8zLCBcImthaG9rdVwiOiBfMywgXCJrYW1pbm95YW1hXCI6IF8zLCBcImthbmV5YW1hXCI6IF8zLCBcImthd2FuaXNoaVwiOiBfMywgXCJtYW11cm9nYXdhXCI6IF8zLCBcIm1pa2F3YVwiOiBfMywgXCJtdXJheWFtYVwiOiBfMywgXCJuYWdhaVwiOiBfMywgXCJuYWtheWFtYVwiOiBfMywgXCJuYW55b1wiOiBfMywgXCJuaXNoaWthd2FcIjogXzMsIFwib2JhbmF6YXdhXCI6IF8zLCBcIm9lXCI6IF8zLCBcIm9ndW5pXCI6IF8zLCBcIm9oa3VyYVwiOiBfMywgXCJvaXNoaWRhXCI6IF8zLCBcInNhZ2FlXCI6IF8zLCBcInNha2F0YVwiOiBfMywgXCJzYWtlZ2F3YVwiOiBfMywgXCJzaGluam9cIjogXzMsIFwic2hpcmF0YWthXCI6IF8zLCBcInNob25haVwiOiBfMywgXCJ0YWthaGF0YVwiOiBfMywgXCJ0ZW5kb1wiOiBfMywgXCJ0b3phd2FcIjogXzMsIFwidHN1cnVva2FcIjogXzMsIFwieWFtYWdhdGFcIjogXzMsIFwieWFtYW5vYmVcIjogXzMsIFwieW9uZXphd2FcIjogXzMsIFwieXV6YVwiOiBfMyB9XSwgXCJ5YW1hZ3VjaGlcIjogWzEsIHsgXCJhYnVcIjogXzMsIFwiaGFnaVwiOiBfMywgXCJoaWthcmlcIjogXzMsIFwiaG9mdVwiOiBfMywgXCJpd2FrdW5pXCI6IF8zLCBcImt1ZGFtYXRzdVwiOiBfMywgXCJtaXRvdVwiOiBfMywgXCJuYWdhdG9cIjogXzMsIFwib3NoaW1hXCI6IF8zLCBcInNoaW1vbm9zZWtpXCI6IF8zLCBcInNodW5hblwiOiBfMywgXCJ0YWJ1c2VcIjogXzMsIFwidG9rdXlhbWFcIjogXzMsIFwidG95b3RhXCI6IF8zLCBcInViZVwiOiBfMywgXCJ5dXVcIjogXzMgfV0sIFwieWFtYW5hc2hpXCI6IFsxLCB7IFwiY2h1b1wiOiBfMywgXCJkb3NoaVwiOiBfMywgXCJmdWVmdWtpXCI6IF8zLCBcImZ1amlrYXdhXCI6IF8zLCBcImZ1amlrYXdhZ3VjaGlrb1wiOiBfMywgXCJmdWppeW9zaGlkYVwiOiBfMywgXCJoYXlha2F3YVwiOiBfMywgXCJob2t1dG9cIjogXzMsIFwiaWNoaWthd2FtaXNhdG9cIjogXzMsIFwia2FpXCI6IF8zLCBcImtvZnVcIjogXzMsIFwia29zaHVcIjogXzMsIFwia29zdWdlXCI6IF8zLCBcIm1pbmFtaS1hbHBzXCI6IF8zLCBcIm1pbm9idVwiOiBfMywgXCJuYWthbWljaGlcIjogXzMsIFwibmFuYnVcIjogXzMsIFwibmFydXNhd2FcIjogXzMsIFwibmlyYXNha2lcIjogXzMsIFwibmlzaGlrYXRzdXJhXCI6IF8zLCBcIm9zaGlub1wiOiBfMywgXCJvdHN1a2lcIjogXzMsIFwic2hvd2FcIjogXzMsIFwidGFiYXlhbWFcIjogXzMsIFwidHN1cnVcIjogXzMsIFwidWVub2hhcmFcIjogXzMsIFwieWFtYW5ha2Frb1wiOiBfMywgXCJ5YW1hbmFzaGlcIjogXzMgfV0sIFwieG4tLWVocXo1Nm5cIjogXzMsIFwi5LiJ6YeNXCI6IF8zLCBcInhuLS0xbHFzMDNuXCI6IF8zLCBcIuS6rOmDvVwiOiBfMywgXCJ4bi0tcXFxdDExbVwiOiBfMywgXCLkvZDos4BcIjogXzMsIFwieG4tLWY2cXg1M2FcIjogXzMsIFwi5YW15bqrXCI6IF8zLCBcInhuLS1kanJzNzJkNnV5XCI6IF8zLCBcIuWMl+a1t+mBk1wiOiBfMywgXCJ4bi0tbWtydTQ1aVwiOiBfMywgXCLljYPokYlcIjogXzMsIFwieG4tLTB0cnE3cDdublwiOiBfMywgXCLlkozmrYzlsbFcIjogXzMsIFwieG4tLTVqczA0NWRcIjogXzMsIFwi5Z+8546JXCI6IF8zLCBcInhuLS1rYnJxN29cIjogXzMsIFwi5aSn5YiGXCI6IF8zLCBcInhuLS1wc3N1MzNsXCI6IF8zLCBcIuWkp+mYqlwiOiBfMywgXCJ4bi0tbnRzcTE3Z1wiOiBfMywgXCLlpYjoia9cIjogXzMsIFwieG4tLXVpc3ozZ1wiOiBfMywgXCLlrq7ln45cIjogXzMsIFwieG4tLTZidHc1YVwiOiBfMywgXCLlrq7ltI5cIjogXzMsIFwieG4tLTFjdHdvXCI6IF8zLCBcIuWvjOWxsVwiOiBfMywgXCJ4bi0tNm9yeDJyXCI6IF8zLCBcIuWxseWPo1wiOiBfMywgXCJ4bi0tcmh0NjFlXCI6IF8zLCBcIuWxseW9olwiOiBfMywgXCJ4bi0tcmh0Mjd6XCI6IF8zLCBcIuWxseaiqFwiOiBfMywgXCJ4bi0tbml0MjI1a1wiOiBfMywgXCLlspDpmJxcIjogXzMsIFwieG4tLXJodDNkXCI6IF8zLCBcIuWyoeWxsVwiOiBfMywgXCJ4bi0tZGp0eTRrXCI6IF8zLCBcIuWyqeaJi1wiOiBfMywgXCJ4bi0ta2x0eTV4XCI6IF8zLCBcIuWztuaguVwiOiBfMywgXCJ4bi0ta2x0eDlhXCI6IF8zLCBcIuW6g+WztlwiOiBfMywgXCJ4bi0ta2x0cDdkXCI6IF8zLCBcIuW+s+WztlwiOiBfMywgXCJ4bi0tYzNzMTRtXCI6IF8zLCBcIuaEm+Wqm1wiOiBfMywgXCJ4bi0tdmd1NDAyY1wiOiBfMywgXCLmhJvnn6VcIjogXzMsIFwieG4tLWVmdm45c1wiOiBfMywgXCLmlrDmvZ9cIjogXzMsIFwieG4tLTFscXM3MWRcIjogXzMsIFwi5p2x5LqsXCI6IF8zLCBcInhuLS00cHZ4c1wiOiBfMywgXCLmoIPmnKhcIjogXzMsIFwieG4tLXV1d3U1OGFcIjogXzMsIFwi5rKW57iEXCI6IF8zLCBcInhuLS16YngwMjVkXCI6IF8zLCBcIua7i+izgFwiOiBfMywgXCJ4bi0tOHB2cjR1XCI6IF8zLCBcIueGiuacrFwiOiBfMywgXCJ4bi0tNXJ0cDQ5Y1wiOiBfMywgXCLnn7Plt51cIjogXzMsIFwieG4tLW50c28waXF4M2FcIjogXzMsIFwi56We5aWI5bedXCI6IF8zLCBcInhuLS1lbHFxMTZoXCI6IF8zLCBcIuemj+S6lVwiOiBfMywgXCJ4bi0tNGl0MTY4ZFwiOiBfMywgXCLnpo/lsqFcIjogXzMsIFwieG4tLWtsdDc4N2RcIjogXzMsIFwi56aP5bO2XCI6IF8zLCBcInhuLS1ybnkzMWhcIjogXzMsIFwi56eL55SwXCI6IF8zLCBcInhuLS03dDBhMjY0Y1wiOiBfMywgXCLnvqTppqxcIjogXzMsIFwieG4tLXVpc3QyMmhcIjogXzMsIFwi6Iyo5Z+OXCI6IF8zLCBcInhuLS04bHRyNjJrXCI6IF8zLCBcIumVt+W0jlwiOiBfMywgXCJ4bi0tMm00YTE1ZVwiOiBfMywgXCLplbfph45cIjogXzMsIFwieG4tLTMydnAzMGhcIjogXzMsIFwi6Z2S5qOuXCI6IF8zLCBcInhuLS00aXQ3OTdrXCI6IF8zLCBcIumdmeWyoVwiOiBfMywgXCJ4bi0tNXJ0cTM0a1wiOiBfMywgXCLpppnlt51cIjogXzMsIFwieG4tLWs3eW45NWVcIjogXzMsIFwi6auY55+lXCI6IF8zLCBcInhuLS10b3IxMzFvXCI6IF8zLCBcIumzpeWPllwiOiBfMywgXCJ4bi0tZDVxdjd6ODc2Y1wiOiBfMywgXCLpub/lhZDls7ZcIjogXzMsIFwia2F3YXNha2lcIjogXzE3LCBcImtpdGFreXVzaHVcIjogXzE3LCBcImtvYmVcIjogXzE3LCBcIm5hZ295YVwiOiBfMTcsIFwic2FwcG9yb1wiOiBfMTcsIFwic2VuZGFpXCI6IF8xNywgXCJ5b2tvaGFtYVwiOiBfMTcsIFwiYnV5c2hvcFwiOiBfNCwgXCJmYXNoaW9uc3RvcmVcIjogXzQsIFwiaGFuZGNyYWZ0ZWRcIjogXzQsIFwia2F3YWlpc2hvcFwiOiBfNCwgXCJzdXBlcnNhbGVcIjogXzQsIFwidGhlc2hvcFwiOiBfNCwgXCIwYW1cIjogXzQsIFwiMGcwXCI6IF80LCBcIjBqMFwiOiBfNCwgXCIwdDBcIjogXzQsIFwibXlkbnNcIjogXzQsIFwicGd3XCI6IF80LCBcIndqZ1wiOiBfNCwgXCJ1c2VyY29udGVudFwiOiBfNCwgXCJhbmdyeVwiOiBfNCwgXCJiYWJ5Ymx1ZVwiOiBfNCwgXCJiYWJ5bWlsa1wiOiBfNCwgXCJiYWNrZHJvcFwiOiBfNCwgXCJiYW1iaW5hXCI6IF80LCBcImJpdHRlclwiOiBfNCwgXCJibHVzaFwiOiBfNCwgXCJib29cIjogXzQsIFwiYm95XCI6IF80LCBcImJveWZyaWVuZFwiOiBfNCwgXCJidXRcIjogXzQsIFwiY2FuZHlwb3BcIjogXzQsIFwiY2Fwb29cIjogXzQsIFwiY2F0Zm9vZFwiOiBfNCwgXCJjaGVhcFwiOiBfNCwgXCJjaGljYXBwYVwiOiBfNCwgXCJjaGlsbG91dFwiOiBfNCwgXCJjaGlwc1wiOiBfNCwgXCJjaG93ZGVyXCI6IF80LCBcImNodVwiOiBfNCwgXCJjaWFvXCI6IF80LCBcImNvY290dGVcIjogXzQsIFwiY29vbGJsb2dcIjogXzQsIFwiY3Jhbmt5XCI6IF80LCBcImN1dGVnaXJsXCI6IF80LCBcImRhYVwiOiBfNCwgXCJkZWNhXCI6IF80LCBcImRlY2lcIjogXzQsIFwiZGlnaWNrXCI6IF80LCBcImVnb2lzbVwiOiBfNCwgXCJmYWtlZnVyXCI6IF80LCBcImZlbVwiOiBfNCwgXCJmbGllclwiOiBfNCwgXCJmbG9wcHlcIjogXzQsIFwiZm9vbFwiOiBfNCwgXCJmcmVuY2hraXNzXCI6IF80LCBcImdpcmxmcmllbmRcIjogXzQsIFwiZ2lybHlcIjogXzQsIFwiZ2xvb215XCI6IF80LCBcImdvbm5hXCI6IF80LCBcImdyZWF0ZXJcIjogXzQsIFwiaGFjY2FcIjogXzQsIFwiaGVhdnlcIjogXzQsIFwiaGVyXCI6IF80LCBcImhpaG9cIjogXzQsIFwiaGlwcHlcIjogXzQsIFwiaG9seVwiOiBfNCwgXCJodW5ncnlcIjogXzQsIFwiaWN1cnVzXCI6IF80LCBcIml0aWdvXCI6IF80LCBcImplbGx5YmVhblwiOiBfNCwgXCJraWtpcmFyYVwiOiBfNCwgXCJraWxsXCI6IF80LCBcImtpbG9cIjogXzQsIFwia3Vyb25cIjogXzQsIFwibGl0dGxlc3RhclwiOiBfNCwgXCJsb2xpcG9wbWNcIjogXzQsIFwibG9saXRhcHVua1wiOiBfNCwgXCJsb21vXCI6IF80LCBcImxvdmVwb3BcIjogXzQsIFwibG92ZXNpY2tcIjogXzQsIFwibWFpblwiOiBfNCwgXCJtb2RzXCI6IF80LCBcIm1vbmRcIjogXzQsIFwibW9uZ29saWFuXCI6IF80LCBcIm1vb1wiOiBfNCwgXCJuYW1hc3RlXCI6IF80LCBcIm5pa2l0YVwiOiBfNCwgXCJub2J1c2hpXCI6IF80LCBcIm5vb3JcIjogXzQsIFwib29wc1wiOiBfNCwgXCJwYXJhbGxlbFwiOiBfNCwgXCJwYXJhc2l0ZVwiOiBfNCwgXCJwZWNvcmlcIjogXzQsIFwicGVld2VlXCI6IF80LCBcInBlbm5lXCI6IF80LCBcInBlcHBlclwiOiBfNCwgXCJwZXJtYVwiOiBfNCwgXCJwaWdib2F0XCI6IF80LCBcInBpbm9rb1wiOiBfNCwgXCJwdW55dVwiOiBfNCwgXCJwdXB1XCI6IF80LCBcInB1c3N5Y2F0XCI6IF80LCBcInB5YVwiOiBfNCwgXCJyYWluZHJvcFwiOiBfNCwgXCJyZWFkeW1hZGVcIjogXzQsIFwic2FkaXN0XCI6IF80LCBcInNjaG9vbGJ1c1wiOiBfNCwgXCJzZWNyZXRcIjogXzQsIFwic3RhYmFcIjogXzQsIFwic3RyaXBwZXJcIjogXzQsIFwic3ViXCI6IF80LCBcInN1bm55ZGF5XCI6IF80LCBcInRoaWNrXCI6IF80LCBcInRvbmtvdHN1XCI6IF80LCBcInVuZGVyXCI6IF80LCBcInVwcGVyXCI6IF80LCBcInZlbHZldFwiOiBfNCwgXCJ2ZXJzZVwiOiBfNCwgXCJ2ZXJzdXNcIjogXzQsIFwidml2aWFuXCI6IF80LCBcIndhdHNvblwiOiBfNCwgXCJ3ZWJsaWtlXCI6IF80LCBcIndoaXRlc25vd1wiOiBfNCwgXCJ6b21iaWVcIjogXzQsIFwiaGF0ZWJsb1wiOiBfNCwgXCJoYXRlbmFibG9nXCI6IF80LCBcImhhdGVuYWRpYXJ5XCI6IF80LCBcIjItZFwiOiBfNCwgXCJib25hXCI6IF80LCBcImNyYXBcIjogXzQsIFwiZGF5bmlnaHRcIjogXzQsIFwiZWVrXCI6IF80LCBcImZsb3BcIjogXzQsIFwiaGFsZm1vb25cIjogXzQsIFwiamVlelwiOiBfNCwgXCJtYXRyaXhcIjogXzQsIFwibWltb3phXCI6IF80LCBcIm5ldGdhbWVyc1wiOiBfNCwgXCJueWFudGFcIjogXzQsIFwibzBvMFwiOiBfNCwgXCJyZHlcIjogXzQsIFwicmdyXCI6IF80LCBcInJ1bGV6XCI6IF80LCBcInNha3VyYXN0b3JhZ2VcIjogWzAsIHsgXCJpc2swMVwiOiBfNTIsIFwiaXNrMDJcIjogXzUyIH1dLCBcInNhbG9vblwiOiBfNCwgXCJzYmxvXCI6IF80LCBcInNrclwiOiBfNCwgXCJ0YW5rXCI6IF80LCBcInVoLW9oXCI6IF80LCBcInVuZG9cIjogXzQsIFwid2ViYWNjZWxcIjogWzAsIHsgXCJyc1wiOiBfNCwgXCJ1c2VyXCI6IF80IH1dLCBcIndlYnNvemFpXCI6IF80LCBcInhpaVwiOiBfNCB9XSwgXCJrZVwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IF8zLCBcImdvXCI6IF8zLCBcImluZm9cIjogXzMsIFwibWVcIjogXzMsIFwibW9iaVwiOiBfMywgXCJuZVwiOiBfMywgXCJvclwiOiBfMywgXCJzY1wiOiBfMyB9XSwgXCJrZ1wiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInVzXCI6IF80IH1dLCBcImtoXCI6IF8xNywgXCJraVwiOiBfNTMsIFwia21cIjogWzEsIHsgXCJhc3NcIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5vbVwiOiBfMywgXCJvcmdcIjogXzMsIFwicHJkXCI6IF8zLCBcInRtXCI6IF8zLCBcImFzc29cIjogXzMsIFwiY29vcFwiOiBfMywgXCJnb3V2XCI6IF8zLCBcIm1lZGVjaW5cIjogXzMsIFwibm90YWlyZXNcIjogXzMsIFwicGhhcm1hY2llbnNcIjogXzMsIFwicHJlc3NlXCI6IF8zLCBcInZldGVyaW5haXJlXCI6IF8zIH1dLCBcImtuXCI6IFsxLCB7IFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcImtwXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwib3JnXCI6IF8zLCBcInJlcFwiOiBfMywgXCJ0cmFcIjogXzMgfV0sIFwia3JcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJjb1wiOiBfMywgXCJlc1wiOiBfMywgXCJnb1wiOiBfMywgXCJoc1wiOiBfMywgXCJrZ1wiOiBfMywgXCJtaWxcIjogXzMsIFwibXNcIjogXzMsIFwibmVcIjogXzMsIFwib3JcIjogXzMsIFwicGVcIjogXzMsIFwicmVcIjogXzMsIFwic2NcIjogXzMsIFwiYnVzYW5cIjogXzMsIFwiY2h1bmdidWtcIjogXzMsIFwiY2h1bmduYW1cIjogXzMsIFwiZGFlZ3VcIjogXzMsIFwiZGFlamVvblwiOiBfMywgXCJnYW5nd29uXCI6IF8zLCBcImd3YW5nanVcIjogXzMsIFwiZ3llb25nYnVrXCI6IF8zLCBcImd5ZW9uZ2dpXCI6IF8zLCBcImd5ZW9uZ25hbVwiOiBfMywgXCJpbmNoZW9uXCI6IF8zLCBcImplanVcIjogXzMsIFwiamVvbmJ1a1wiOiBfMywgXCJqZW9ubmFtXCI6IF8zLCBcInNlb3VsXCI6IF8zLCBcInVsc2FuXCI6IF8zIH1dLCBcImt3XCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJlbWJcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcImt5XCI6IF80MywgXCJrelwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImpjbG91ZFwiOiBfNCB9XSwgXCJsYVwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwiaW50XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicGVyXCI6IF8zLCBcImJuclwiOiBfNCB9XSwgXCJsYlwiOiBfNSwgXCJsY1wiOiBbMSwgeyBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwib3lcIjogXzQgfV0sIFwibGlcIjogXzMsIFwibGtcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJhc3NuXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImdycFwiOiBfMywgXCJob3RlbFwiOiBfMywgXCJpbnRcIjogXzMsIFwibHRkXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJuZ29cIjogXzMsIFwib3JnXCI6IF8zLCBcInNjaFwiOiBfMywgXCJzb2NcIjogXzMsIFwid2ViXCI6IF8zIH1dLCBcImxyXCI6IF81LCBcImxzXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiYml6XCI6IF8zLCBcImNvXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaW5mb1wiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInNjXCI6IF8zIH1dLCBcImx0XCI6IF8xMCwgXCJsdVwiOiBbMSwgeyBcIjEyM3dlYnNpdGVcIjogXzQgfV0sIFwibHZcIjogWzEsIHsgXCJhc25cIjogXzMsIFwiY29tXCI6IF8zLCBcImNvbmZcIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJpZFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJseVwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImlkXCI6IF8zLCBcIm1lZFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInBsY1wiOiBfMywgXCJzY2hcIjogXzMgfV0sIFwibWFcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJjb1wiOiBfMywgXCJnb3ZcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwcmVzc1wiOiBfMyB9XSwgXCJtY1wiOiBbMSwgeyBcImFzc29cIjogXzMsIFwidG1cIjogXzMgfV0sIFwibWRcIjogWzEsIHsgXCJpclwiOiBfNCB9XSwgXCJtZVwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaXRzXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicHJpdlwiOiBfMywgXCJjNjZcIjogXzQsIFwiY3JhZnRcIjogXzQsIFwiZWRnZXN0YWNrXCI6IF80LCBcImZpbGVnZWFyXCI6IF80LCBcImdsaXRjaFwiOiBfNCwgXCJmaWxlZ2Vhci1zZ1wiOiBfNCwgXCJsb2htdXNcIjogXzQsIFwiYmFyc3lcIjogXzQsIFwibWNkaXJcIjogXzQsIFwiYnJhc2lsaWFcIjogXzQsIFwiZGRuc1wiOiBfNCwgXCJkbnNmb3JcIjogXzQsIFwiaG9wdG9cIjogXzQsIFwibG9naW50b1wiOiBfNCwgXCJub2lwXCI6IF80LCBcIndlYmhvcFwiOiBfNCwgXCJzb3VuZGNhc3RcIjogXzQsIFwidGNwNFwiOiBfNCwgXCJ2cDRcIjogXzQsIFwiZGlza3N0YXRpb25cIjogXzQsIFwiZHNjbG91ZFwiOiBfNCwgXCJpMjM0XCI6IF80LCBcIm15ZHNcIjogXzQsIFwic3lub2xvZ3lcIjogXzQsIFwidHJhbnNpcFwiOiBfNDIsIFwibm9ob3N0XCI6IF80IH1dLCBcIm1nXCI6IFsxLCB7IFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5vbVwiOiBfMywgXCJvcmdcIjogXzMsIFwicHJkXCI6IF8zIH1dLCBcIm1oXCI6IF8zLCBcIm1pbFwiOiBfMywgXCJta1wiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZlwiOiBfMywgXCJuYW1lXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwibWxcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJhcnRcIjogXzMsIFwiYXNzb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdXZcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwiaW5zdFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInByXCI6IF8zLCBcInByZXNzZVwiOiBfMyB9XSwgXCJtbVwiOiBfMTcsIFwibW5cIjogWzEsIHsgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJueWNcIjogXzQgfV0sIFwibW9cIjogXzUsIFwibW9iaVwiOiBbMSwgeyBcImJhcnN5XCI6IF80LCBcImRzY2xvdWRcIjogXzQgfV0sIFwibXBcIjogWzEsIHsgXCJqdVwiOiBfNCB9XSwgXCJtcVwiOiBfMywgXCJtclwiOiBfMTAsIFwibXNcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcIm1pbmlzaXRlXCI6IF80IH1dLCBcIm10XCI6IF80MywgXCJtdVwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yXCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJtdXNldW1cIjogXzMsIFwibXZcIjogWzEsIHsgXCJhZXJvXCI6IF8zLCBcImJpelwiOiBfMywgXCJjb21cIjogXzMsIFwiY29vcFwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwiaW50XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJtdXNldW1cIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInByb1wiOiBfMyB9XSwgXCJtd1wiOiBbMSwgeyBcImFjXCI6IF8zLCBcImJpelwiOiBfMywgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiY29vcFwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImludFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcIm14XCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJteVwiOiBbMSwgeyBcImJpelwiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcIm16XCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiYWR2XCI6IF8zLCBcImNvXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwibmFcIjogWzEsIHsgXCJhbHRcIjogXzMsIFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcIm5hbWVcIjogWzEsIHsgXCJoZXJcIjogXzU1LCBcImhpc1wiOiBfNTUgfV0sIFwibmNcIjogWzEsIHsgXCJhc3NvXCI6IF8zLCBcIm5vbVwiOiBfMyB9XSwgXCJuZVwiOiBfMywgXCJuZXRcIjogWzEsIHsgXCJhZG9iZWFlbWNsb3VkXCI6IF80LCBcImFkb2JlaW8tc3RhdGljXCI6IF80LCBcImFkb2JlaW9ydW50aW1lXCI6IF80LCBcImFrYWRuc1wiOiBfNCwgXCJha2FtYWlcIjogXzQsIFwiYWthbWFpLXN0YWdpbmdcIjogXzQsIFwiYWthbWFpZWRnZVwiOiBfNCwgXCJha2FtYWllZGdlLXN0YWdpbmdcIjogXzQsIFwiYWthbWFpaGRcIjogXzQsIFwiYWthbWFpaGQtc3RhZ2luZ1wiOiBfNCwgXCJha2FtYWlvcmlnaW5cIjogXzQsIFwiYWthbWFpb3JpZ2luLXN0YWdpbmdcIjogXzQsIFwiYWthbWFpemVkXCI6IF80LCBcImFrYW1haXplZC1zdGFnaW5nXCI6IF80LCBcImVkZ2VrZXlcIjogXzQsIFwiZWRnZWtleS1zdGFnaW5nXCI6IF80LCBcImVkZ2VzdWl0ZVwiOiBfNCwgXCJlZGdlc3VpdGUtc3RhZ2luZ1wiOiBfNCwgXCJhbHdheXNkYXRhXCI6IF80LCBcIm15YW1hemVcIjogXzQsIFwiY2xvdWRmcm9udFwiOiBfNCwgXCJhcHB1ZG9cIjogXzQsIFwiYXRsYXNzaWFuLWRldlwiOiBbMCwgeyBcInByb2RcIjogXzU2IH1dLCBcIm15ZnJpdHpcIjogXzQsIFwib25hdnN0YWNrXCI6IF80LCBcInNob3BzZWxlY3RcIjogXzQsIFwiYmxhY2tiYXVkY2RuXCI6IF80LCBcImJvb21sYVwiOiBfNCwgXCJicGxhY2VkXCI6IF80LCBcInNxdWFyZTdcIjogXzQsIFwiY2RuNzdcIjogWzAsIHsgXCJyXCI6IF80IH1dLCBcImNkbjc3LXNzbFwiOiBfNCwgXCJnYlwiOiBfNCwgXCJodVwiOiBfNCwgXCJqcFwiOiBfNCwgXCJzZVwiOiBfNCwgXCJ1a1wiOiBfNCwgXCJjbGlja3Jpc2luZ1wiOiBfNCwgXCJkZG5zLWlwXCI6IF80LCBcImRucy1jbG91ZFwiOiBfNCwgXCJkbnMtZHluYW1pY1wiOiBfNCwgXCJjbG91ZGFjY2Vzc1wiOiBfNCwgXCJjbG91ZGZsYXJlXCI6IFsyLCB7IFwiY2RuXCI6IF80IH1dLCBcImNsb3VkZmxhcmVhbnljYXN0XCI6IF81NiwgXCJjbG91ZGZsYXJlY25cIjogXzU2LCBcImNsb3VkZmxhcmVnbG9iYWxcIjogXzU2LCBcImN0ZmNsb3VkXCI6IF80LCBcImZlc3RlLWlwXCI6IF80LCBcImtueC1zZXJ2ZXJcIjogXzQsIFwic3RhdGljLWFjY2Vzc1wiOiBfNCwgXCJjcnlwdG9ub21pY1wiOiBfNywgXCJkYXR0b2xvY2FsXCI6IF80LCBcIm15ZGF0dG9cIjogXzQsIFwiZGViaWFuXCI6IF80LCBcImRlZmluaW1hXCI6IF80LCBcImF0LWJhbmQtY2FtcFwiOiBfNCwgXCJibG9nZG5zXCI6IF80LCBcImJyb2tlLWl0XCI6IF80LCBcImJ1eXNob3VzZXNcIjogXzQsIFwiZG5zYWxpYXNcIjogXzQsIFwiZG5zZG9qb1wiOiBfNCwgXCJkb2VzLWl0XCI6IF80LCBcImRvbnRleGlzdFwiOiBfNCwgXCJkeW5hbGlhc1wiOiBfNCwgXCJkeW5hdGhvbWVcIjogXzQsIFwiZW5kb2ZpbnRlcm5ldFwiOiBfNCwgXCJmcm9tLWF6XCI6IF80LCBcImZyb20tY29cIjogXzQsIFwiZnJvbS1sYVwiOiBfNCwgXCJmcm9tLW55XCI6IF80LCBcImdldHMtaXRcIjogXzQsIFwiaGFtLXJhZGlvLW9wXCI6IF80LCBcImhvbWVmdHBcIjogXzQsIFwiaG9tZWlwXCI6IF80LCBcImhvbWVsaW51eFwiOiBfNCwgXCJob21ldW5peFwiOiBfNCwgXCJpbi10aGUtYmFuZFwiOiBfNCwgXCJpcy1hLWNoZWZcIjogXzQsIFwiaXMtYS1nZWVrXCI6IF80LCBcImlzYS1nZWVrXCI6IF80LCBcImtpY2tzLWFzc1wiOiBfNCwgXCJvZmZpY2Utb24tdGhlXCI6IF80LCBcInBvZHpvbmVcIjogXzQsIFwic2NyYXBwZXItc2l0ZVwiOiBfNCwgXCJzZWxmaXBcIjogXzQsIFwic2VsbHMtaXRcIjogXzQsIFwic2VydmViYnNcIjogXzQsIFwic2VydmVmdHBcIjogXzQsIFwidGhydWhlcmVcIjogXzQsIFwid2ViaG9wXCI6IF80LCBcImNhc2FjYW1cIjogXzQsIFwiZHludVwiOiBfNCwgXCJkeW52NlwiOiBfNCwgXCJ0d21haWxcIjogXzQsIFwicnVcIjogXzQsIFwiY2hhbm5lbHNkdnJcIjogWzIsIHsgXCJ1XCI6IF80IH1dLCBcImZhc3RseVwiOiBbMCwgeyBcImZyZWV0bHNcIjogXzQsIFwibWFwXCI6IF80LCBcInByb2RcIjogWzAsIHsgXCJhXCI6IF80LCBcImdsb2JhbFwiOiBfNCB9XSwgXCJzc2xcIjogWzAsIHsgXCJhXCI6IF80LCBcImJcIjogXzQsIFwiZ2xvYmFsXCI6IF80IH1dIH1dLCBcImZhc3RseWxiXCI6IFsyLCB7IFwibWFwXCI6IF80IH1dLCBcImVkZ2VhcHBcIjogXzQsIFwia2V5d29yZC1vblwiOiBfNCwgXCJsaXZlLW9uXCI6IF80LCBcInNlcnZlci1vblwiOiBfNCwgXCJjZG4tZWRnZXNcIjogXzQsIFwiaGV0ZW1sXCI6IF80LCBcImNsb3VkZnVuY3Rpb25zXCI6IF80LCBcImdyYWZhbmEtZGV2XCI6IF80LCBcImlvYmJcIjogXzQsIFwibW9vbnNjYWxlXCI6IF80LCBcImluLWRzbFwiOiBfNCwgXCJpbi12cG5cIjogXzQsIFwiYm90ZGFzaFwiOiBfNCwgXCJhcHBzLTFhbmQxXCI6IF80LCBcImlwaWZvbnlcIjogXzQsIFwiY2xvdWRqaWZmeVwiOiBbMiwgeyBcImZyYTEtZGVcIjogXzQsIFwid2VzdDEtdXNcIjogXzQgfV0sIFwiZWxhc3R4XCI6IFswLCB7IFwiamxzLXN0bzFcIjogXzQsIFwiamxzLXN0bzJcIjogXzQsIFwiamxzLXN0bzNcIjogXzQgfV0sIFwibWFzc2l2ZWdyaWRcIjogWzAsIHsgXCJwYWFzXCI6IFswLCB7IFwiZnItMVwiOiBfNCwgXCJsb24tMVwiOiBfNCwgXCJsb24tMlwiOiBfNCwgXCJueS0xXCI6IF80LCBcIm55LTJcIjogXzQsIFwic2ctMVwiOiBfNCB9XSB9XSwgXCJzYXZlaW5jbG91ZFwiOiBbMCwgeyBcImplbGFzdGljXCI6IF80LCBcIm5vcmRlc3RlLWlkY1wiOiBfNCB9XSwgXCJzY2FsZWZvcmNlXCI6IF80NCwgXCJraW5naG9zdFwiOiBfNCwgXCJ1bmk1XCI6IF80LCBcImtyZWxsaWFuXCI6IF80LCBcImdnZmZcIjogXzQsIFwibG9jYWxjZXJ0XCI6IF80LCBcImxvY2FsaG9zdGNlcnRcIjogXzQsIFwiYmFyc3lcIjogXzQsIFwibWVtc2V0XCI6IF80LCBcImF6dXJlLWFwaVwiOiBfNCwgXCJhenVyZS1tb2JpbGVcIjogXzQsIFwiYXp1cmVlZGdlXCI6IF80LCBcImF6dXJlZmRcIjogXzQsIFwiYXp1cmVzdGF0aWNhcHBzXCI6IFsyLCB7IFwiMVwiOiBfNCwgXCIyXCI6IF80LCBcIjNcIjogXzQsIFwiNFwiOiBfNCwgXCI1XCI6IF80LCBcIjZcIjogXzQsIFwiN1wiOiBfNCwgXCJjZW50cmFsdXNcIjogXzQsIFwiZWFzdGFzaWFcIjogXzQsIFwiZWFzdHVzMlwiOiBfNCwgXCJ3ZXN0ZXVyb3BlXCI6IF80LCBcIndlc3R1czJcIjogXzQgfV0sIFwiYXp1cmV3ZWJzaXRlc1wiOiBfNCwgXCJjbG91ZGFwcFwiOiBfNCwgXCJ0cmFmZmljbWFuYWdlclwiOiBfNCwgXCJ3aW5kb3dzXCI6IFswLCB7IFwiY29yZVwiOiBbMCwgeyBcImJsb2JcIjogXzQgfV0sIFwic2VydmljZWJ1c1wiOiBfNCB9XSwgXCJteW5ldG5hbWVcIjogWzAsIHsgXCJzblwiOiBfNCB9XSwgXCJyb3V0aW5ndGhlY2xvdWRcIjogXzQsIFwiYm91bmNlbWVcIjogXzQsIFwiZGRuc1wiOiBfNCwgXCJlYXRpbmctb3JnYW5pY1wiOiBfNCwgXCJteWRpc3NlbnRcIjogXzQsIFwibXllZmZlY3RcIjogXzQsIFwibXltZWRpYXBjXCI6IF80LCBcIm15cHN4XCI6IF80LCBcIm15c2VjdXJpdHljYW1lcmFcIjogXzQsIFwibmhsZmFuXCI6IF80LCBcIm5vLWlwXCI6IF80LCBcInBnYWZhblwiOiBfNCwgXCJwcml2YXRpemVoZWFsdGhpbnN1cmFuY2VcIjogXzQsIFwicmVkaXJlY3RtZVwiOiBfNCwgXCJzZXJ2ZWJsb2dcIjogXzQsIFwic2VydmVtaW5lY3JhZnRcIjogXzQsIFwic3l0ZXNcIjogXzQsIFwiZG5zdXBcIjogXzQsIFwiaGljYW1cIjogXzQsIFwibm93LWRuc1wiOiBfNCwgXCJvd25pcFwiOiBfNCwgXCJ2cG5kbnNcIjogXzQsIFwiY2xvdWR5Y2x1c3RlclwiOiBfNCwgXCJvdmhcIjogWzAsIHsgXCJob3N0aW5nXCI6IF83LCBcIndlYnBhYXNcIjogXzcgfV0sIFwicmFja21hemVcIjogXzQsIFwibXlyYWR3ZWJcIjogXzQsIFwiaW5cIjogXzQsIFwic3Vic2MtcGF5XCI6IF80LCBcInNxdWFyZXNcIjogXzQsIFwic2Nob2tva2Vrc1wiOiBfNCwgXCJmaXJld2FsbC1nYXRld2F5XCI6IF80LCBcInNlaWRhdFwiOiBfNCwgXCJzZW5zZWVyaW5nXCI6IF80LCBcInNpdGVsZWFmXCI6IF80LCBcIm1hZmVsb1wiOiBfNCwgXCJteXNwcmVhZHNob3BcIjogXzQsIFwidnBzLWhvc3RcIjogWzIsIHsgXCJqZWxhc3RpY1wiOiBbMCwgeyBcImF0bFwiOiBfNCwgXCJuanNcIjogXzQsIFwicmljXCI6IF80IH1dIH1dLCBcInNyY2ZcIjogWzAsIHsgXCJzb2NcIjogXzQsIFwidXNlclwiOiBfNCB9XSwgXCJzdXBhYmFzZVwiOiBfNCwgXCJkc215bmFzXCI6IF80LCBcImZhbWlseWRzXCI6IF80LCBcInRzXCI6IFsyLCB7IFwiY1wiOiBfNyB9XSwgXCJ0b3Jwcm9qZWN0XCI6IFsyLCB7IFwicGFnZXNcIjogXzQgfV0sIFwidnVzZXJjb250ZW50XCI6IF80LCBcInJlc2VydmUtb25saW5lXCI6IF80LCBcImNvbW11bml0eS1wcm9cIjogXzQsIFwibWVpbmZvcnVtXCI6IF80LCBcInlhbmRleGNsb3VkXCI6IFsyLCB7IFwic3RvcmFnZVwiOiBfNCwgXCJ3ZWJzaXRlXCI6IF80IH1dLCBcInphXCI6IF80IH1dLCBcIm5mXCI6IFsxLCB7IFwiYXJ0c1wiOiBfMywgXCJjb21cIjogXzMsIFwiZmlybVwiOiBfMywgXCJpbmZvXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvdGhlclwiOiBfMywgXCJwZXJcIjogXzMsIFwicmVjXCI6IF8zLCBcInN0b3JlXCI6IF8zLCBcIndlYlwiOiBfMyB9XSwgXCJuZ1wiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImlcIjogXzMsIFwibWlsXCI6IF8zLCBcIm1vYmlcIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInNjaFwiOiBfMywgXCJiaXpcIjogWzIsIHsgXCJjb1wiOiBfNCwgXCJkbFwiOiBfNCwgXCJnb1wiOiBfNCwgXCJsZ1wiOiBfNCwgXCJvblwiOiBfNCB9XSwgXCJjb2xcIjogXzQsIFwiZmlybVwiOiBfNCwgXCJnZW5cIjogXzQsIFwibHRkXCI6IF80LCBcIm5nb1wiOiBfNCwgXCJwbGNcIjogXzQgfV0sIFwibmlcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJiaXpcIjogXzMsIFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwiaW5cIjogXzMsIFwiaW5mb1wiOiBfMywgXCJpbnRcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJub21cIjogXzMsIFwib3JnXCI6IF8zLCBcIndlYlwiOiBfMyB9XSwgXCJubFwiOiBbMSwgeyBcImNvXCI6IF80LCBcImhvc3RpbmctY2x1c3RlclwiOiBfNCwgXCJnb3ZcIjogXzQsIFwia2hwbGF5XCI6IF80LCBcIjEyM3dlYnNpdGVcIjogXzQsIFwibXlzcHJlYWRzaG9wXCI6IF80LCBcInRyYW5zdXJsXCI6IF83LCBcImNpc3Ryb25cIjogXzQsIFwiZGVtb25cIjogXzQgfV0sIFwibm9cIjogWzEsIHsgXCJmaHNcIjogXzMsIFwiZm9sa2ViaWJsXCI6IF8zLCBcImZ5bGtlc2JpYmxcIjogXzMsIFwiaWRyZXR0XCI6IF8zLCBcIm11c2V1bVwiOiBfMywgXCJwcml2XCI6IF8zLCBcInZnc1wiOiBfMywgXCJkZXBcIjogXzMsIFwiaGVyYWRcIjogXzMsIFwia29tbXVuZVwiOiBfMywgXCJtaWxcIjogXzMsIFwic3RhdFwiOiBfMywgXCJhYVwiOiBfNTcsIFwiYWhcIjogXzU3LCBcImJ1XCI6IF81NywgXCJmbVwiOiBfNTcsIFwiaGxcIjogXzU3LCBcImhtXCI6IF81NywgXCJqYW4tbWF5ZW5cIjogXzU3LCBcIm1yXCI6IF81NywgXCJubFwiOiBfNTcsIFwibnRcIjogXzU3LCBcIm9mXCI6IF81NywgXCJvbFwiOiBfNTcsIFwib3Nsb1wiOiBfNTcsIFwicmxcIjogXzU3LCBcInNmXCI6IF81NywgXCJzdFwiOiBfNTcsIFwic3ZhbGJhcmRcIjogXzU3LCBcInRtXCI6IF81NywgXCJ0clwiOiBfNTcsIFwidmFcIjogXzU3LCBcInZmXCI6IF81NywgXCJha3JlaGFtblwiOiBfMywgXCJ4bi0ta3JlaGFtbi1keGFcIjogXzMsIFwiw6VrcmVoYW1uXCI6IF8zLCBcImFsZ2FyZFwiOiBfMywgXCJ4bi0tbGdyZC1wb2FjXCI6IF8zLCBcIsOlbGfDpXJkXCI6IF8zLCBcImFybmFcIjogXzMsIFwiYnJvbm5veXN1bmRcIjogXzMsIFwieG4tLWJybm55c3VuZC1tOGFjXCI6IF8zLCBcImJyw7hubsO4eXN1bmRcIjogXzMsIFwiYnJ1bXVuZGRhbFwiOiBfMywgXCJicnluZVwiOiBfMywgXCJkcm9iYWtcIjogXzMsIFwieG4tLWRyYmFrLXd1YVwiOiBfMywgXCJkcsO4YmFrXCI6IF8zLCBcImVnZXJzdW5kXCI6IF8zLCBcImZldHN1bmRcIjogXzMsIFwiZmxvcm9cIjogXzMsIFwieG4tLWZsb3ItanJhXCI6IF8zLCBcImZsb3LDuFwiOiBfMywgXCJmcmVkcmlrc3RhZFwiOiBfMywgXCJob2trc3VuZFwiOiBfMywgXCJob25lZm9zc1wiOiBfMywgXCJ4bi0taG5lZm9zcy1xMWFcIjogXzMsIFwiaMO4bmVmb3NzXCI6IF8zLCBcImplc3NoZWltXCI6IF8zLCBcImpvcnBlbGFuZFwiOiBfMywgXCJ4bi0tanJwZWxhbmQtNTRhXCI6IF8zLCBcImrDuHJwZWxhbmRcIjogXzMsIFwia2lya2VuZXNcIjogXzMsIFwia29wZXJ2aWtcIjogXzMsIFwia3Jva3N0YWRlbHZhXCI6IF8zLCBcImxhbmdldmFnXCI6IF8zLCBcInhuLS1sYW5nZXZnLWp4YVwiOiBfMywgXCJsYW5nZXbDpWdcIjogXzMsIFwibGVpcnZpa1wiOiBfMywgXCJtam9uZGFsZW5cIjogXzMsIFwieG4tLW1qbmRhbGVuLTY0YVwiOiBfMywgXCJtasO4bmRhbGVuXCI6IF8zLCBcIm1vLWktcmFuYVwiOiBfMywgXCJtb3Nqb2VuXCI6IF8zLCBcInhuLS1tb3NqZW4tZXlhXCI6IF8zLCBcIm1vc2rDuGVuXCI6IF8zLCBcIm5lc29kZHRhbmdlblwiOiBfMywgXCJvcmthbmdlclwiOiBfMywgXCJvc295cm9cIjogXzMsIFwieG4tLW9zeXJvLXd1YVwiOiBfMywgXCJvc8O4eXJvXCI6IF8zLCBcInJhaG9sdFwiOiBfMywgXCJ4bi0tcmhvbHQtbXJhXCI6IF8zLCBcInLDpWhvbHRcIjogXzMsIFwic2FuZG5lc3Nqb2VuXCI6IF8zLCBcInhuLS1zYW5kbmVzc2plbi1vZ2JcIjogXzMsIFwic2FuZG5lc3Nqw7hlblwiOiBfMywgXCJza2Vkc21va29yc2V0XCI6IF8zLCBcInNsYXR0dW1cIjogXzMsIFwic3BqZWxrYXZpa1wiOiBfMywgXCJzdGF0aGVsbGVcIjogXzMsIFwic3RhdmVyblwiOiBfMywgXCJzdGpvcmRhbHNoYWxzZW5cIjogXzMsIFwieG4tLXN0anJkYWxzaGFsc2VuLXNxYlwiOiBfMywgXCJzdGrDuHJkYWxzaGFsc2VuXCI6IF8zLCBcInRhbmFuZ2VyXCI6IF8zLCBcInRyYW5ieVwiOiBfMywgXCJ2b3NzZXZhbmdlblwiOiBfMywgXCJhYXJib3J0ZVwiOiBfMywgXCJhZWpyaWVcIjogXzMsIFwiYWZqb3JkXCI6IF8zLCBcInhuLS1mam9yZC1scmFcIjogXzMsIFwiw6Vmam9yZFwiOiBfMywgXCJhZ2RlbmVzXCI6IF8zLCBcImFrZXJzaHVzXCI6IF81OCwgXCJha25vbHVva3RhXCI6IF8zLCBcInhuLS1rb2x1b2t0YS03eWE1N2hcIjogXzMsIFwiw6FrxYtvbHVva3RhXCI6IF8zLCBcImFsXCI6IF8zLCBcInhuLS1sLTFmYVwiOiBfMywgXCLDpWxcIjogXzMsIFwiYWxhaGVhZGp1XCI6IF8zLCBcInhuLS1sYWhlYWRqdS03eWFcIjogXzMsIFwiw6FsYWhlYWRqdVwiOiBfMywgXCJhbGVzdW5kXCI6IF8zLCBcInhuLS1sZXN1bmQtaHVhXCI6IF8zLCBcIsOlbGVzdW5kXCI6IF8zLCBcImFsc3RhaGF1Z1wiOiBfMywgXCJhbHRhXCI6IF8zLCBcInhuLS1sdC1saWFjXCI6IF8zLCBcIsOhbHTDoVwiOiBfMywgXCJhbHZkYWxcIjogXzMsIFwiYW1saVwiOiBfMywgXCJ4bi0tbWxpLXRsYVwiOiBfMywgXCLDpW1saVwiOiBfMywgXCJhbW90XCI6IF8zLCBcInhuLS1tb3QtdGxhXCI6IF8zLCBcIsOlbW90XCI6IF8zLCBcImFuZGFzdW9sb1wiOiBfMywgXCJhbmRlYnVcIjogXzMsIFwiYW5kb3lcIjogXzMsIFwieG4tLWFuZHktaXJhXCI6IF8zLCBcImFuZMO4eVwiOiBfMywgXCJhcmRhbFwiOiBfMywgXCJ4bi0tcmRhbC1wb2FcIjogXzMsIFwiw6VyZGFsXCI6IF8zLCBcImFyZW1hcmtcIjogXzMsIFwiYXJlbmRhbFwiOiBfMywgXCJ4bi0tcy0xZmFcIjogXzMsIFwiw6VzXCI6IF8zLCBcImFzZXJhbFwiOiBfMywgXCJ4bi0tc2VyYWwtbHJhXCI6IF8zLCBcIsOlc2VyYWxcIjogXzMsIFwiYXNrZXJcIjogXzMsIFwiYXNraW1cIjogXzMsIFwiYXNrb3lcIjogXzMsIFwieG4tLWFza3ktaXJhXCI6IF8zLCBcImFza8O4eVwiOiBfMywgXCJhc2t2b2xsXCI6IF8zLCBcImFzbmVzXCI6IF8zLCBcInhuLS1zbmVzLXBvYVwiOiBfMywgXCLDpXNuZXNcIjogXzMsIFwiYXVkbmVkYWxuXCI6IF8zLCBcImF1a3JhXCI6IF8zLCBcImF1cmVcIjogXzMsIFwiYXVybGFuZFwiOiBfMywgXCJhdXJza29nLWhvbGFuZFwiOiBfMywgXCJ4bi0tYXVyc2tvZy1obGFuZC1qbmJcIjogXzMsIFwiYXVyc2tvZy1ow7hsYW5kXCI6IF8zLCBcImF1c3Rldm9sbFwiOiBfMywgXCJhdXN0cmhlaW1cIjogXzMsIFwiYXZlcm95XCI6IF8zLCBcInhuLS1hdmVyeS15dWFcIjogXzMsIFwiYXZlcsO4eVwiOiBfMywgXCJiYWRhZGRqYVwiOiBfMywgXCJ4bi0tYmRkZGotbXJhYmRcIjogXzMsIFwiYsOlZMOlZGRqw6VcIjogXzMsIFwieG4tLWJydW0tdm9hXCI6IF8zLCBcImLDpnJ1bVwiOiBfMywgXCJiYWhjYXZ1b3RuYVwiOiBfMywgXCJ4bi0tYmhjYXZ1b3RuYS1zNGFcIjogXzMsIFwiYsOhaGNhdnVvdG5hXCI6IF8zLCBcImJhaGNjYXZ1b3RuYVwiOiBfMywgXCJ4bi0tYmhjY2F2dW90bmEtazdhXCI6IF8zLCBcImLDoWhjY2F2dW90bmFcIjogXzMsIFwiYmFpZGFyXCI6IF8zLCBcInhuLS1iaWRyLTVuYWNcIjogXzMsIFwiYsOhaWTDoXJcIjogXzMsIFwiYmFqZGRhclwiOiBfMywgXCJ4bi0tYmpkZGFyLXB0YVwiOiBfMywgXCJiw6FqZGRhclwiOiBfMywgXCJiYWxhdFwiOiBfMywgXCJ4bi0tYmx0LWVsYWJcIjogXzMsIFwiYsOhbMOhdFwiOiBfMywgXCJiYWxlc3RyYW5kXCI6IF8zLCBcImJhbGxhbmdlblwiOiBfMywgXCJiYWxzZmpvcmRcIjogXzMsIFwiYmFtYmxlXCI6IF8zLCBcImJhcmR1XCI6IF8zLCBcImJhcnVtXCI6IF8zLCBcImJhdHNmam9yZFwiOiBfMywgXCJ4bi0tYnRzZmpvcmQtOXphXCI6IF8zLCBcImLDpXRzZmpvcmRcIjogXzMsIFwiYmVhcmFsdmFoa2lcIjogXzMsIFwieG4tLWJlYXJhbHZoa2kteTRhXCI6IF8zLCBcImJlYXJhbHbDoWhraVwiOiBfMywgXCJiZWFyZHVcIjogXzMsIFwiYmVpYXJuXCI6IF8zLCBcImJlcmdcIjogXzMsIFwiYmVyZ2VuXCI6IF8zLCBcImJlcmxldmFnXCI6IF8zLCBcInhuLS1iZXJsZXZnLWp4YVwiOiBfMywgXCJiZXJsZXbDpWdcIjogXzMsIFwiYmlldmF0XCI6IF8zLCBcInhuLS1iaWV2dC0wcWFcIjogXzMsIFwiYmlldsOhdFwiOiBfMywgXCJiaW5kYWxcIjogXzMsIFwiYmlya2VuZXNcIjogXzMsIFwiYmphcmtveVwiOiBfMywgXCJ4bi0tYmphcmt5LWZ5YVwiOiBfMywgXCJiamFya8O4eVwiOiBfMywgXCJiamVya3JlaW1cIjogXzMsIFwiYmp1Z25cIjogXzMsIFwiYm9kb1wiOiBfMywgXCJ4bi0tYm9kLTJuYVwiOiBfMywgXCJib2TDuFwiOiBfMywgXCJib2tuXCI6IF8zLCBcImJvbWxvXCI6IF8zLCBcInhuLS1ibWxvLWdyYVwiOiBfMywgXCJiw7htbG9cIjogXzMsIFwiYnJlbWFuZ2VyXCI6IF8zLCBcImJyb25ub3lcIjogXzMsIFwieG4tLWJybm55LXd1YWNcIjogXzMsIFwiYnLDuG5uw7h5XCI6IF8zLCBcImJ1ZGVqanVcIjogXzMsIFwiYnVza2VydWRcIjogXzU4LCBcImJ5Z2xhbmRcIjogXzMsIFwiYnlrbGVcIjogXzMsIFwiY2FoY2VzdW9sb1wiOiBfMywgXCJ4bi0taGNlc3VvbG8tN3lhMzViXCI6IF8zLCBcIsSNw6FoY2VzdW9sb1wiOiBfMywgXCJkYXZ2ZW5qYXJnYVwiOiBfMywgXCJ4bi0tZGF2dmVuanJnYS15NGFcIjogXzMsIFwiZGF2dmVuasOhcmdhXCI6IF8zLCBcImRhdnZlc2lpZGFcIjogXzMsIFwiZGVhdG51XCI6IF8zLCBcImRpZWxkZGFudW9ycmlcIjogXzMsIFwiZGl2dGFzdnVvZG5hXCI6IF8zLCBcImRpdnR0YXN2dW90bmFcIjogXzMsIFwiZG9ubmFcIjogXzMsIFwieG4tLWRubmEtZ3JhXCI6IF8zLCBcImTDuG5uYVwiOiBfMywgXCJkb3ZyZVwiOiBfMywgXCJkcmFtbWVuXCI6IF8zLCBcImRyYW5nZWRhbFwiOiBfMywgXCJkeXJveVwiOiBfMywgXCJ4bi0tZHlyeS1pcmFcIjogXzMsIFwiZHlyw7h5XCI6IF8zLCBcImVpZFwiOiBfMywgXCJlaWRmam9yZFwiOiBfMywgXCJlaWRzYmVyZ1wiOiBfMywgXCJlaWRza29nXCI6IF8zLCBcImVpZHN2b2xsXCI6IF8zLCBcImVpZ2Vyc3VuZFwiOiBfMywgXCJlbHZlcnVtXCI6IF8zLCBcImVuZWJha2tcIjogXzMsIFwiZW5nZXJkYWxcIjogXzMsIFwiZXRuZVwiOiBfMywgXCJldG5lZGFsXCI6IF8zLCBcImV2ZW5hc3NpXCI6IF8zLCBcInhuLS1ldmVuaS0wcWEwMWdhXCI6IF8zLCBcImV2ZW7DocWhxaFpXCI6IF8zLCBcImV2ZW5lc1wiOiBfMywgXCJldmplLW9nLWhvcm5uZXNcIjogXzMsIFwiZmFyc3VuZFwiOiBfMywgXCJmYXVza2VcIjogXzMsIFwiZmVkamVcIjogXzMsIFwiZmV0XCI6IF8zLCBcImZpbm5veVwiOiBfMywgXCJ4bi0tZmlubnkteXVhXCI6IF8zLCBcImZpbm7DuHlcIjogXzMsIFwiZml0amFyXCI6IF8zLCBcImZqYWxlclwiOiBfMywgXCJmamVsbFwiOiBfMywgXCJmbGFcIjogXzMsIFwieG4tLWZsLXppYVwiOiBfMywgXCJmbMOlXCI6IF8zLCBcImZsYWtzdGFkXCI6IF8zLCBcImZsYXRhbmdlclwiOiBfMywgXCJmbGVra2Vmam9yZFwiOiBfMywgXCJmbGVzYmVyZ1wiOiBfMywgXCJmbG9yYVwiOiBfMywgXCJmb2xsZGFsXCI6IF8zLCBcImZvcmRlXCI6IF8zLCBcInhuLS1mcmRlLWdyYVwiOiBfMywgXCJmw7hyZGVcIjogXzMsIFwiZm9yc2FuZFwiOiBfMywgXCJmb3NuZXNcIjogXzMsIFwieG4tLWZybmEtd29hXCI6IF8zLCBcImZyw6ZuYVwiOiBfMywgXCJmcmFuYVwiOiBfMywgXCJmcmVpXCI6IF8zLCBcImZyb2duXCI6IF8zLCBcImZyb2xhbmRcIjogXzMsIFwiZnJvc3RhXCI6IF8zLCBcImZyb3lhXCI6IF8zLCBcInhuLS1mcnlhLWhyYVwiOiBfMywgXCJmcsO4eWFcIjogXzMsIFwiZnVvaXNrdVwiOiBfMywgXCJmdW9zc2tvXCI6IF8zLCBcImZ1c2FcIjogXzMsIFwiZnlyZXNkYWxcIjogXzMsIFwiZ2FpdnVvdG5hXCI6IF8zLCBcInhuLS1naXZ1b3RuYS04eWFcIjogXzMsIFwiZ8OhaXZ1b3RuYVwiOiBfMywgXCJnYWxzYVwiOiBfMywgXCJ4bi0tZ2xzLWVsYWNcIjogXzMsIFwiZ8OhbHPDoVwiOiBfMywgXCJnYW12aWtcIjogXzMsIFwiZ2FuZ2F2aWlrYVwiOiBfMywgXCJ4bi0tZ2dhdmlpa2EtOHlhNDdoXCI6IF8zLCBcImfDocWLZ2F2aWlrYVwiOiBfMywgXCJnYXVsYXJcIjogXzMsIFwiZ2F1c2RhbFwiOiBfMywgXCJnaWVodGF2dW9hdG5hXCI6IF8zLCBcImdpbGRlc2thbFwiOiBfMywgXCJ4bi0tZ2lsZGVza2wtZzBhXCI6IF8zLCBcImdpbGRlc2vDpWxcIjogXzMsIFwiZ2lza2VcIjogXzMsIFwiZ2plbW5lc1wiOiBfMywgXCJnamVyZHJ1bVwiOiBfMywgXCJnamVyc3RhZFwiOiBfMywgXCJnamVzZGFsXCI6IF8zLCBcImdqb3Zpa1wiOiBfMywgXCJ4bi0tZ2p2aWstd3VhXCI6IF8zLCBcImdqw7h2aWtcIjogXzMsIFwiZ2xvcHBlblwiOiBfMywgXCJnb2xcIjogXzMsIFwiZ3JhblwiOiBfMywgXCJncmFuZVwiOiBfMywgXCJncmFudmluXCI6IF8zLCBcImdyYXRhbmdlblwiOiBfMywgXCJncmltc3RhZFwiOiBfMywgXCJncm9uZ1wiOiBfMywgXCJncnVlXCI6IF8zLCBcImd1bGVuXCI6IF8zLCBcImd1b3ZkYWdlYWlkbnVcIjogXzMsIFwiaGFcIjogXzMsIFwieG4tLWgtMmZhXCI6IF8zLCBcImjDpVwiOiBfMywgXCJoYWJtZXJcIjogXzMsIFwieG4tLWhibWVyLXhxYVwiOiBfMywgXCJow6FibWVyXCI6IF8zLCBcImhhZHNlbFwiOiBfMywgXCJ4bi0taGdlYm9zdGFkLWczYVwiOiBfMywgXCJow6ZnZWJvc3RhZFwiOiBfMywgXCJoYWdlYm9zdGFkXCI6IF8zLCBcImhhbGRlblwiOiBfMywgXCJoYWxzYVwiOiBfMywgXCJoYW1hclwiOiBfMywgXCJoYW1hcm95XCI6IF8zLCBcImhhbW1hcmZlYXN0YVwiOiBfMywgXCJ4bi0taG1tcmZlYXN0YS1zNGFjXCI6IF8zLCBcImjDoW1tw6FyZmVhc3RhXCI6IF8zLCBcImhhbW1lcmZlc3RcIjogXzMsIFwiaGFwbWlyXCI6IF8zLCBcInhuLS1ocG1pci14cWFcIjogXzMsIFwiaMOhcG1pclwiOiBfMywgXCJoYXJhbVwiOiBfMywgXCJoYXJlaWRcIjogXzMsIFwiaGFyc3RhZFwiOiBfMywgXCJoYXN2aWtcIjogXzMsIFwiaGF0dGZqZWxsZGFsXCI6IF8zLCBcImhhdWdlc3VuZFwiOiBfMywgXCJoZWRtYXJrXCI6IFswLCB7IFwib3NcIjogXzMsIFwidmFsZXJcIjogXzMsIFwieG4tLXZsZXItcW9hXCI6IF8zLCBcInbDpWxlclwiOiBfMyB9XSwgXCJoZW1uZVwiOiBfMywgXCJoZW1uZXNcIjogXzMsIFwiaGVtc2VkYWxcIjogXzMsIFwiaGl0cmFcIjogXzMsIFwiaGphcnRkYWxcIjogXzMsIFwiaGplbG1lbGFuZFwiOiBfMywgXCJob2JvbFwiOiBfMywgXCJ4bi0taG9ibC1pcmFcIjogXzMsIFwiaG9iw7hsXCI6IF8zLCBcImhvZlwiOiBfMywgXCJob2xcIjogXzMsIFwiaG9sZVwiOiBfMywgXCJob2xtZXN0cmFuZFwiOiBfMywgXCJob2x0YWxlblwiOiBfMywgXCJ4bi0taG9sdGxlbi1oeGFcIjogXzMsIFwiaG9sdMOlbGVuXCI6IF8zLCBcImhvcmRhbGFuZFwiOiBbMCwgeyBcIm9zXCI6IF8zIH1dLCBcImhvcm5pbmRhbFwiOiBfMywgXCJob3J0ZW5cIjogXzMsIFwiaG95YW5nZXJcIjogXzMsIFwieG4tLWh5YW5nZXItcTFhXCI6IF8zLCBcImjDuHlhbmdlclwiOiBfMywgXCJob3lsYW5kZXRcIjogXzMsIFwieG4tLWh5bGFuZGV0LTU0YVwiOiBfMywgXCJow7h5bGFuZGV0XCI6IF8zLCBcImh1cmRhbFwiOiBfMywgXCJodXJ1bVwiOiBfMywgXCJodmFsZXJcIjogXzMsIFwiaHlsbGVzdGFkXCI6IF8zLCBcImliZXN0YWRcIjogXzMsIFwiaW5kZXJveVwiOiBfMywgXCJ4bi0taW5kZXJ5LWZ5YVwiOiBfMywgXCJpbmRlcsO4eVwiOiBfMywgXCJpdmVsYW5kXCI6IF8zLCBcIml2Z3VcIjogXzMsIFwiamV2bmFrZXJcIjogXzMsIFwiam9sc3RlclwiOiBfMywgXCJ4bi0tamxzdGVyLWJ5YVwiOiBfMywgXCJqw7hsc3RlclwiOiBfMywgXCJqb25kYWxcIjogXzMsIFwia2Fmam9yZFwiOiBfMywgXCJ4bi0ta2Zqb3JkLWl1YVwiOiBfMywgXCJrw6Vmam9yZFwiOiBfMywgXCJrYXJhc2pvaGthXCI6IF8zLCBcInhuLS1rcmpvaGthLWh3YWI0OWpcIjogXzMsIFwia8OhcsOhxaFqb2hrYVwiOiBfMywgXCJrYXJhc2pva1wiOiBfMywgXCJrYXJsc295XCI6IF8zLCBcImthcm1veVwiOiBfMywgXCJ4bi0ta2FybXkteXVhXCI6IF8zLCBcImthcm3DuHlcIjogXzMsIFwia2F1dG9rZWlub1wiOiBfMywgXCJrbGFidVwiOiBfMywgXCJ4bi0ta2xidS13b2FcIjogXzMsIFwia2zDpmJ1XCI6IF8zLCBcImtsZXBwXCI6IF8zLCBcImtvbmdzYmVyZ1wiOiBfMywgXCJrb25nc3ZpbmdlclwiOiBfMywgXCJrcmFhbmdoa2VcIjogXzMsIFwieG4tLWtyYW5naGtlLWIwYVwiOiBfMywgXCJrcsOlYW5naGtlXCI6IF8zLCBcImtyYWdlcm9cIjogXzMsIFwieG4tLWtyYWdlci1neWFcIjogXzMsIFwia3JhZ2Vyw7hcIjogXzMsIFwia3Jpc3RpYW5zYW5kXCI6IF8zLCBcImtyaXN0aWFuc3VuZFwiOiBfMywgXCJrcm9kc2hlcmFkXCI6IF8zLCBcInhuLS1rcmRzaGVyYWQtbThhXCI6IF8zLCBcImtyw7hkc2hlcmFkXCI6IF8zLCBcInhuLS1rdmZqb3JkLW54YVwiOiBfMywgXCJrdsOmZmpvcmRcIjogXzMsIFwieG4tLWt2bmFuZ2VuLWswYVwiOiBfMywgXCJrdsOmbmFuZ2VuXCI6IF8zLCBcImt2YWZqb3JkXCI6IF8zLCBcImt2YWxzdW5kXCI6IF8zLCBcImt2YW1cIjogXzMsIFwia3ZhbmFuZ2VuXCI6IF8zLCBcImt2aW5lc2RhbFwiOiBfMywgXCJrdmlubmhlcmFkXCI6IF8zLCBcImt2aXRlc2VpZFwiOiBfMywgXCJrdml0c295XCI6IF8zLCBcInhuLS1rdml0c3ktZnlhXCI6IF8zLCBcImt2aXRzw7h5XCI6IF8zLCBcImxhYWtlc3Z1ZW1pZVwiOiBfMywgXCJ4bi0tbHJkYWwtc3JhXCI6IF8zLCBcImzDpnJkYWxcIjogXzMsIFwibGFocHBpXCI6IF8zLCBcInhuLS1saHBwaS14cWFcIjogXzMsIFwibMOhaHBwaVwiOiBfMywgXCJsYXJkYWxcIjogXzMsIFwibGFydmlrXCI6IF8zLCBcImxhdmFnaXNcIjogXzMsIFwibGF2YW5nZW5cIjogXzMsIFwibGVhbmdhdmlpa2FcIjogXzMsIFwieG4tLWxlYWdhdmlpa2EtNTJiXCI6IF8zLCBcImxlYcWLZ2F2aWlrYVwiOiBfMywgXCJsZWJlc2J5XCI6IF8zLCBcImxlaWthbmdlclwiOiBfMywgXCJsZWlyZmpvcmRcIjogXzMsIFwibGVrYVwiOiBfMywgXCJsZWtzdmlrXCI6IF8zLCBcImxlbnZpa1wiOiBfMywgXCJsZXJkYWxcIjogXzMsIFwibGVzamFcIjogXzMsIFwibGV2YW5nZXJcIjogXzMsIFwibGllclwiOiBfMywgXCJsaWVybmVcIjogXzMsIFwibGlsbGVoYW1tZXJcIjogXzMsIFwibGlsbGVzYW5kXCI6IF8zLCBcImxpbmRhc1wiOiBfMywgXCJ4bi0tbGluZHMtcHJhXCI6IF8zLCBcImxpbmTDpXNcIjogXzMsIFwibGluZGVzbmVzXCI6IF8zLCBcImxvYWJhdFwiOiBfMywgXCJ4bi0tbG9hYnQtMHFhXCI6IF8zLCBcImxvYWLDoXRcIjogXzMsIFwibG9kaW5nZW5cIjogXzMsIFwieG4tLWxkaW5nZW4tcTFhXCI6IF8zLCBcImzDuGRpbmdlblwiOiBfMywgXCJsb21cIjogXzMsIFwibG9wcGFcIjogXzMsIFwibG9yZW5za29nXCI6IF8zLCBcInhuLS1scmVuc2tvZy01NGFcIjogXzMsIFwibMO4cmVuc2tvZ1wiOiBfMywgXCJsb3RlblwiOiBfMywgXCJ4bi0tbHRlbi1ncmFcIjogXzMsIFwibMO4dGVuXCI6IF8zLCBcImx1bmRcIjogXzMsIFwibHVubmVyXCI6IF8zLCBcImx1cm95XCI6IF8zLCBcInhuLS1sdXJ5LWlyYVwiOiBfMywgXCJsdXLDuHlcIjogXzMsIFwibHVzdGVyXCI6IF8zLCBcImx5bmdkYWxcIjogXzMsIFwibHluZ2VuXCI6IF8zLCBcIm1hbGF0dnVvcG1pXCI6IF8zLCBcInhuLS1tbGF0dnVvcG1pLXM0YVwiOiBfMywgXCJtw6FsYXR2dW9wbWlcIjogXzMsIFwibWFsc2VsdlwiOiBfMywgXCJ4bi0tbWxzZWx2LWl1YVwiOiBfMywgXCJtw6Vsc2VsdlwiOiBfMywgXCJtYWx2aWtcIjogXzMsIFwibWFuZGFsXCI6IF8zLCBcIm1hcmtlclwiOiBfMywgXCJtYXJuYXJkYWxcIjogXzMsIFwibWFzZmpvcmRlblwiOiBfMywgXCJtYXNveVwiOiBfMywgXCJ4bi0tbXN5LXVsYTBoXCI6IF8zLCBcIm3DpXPDuHlcIjogXzMsIFwibWF0dGEtdmFyamphdFwiOiBfMywgXCJ4bi0tbXR0YS12cmpqYXQtazdhZlwiOiBfMywgXCJtw6F0dGEtdsOhcmpqYXRcIjogXzMsIFwibWVsYW5kXCI6IF8zLCBcIm1lbGRhbFwiOiBfMywgXCJtZWxodXNcIjogXzMsIFwibWVsb3lcIjogXzMsIFwieG4tLW1lbHktaXJhXCI6IF8zLCBcIm1lbMO4eVwiOiBfMywgXCJtZXJha2VyXCI6IF8zLCBcInhuLS1tZXJrZXIta3VhXCI6IF8zLCBcIm1lcsOla2VyXCI6IF8zLCBcIm1pZHN1bmRcIjogXzMsIFwibWlkdHJlLWdhdWxkYWxcIjogXzMsIFwibW9hcmVrZVwiOiBfMywgXCJ4bi0tbW9yZWtlLWp1YVwiOiBfMywgXCJtb8OlcmVrZVwiOiBfMywgXCJtb2RhbGVuXCI6IF8zLCBcIm1vZHVtXCI6IF8zLCBcIm1vbGRlXCI6IF8zLCBcIm1vcmUtb2ctcm9tc2RhbFwiOiBbMCwgeyBcImhlcm95XCI6IF8zLCBcInNhbmRlXCI6IF8zIH1dLCBcInhuLS1tcmUtb2ctcm9tc2RhbC1xcWJcIjogWzAsIHsgXCJ4bi0taGVyeS1pcmFcIjogXzMsIFwic2FuZGVcIjogXzMgfV0sIFwibcO4cmUtb2ctcm9tc2RhbFwiOiBbMCwgeyBcImhlcsO4eVwiOiBfMywgXCJzYW5kZVwiOiBfMyB9XSwgXCJtb3NrZW5lc1wiOiBfMywgXCJtb3NzXCI6IF8zLCBcIm1vc3Zpa1wiOiBfMywgXCJtdW9zYXRcIjogXzMsIFwieG4tLW11b3N0LTBxYVwiOiBfMywgXCJtdW9zw6F0XCI6IF8zLCBcIm5hYW1lc2pldnVlbWllXCI6IF8zLCBcInhuLS1ubWVzamV2dWVtaWUtdGNiYVwiOiBfMywgXCJuw6XDpW1lc2pldnVlbWllXCI6IF8zLCBcInhuLS1ucnkteWxhNWdcIjogXzMsIFwibsOmcsO4eVwiOiBfMywgXCJuYW1kYWxzZWlkXCI6IF8zLCBcIm5hbXNvc1wiOiBfMywgXCJuYW1zc2tvZ2FuXCI6IF8zLCBcIm5hbm5lc3RhZFwiOiBfMywgXCJuYXJveVwiOiBfMywgXCJuYXJ2aWlrYVwiOiBfMywgXCJuYXJ2aWtcIjogXzMsIFwibmF1c3RkYWxcIjogXzMsIFwibmF2dW90bmFcIjogXzMsIFwieG4tLW52dW90bmEtaHdhXCI6IF8zLCBcIm7DoXZ1b3RuYVwiOiBfMywgXCJuZWRyZS1laWtlclwiOiBfMywgXCJuZXNuYVwiOiBfMywgXCJuZXNvZGRlblwiOiBfMywgXCJuZXNzZWJ5XCI6IF8zLCBcIm5lc3NldFwiOiBfMywgXCJuaXNzZWRhbFwiOiBfMywgXCJuaXR0ZWRhbFwiOiBfMywgXCJub3JkLWF1cmRhbFwiOiBfMywgXCJub3JkLWZyb25cIjogXzMsIFwibm9yZC1vZGFsXCI6IF8zLCBcIm5vcmRkYWxcIjogXzMsIFwibm9yZGthcHBcIjogXzMsIFwibm9yZGxhbmRcIjogWzAsIHsgXCJib1wiOiBfMywgXCJ4bi0tYi01Z2FcIjogXzMsIFwiYsO4XCI6IF8zLCBcImhlcm95XCI6IF8zLCBcInhuLS1oZXJ5LWlyYVwiOiBfMywgXCJoZXLDuHlcIjogXzMgfV0sIFwibm9yZHJlLWxhbmRcIjogXzMsIFwibm9yZHJlaXNhXCI6IF8zLCBcIm5vcmUtb2ctdXZkYWxcIjogXzMsIFwibm90b2RkZW5cIjogXzMsIFwibm90dGVyb3lcIjogXzMsIFwieG4tLW50dGVyeS1ieWFlXCI6IF8zLCBcIm7DuHR0ZXLDuHlcIjogXzMsIFwib2RkYVwiOiBfMywgXCJva3NuZXNcIjogXzMsIFwieG4tLWtzbmVzLXV1YVwiOiBfMywgXCLDuGtzbmVzXCI6IF8zLCBcIm9tYXN2dW90bmFcIjogXzMsIFwib3BwZGFsXCI6IF8zLCBcIm9wcGVnYXJkXCI6IF8zLCBcInhuLS1vcHBlZ3JkLWl4YVwiOiBfMywgXCJvcHBlZ8OlcmRcIjogXzMsIFwib3JrZGFsXCI6IF8zLCBcIm9ybGFuZFwiOiBfMywgXCJ4bi0tcmxhbmQtdXVhXCI6IF8zLCBcIsO4cmxhbmRcIjogXzMsIFwib3Jza29nXCI6IF8zLCBcInhuLS1yc2tvZy11dWFcIjogXzMsIFwiw7hyc2tvZ1wiOiBfMywgXCJvcnN0YVwiOiBfMywgXCJ4bi0tcnN0YS1mcmFcIjogXzMsIFwiw7hyc3RhXCI6IF8zLCBcIm9zZW5cIjogXzMsIFwib3N0ZXJveVwiOiBfMywgXCJ4bi0tb3N0ZXJ5LWZ5YVwiOiBfMywgXCJvc3RlcsO4eVwiOiBfMywgXCJvc3Rmb2xkXCI6IFswLCB7IFwidmFsZXJcIjogXzMgfV0sIFwieG4tLXN0Zm9sZC05eGFcIjogWzAsIHsgXCJ4bi0tdmxlci1xb2FcIjogXzMgfV0sIFwiw7hzdGZvbGRcIjogWzAsIHsgXCJ2w6VsZXJcIjogXzMgfV0sIFwib3N0cmUtdG90ZW5cIjogXzMsIFwieG4tLXN0cmUtdG90ZW4temNiXCI6IF8zLCBcIsO4c3RyZS10b3RlblwiOiBfMywgXCJvdmVyaGFsbGFcIjogXzMsIFwib3ZyZS1laWtlclwiOiBfMywgXCJ4bi0tdnJlLWVpa2VyLWs4YVwiOiBfMywgXCLDuHZyZS1laWtlclwiOiBfMywgXCJveWVyXCI6IF8zLCBcInhuLS15ZXItem5hXCI6IF8zLCBcIsO4eWVyXCI6IF8zLCBcIm95Z2FyZGVuXCI6IF8zLCBcInhuLS15Z2FyZGVuLXAxYVwiOiBfMywgXCLDuHlnYXJkZW5cIjogXzMsIFwib3lzdHJlLXNsaWRyZVwiOiBfMywgXCJ4bi0teXN0cmUtc2xpZHJlLXVqYlwiOiBfMywgXCLDuHlzdHJlLXNsaWRyZVwiOiBfMywgXCJwb3JzYW5nZXJcIjogXzMsIFwicG9yc2FuZ3VcIjogXzMsIFwieG4tLXBvcnNndS1zdGEyNmZcIjogXzMsIFwicG9yc8OhxYtndVwiOiBfMywgXCJwb3JzZ3J1bm5cIjogXzMsIFwicmFkZVwiOiBfMywgXCJ4bi0tcmRlLXVsYVwiOiBfMywgXCJyw6VkZVwiOiBfMywgXCJyYWRveVwiOiBfMywgXCJ4bi0tcmFkeS1pcmFcIjogXzMsIFwicmFkw7h5XCI6IF8zLCBcInhuLS1ybGluZ2VuLW14YVwiOiBfMywgXCJyw6ZsaW5nZW5cIjogXzMsIFwicmFoa2tlcmF2anVcIjogXzMsIFwieG4tLXJoa2tlcnZqdS0wMWFmXCI6IF8zLCBcInLDoWhra2Vyw6F2anVcIjogXzMsIFwicmFpc2FcIjogXzMsIFwieG4tLXJpc2EtNW5hXCI6IF8zLCBcInLDoWlzYVwiOiBfMywgXCJyYWtrZXN0YWRcIjogXzMsIFwicmFsaW5nZW5cIjogXzMsIFwicmFuYVwiOiBfMywgXCJyYW5kYWJlcmdcIjogXzMsIFwicmF1bWFcIjogXzMsIFwicmVuZGFsZW5cIjogXzMsIFwicmVubmVidVwiOiBfMywgXCJyZW5uZXNveVwiOiBfMywgXCJ4bi0tcmVubmVzeS12MWFcIjogXzMsIFwicmVubmVzw7h5XCI6IF8zLCBcInJpbmRhbFwiOiBfMywgXCJyaW5nZWJ1XCI6IF8zLCBcInJpbmdlcmlrZVwiOiBfMywgXCJyaW5nc2FrZXJcIjogXzMsIFwicmlzb3JcIjogXzMsIFwieG4tLXJpc3ItaXJhXCI6IF8zLCBcInJpc8O4clwiOiBfMywgXCJyaXNzYVwiOiBfMywgXCJyb2FuXCI6IF8zLCBcInJvZG95XCI6IF8zLCBcInhuLS1yZHktMG5hYlwiOiBfMywgXCJyw7hkw7h5XCI6IF8zLCBcInJvbGxhZ1wiOiBfMywgXCJyb21zYVwiOiBfMywgXCJyb21za29nXCI6IF8zLCBcInhuLS1ybXNrb2ctYnlhXCI6IF8zLCBcInLDuG1za29nXCI6IF8zLCBcInJvcm9zXCI6IF8zLCBcInhuLS1ycm9zLWdyYVwiOiBfMywgXCJyw7hyb3NcIjogXzMsIFwicm9zdFwiOiBfMywgXCJ4bi0tcnN0LTBuYVwiOiBfMywgXCJyw7hzdFwiOiBfMywgXCJyb3lrZW5cIjogXzMsIFwieG4tLXJ5a2VuLXZ1YVwiOiBfMywgXCJyw7h5a2VuXCI6IF8zLCBcInJveXJ2aWtcIjogXzMsIFwieG4tLXJ5cnZpay1ieWFcIjogXzMsIFwicsO4eXJ2aWtcIjogXzMsIFwicnVvdmF0XCI6IF8zLCBcInJ5Z2dlXCI6IF8zLCBcInNhbGFuZ2VuXCI6IF8zLCBcInNhbGF0XCI6IF8zLCBcInhuLS1zbGF0LTVuYVwiOiBfMywgXCJzw6FsYXRcIjogXzMsIFwieG4tLXNsdC1lbGFiXCI6IF8zLCBcInPDoWzDoXRcIjogXzMsIFwic2FsdGRhbFwiOiBfMywgXCJzYW1uYW5nZXJcIjogXzMsIFwic2FuZGVmam9yZFwiOiBfMywgXCJzYW5kbmVzXCI6IF8zLCBcInNhbmRveVwiOiBfMywgXCJ4bi0tc2FuZHkteXVhXCI6IF8zLCBcInNhbmTDuHlcIjogXzMsIFwic2FycHNib3JnXCI6IF8zLCBcInNhdWRhXCI6IF8zLCBcInNhdWhlcmFkXCI6IF8zLCBcInNlbFwiOiBfMywgXCJzZWxidVwiOiBfMywgXCJzZWxqZVwiOiBfMywgXCJzZWxqb3JkXCI6IF8zLCBcInNpZWxsYWtcIjogXzMsIFwic2lnZGFsXCI6IF8zLCBcInNpbGphblwiOiBfMywgXCJzaXJkYWxcIjogXzMsIFwic2thbml0XCI6IF8zLCBcInhuLS1za25pdC15cWFcIjogXzMsIFwic2vDoW5pdFwiOiBfMywgXCJza2FubGFuZFwiOiBfMywgXCJ4bi0tc2tubGFuZC1meGFcIjogXzMsIFwic2vDpW5sYW5kXCI6IF8zLCBcInNrYXVuXCI6IF8zLCBcInNrZWRzbW9cIjogXzMsIFwic2tpXCI6IF8zLCBcInNraWVuXCI6IF8zLCBcInNraWVydmFcIjogXzMsIFwieG4tLXNraWVydi11dGFcIjogXzMsIFwic2tpZXJ2w6FcIjogXzMsIFwic2tpcHR2ZXRcIjogXzMsIFwic2tqYWtcIjogXzMsIFwieG4tLXNramstc29hXCI6IF8zLCBcInNrasOla1wiOiBfMywgXCJza2plcnZveVwiOiBfMywgXCJ4bi0tc2tqZXJ2eS12MWFcIjogXzMsIFwic2tqZXJ2w7h5XCI6IF8zLCBcInNrb2RqZVwiOiBfMywgXCJzbW9sYVwiOiBfMywgXCJ4bi0tc21sYS1ocmFcIjogXzMsIFwic23DuGxhXCI6IF8zLCBcInNuYWFzZVwiOiBfMywgXCJ4bi0tc25hc2UtbnJhXCI6IF8zLCBcInNuw6Vhc2VcIjogXzMsIFwic25hc2FcIjogXzMsIFwieG4tLXNuc2Etcm9hXCI6IF8zLCBcInNuw6VzYVwiOiBfMywgXCJzbmlsbGZqb3JkXCI6IF8zLCBcInNub2FzYVwiOiBfMywgXCJzb2duZGFsXCI6IF8zLCBcInNvZ25lXCI6IF8zLCBcInhuLS1zZ25lLWdyYVwiOiBfMywgXCJzw7hnbmVcIjogXzMsIFwic29rbmRhbFwiOiBfMywgXCJzb2xhXCI6IF8zLCBcInNvbHVuZFwiOiBfMywgXCJzb21uYVwiOiBfMywgXCJ4bi0tc21uYS1ncmFcIjogXzMsIFwic8O4bW5hXCI6IF8zLCBcInNvbmRyZS1sYW5kXCI6IF8zLCBcInhuLS1zbmRyZS1sYW5kLTBjYlwiOiBfMywgXCJzw7huZHJlLWxhbmRcIjogXzMsIFwic29uZ2RhbGVuXCI6IF8zLCBcInNvci1hdXJkYWxcIjogXzMsIFwieG4tLXNyLWF1cmRhbC1sOGFcIjogXzMsIFwic8O4ci1hdXJkYWxcIjogXzMsIFwic29yLWZyb25cIjogXzMsIFwieG4tLXNyLWZyb24tcTFhXCI6IF8zLCBcInPDuHItZnJvblwiOiBfMywgXCJzb3Itb2RhbFwiOiBfMywgXCJ4bi0tc3Itb2RhbC1xMWFcIjogXzMsIFwic8O4ci1vZGFsXCI6IF8zLCBcInNvci12YXJhbmdlclwiOiBfMywgXCJ4bi0tc3ItdmFyYW5nZXItZ2diXCI6IF8zLCBcInPDuHItdmFyYW5nZXJcIjogXzMsIFwic29yZm9sZFwiOiBfMywgXCJ4bi0tc3Jmb2xkLWJ5YVwiOiBfMywgXCJzw7hyZm9sZFwiOiBfMywgXCJzb3JyZWlzYVwiOiBfMywgXCJ4bi0tc3JyZWlzYS1xMWFcIjogXzMsIFwic8O4cnJlaXNhXCI6IF8zLCBcInNvcnRsYW5kXCI6IF8zLCBcInNvcnVtXCI6IF8zLCBcInhuLS1zcnVtLWdyYVwiOiBfMywgXCJzw7hydW1cIjogXzMsIFwic3B5ZGViZXJnXCI6IF8zLCBcInN0YW5nZVwiOiBfMywgXCJzdGF2YW5nZXJcIjogXzMsIFwic3RlaWdlblwiOiBfMywgXCJzdGVpbmtqZXJcIjogXzMsIFwic3Rqb3JkYWxcIjogXzMsIFwieG4tLXN0anJkYWwtczFhXCI6IF8zLCBcInN0asO4cmRhbFwiOiBfMywgXCJzdG9ra2VcIjogXzMsIFwic3Rvci1lbHZkYWxcIjogXzMsIFwic3RvcmRcIjogXzMsIFwic3RvcmRhbFwiOiBfMywgXCJzdG9yZmpvcmRcIjogXzMsIFwic3RyYW5kXCI6IF8zLCBcInN0cmFuZGFcIjogXzMsIFwic3RyeW5cIjogXzMsIFwic3VsYVwiOiBfMywgXCJzdWxkYWxcIjogXzMsIFwic3VuZFwiOiBfMywgXCJzdW5uZGFsXCI6IF8zLCBcInN1cm5hZGFsXCI6IF8zLCBcInN2ZWlvXCI6IF8zLCBcInN2ZWx2aWtcIjogXzMsIFwic3lra3lsdmVuXCI6IF8zLCBcInRhbmFcIjogXzMsIFwidGVsZW1hcmtcIjogWzAsIHsgXCJib1wiOiBfMywgXCJ4bi0tYi01Z2FcIjogXzMsIFwiYsO4XCI6IF8zIH1dLCBcInRpbWVcIjogXzMsIFwidGluZ3ZvbGxcIjogXzMsIFwidGlublwiOiBfMywgXCJ0amVsZHN1bmRcIjogXzMsIFwidGpvbWVcIjogXzMsIFwieG4tLXRqbWUtaHJhXCI6IF8zLCBcInRqw7htZVwiOiBfMywgXCJ0b2trZVwiOiBfMywgXCJ0b2xnYVwiOiBfMywgXCJ0b25zYmVyZ1wiOiBfMywgXCJ4bi0tdG5zYmVyZy1xMWFcIjogXzMsIFwidMO4bnNiZXJnXCI6IF8zLCBcInRvcnNrZW5cIjogXzMsIFwieG4tLXRybmEtd29hXCI6IF8zLCBcInRyw6ZuYVwiOiBfMywgXCJ0cmFuYVwiOiBfMywgXCJ0cmFub3lcIjogXzMsIFwieG4tLXRyYW55LXl1YVwiOiBfMywgXCJ0cmFuw7h5XCI6IF8zLCBcInRyb2FuZGluXCI6IF8zLCBcInRyb2dzdGFkXCI6IF8zLCBcInhuLS10cmdzdGFkLXIxYVwiOiBfMywgXCJ0csO4Z3N0YWRcIjogXzMsIFwidHJvbXNhXCI6IF8zLCBcInRyb21zb1wiOiBfMywgXCJ4bi0tdHJvbXMtenVhXCI6IF8zLCBcInRyb21zw7hcIjogXzMsIFwidHJvbmRoZWltXCI6IF8zLCBcInRyeXNpbFwiOiBfMywgXCJ0dmVkZXN0cmFuZFwiOiBfMywgXCJ0eWRhbFwiOiBfMywgXCJ0eW5zZXRcIjogXzMsIFwidHlzZmpvcmRcIjogXzMsIFwidHlzbmVzXCI6IF8zLCBcInhuLS10eXN2ci12cmFcIjogXzMsIFwidHlzdsOmclwiOiBfMywgXCJ0eXN2YXJcIjogXzMsIFwidWxsZW5zYWtlclwiOiBfMywgXCJ1bGxlbnN2YW5nXCI6IF8zLCBcInVsdmlrXCI6IF8zLCBcInVuamFyZ2FcIjogXzMsIFwieG4tLXVuanJnYS1ydGFcIjogXzMsIFwidW5qw6FyZ2FcIjogXzMsIFwidXRzaXJhXCI6IF8zLCBcInZhYXBzdGVcIjogXzMsIFwidmFkc29cIjogXzMsIFwieG4tLXZhZHMtanJhXCI6IF8zLCBcInZhZHPDuFwiOiBfMywgXCJ4bi0tdnJ5LXlsYTVnXCI6IF8zLCBcInbDpnLDuHlcIjogXzMsIFwidmFnYVwiOiBfMywgXCJ4bi0tdmcteWlhYlwiOiBfMywgXCJ2w6Vnw6VcIjogXzMsIFwidmFnYW5cIjogXzMsIFwieG4tLXZnYW4tcW9hXCI6IF8zLCBcInbDpWdhblwiOiBfMywgXCJ2YWdzb3lcIjogXzMsIFwieG4tLXZnc3ktcW9hMGpcIjogXzMsIFwidsOlZ3PDuHlcIjogXzMsIFwidmFrc2RhbFwiOiBfMywgXCJ2YWxsZVwiOiBfMywgXCJ2YW5nXCI6IF8zLCBcInZhbnlsdmVuXCI6IF8zLCBcInZhcmRvXCI6IF8zLCBcInhuLS12YXJkLWpyYVwiOiBfMywgXCJ2YXJkw7hcIjogXzMsIFwidmFyZ2dhdFwiOiBfMywgXCJ4bi0tdnJnZ3QteHFhZFwiOiBfMywgXCJ2w6FyZ2fDoXRcIjogXzMsIFwidmFyb3lcIjogXzMsIFwidmVmc25cIjogXzMsIFwidmVnYVwiOiBfMywgXCJ2ZWdhcnNoZWlcIjogXzMsIFwieG4tLXZlZ3JzaGVpLWMwYVwiOiBfMywgXCJ2ZWfDpXJzaGVpXCI6IF8zLCBcInZlbm5lc2xhXCI6IF8zLCBcInZlcmRhbFwiOiBfMywgXCJ2ZXJyYW5cIjogXzMsIFwidmVzdGJ5XCI6IF8zLCBcInZlc3Rmb2xkXCI6IFswLCB7IFwic2FuZGVcIjogXzMgfV0sIFwidmVzdG5lc1wiOiBfMywgXCJ2ZXN0cmUtc2xpZHJlXCI6IF8zLCBcInZlc3RyZS10b3RlblwiOiBfMywgXCJ2ZXN0dmFnb3lcIjogXzMsIFwieG4tLXZlc3R2Z3ktaXhhNm9cIjogXzMsIFwidmVzdHbDpWfDuHlcIjogXzMsIFwidmV2ZWxzdGFkXCI6IF8zLCBcInZpa1wiOiBfMywgXCJ2aWtuYVwiOiBfMywgXCJ2aW5kYWZqb3JkXCI6IF8zLCBcInZvYWdhdFwiOiBfMywgXCJ2b2xkYVwiOiBfMywgXCJ2b3NzXCI6IF8zLCBcImNvXCI6IF80LCBcIjEyM2hqZW1tZXNpZGVcIjogXzQsIFwibXlzcHJlYWRzaG9wXCI6IF80IH1dLCBcIm5wXCI6IF8xNywgXCJuclwiOiBfNTMsIFwibnVcIjogWzEsIHsgXCJtZXJzZWluZVwiOiBfNCwgXCJtaW5lXCI6IF80LCBcInNoYWNrbmV0XCI6IF80LCBcImVudGVycHJpc2VjbG91ZFwiOiBfNCB9XSwgXCJuelwiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IF8zLCBcImNyaVwiOiBfMywgXCJnZWVrXCI6IF8zLCBcImdlblwiOiBfMywgXCJnb3Z0XCI6IF8zLCBcImhlYWx0aFwiOiBfMywgXCJpd2lcIjogXzMsIFwia2l3aVwiOiBfMywgXCJtYW9yaVwiOiBfMywgXCJ4bi0tbW9yaS1xc2FcIjogXzMsIFwibcSBb3JpXCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInBhcmxpYW1lbnRcIjogXzMsIFwic2Nob29sXCI6IF8zLCBcImNsb3VkbnNcIjogXzQgfV0sIFwib21cIjogWzEsIHsgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtZWRcIjogXzMsIFwibXVzZXVtXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicHJvXCI6IF8zIH1dLCBcIm9uaW9uXCI6IF8zLCBcIm9yZ1wiOiBbMSwgeyBcImFsdGVydmlzdGFcIjogXzQsIFwicGltaWVudGFcIjogXzQsIFwicG9pdnJvblwiOiBfNCwgXCJwb3RhZ2VyXCI6IF80LCBcInN3ZWV0cGVwcGVyXCI6IF80LCBcImNkbjc3XCI6IFswLCB7IFwiY1wiOiBfNCwgXCJyc2NcIjogXzQgfV0sIFwiY2RuNzctc2VjdXJlXCI6IFswLCB7IFwib3JpZ2luXCI6IFswLCB7IFwic3NsXCI6IF80IH1dIH1dLCBcImFlXCI6IF80LCBcImNsb3VkbnNcIjogXzQsIFwiaXAtZHluYW1pY1wiOiBfNCwgXCJkZG5zc1wiOiBfNCwgXCJkdWNrZG5zXCI6IF80LCBcInR1bmtcIjogXzQsIFwiYmxvZ2Ruc1wiOiBfNCwgXCJibG9nc2l0ZVwiOiBfNCwgXCJib2xkbHlnb2luZ25vd2hlcmVcIjogXzQsIFwiZG5zYWxpYXNcIjogXzQsIFwiZG5zZG9qb1wiOiBfNCwgXCJkb2VzbnRleGlzdFwiOiBfNCwgXCJkb250ZXhpc3RcIjogXzQsIFwiZG9vbWRuc1wiOiBfNCwgXCJkdnJkbnNcIjogXzQsIFwiZHluYWxpYXNcIjogXzQsIFwiZHluZG5zXCI6IFsyLCB7IFwiZ29cIjogXzQsIFwiaG9tZVwiOiBfNCB9XSwgXCJlbmRvZmludGVybmV0XCI6IF80LCBcImVuZG9mdGhlaW50ZXJuZXRcIjogXzQsIFwiZnJvbS1tZVwiOiBfNCwgXCJnYW1lLWhvc3RcIjogXzQsIFwiZ290ZG5zXCI6IF80LCBcImhvYmJ5LXNpdGVcIjogXzQsIFwiaG9tZWRuc1wiOiBfNCwgXCJob21lZnRwXCI6IF80LCBcImhvbWVsaW51eFwiOiBfNCwgXCJob21ldW5peFwiOiBfNCwgXCJpcy1hLWJydWluc2ZhblwiOiBfNCwgXCJpcy1hLWNhbmRpZGF0ZVwiOiBfNCwgXCJpcy1hLWNlbHRpY3NmYW5cIjogXzQsIFwiaXMtYS1jaGVmXCI6IF80LCBcImlzLWEtZ2Vla1wiOiBfNCwgXCJpcy1hLWtuaWdodFwiOiBfNCwgXCJpcy1hLWxpbnV4LXVzZXJcIjogXzQsIFwiaXMtYS1wYXRzZmFuXCI6IF80LCBcImlzLWEtc294ZmFuXCI6IF80LCBcImlzLWZvdW5kXCI6IF80LCBcImlzLWxvc3RcIjogXzQsIFwiaXMtc2F2ZWRcIjogXzQsIFwiaXMtdmVyeS1iYWRcIjogXzQsIFwiaXMtdmVyeS1ldmlsXCI6IF80LCBcImlzLXZlcnktZ29vZFwiOiBfNCwgXCJpcy12ZXJ5LW5pY2VcIjogXzQsIFwiaXMtdmVyeS1zd2VldFwiOiBfNCwgXCJpc2EtZ2Vla1wiOiBfNCwgXCJraWNrcy1hc3NcIjogXzQsIFwibWlzY29uZnVzZWRcIjogXzQsIFwicG9kem9uZVwiOiBfNCwgXCJyZWFkbXlibG9nXCI6IF80LCBcInNlbGZpcFwiOiBfNCwgXCJzZWxsc3lvdXJob21lXCI6IF80LCBcInNlcnZlYmJzXCI6IF80LCBcInNlcnZlZnRwXCI6IF80LCBcInNlcnZlZ2FtZVwiOiBfNCwgXCJzdHVmZi00LXNhbGVcIjogXzQsIFwid2ViaG9wXCI6IF80LCBcImFjY2Vzc2NhbVwiOiBfNCwgXCJjYW1kdnJcIjogXzQsIFwiZnJlZWRkbnNcIjogXzQsIFwibXl3aXJlXCI6IF80LCBcIndlYnJlZGlyZWN0XCI6IF80LCBcInR3bWFpbFwiOiBfNCwgXCJldVwiOiBbMiwgeyBcImFsXCI6IF80LCBcImFzc29cIjogXzQsIFwiYXRcIjogXzQsIFwiYXVcIjogXzQsIFwiYmVcIjogXzQsIFwiYmdcIjogXzQsIFwiY2FcIjogXzQsIFwiY2RcIjogXzQsIFwiY2hcIjogXzQsIFwiY25cIjogXzQsIFwiY3lcIjogXzQsIFwiY3pcIjogXzQsIFwiZGVcIjogXzQsIFwiZGtcIjogXzQsIFwiZWR1XCI6IF80LCBcImVlXCI6IF80LCBcImVzXCI6IF80LCBcImZpXCI6IF80LCBcImZyXCI6IF80LCBcImdyXCI6IF80LCBcImhyXCI6IF80LCBcImh1XCI6IF80LCBcImllXCI6IF80LCBcImlsXCI6IF80LCBcImluXCI6IF80LCBcImludFwiOiBfNCwgXCJpc1wiOiBfNCwgXCJpdFwiOiBfNCwgXCJqcFwiOiBfNCwgXCJrclwiOiBfNCwgXCJsdFwiOiBfNCwgXCJsdVwiOiBfNCwgXCJsdlwiOiBfNCwgXCJtZVwiOiBfNCwgXCJta1wiOiBfNCwgXCJtdFwiOiBfNCwgXCJteVwiOiBfNCwgXCJuZXRcIjogXzQsIFwibmdcIjogXzQsIFwibmxcIjogXzQsIFwibm9cIjogXzQsIFwibnpcIjogXzQsIFwicGxcIjogXzQsIFwicHRcIjogXzQsIFwicm9cIjogXzQsIFwicnVcIjogXzQsIFwic2VcIjogXzQsIFwic2lcIjogXzQsIFwic2tcIjogXzQsIFwidHJcIjogXzQsIFwidWtcIjogXzQsIFwidXNcIjogXzQgfV0sIFwiZmVkb3JhaW5mcmFjbG91ZFwiOiBfNCwgXCJmZWRvcmFwZW9wbGVcIjogXzQsIFwiZmVkb3JhcHJvamVjdFwiOiBbMCwgeyBcImNsb3VkXCI6IF80LCBcIm9zXCI6IF80MSwgXCJzdGdcIjogWzAsIHsgXCJvc1wiOiBfNDEgfV0gfV0sIFwiZnJlZWRlc2t0b3BcIjogXzQsIFwiaGF0ZW5hZGlhcnlcIjogXzQsIFwiaGVwZm9yZ2VcIjogXzQsIFwiaW4tZHNsXCI6IF80LCBcImluLXZwblwiOiBfNCwgXCJqc1wiOiBfNCwgXCJiYXJzeVwiOiBfNCwgXCJtYXlmaXJzdFwiOiBfNCwgXCJyb3V0aW5ndGhlY2xvdWRcIjogXzQsIFwiYm1vYXR0YWNobWVudHNcIjogXzQsIFwiY2FibGUtbW9kZW1cIjogXzQsIFwiY29sbGVnZWZhblwiOiBfNCwgXCJjb3VjaHBvdGF0b2ZyaWVzXCI6IF80LCBcImhvcHRvXCI6IF80LCBcIm1sYmZhblwiOiBfNCwgXCJteWZ0cFwiOiBfNCwgXCJteXNlY3VyaXR5Y2FtZXJhXCI6IF80LCBcIm5mbGZhblwiOiBfNCwgXCJuby1pcFwiOiBfNCwgXCJyZWFkLWJvb2tzXCI6IF80LCBcInVmY2ZhblwiOiBfNCwgXCJ6YXB0b1wiOiBfNCwgXCJkeW5zZXJ2XCI6IF80LCBcIm5vdy1kbnNcIjogXzQsIFwiaXMtbG9jYWxcIjogXzQsIFwiaHR0cGJpblwiOiBfNCwgXCJwdWJ0bHNcIjogXzQsIFwianBuXCI6IF80LCBcIm15LWZpcmV3YWxsXCI6IF80LCBcIm15ZmlyZXdhbGxcIjogXzQsIFwic3BkbnNcIjogXzQsIFwic21hbGwtd2ViXCI6IF80LCBcImRzbXluYXNcIjogXzQsIFwiZmFtaWx5ZHNcIjogXzQsIFwidGVja2lkc1wiOiBfNTIsIFwidHV4ZmFtaWx5XCI6IF80LCBcImRpc2tzdGF0aW9uXCI6IF80LCBcImhrXCI6IF80LCBcInVzXCI6IF80LCBcInRvb2xmb3JnZVwiOiBfNCwgXCJ3bWNsb3VkXCI6IF80LCBcIndtZmxhYnNcIjogXzQsIFwiemFcIjogXzQgfV0sIFwicGFcIjogWzEsIHsgXCJhYm9cIjogXzMsIFwiYWNcIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwiaW5nXCI6IF8zLCBcIm1lZFwiOiBfMywgXCJuZXRcIjogXzMsIFwibm9tXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJzbGRcIjogXzMgfV0sIFwicGVcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvYlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm5vbVwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwicGZcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJwZ1wiOiBfMTcsIFwicGhcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJpXCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwibmdvXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJjbG91ZG5zXCI6IF80IH1dLCBcInBrXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiYml6XCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZmFtXCI6IF8zLCBcImdrcFwiOiBfMywgXCJnb2JcIjogXzMsIFwiZ29nXCI6IF8zLCBcImdva1wiOiBfMywgXCJnb3BcIjogXzMsIFwiZ29zXCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcIndlYlwiOiBfMyB9XSwgXCJwbFwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImFncm9cIjogXzMsIFwiYWlkXCI6IF8zLCBcImF0bVwiOiBfMywgXCJhdXRvXCI6IF8zLCBcImJpelwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ21pbmFcIjogXzMsIFwiZ3NtXCI6IF8zLCBcImluZm9cIjogXzMsIFwibWFpbFwiOiBfMywgXCJtZWRpYVwiOiBfMywgXCJtaWFzdGFcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5pZXJ1Y2hvbW9zY2lcIjogXzMsIFwibm9tXCI6IF8zLCBcInBjXCI6IF8zLCBcInBvd2lhdFwiOiBfMywgXCJwcml2XCI6IF8zLCBcInJlYWxlc3RhdGVcIjogXzMsIFwicmVsXCI6IF8zLCBcInNleFwiOiBfMywgXCJzaG9wXCI6IF8zLCBcInNrbGVwXCI6IF8zLCBcInNvc1wiOiBfMywgXCJzemtvbGFcIjogXzMsIFwidGFyZ2lcIjogXzMsIFwidG1cIjogXzMsIFwidG91cmlzbVwiOiBfMywgXCJ0cmF2ZWxcIjogXzMsIFwidHVyeXN0eWthXCI6IF8zLCBcImdvdlwiOiBbMSwgeyBcImFwXCI6IF8zLCBcImdyaXdcIjogXzMsIFwiaWNcIjogXzMsIFwiaXNcIjogXzMsIFwia21wc3BcIjogXzMsIFwia29uc3VsYXRcIjogXzMsIFwia3Bwc3BcIjogXzMsIFwia3dwXCI6IF8zLCBcImt3cHNwXCI6IF8zLCBcIm11cFwiOiBfMywgXCJtd1wiOiBfMywgXCJvaWFcIjogXzMsIFwib2lybVwiOiBfMywgXCJva2VcIjogXzMsIFwib293XCI6IF8zLCBcIm9zY2hyXCI6IF8zLCBcIm91bVwiOiBfMywgXCJwYVwiOiBfMywgXCJwaW5iXCI6IF8zLCBcInBpd1wiOiBfMywgXCJwb1wiOiBfMywgXCJwclwiOiBfMywgXCJwc3BcIjogXzMsIFwicHNzZVwiOiBfMywgXCJwdXBcIjogXzMsIFwicnpnd1wiOiBfMywgXCJzYVwiOiBfMywgXCJzZG5cIjogXzMsIFwic2tvXCI6IF8zLCBcInNvXCI6IF8zLCBcInNyXCI6IF8zLCBcInN0YXJvc3R3b1wiOiBfMywgXCJ1Z1wiOiBfMywgXCJ1Z2ltXCI6IF8zLCBcInVtXCI6IF8zLCBcInVtaWdcIjogXzMsIFwidXBvd1wiOiBfMywgXCJ1cHBvXCI6IF8zLCBcInVzXCI6IF8zLCBcInV3XCI6IF8zLCBcInV6c1wiOiBfMywgXCJ3aWZcIjogXzMsIFwid2lpaFwiOiBfMywgXCJ3aW5iXCI6IF8zLCBcIndpb3NcIjogXzMsIFwid2l0ZFwiOiBfMywgXCJ3aXdcIjogXzMsIFwid2t6XCI6IF8zLCBcIndzYVwiOiBfMywgXCJ3c2tyXCI6IF8zLCBcIndzc2VcIjogXzMsIFwid3VvelwiOiBfMywgXCJ3em1pdXdcIjogXzMsIFwienBcIjogXzMsIFwienBpc2RuXCI6IF8zIH1dLCBcImF1Z3VzdG93XCI6IF8zLCBcImJhYmlhLWdvcmFcIjogXzMsIFwiYmVkemluXCI6IF8zLCBcImJlc2tpZHlcIjogXzMsIFwiYmlhbG93aWV6YVwiOiBfMywgXCJiaWFseXN0b2tcIjogXzMsIFwiYmllbGF3YVwiOiBfMywgXCJiaWVzemN6YWR5XCI6IF8zLCBcImJvbGVzbGF3aWVjXCI6IF8zLCBcImJ5ZGdvc3pjelwiOiBfMywgXCJieXRvbVwiOiBfMywgXCJjaWVzenluXCI6IF8zLCBcImN6ZWxhZHpcIjogXzMsIFwiY3plc3RcIjogXzMsIFwiZGx1Z29sZWthXCI6IF8zLCBcImVsYmxhZ1wiOiBfMywgXCJlbGtcIjogXzMsIFwiZ2xvZ293XCI6IF8zLCBcImduaWV6bm9cIjogXzMsIFwiZ29ybGljZVwiOiBfMywgXCJncmFqZXdvXCI6IF8zLCBcImlsYXdhXCI6IF8zLCBcImphd29yem5vXCI6IF8zLCBcImplbGVuaWEtZ29yYVwiOiBfMywgXCJqZ29yYVwiOiBfMywgXCJrYWxpc3pcIjogXzMsIFwia2FycGFjelwiOiBfMywgXCJrYXJ0dXp5XCI6IF8zLCBcImthc3p1YnlcIjogXzMsIFwia2F0b3dpY2VcIjogXzMsIFwia2F6aW1pZXJ6LWRvbG55XCI6IF8zLCBcImtlcG5vXCI6IF8zLCBcImtldHJ6eW5cIjogXzMsIFwia2xvZHprb1wiOiBfMywgXCJrb2JpZXJ6eWNlXCI6IF8zLCBcImtvbG9icnplZ1wiOiBfMywgXCJrb25pblwiOiBfMywgXCJrb25za293b2xhXCI6IF8zLCBcImt1dG5vXCI6IF8zLCBcImxhcHlcIjogXzMsIFwibGVib3JrXCI6IF8zLCBcImxlZ25pY2FcIjogXzMsIFwibGV6YWpza1wiOiBfMywgXCJsaW1hbm93YVwiOiBfMywgXCJsb216YVwiOiBfMywgXCJsb3dpY3pcIjogXzMsIFwibHViaW5cIjogXzMsIFwibHVrb3dcIjogXzMsIFwibWFsYm9ya1wiOiBfMywgXCJtYWxvcG9sc2thXCI6IF8zLCBcIm1hem93c3plXCI6IF8zLCBcIm1henVyeVwiOiBfMywgXCJtaWVsZWNcIjogXzMsIFwibWllbG5vXCI6IF8zLCBcIm1yYWdvd29cIjogXzMsIFwibmFrbG9cIjogXzMsIFwibm93YXJ1ZGFcIjogXzMsIFwibnlzYVwiOiBfMywgXCJvbGF3YVwiOiBfMywgXCJvbGVja29cIjogXzMsIFwib2xrdXN6XCI6IF8zLCBcIm9sc3p0eW5cIjogXzMsIFwib3BvY3pub1wiOiBfMywgXCJvcG9sZVwiOiBfMywgXCJvc3Ryb2RhXCI6IF8zLCBcIm9zdHJvbGVrYVwiOiBfMywgXCJvc3Ryb3dpZWNcIjogXzMsIFwib3N0cm93d2xrcFwiOiBfMywgXCJwaWxhXCI6IF8zLCBcInBpc3pcIjogXzMsIFwicG9kaGFsZVwiOiBfMywgXCJwb2RsYXNpZVwiOiBfMywgXCJwb2xrb3dpY2VcIjogXzMsIFwicG9tb3Jza2llXCI6IF8zLCBcInBvbW9yemVcIjogXzMsIFwicHJvY2hvd2ljZVwiOiBfMywgXCJwcnVzemtvd1wiOiBfMywgXCJwcnpld29yc2tcIjogXzMsIFwicHVsYXd5XCI6IF8zLCBcInJhZG9tXCI6IF8zLCBcInJhd2EtbWF6XCI6IF8zLCBcInJ5Ym5pa1wiOiBfMywgXCJyemVzem93XCI6IF8zLCBcInNhbm9rXCI6IF8zLCBcInNlam55XCI6IF8zLCBcInNrb2N6b3dcIjogXzMsIFwic2xhc2tcIjogXzMsIFwic2x1cHNrXCI6IF8zLCBcInNvc25vd2llY1wiOiBfMywgXCJzdGFsb3dhLXdvbGFcIjogXzMsIFwic3RhcmFjaG93aWNlXCI6IF8zLCBcInN0YXJnYXJkXCI6IF8zLCBcInN1d2Fsa2lcIjogXzMsIFwic3dpZG5pY2FcIjogXzMsIFwic3dpZWJvZHppblwiOiBfMywgXCJzd2lub3Vqc2NpZVwiOiBfMywgXCJzemN6ZWNpblwiOiBfMywgXCJzemN6eXRub1wiOiBfMywgXCJ0YXJub2JyemVnXCI6IF8zLCBcInRnb3J5XCI6IF8zLCBcInR1cmVrXCI6IF8zLCBcInR5Y2h5XCI6IF8zLCBcInVzdGthXCI6IF8zLCBcIndhbGJyenljaFwiOiBfMywgXCJ3YXJtaWFcIjogXzMsIFwid2Fyc3phd2FcIjogXzMsIFwid2F3XCI6IF8zLCBcIndlZ3Jvd1wiOiBfMywgXCJ3aWVsdW5cIjogXzMsIFwid2xvY2xcIjogXzMsIFwid2xvY2xhd2VrXCI6IF8zLCBcIndvZHppc2xhd1wiOiBfMywgXCJ3b2xvbWluXCI6IF8zLCBcIndyb2NsYXdcIjogXzMsIFwiemFjaHBvbW9yXCI6IF8zLCBcInphZ2FuXCI6IF8zLCBcInphcm93XCI6IF8zLCBcInpnb3JhXCI6IF8zLCBcInpnb3J6ZWxlY1wiOiBfMywgXCJhcnRcIjogXzQsIFwiZ2xpd2ljZVwiOiBfNCwgXCJrcmFrb3dcIjogXzQsIFwicG96bmFuXCI6IF80LCBcIndyb2NcIjogXzQsIFwiemFrb3BhbmVcIjogXzQsIFwiYmVlcFwiOiBfNCwgXCJlY29tbWVyY2Utc2hvcFwiOiBfNCwgXCJjZm9sa3NcIjogXzQsIFwiZGZpcm1hXCI6IF80LCBcImRrb250b1wiOiBfNCwgXCJ5b3UyXCI6IF80LCBcInNob3BhcmVuYVwiOiBfNCwgXCJob21lc2tsZXBcIjogXzQsIFwic2RzY2xvdWRcIjogXzQsIFwidW5pY2xvdWRcIjogXzQsIFwibG9kelwiOiBfNCwgXCJwYWJpYW5pY2VcIjogXzQsIFwicGxvY2tcIjogXzQsIFwic2llcmFkelwiOiBfNCwgXCJza2llcm5pZXdpY2VcIjogXzQsIFwiemdpZXJ6XCI6IF80LCBcImtyYXNuaWtcIjogXzQsIFwibGVjem5hXCI6IF80LCBcImx1YmFydG93XCI6IF80LCBcImx1YmxpblwiOiBfNCwgXCJwb25pYXRvd2FcIjogXzQsIFwic3dpZG5pa1wiOiBfNCwgXCJjb1wiOiBfNCwgXCJ0b3J1blwiOiBfNCwgXCJzaW1wbGVzaXRlXCI6IF80LCBcIm15c3ByZWFkc2hvcFwiOiBfNCwgXCJnZGFcIjogXzQsIFwiZ2RhbnNrXCI6IF80LCBcImdkeW5pYVwiOiBfNCwgXCJtZWRcIjogXzQsIFwic29wb3RcIjogXzQsIFwiYmllbHNrb1wiOiBfNCB9XSwgXCJwbVwiOiBbMSwgeyBcIm93blwiOiBfNCwgXCJuYW1lXCI6IF80IH1dLCBcInBuXCI6IFsxLCB7IFwiY29cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcInBvc3RcIjogXzMsIFwicHJcIjogWzEsIHsgXCJiaXpcIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaW5mb1wiOiBfMywgXCJpc2xhXCI6IF8zLCBcIm5hbWVcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwcm9cIjogXzMsIFwiYWNcIjogXzMsIFwiZXN0XCI6IF8zLCBcInByb2ZcIjogXzMgfV0sIFwicHJvXCI6IFsxLCB7IFwiYWFhXCI6IF8zLCBcImFjYVwiOiBfMywgXCJhY2N0XCI6IF8zLCBcImF2b2NhdFwiOiBfMywgXCJiYXJcIjogXzMsIFwiY3BhXCI6IF8zLCBcImVuZ1wiOiBfMywgXCJqdXJcIjogXzMsIFwibGF3XCI6IF8zLCBcIm1lZFwiOiBfMywgXCJyZWNodFwiOiBfMywgXCIxMmNoYXJzXCI6IF80LCBcImNsb3VkbnNcIjogXzQsIFwiYmFyc3lcIjogXzQsIFwibmdyb2tcIjogXzQgfV0sIFwicHNcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInBsb1wiOiBfMywgXCJzZWNcIjogXzMgfV0sIFwicHRcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJpbnRcIjogXzMsIFwibmV0XCI6IF8zLCBcIm5vbWVcIjogXzMsIFwib3JnXCI6IF8zLCBcInB1YmxcIjogXzMsIFwiMTIzcGFnaW5hd2ViXCI6IF80IH1dLCBcInB3XCI6IFsxLCB7IFwiZ292XCI6IF8zLCBcImNsb3VkbnNcIjogXzQsIFwieDQ0M1wiOiBfNCB9XSwgXCJweVwiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJjb29wXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwicWFcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInNjaFwiOiBfMyB9XSwgXCJyZVwiOiBbMSwgeyBcImFzc29cIjogXzMsIFwiY29tXCI6IF8zLCBcIm5ldGxpYlwiOiBfNCwgXCJjYW5cIjogXzQgfV0sIFwicm9cIjogWzEsIHsgXCJhcnRzXCI6IF8zLCBcImNvbVwiOiBfMywgXCJmaXJtXCI6IF8zLCBcImluZm9cIjogXzMsIFwibm9tXCI6IF8zLCBcIm50XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJyZWNcIjogXzMsIFwic3RvcmVcIjogXzMsIFwidG1cIjogXzMsIFwid3d3XCI6IF8zLCBcImNvXCI6IF80LCBcInNob3BcIjogXzQsIFwiYmFyc3lcIjogXzQgfV0sIFwicnNcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJjb1wiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImluXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJicmVuZGx5XCI6IF80OSwgXCJiYXJzeVwiOiBfNCwgXCJveFwiOiBfNCB9XSwgXCJydVwiOiBbMSwgeyBcImFjXCI6IF80LCBcImVkdVwiOiBfNCwgXCJnb3ZcIjogXzQsIFwiaW50XCI6IF80LCBcIm1pbFwiOiBfNCwgXCJldXJvZGlyXCI6IF80LCBcImFkeWdleWFcIjogXzQsIFwiYmFzaGtpcmlhXCI6IF80LCBcImJpclwiOiBfNCwgXCJjYmdcIjogXzQsIFwiY29tXCI6IF80LCBcImRhZ2VzdGFuXCI6IF80LCBcImdyb3pueVwiOiBfNCwgXCJrYWxteWtpYVwiOiBfNCwgXCJrdXN0YW5haVwiOiBfNCwgXCJtYXJpbmVcIjogXzQsIFwibW9yZG92aWFcIjogXzQsIFwibXNrXCI6IF80LCBcIm15dGlzXCI6IF80LCBcIm5hbGNoaWtcIjogXzQsIFwibm92XCI6IF80LCBcInB5YXRpZ29yc2tcIjogXzQsIFwic3BiXCI6IF80LCBcInZsYWRpa2F2a2F6XCI6IF80LCBcInZsYWRpbWlyXCI6IF80LCBcIm5hNHVcIjogXzQsIFwibWlyY2xvdWRcIjogXzQsIFwibXlqaW5vXCI6IFsyLCB7IFwiaG9zdGluZ1wiOiBfNywgXCJsYW5kaW5nXCI6IF83LCBcInNwZWN0cnVtXCI6IF83LCBcInZwc1wiOiBfNyB9XSwgXCJjbGRtYWlsXCI6IFswLCB7IFwiaGJcIjogXzQgfV0sIFwibWNkaXJcIjogWzIsIHsgXCJ2cHNcIjogXzQgfV0sIFwibWNwcmVcIjogXzQsIFwibmV0XCI6IF80LCBcIm9yZ1wiOiBfNCwgXCJwcFwiOiBfNCwgXCJsazNcIjogXzQsIFwicmFzXCI6IF80IH1dLCBcInJ3XCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiY29cIjogXzMsIFwiY29vcFwiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwic2FcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtZWRcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwdWJcIjogXzMsIFwic2NoXCI6IF8zIH1dLCBcInNiXCI6IF81LCBcInNjXCI6IF81LCBcInNkXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaW5mb1wiOiBfMywgXCJtZWRcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ0dlwiOiBfMyB9XSwgXCJzZVwiOiBbMSwgeyBcImFcIjogXzMsIFwiYWNcIjogXzMsIFwiYlwiOiBfMywgXCJiZFwiOiBfMywgXCJicmFuZFwiOiBfMywgXCJjXCI6IF8zLCBcImRcIjogXzMsIFwiZVwiOiBfMywgXCJmXCI6IF8zLCBcImZoXCI6IF8zLCBcImZoc2tcIjogXzMsIFwiZmh2XCI6IF8zLCBcImdcIjogXzMsIFwiaFwiOiBfMywgXCJpXCI6IF8zLCBcImtcIjogXzMsIFwia29tZm9yYlwiOiBfMywgXCJrb21tdW5hbGZvcmJ1bmRcIjogXzMsIFwia29tdnV4XCI6IF8zLCBcImxcIjogXzMsIFwibGFuYmliXCI6IF8zLCBcIm1cIjogXzMsIFwiblwiOiBfMywgXCJuYXR1cmJydWtzZ3ltblwiOiBfMywgXCJvXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwXCI6IF8zLCBcInBhcnRpXCI6IF8zLCBcInBwXCI6IF8zLCBcInByZXNzXCI6IF8zLCBcInJcIjogXzMsIFwic1wiOiBfMywgXCJ0XCI6IF8zLCBcInRtXCI6IF8zLCBcInVcIjogXzMsIFwid1wiOiBfMywgXCJ4XCI6IF8zLCBcInlcIjogXzMsIFwielwiOiBfMywgXCJjb21cIjogXzQsIFwiaW9wc3lzXCI6IF80LCBcIjEyM21pbnNpZGFcIjogXzQsIFwiaXRjb3VsZGJld29yXCI6IF80LCBcIm15c3ByZWFkc2hvcFwiOiBfNCB9XSwgXCJzZ1wiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwiZW5zY2FsZWRcIjogXzQgfV0sIFwic2hcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImhhc2hiYW5nXCI6IF80LCBcImJvdGRhXCI6IF80LCBcInBsYXRmb3JtXCI6IFswLCB7IFwiZW50XCI6IF80LCBcImV1XCI6IF80LCBcInVzXCI6IF80IH1dLCBcIm5vd1wiOiBfNCB9XSwgXCJzaVwiOiBbMSwgeyBcImY1XCI6IF80LCBcImdpdGFwcFwiOiBfNCwgXCJnaXRwYWdlXCI6IF80IH1dLCBcInNqXCI6IF8zLCBcInNrXCI6IF8zLCBcInNsXCI6IF81LCBcInNtXCI6IF8zLCBcInNuXCI6IFsxLCB7IFwiYXJ0XCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ291dlwiOiBfMywgXCJvcmdcIjogXzMsIFwicGVyc29cIjogXzMsIFwidW5pdlwiOiBfMyB9XSwgXCJzb1wiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm1lXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwic3VydmV5c1wiOiBfNCB9XSwgXCJzclwiOiBfMywgXCJzc1wiOiBbMSwgeyBcImJpelwiOiBfMywgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInNjaFwiOiBfMyB9XSwgXCJzdFwiOiBbMSwgeyBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJjb25zdWxhZG9cIjogXzMsIFwiZWR1XCI6IF8zLCBcImVtYmFpeGFkYVwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJwcmluY2lwZVwiOiBfMywgXCJzYW90b21lXCI6IF8zLCBcInN0b3JlXCI6IF8zLCBcImhlbGlvaG9cIjogXzQsIFwia2lyYXJhXCI6IF80LCBcIm5vaG9cIjogXzQgfV0sIFwic3VcIjogWzEsIHsgXCJhYmtoYXppYVwiOiBfNCwgXCJhZHlnZXlhXCI6IF80LCBcImFrdHl1Ymluc2tcIjogXzQsIFwiYXJraGFuZ2Vsc2tcIjogXzQsIFwiYXJtZW5pYVwiOiBfNCwgXCJhc2hnYWJhZFwiOiBfNCwgXCJhemVyYmFpamFuXCI6IF80LCBcImJhbGFzaG92XCI6IF80LCBcImJhc2hraXJpYVwiOiBfNCwgXCJicnlhbnNrXCI6IF80LCBcImJ1a2hhcmFcIjogXzQsIFwiY2hpbWtlbnRcIjogXzQsIFwiZGFnZXN0YW5cIjogXzQsIFwiZWFzdC1rYXpha2hzdGFuXCI6IF80LCBcImV4bmV0XCI6IF80LCBcImdlb3JnaWFcIjogXzQsIFwiZ3Jvem55XCI6IF80LCBcIml2YW5vdm9cIjogXzQsIFwiamFtYnlsXCI6IF80LCBcImthbG15a2lhXCI6IF80LCBcImthbHVnYVwiOiBfNCwgXCJrYXJhY29sXCI6IF80LCBcImthcmFnYW5kYVwiOiBfNCwgXCJrYXJlbGlhXCI6IF80LCBcImtoYWthc3NpYVwiOiBfNCwgXCJrcmFzbm9kYXJcIjogXzQsIFwia3VyZ2FuXCI6IF80LCBcImt1c3RhbmFpXCI6IF80LCBcImxlbnVnXCI6IF80LCBcIm1hbmd5c2hsYWtcIjogXzQsIFwibW9yZG92aWFcIjogXzQsIFwibXNrXCI6IF80LCBcIm11cm1hbnNrXCI6IF80LCBcIm5hbGNoaWtcIjogXzQsIFwibmF2b2lcIjogXzQsIFwibm9ydGgta2F6YWtoc3RhblwiOiBfNCwgXCJub3ZcIjogXzQsIFwib2JuaW5za1wiOiBfNCwgXCJwZW56YVwiOiBfNCwgXCJwb2tyb3Zza1wiOiBfNCwgXCJzb2NoaVwiOiBfNCwgXCJzcGJcIjogXzQsIFwidGFzaGtlbnRcIjogXzQsIFwidGVybWV6XCI6IF80LCBcInRvZ2xpYXR0aVwiOiBfNCwgXCJ0cm9pdHNrXCI6IF80LCBcInRzZWxpbm9ncmFkXCI6IF80LCBcInR1bGFcIjogXzQsIFwidHV2YVwiOiBfNCwgXCJ2bGFkaWthdmthelwiOiBfNCwgXCJ2bGFkaW1pclwiOiBfNCwgXCJ2b2xvZ2RhXCI6IF80IH1dLCBcInN2XCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb2JcIjogXzMsIFwib3JnXCI6IF8zLCBcInJlZFwiOiBfMyB9XSwgXCJzeFwiOiBfMTAsIFwic3lcIjogXzYsIFwic3pcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJjb1wiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwidGNcIjogXzMsIFwidGRcIjogXzMsIFwidGVsXCI6IF8zLCBcInRmXCI6IFsxLCB7IFwic2NoXCI6IF80IH1dLCBcInRnXCI6IF8zLCBcInRoXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiY29cIjogXzMsIFwiZ29cIjogXzMsIFwiaW5cIjogXzMsIFwibWlcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yXCI6IF8zLCBcIm9ubGluZVwiOiBfNCwgXCJzaG9wXCI6IF80IH1dLCBcInRqXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiYml6XCI6IF8zLCBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ29cIjogXzMsIFwiZ292XCI6IF8zLCBcImludFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwibmljXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ0ZXN0XCI6IF8zLCBcIndlYlwiOiBfMyB9XSwgXCJ0a1wiOiBfMywgXCJ0bFwiOiBfMTAsIFwidG1cIjogWzEsIHsgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm5vbVwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwidG5cIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZW5zXCI6IF8zLCBcImZpblwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaW5kXCI6IF8zLCBcImluZm9cIjogXzMsIFwiaW50bFwiOiBfMywgXCJtaW5jb21cIjogXzMsIFwibmF0XCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicGVyc29cIjogXzMsIFwidG91cmlzbVwiOiBfMywgXCJvcmFuZ2VjbG91ZFwiOiBfNCB9XSwgXCJ0b1wiOiBbMSwgeyBcIjYxMVwiOiBfNCwgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJveWFcIjogXzQsIFwieDBcIjogXzQsIFwicXVpY2tjb25uZWN0XCI6IF8yNCwgXCJ2cG5wbHVzXCI6IF80IH1dLCBcInRyXCI6IFsxLCB7IFwiYXZcIjogXzMsIFwiYmJzXCI6IF8zLCBcImJlbFwiOiBfMywgXCJiaXpcIjogXzMsIFwiY29tXCI6IF8zLCBcImRyXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnZW5cIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwiazEyXCI6IF8zLCBcImtlcFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInBvbFwiOiBfMywgXCJ0ZWxcIjogXzMsIFwidHNrXCI6IF8zLCBcInR2XCI6IF8zLCBcIndlYlwiOiBfMywgXCJuY1wiOiBfMTAgfV0sIFwidHRcIjogWzEsIHsgXCJiaXpcIjogXzMsIFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaW5mb1wiOiBfMywgXCJtaWxcIjogXzMsIFwibmFtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcInByb1wiOiBfMyB9XSwgXCJ0dlwiOiBbMSwgeyBcImJldHRlci10aGFuXCI6IF80LCBcImR5bmRuc1wiOiBfNCwgXCJvbi10aGUtd2ViXCI6IF80LCBcIndvcnNlLXRoYW5cIjogXzQsIFwiZnJvbVwiOiBfNCwgXCJzYWt1cmFcIjogXzQgfV0sIFwidHdcIjogWzEsIHsgXCJjbHViXCI6IF8zLCBcImNvbVwiOiBbMSwgeyBcIm15bWFpbGVyXCI6IF80IH1dLCBcImViaXpcIjogXzMsIFwiZWR1XCI6IF8zLCBcImdhbWVcIjogXzMsIFwiZ292XCI6IF8zLCBcImlkdlwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJ1cmxcIjogXzQsIFwibXlkbnNcIjogXzQgfV0sIFwidHpcIjogWzEsIHsgXCJhY1wiOiBfMywgXCJjb1wiOiBfMywgXCJnb1wiOiBfMywgXCJob3RlbFwiOiBfMywgXCJpbmZvXCI6IF8zLCBcIm1lXCI6IF8zLCBcIm1pbFwiOiBfMywgXCJtb2JpXCI6IF8zLCBcIm5lXCI6IF8zLCBcIm9yXCI6IF8zLCBcInNjXCI6IF8zLCBcInR2XCI6IF8zIH1dLCBcInVhXCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb3ZcIjogXzMsIFwiaW5cIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJjaGVya2Fzc3lcIjogXzMsIFwiY2hlcmthc3lcIjogXzMsIFwiY2hlcm5pZ292XCI6IF8zLCBcImNoZXJuaWhpdlwiOiBfMywgXCJjaGVybml2dHNpXCI6IF8zLCBcImNoZXJub3Z0c3lcIjogXzMsIFwiY2tcIjogXzMsIFwiY25cIjogXzMsIFwiY3JcIjogXzMsIFwiY3JpbWVhXCI6IF8zLCBcImN2XCI6IF8zLCBcImRuXCI6IF8zLCBcImRuZXByb3BldHJvdnNrXCI6IF8zLCBcImRuaXByb3BldHJvdnNrXCI6IF8zLCBcImRvbmV0c2tcIjogXzMsIFwiZHBcIjogXzMsIFwiaWZcIjogXzMsIFwiaXZhbm8tZnJhbmtpdnNrXCI6IF8zLCBcImtoXCI6IF8zLCBcImtoYXJraXZcIjogXzMsIFwia2hhcmtvdlwiOiBfMywgXCJraGVyc29uXCI6IF8zLCBcImtobWVsbml0c2tpeVwiOiBfMywgXCJraG1lbG55dHNreWlcIjogXzMsIFwia2lldlwiOiBfMywgXCJraXJvdm9ncmFkXCI6IF8zLCBcImttXCI6IF8zLCBcImtyXCI6IF8zLCBcImtyb3B5dm55dHNreWlcIjogXzMsIFwia3J5bVwiOiBfMywgXCJrc1wiOiBfMywgXCJrdlwiOiBfMywgXCJreWl2XCI6IF8zLCBcImxnXCI6IF8zLCBcImx0XCI6IF8zLCBcImx1Z2Fuc2tcIjogXzMsIFwibHVoYW5za1wiOiBfMywgXCJsdXRza1wiOiBfMywgXCJsdlwiOiBfMywgXCJsdml2XCI6IF8zLCBcIm1rXCI6IF8zLCBcIm15a29sYWl2XCI6IF8zLCBcIm5pa29sYWV2XCI6IF8zLCBcIm9kXCI6IF8zLCBcIm9kZXNhXCI6IF8zLCBcIm9kZXNzYVwiOiBfMywgXCJwbFwiOiBfMywgXCJwb2x0YXZhXCI6IF8zLCBcInJpdm5lXCI6IF8zLCBcInJvdm5vXCI6IF8zLCBcInJ2XCI6IF8zLCBcInNiXCI6IF8zLCBcInNlYmFzdG9wb2xcIjogXzMsIFwic2V2YXN0b3BvbFwiOiBfMywgXCJzbVwiOiBfMywgXCJzdW15XCI6IF8zLCBcInRlXCI6IF8zLCBcInRlcm5vcGlsXCI6IF8zLCBcInV6XCI6IF8zLCBcInV6aGdvcm9kXCI6IF8zLCBcInV6aGhvcm9kXCI6IF8zLCBcInZpbm5pY2FcIjogXzMsIFwidmlubnl0c2lhXCI6IF8zLCBcInZuXCI6IF8zLCBcInZvbHluXCI6IF8zLCBcInlhbHRhXCI6IF8zLCBcInpha2FycGF0dGlhXCI6IF8zLCBcInphcG9yaXpoemhlXCI6IF8zLCBcInphcG9yaXpoemhpYVwiOiBfMywgXCJ6aGl0b21pclwiOiBfMywgXCJ6aHl0b215clwiOiBfMywgXCJ6cFwiOiBfMywgXCJ6dFwiOiBfMywgXCJjY1wiOiBfNCwgXCJpbmZcIjogXzQsIFwibHRkXCI6IF80LCBcImN4XCI6IF80LCBcImllXCI6IF80LCBcImJpelwiOiBfNCwgXCJjb1wiOiBfNCwgXCJwcFwiOiBfNCwgXCJ2XCI6IF80IH1dLCBcInVnXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJnb1wiOiBfMywgXCJnb3ZcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5lXCI6IF8zLCBcIm9yXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJzY1wiOiBfMywgXCJ1c1wiOiBfMyB9XSwgXCJ1a1wiOiBbMSwgeyBcImFjXCI6IF8zLCBcImNvXCI6IFsxLCB7IFwiYnl0ZW1hcmtcIjogWzAsIHsgXCJkaFwiOiBfNCwgXCJ2bVwiOiBfNCB9XSwgXCJsYXllcnNoaWZ0XCI6IF80NCwgXCJiYXJzeVwiOiBfNCwgXCJiYXJzeW9ubGluZVwiOiBfNCwgXCJyZXRyb3NudWJcIjogXzUxLCBcIm5oLXNlcnZcIjogXzQsIFwibm8taXBcIjogXzQsIFwiYWRpbW9cIjogXzQsIFwibXlzcHJlYWRzaG9wXCI6IF80IH1dLCBcImdvdlwiOiBbMSwgeyBcImFwaVwiOiBfNCwgXCJjYW1wYWlnblwiOiBfNCwgXCJzZXJ2aWNlXCI6IF80IH1dLCBcImx0ZFwiOiBfMywgXCJtZVwiOiBfMywgXCJuZXRcIjogXzMsIFwibmhzXCI6IF8zLCBcIm9yZ1wiOiBbMSwgeyBcImdsdWdcIjogXzQsIFwibHVnXCI6IF80LCBcImx1Z3NcIjogXzQsIFwiYWZmaW5pdHlsb3R0ZXJ5XCI6IF80LCBcInJhZmZsZWVudHJ5XCI6IF80LCBcIndlZWtseWxvdHRlcnlcIjogXzQgfV0sIFwicGxjXCI6IF8zLCBcInBvbGljZVwiOiBfMywgXCJzY2hcIjogXzE3LCBcImNvbm5cIjogXzQsIFwiY29wcm9cIjogXzQsIFwiaG9zcFwiOiBfNCwgXCJpbmRlcGVuZGVudC1jb21taXNzaW9uXCI6IF80LCBcImluZGVwZW5kZW50LWlucXVlc3RcIjogXzQsIFwiaW5kZXBlbmRlbnQtaW5xdWlyeVwiOiBfNCwgXCJpbmRlcGVuZGVudC1wYW5lbFwiOiBfNCwgXCJpbmRlcGVuZGVudC1yZXZpZXdcIjogXzQsIFwicHVibGljLWlucXVpcnlcIjogXzQsIFwicm95YWwtY29tbWlzc2lvblwiOiBfNCwgXCJweW1udFwiOiBfNCwgXCJiYXJzeVwiOiBfNCwgXCJuaW1zaXRlXCI6IF80LCBcIm9yYWNsZWdvdmNsb3VkYXBwc1wiOiBfNyB9XSwgXCJ1c1wiOiBbMSwgeyBcImRuaVwiOiBfMywgXCJpc2FcIjogXzMsIFwibnNuXCI6IF8zLCBcImFrXCI6IF81OSwgXCJhbFwiOiBfNTksIFwiYXJcIjogXzU5LCBcImFzXCI6IF81OSwgXCJhelwiOiBfNTksIFwiY2FcIjogXzU5LCBcImNvXCI6IF81OSwgXCJjdFwiOiBfNTksIFwiZGNcIjogXzU5LCBcImRlXCI6IFsxLCB7IFwiY2NcIjogXzMsIFwibGliXCI6IF80IH1dLCBcImZsXCI6IF81OSwgXCJnYVwiOiBfNTksIFwiZ3VcIjogXzU5LCBcImhpXCI6IF82MCwgXCJpYVwiOiBfNTksIFwiaWRcIjogXzU5LCBcImlsXCI6IF81OSwgXCJpblwiOiBfNTksIFwia3NcIjogXzU5LCBcImt5XCI6IF81OSwgXCJsYVwiOiBfNTksIFwibWFcIjogWzEsIHsgXCJrMTJcIjogWzEsIHsgXCJjaHRyXCI6IF8zLCBcInBhcm9jaFwiOiBfMywgXCJwdnRcIjogXzMgfV0sIFwiY2NcIjogXzMsIFwibGliXCI6IF8zIH1dLCBcIm1kXCI6IF81OSwgXCJtZVwiOiBfNTksIFwibWlcIjogWzEsIHsgXCJrMTJcIjogXzMsIFwiY2NcIjogXzMsIFwibGliXCI6IF8zLCBcImFubi1hcmJvclwiOiBfMywgXCJjb2dcIjogXzMsIFwiZHN0XCI6IF8zLCBcImVhdG9uXCI6IF8zLCBcImdlblwiOiBfMywgXCJtdXNcIjogXzMsIFwidGVjXCI6IF8zLCBcIndhc2h0ZW5hd1wiOiBfMyB9XSwgXCJtblwiOiBfNTksIFwibW9cIjogXzU5LCBcIm1zXCI6IF81OSwgXCJtdFwiOiBfNTksIFwibmNcIjogXzU5LCBcIm5kXCI6IF82MCwgXCJuZVwiOiBfNTksIFwibmhcIjogXzU5LCBcIm5qXCI6IF81OSwgXCJubVwiOiBfNTksIFwibnZcIjogXzU5LCBcIm55XCI6IF81OSwgXCJvaFwiOiBfNTksIFwib2tcIjogXzU5LCBcIm9yXCI6IF81OSwgXCJwYVwiOiBfNTksIFwicHJcIjogXzU5LCBcInJpXCI6IF82MCwgXCJzY1wiOiBfNTksIFwic2RcIjogXzYwLCBcInRuXCI6IF81OSwgXCJ0eFwiOiBfNTksIFwidXRcIjogXzU5LCBcInZhXCI6IF81OSwgXCJ2aVwiOiBfNTksIFwidnRcIjogXzU5LCBcIndhXCI6IF81OSwgXCJ3aVwiOiBfNTksIFwid3ZcIjogWzEsIHsgXCJjY1wiOiBfMyB9XSwgXCJ3eVwiOiBfNTksIFwiY2xvdWRuc1wiOiBfNCwgXCJpcy1ieVwiOiBfNCwgXCJsYW5kLTQtc2FsZVwiOiBfNCwgXCJzdHVmZi00LXNhbGVcIjogXzQsIFwiaGVsaW9ob3N0XCI6IF80LCBcImVuc2NhbGVkXCI6IFswLCB7IFwicGh4XCI6IF80IH1dLCBcIm1pcmNsb3VkXCI6IF80LCBcIm5nb1wiOiBfNCwgXCJnb2xmZmFuXCI6IF80LCBcIm5vaXBcIjogXzQsIFwicG9pbnR0b1wiOiBfNCwgXCJmcmVlZGRuc1wiOiBfNCwgXCJzcnZcIjogWzIsIHsgXCJnaFwiOiBfNCwgXCJnbFwiOiBfNCB9XSwgXCJwbGF0dGVycFwiOiBfNCwgXCJzZXJ2ZXJuYW1lXCI6IF80IH1dLCBcInV5XCI6IFsxLCB7IFwiY29tXCI6IF8zLCBcImVkdVwiOiBfMywgXCJndWJcIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwidXpcIjogWzEsIHsgXCJjb1wiOiBfMywgXCJjb21cIjogXzMsIFwibmV0XCI6IF8zLCBcIm9yZ1wiOiBfMyB9XSwgXCJ2YVwiOiBfMywgXCJ2Y1wiOiBbMSwgeyBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImd2XCI6IFsyLCB7IFwiZFwiOiBfNCB9XSwgXCIwZVwiOiBfNywgXCJteWRuc1wiOiBfNCB9XSwgXCJ2ZVwiOiBbMSwgeyBcImFydHNcIjogXzMsIFwiYmliXCI6IF8zLCBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlMTJcIjogXzMsIFwiZWR1XCI6IF8zLCBcImZpcm1cIjogXzMsIFwiZ29iXCI6IF8zLCBcImdvdlwiOiBfMywgXCJpbmZvXCI6IF8zLCBcImludFwiOiBfMywgXCJtaWxcIjogXzMsIFwibmV0XCI6IF8zLCBcIm5vbVwiOiBfMywgXCJvcmdcIjogXzMsIFwicmFyXCI6IF8zLCBcInJlY1wiOiBfMywgXCJzdG9yZVwiOiBfMywgXCJ0ZWNcIjogXzMsIFwid2ViXCI6IF8zIH1dLCBcInZnXCI6IFsxLCB7IFwiZWR1XCI6IF8zIH1dLCBcInZpXCI6IFsxLCB7IFwiY29cIjogXzMsIFwiY29tXCI6IF8zLCBcImsxMlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zIH1dLCBcInZuXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiYWlcIjogXzMsIFwiYml6XCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImhlYWx0aFwiOiBfMywgXCJpZFwiOiBfMywgXCJpbmZvXCI6IF8zLCBcImludFwiOiBfMywgXCJpb1wiOiBfMywgXCJuYW1lXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwicHJvXCI6IF8zLCBcImFuZ2lhbmdcIjogXzMsIFwiYmFjZ2lhbmdcIjogXzMsIFwiYmFja2FuXCI6IF8zLCBcImJhY2xpZXVcIjogXzMsIFwiYmFjbmluaFwiOiBfMywgXCJiYXJpYS12dW5ndGF1XCI6IF8zLCBcImJlbnRyZVwiOiBfMywgXCJiaW5oZGluaFwiOiBfMywgXCJiaW5oZHVvbmdcIjogXzMsIFwiYmluaHBodW9jXCI6IF8zLCBcImJpbmh0aHVhblwiOiBfMywgXCJjYW1hdVwiOiBfMywgXCJjYW50aG9cIjogXzMsIFwiY2FvYmFuZ1wiOiBfMywgXCJkYWtsYWtcIjogXzMsIFwiZGFrbm9uZ1wiOiBfMywgXCJkYW5hbmdcIjogXzMsIFwiZGllbmJpZW5cIjogXzMsIFwiZG9uZ25haVwiOiBfMywgXCJkb25ndGhhcFwiOiBfMywgXCJnaWFsYWlcIjogXzMsIFwiaGFnaWFuZ1wiOiBfMywgXCJoYWlkdW9uZ1wiOiBfMywgXCJoYWlwaG9uZ1wiOiBfMywgXCJoYW5hbVwiOiBfMywgXCJoYW5vaVwiOiBfMywgXCJoYXRpbmhcIjogXzMsIFwiaGF1Z2lhbmdcIjogXzMsIFwiaG9hYmluaFwiOiBfMywgXCJodW5neWVuXCI6IF8zLCBcImtoYW5oaG9hXCI6IF8zLCBcImtpZW5naWFuZ1wiOiBfMywgXCJrb250dW1cIjogXzMsIFwibGFpY2hhdVwiOiBfMywgXCJsYW1kb25nXCI6IF8zLCBcImxhbmdzb25cIjogXzMsIFwibGFvY2FpXCI6IF8zLCBcImxvbmdhblwiOiBfMywgXCJuYW1kaW5oXCI6IF8zLCBcIm5naGVhblwiOiBfMywgXCJuaW5oYmluaFwiOiBfMywgXCJuaW5odGh1YW5cIjogXzMsIFwicGh1dGhvXCI6IF8zLCBcInBodXllblwiOiBfMywgXCJxdWFuZ2JpbmhcIjogXzMsIFwicXVhbmduYW1cIjogXzMsIFwicXVhbmduZ2FpXCI6IF8zLCBcInF1YW5nbmluaFwiOiBfMywgXCJxdWFuZ3RyaVwiOiBfMywgXCJzb2N0cmFuZ1wiOiBfMywgXCJzb25sYVwiOiBfMywgXCJ0YXluaW5oXCI6IF8zLCBcInRoYWliaW5oXCI6IF8zLCBcInRoYWluZ3V5ZW5cIjogXzMsIFwidGhhbmhob2FcIjogXzMsIFwidGhhbmhwaG9ob2NoaW1pbmhcIjogXzMsIFwidGh1YXRoaWVuaHVlXCI6IF8zLCBcInRpZW5naWFuZ1wiOiBfMywgXCJ0cmF2aW5oXCI6IF8zLCBcInR1eWVucXVhbmdcIjogXzMsIFwidmluaGxvbmdcIjogXzMsIFwidmluaHBodWNcIjogXzMsIFwieWVuYmFpXCI6IF8zIH1dLCBcInZ1XCI6IF80MywgXCJ3ZlwiOiBbMSwgeyBcImJpelwiOiBfNCwgXCJzY2hcIjogXzQgfV0sIFwid3NcIjogWzEsIHsgXCJjb21cIjogXzMsIFwiZWR1XCI6IF8zLCBcImdvdlwiOiBfMywgXCJuZXRcIjogXzMsIFwib3JnXCI6IF8zLCBcImFkdmlzb3JcIjogXzcsIFwiY2xvdWQ2NlwiOiBfNCwgXCJkeW5kbnNcIjogXzQsIFwibXlwZXRzXCI6IF80IH1dLCBcInl0XCI6IFsxLCB7IFwib3JnXCI6IF80IH1dLCBcInhuLS1tZ2JhYW03YThoXCI6IF8zLCBcItin2YXYp9ix2KfYqlwiOiBfMywgXCJ4bi0teTlhM2FxXCI6IF8zLCBcItWw1aHVtVwiOiBfMywgXCJ4bi0tNTRiN2Z0YTBjY1wiOiBfMywgXCLgpqzgpr7gpoLgprLgpr5cIjogXzMsIFwieG4tLTkwYWVcIjogXzMsIFwi0LHQs1wiOiBfMywgXCJ4bi0tbWdiY3BxNmdwYTFhXCI6IF8zLCBcItin2YTYqNit2LHZitmGXCI6IF8zLCBcInhuLS05MGFpc1wiOiBfMywgXCLQsdC10LtcIjogXzMsIFwieG4tLWZpcXM4c1wiOiBfMywgXCLkuK3lm71cIjogXzMsIFwieG4tLWZpcXo5c1wiOiBfMywgXCLkuK3lnItcIjogXzMsIFwieG4tLWxnYmJhdDFhZDhqXCI6IF8zLCBcItin2YTYrNiy2KfYptixXCI6IF8zLCBcInhuLS13Z2JoMWNcIjogXzMsIFwi2YXYtdixXCI6IF8zLCBcInhuLS1lMWE0Y1wiOiBfMywgXCLQtdGOXCI6IF8zLCBcInhuLS1xeGE2YVwiOiBfMywgXCLOtc+FXCI6IF8zLCBcInhuLS1tZ2JhaDFhM2hqa3JkXCI6IF8zLCBcItmF2YjYsdmK2KrYp9mG2YrYp1wiOiBfMywgXCJ4bi0tbm9kZVwiOiBfMywgXCLhg5Lhg5RcIjogXzMsIFwieG4tLXF4YW1cIjogXzMsIFwizrXOu1wiOiBfMywgXCJ4bi0tajZ3MTkzZ1wiOiBbMSwgeyBcInhuLS1nbXF3NWFcIjogXzMsIFwieG4tLTU1cXg1ZFwiOiBfMywgXCJ4bi0tbXh0cTFtXCI6IF8zLCBcInhuLS13Y3ZzMjJkXCI6IF8zLCBcInhuLS11YzBhdHZcIjogXzMsIFwieG4tLW9kMGFsZ1wiOiBfMyB9XSwgXCLpppnmuK9cIjogWzEsIHsgXCLlgIvkurpcIjogXzMsIFwi5YWs5Y+4XCI6IF8zLCBcIuaUv+W6nFwiOiBfMywgXCLmlZnogrJcIjogXzMsIFwi57WE57mUXCI6IF8zLCBcIue2sue1oVwiOiBfMyB9XSwgXCJ4bi0tMnNjcmo5Y1wiOiBfMywgXCLgsq3gsr7gsrDgsqRcIjogXzMsIFwieG4tLTNoY3JqOWNcIjogXzMsIFwi4Kyt4Ky+4Kyw4KykXCI6IF8zLCBcInhuLS00NWJyNWN5bFwiOiBfMywgXCLgpq3gpr7gp7DgpqRcIjogXzMsIFwieG4tLWgyYnJlZzNldmVcIjogXzMsIFwi4KSt4KS+4KSw4KSk4KSu4KWNXCI6IF8zLCBcInhuLS1oMmJyajljOGNcIjogXzMsIFwi4KSt4KS+4KSw4KWL4KSkXCI6IF8zLCBcInhuLS1tZ2JndTgyYVwiOiBfMywgXCLagNin2LHYqlwiOiBfMywgXCJ4bi0tcnZjMWUwYW0zZVwiOiBfMywgXCLgtK3gtL7gtLDgtKTgtIJcIjogXzMsIFwieG4tLWgyYnJqOWNcIjogXzMsIFwi4KSt4KS+4KSw4KSkXCI6IF8zLCBcInhuLS1tZ2JiaDFhXCI6IF8zLCBcItio2KfYsdiqXCI6IF8zLCBcInhuLS1tZ2JiaDFhNzFlXCI6IF8zLCBcItio2r7Yp9ix2KpcIjogXzMsIFwieG4tLWZwY3JqOWMzZFwiOiBfMywgXCLgsK3gsL7gsLDgsKTgsY1cIjogXzMsIFwieG4tLWdlY3JqOWNcIjogXzMsIFwi4Kqt4Kq+4Kqw4KqkXCI6IF8zLCBcInhuLS1zOWJyajljXCI6IF8zLCBcIuCoreCovuCosOCopFwiOiBfMywgXCJ4bi0tNDVicmo5Y1wiOiBfMywgXCLgpq3gpr7gprDgpqRcIjogXzMsIFwieG4tLXhrYzJkbDNhNWVlMGhcIjogXzMsIFwi4K6H4K6o4K+N4K6k4K6/4K6v4K6+XCI6IF8zLCBcInhuLS1tZ2JhM2E0ZjE2YVwiOiBfMywgXCLYp9uM2LHYp9mGXCI6IF8zLCBcInhuLS1tZ2JhM2E0ZnJhXCI6IF8zLCBcItin2YrYsdin2YZcIjogXzMsIFwieG4tLW1nYnR4MmJcIjogXzMsIFwi2LnYsdin2YJcIjogXzMsIFwieG4tLW1nYmF5aDdncGFcIjogXzMsIFwi2KfZhNin2LHYr9mGXCI6IF8zLCBcInhuLS0zZTBiNzA3ZVwiOiBfMywgXCLtlZzqta1cIjogXzMsIFwieG4tLTgwYW8yMWFcIjogXzMsIFwi0pvQsNC3XCI6IF8zLCBcInhuLS1xN2NlNmFcIjogXzMsIFwi4Lql4Lqy4LqnXCI6IF8zLCBcInhuLS1memMyYzllMmNcIjogXzMsIFwi4La94LaC4Laa4LePXCI6IF8zLCBcInhuLS14a2MyYWwzaHllMmFcIjogXzMsIFwi4K6H4K6y4K6Z4K+N4K6V4K+IXCI6IF8zLCBcInhuLS1tZ2JjMGE5YXpjZ1wiOiBfMywgXCLYp9mE2YXYutix2KhcIjogXzMsIFwieG4tLWQxYWxmXCI6IF8zLCBcItC80LrQtFwiOiBfMywgXCJ4bi0tbDFhY2NcIjogXzMsIFwi0LzQvtC9XCI6IF8zLCBcInhuLS1taXg4OTFmXCI6IF8zLCBcIua+s+mWgFwiOiBfMywgXCJ4bi0tbWl4MDgyZlwiOiBfMywgXCLmvrPpl6hcIjogXzMsIFwieG4tLW1nYng0Y2QwYWJcIjogXzMsIFwi2YXZhNmK2LPZitinXCI6IF8zLCBcInhuLS1tZ2I5YXdiZlwiOiBfMywgXCLYudmF2KfZhlwiOiBfMywgXCJ4bi0tbWdiYWk5YXpncXA2alwiOiBfMywgXCLZvtin2qnYs9iq2KfZhlwiOiBfMywgXCJ4bi0tbWdiYWk5YTVldmEwMGJcIjogXzMsIFwi2b7Yp9mD2LPYqtin2YZcIjogXzMsIFwieG4tLXlnYmkyYW1teFwiOiBfMywgXCLZgdmE2LPYt9mK2YZcIjogXzMsIFwieG4tLTkwYTNhY1wiOiBbMSwgeyBcInhuLS04MGF1XCI6IF8zLCBcInhuLS05MGF6aFwiOiBfMywgXCJ4bi0tZDFhdFwiOiBfMywgXCJ4bi0tYzFhdmdcIjogXzMsIFwieG4tLW8xYWNcIjogXzMsIFwieG4tLW8xYWNoXCI6IF8zIH1dLCBcItGB0YDQsVwiOiBbMSwgeyBcItCw0LpcIjogXzMsIFwi0L7QsdGAXCI6IF8zLCBcItC+0LRcIjogXzMsIFwi0L7RgNCzXCI6IF8zLCBcItC/0YBcIjogXzMsIFwi0YPQv9GAXCI6IF8zIH1dLCBcInhuLS1wMWFpXCI6IF8zLCBcItGA0YRcIjogXzMsIFwieG4tLXdnYmw2YVwiOiBfMywgXCLZgti32LFcIjogXzMsIFwieG4tLW1nYmVycDRhNWQ0YXJcIjogXzMsIFwi2KfZhNiz2LnZiNiv2YrYqVwiOiBfMywgXCJ4bi0tbWdiZXJwNGE1ZDRhODdnXCI6IF8zLCBcItin2YTYs9i52YjYr9uM2KlcIjogXzMsIFwieG4tLW1nYnFseTdjMGE2N2ZiY1wiOiBfMywgXCLYp9mE2LPYudmI2K/bjNuDXCI6IF8zLCBcInhuLS1tZ2JxbHk3Y3ZhZnJcIjogXzMsIFwi2KfZhNiz2LnZiNiv2YrZh1wiOiBfMywgXCJ4bi0tbWdicGwyZmhcIjogXzMsIFwi2LPZiNiv2KfZhlwiOiBfMywgXCJ4bi0teWZybzRpNjdvXCI6IF8zLCBcIuaWsOWKoOWdoVwiOiBfMywgXCJ4bi0tY2xjaGMwZWEwYjJnMmE5Z2NkXCI6IF8zLCBcIuCumuCuv+CumeCvjeCuleCuquCvjeCuquCvguCusOCvjVwiOiBfMywgXCJ4bi0tb2dicGY4ZmxcIjogXzMsIFwi2LPZiNix2YrYqVwiOiBfMywgXCJ4bi0tbWdidGY4ZmxcIjogXzMsIFwi2LPZiNix2YrYp1wiOiBfMywgXCJ4bi0tbzNjdzRoXCI6IFsxLCB7IFwieG4tLW8zY3l4MmFcIjogXzMsIFwieG4tLTEyY28wYzNiNGV2YVwiOiBfMywgXCJ4bi0tbTNjaDBqM2FcIjogXzMsIFwieG4tLWgzY3V6azFkaVwiOiBfMywgXCJ4bi0tMTJjMWZlMGJyXCI6IF8zLCBcInhuLS0xMmNmaThpeGI4bFwiOiBfMyB9XSwgXCLguYTguJfguKJcIjogWzEsIHsgXCLguJfguKvguLLguKNcIjogXzMsIFwi4LiY4Li44Lij4LiB4Li04LiIXCI6IF8zLCBcIuC5gOC4meC5h+C4lVwiOiBfMywgXCLguKPguLHguJDguJrguLLguKVcIjogXzMsIFwi4Lio4Li24LiB4Lip4LiyXCI6IF8zLCBcIuC4reC4h+C4hOC5jOC4geC4o1wiOiBfMyB9XSwgXCJ4bi0tcGdiczBkaFwiOiBfMywgXCLYqtmI2YbYs1wiOiBfMywgXCJ4bi0ta3ByeTU3ZFwiOiBfMywgXCLlj7DngaNcIjogXzMsIFwieG4tLWtwcncxM2RcIjogXzMsIFwi5Y+w5rm+XCI6IF8zLCBcInhuLS1ubngzODhhXCI6IF8zLCBcIuiHuueBo1wiOiBfMywgXCJ4bi0tajFhbWhcIjogXzMsIFwi0YPQutGAXCI6IF8zLCBcInhuLS1tZ2IyZGRlc1wiOiBfMywgXCLYp9mE2YrZhdmGXCI6IF8zLCBcInh4eFwiOiBfMywgXCJ5ZVwiOiBfNiwgXCJ6YVwiOiBbMCwgeyBcImFjXCI6IF8zLCBcImFncmljXCI6IF8zLCBcImFsdFwiOiBfMywgXCJjb1wiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImdyb25kYXJcIjogXzMsIFwibGF3XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJuZXRcIjogXzMsIFwibmdvXCI6IF8zLCBcIm5pY1wiOiBfMywgXCJuaXNcIjogXzMsIFwibm9tXCI6IF8zLCBcIm9yZ1wiOiBfMywgXCJzY2hvb2xcIjogXzMsIFwidG1cIjogXzMsIFwid2ViXCI6IF8zIH1dLCBcInptXCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiYml6XCI6IF8zLCBcImNvXCI6IF8zLCBcImNvbVwiOiBfMywgXCJlZHVcIjogXzMsIFwiZ292XCI6IF8zLCBcImluZm9cIjogXzMsIFwibWlsXCI6IF8zLCBcIm5ldFwiOiBfMywgXCJvcmdcIjogXzMsIFwic2NoXCI6IF8zIH1dLCBcInp3XCI6IFsxLCB7IFwiYWNcIjogXzMsIFwiY29cIjogXzMsIFwiZ292XCI6IF8zLCBcIm1pbFwiOiBfMywgXCJvcmdcIjogXzMgfV0sIFwiYWFhXCI6IF8zLCBcImFhcnBcIjogXzMsIFwiYWJiXCI6IF8zLCBcImFiYm90dFwiOiBfMywgXCJhYmJ2aWVcIjogXzMsIFwiYWJjXCI6IF8zLCBcImFibGVcIjogXzMsIFwiYWJvZ2Fkb1wiOiBfMywgXCJhYnVkaGFiaVwiOiBfMywgXCJhY2FkZW15XCI6IFsxLCB7IFwib2ZmaWNpYWxcIjogXzQgfV0sIFwiYWNjZW50dXJlXCI6IF8zLCBcImFjY291bnRhbnRcIjogXzMsIFwiYWNjb3VudGFudHNcIjogXzMsIFwiYWNvXCI6IF8zLCBcImFjdG9yXCI6IF8zLCBcImFkc1wiOiBfMywgXCJhZHVsdFwiOiBfMywgXCJhZWdcIjogXzMsIFwiYWV0bmFcIjogXzMsIFwiYWZsXCI6IF8zLCBcImFmcmljYVwiOiBfMywgXCJhZ2FraGFuXCI6IF8zLCBcImFnZW5jeVwiOiBfMywgXCJhaWdcIjogXzMsIFwiYWlyYnVzXCI6IF8zLCBcImFpcmZvcmNlXCI6IF8zLCBcImFpcnRlbFwiOiBfMywgXCJha2RuXCI6IF8zLCBcImFsaWJhYmFcIjogXzMsIFwiYWxpcGF5XCI6IF8zLCBcImFsbGZpbmFuelwiOiBfMywgXCJhbGxzdGF0ZVwiOiBfMywgXCJhbGx5XCI6IF8zLCBcImFsc2FjZVwiOiBfMywgXCJhbHN0b21cIjogXzMsIFwiYW1hem9uXCI6IF8zLCBcImFtZXJpY2FuZXhwcmVzc1wiOiBfMywgXCJhbWVyaWNhbmZhbWlseVwiOiBfMywgXCJhbWV4XCI6IF8zLCBcImFtZmFtXCI6IF8zLCBcImFtaWNhXCI6IF8zLCBcImFtc3RlcmRhbVwiOiBfMywgXCJhbmFseXRpY3NcIjogXzMsIFwiYW5kcm9pZFwiOiBfMywgXCJhbnF1YW5cIjogXzMsIFwiYW56XCI6IF8zLCBcImFvbFwiOiBfMywgXCJhcGFydG1lbnRzXCI6IF8zLCBcImFwcFwiOiBbMSwgeyBcImFkYXB0YWJsZVwiOiBfNCwgXCJhaXZlblwiOiBfNCwgXCJiZWdldFwiOiBfNywgXCJjbGVya1wiOiBfNCwgXCJjbGVya3N0YWdlXCI6IF80LCBcInduZXh0XCI6IF80LCBcImNzYlwiOiBbMiwgeyBcInByZXZpZXdcIjogXzQgfV0sIFwiZGV0YVwiOiBfNCwgXCJvbmRpZ2l0YWxvY2VhblwiOiBfNCwgXCJlYXN5cGFuZWxcIjogXzQsIFwiZW5jclwiOiBfNCwgXCJldmVydmF1bHRcIjogXzgsIFwiZXhwb1wiOiBbMiwgeyBcInN0YWdpbmdcIjogXzQgfV0sIFwiZWRnZWNvbXB1dGVcIjogXzQsIFwib24tZmxlZWtcIjogXzQsIFwiZmx1dHRlcmZsb3dcIjogXzQsIFwiZnJhbWVyXCI6IF80LCBcImhvc3RlZFwiOiBfNywgXCJydW5cIjogXzcsIFwid2ViXCI6IF80LCBcImhhc3VyYVwiOiBfNCwgXCJib3RkYXNoXCI6IF80LCBcImxvZ2lubGluZVwiOiBfNCwgXCJtZWR1c2Fqc1wiOiBfNCwgXCJtZXNzZXJsaVwiOiBfNCwgXCJuZXRmeVwiOiBfNCwgXCJuZXRsaWZ5XCI6IF80LCBcIm5ncm9rXCI6IF80LCBcIm5ncm9rLWZyZWVcIjogXzQsIFwiZGV2ZWxvcGVyXCI6IF83LCBcIm5vb3BcIjogXzQsIFwibm9ydGhmbGFua1wiOiBfNywgXCJ1cHN1blwiOiBfNywgXCJyZXBsaXRcIjogXzksIFwibnlhdFwiOiBfNCwgXCJzbm93Zmxha2VcIjogWzAsIHsgXCIqXCI6IF80LCBcInByaXZhdGVsaW5rXCI6IF83IH1dLCBcInN0cmVhbWxpdFwiOiBfNCwgXCJzdG9yaXByZXNzXCI6IF80LCBcInRlbGViaXRcIjogXzQsIFwidHlwZWRyZWFtXCI6IF80LCBcInZlcmNlbFwiOiBfNCwgXCJib29rb25saW5lXCI6IF80LCBcIndkaFwiOiBfNCwgXCJ6ZWFidXJcIjogXzQgfV0sIFwiYXBwbGVcIjogXzMsIFwiYXF1YXJlbGxlXCI6IF8zLCBcImFyYWJcIjogXzMsIFwiYXJhbWNvXCI6IF8zLCBcImFyY2hpXCI6IF8zLCBcImFybXlcIjogXzMsIFwiYXJ0XCI6IF8zLCBcImFydGVcIjogXzMsIFwiYXNkYVwiOiBfMywgXCJhc3NvY2lhdGVzXCI6IF8zLCBcImF0aGxldGFcIjogXzMsIFwiYXR0b3JuZXlcIjogXzMsIFwiYXVjdGlvblwiOiBfMywgXCJhdWRpXCI6IF8zLCBcImF1ZGlibGVcIjogXzMsIFwiYXVkaW9cIjogXzMsIFwiYXVzcG9zdFwiOiBfMywgXCJhdXRob3JcIjogXzMsIFwiYXV0b1wiOiBfMywgXCJhdXRvc1wiOiBfMywgXCJhd3NcIjogWzEsIHsgXCJzYWdlbWFrZXJcIjogWzAsIHsgXCJhcC1ub3J0aGVhc3QtMVwiOiBfMTMsIFwiYXAtbm9ydGhlYXN0LTJcIjogXzEzLCBcImFwLXNvdXRoLTFcIjogXzEzLCBcImFwLXNvdXRoZWFzdC0xXCI6IF8xMywgXCJhcC1zb3V0aGVhc3QtMlwiOiBfMTMsIFwiY2EtY2VudHJhbC0xXCI6IF8xNSwgXCJldS1jZW50cmFsLTFcIjogXzEzLCBcImV1LXdlc3QtMVwiOiBfMTMsIFwiZXUtd2VzdC0yXCI6IF8xMywgXCJ1cy1lYXN0LTFcIjogXzE1LCBcInVzLWVhc3QtMlwiOiBfMTUsIFwidXMtd2VzdC0yXCI6IF8xNSwgXCJhZi1zb3V0aC0xXCI6IF8xMiwgXCJhcC1lYXN0LTFcIjogXzEyLCBcImFwLW5vcnRoZWFzdC0zXCI6IF8xMiwgXCJhcC1zb3V0aC0yXCI6IF8xNCwgXCJhcC1zb3V0aGVhc3QtM1wiOiBfMTIsIFwiYXAtc291dGhlYXN0LTRcIjogXzE0LCBcImNhLXdlc3QtMVwiOiBbMCwgeyBcIm5vdGVib29rXCI6IF80LCBcIm5vdGVib29rLWZpcHNcIjogXzQgfV0sIFwiZXUtY2VudHJhbC0yXCI6IF8xMiwgXCJldS1ub3J0aC0xXCI6IF8xMiwgXCJldS1zb3V0aC0xXCI6IF8xMiwgXCJldS1zb3V0aC0yXCI6IF8xMiwgXCJldS13ZXN0LTNcIjogXzEyLCBcImlsLWNlbnRyYWwtMVwiOiBfMTIsIFwibWUtY2VudHJhbC0xXCI6IF8xMiwgXCJtZS1zb3V0aC0xXCI6IF8xMiwgXCJzYS1lYXN0LTFcIjogXzEyLCBcInVzLWdvdi1lYXN0LTFcIjogXzE2LCBcInVzLWdvdi13ZXN0LTFcIjogXzE2LCBcInVzLXdlc3QtMVwiOiBbMCwgeyBcIm5vdGVib29rXCI6IF80LCBcIm5vdGVib29rLWZpcHNcIjogXzQsIFwic3R1ZGlvXCI6IF80IH1dLCBcImV4cGVyaW1lbnRzXCI6IF83IH1dLCBcInJlcG9zdFwiOiBbMCwgeyBcInByaXZhdGVcIjogXzcgfV0sIFwib25cIjogWzAsIHsgXCJhcC1ub3J0aGVhc3QtMVwiOiBfMTEsIFwiYXAtc291dGhlYXN0LTFcIjogXzExLCBcImFwLXNvdXRoZWFzdC0yXCI6IF8xMSwgXCJldS1jZW50cmFsLTFcIjogXzExLCBcImV1LW5vcnRoLTFcIjogXzExLCBcImV1LXdlc3QtMVwiOiBfMTEsIFwidXMtZWFzdC0xXCI6IF8xMSwgXCJ1cy1lYXN0LTJcIjogXzExLCBcInVzLXdlc3QtMlwiOiBfMTEgfV0gfV0sIFwiYXhhXCI6IF8zLCBcImF6dXJlXCI6IF8zLCBcImJhYnlcIjogXzMsIFwiYmFpZHVcIjogXzMsIFwiYmFuYW1leFwiOiBfMywgXCJiYW5kXCI6IF8zLCBcImJhbmtcIjogXzMsIFwiYmFyXCI6IF8zLCBcImJhcmNlbG9uYVwiOiBfMywgXCJiYXJjbGF5Y2FyZFwiOiBfMywgXCJiYXJjbGF5c1wiOiBfMywgXCJiYXJlZm9vdFwiOiBfMywgXCJiYXJnYWluc1wiOiBfMywgXCJiYXNlYmFsbFwiOiBfMywgXCJiYXNrZXRiYWxsXCI6IFsxLCB7IFwiYXVzXCI6IF80LCBcIm56XCI6IF80IH1dLCBcImJhdWhhdXNcIjogXzMsIFwiYmF5ZXJuXCI6IF8zLCBcImJiY1wiOiBfMywgXCJiYnRcIjogXzMsIFwiYmJ2YVwiOiBfMywgXCJiY2dcIjogXzMsIFwiYmNuXCI6IF8zLCBcImJlYXRzXCI6IF8zLCBcImJlYXV0eVwiOiBfMywgXCJiZWVyXCI6IF8zLCBcImJlbnRsZXlcIjogXzMsIFwiYmVybGluXCI6IF8zLCBcImJlc3RcIjogXzMsIFwiYmVzdGJ1eVwiOiBfMywgXCJiZXRcIjogXzMsIFwiYmhhcnRpXCI6IF8zLCBcImJpYmxlXCI6IF8zLCBcImJpZFwiOiBfMywgXCJiaWtlXCI6IF8zLCBcImJpbmdcIjogXzMsIFwiYmluZ29cIjogXzMsIFwiYmlvXCI6IF8zLCBcImJsYWNrXCI6IF8zLCBcImJsYWNrZnJpZGF5XCI6IF8zLCBcImJsb2NrYnVzdGVyXCI6IF8zLCBcImJsb2dcIjogXzMsIFwiYmxvb21iZXJnXCI6IF8zLCBcImJsdWVcIjogXzMsIFwiYm1zXCI6IF8zLCBcImJtd1wiOiBfMywgXCJibnBwYXJpYmFzXCI6IF8zLCBcImJvYXRzXCI6IF8zLCBcImJvZWhyaW5nZXJcIjogXzMsIFwiYm9mYVwiOiBfMywgXCJib21cIjogXzMsIFwiYm9uZFwiOiBfMywgXCJib29cIjogXzMsIFwiYm9va1wiOiBfMywgXCJib29raW5nXCI6IF8zLCBcImJvc2NoXCI6IF8zLCBcImJvc3Rpa1wiOiBfMywgXCJib3N0b25cIjogXzMsIFwiYm90XCI6IF8zLCBcImJvdXRpcXVlXCI6IF8zLCBcImJveFwiOiBfMywgXCJicmFkZXNjb1wiOiBfMywgXCJicmlkZ2VzdG9uZVwiOiBfMywgXCJicm9hZHdheVwiOiBfMywgXCJicm9rZXJcIjogXzMsIFwiYnJvdGhlclwiOiBfMywgXCJicnVzc2Vsc1wiOiBfMywgXCJidWlsZFwiOiBbMSwgeyBcInYwXCI6IF80IH1dLCBcImJ1aWxkZXJzXCI6IFsxLCB7IFwiY2xvdWRzaXRlXCI6IF80IH1dLCBcImJ1c2luZXNzXCI6IF8xOCwgXCJidXlcIjogXzMsIFwiYnV6elwiOiBfMywgXCJiemhcIjogXzMsIFwiY2FiXCI6IF8zLCBcImNhZmVcIjogXzMsIFwiY2FsXCI6IF8zLCBcImNhbGxcIjogXzMsIFwiY2Fsdmlua2xlaW5cIjogXzMsIFwiY2FtXCI6IF8zLCBcImNhbWVyYVwiOiBfMywgXCJjYW1wXCI6IFsxLCB7IFwiZW1mXCI6IFswLCB7IFwiYXRcIjogXzQgfV0gfV0sIFwiY2Fub25cIjogXzMsIFwiY2FwZXRvd25cIjogXzMsIFwiY2FwaXRhbFwiOiBfMywgXCJjYXBpdGFsb25lXCI6IF8zLCBcImNhclwiOiBfMywgXCJjYXJhdmFuXCI6IF8zLCBcImNhcmRzXCI6IF8zLCBcImNhcmVcIjogXzMsIFwiY2FyZWVyXCI6IF8zLCBcImNhcmVlcnNcIjogXzMsIFwiY2Fyc1wiOiBfMywgXCJjYXNhXCI6IFsxLCB7IFwibmFidVwiOiBbMCwgeyBcInVpXCI6IF80IH1dIH1dLCBcImNhc2VcIjogXzMsIFwiY2FzaFwiOiBfMywgXCJjYXNpbm9cIjogXzMsIFwiY2F0ZXJpbmdcIjogXzMsIFwiY2F0aG9saWNcIjogXzMsIFwiY2JhXCI6IF8zLCBcImNiblwiOiBfMywgXCJjYnJlXCI6IF8zLCBcImNlbnRlclwiOiBfMywgXCJjZW9cIjogXzMsIFwiY2VyblwiOiBfMywgXCJjZmFcIjogXzMsIFwiY2ZkXCI6IF8zLCBcImNoYW5lbFwiOiBfMywgXCJjaGFubmVsXCI6IF8zLCBcImNoYXJpdHlcIjogXzMsIFwiY2hhc2VcIjogXzMsIFwiY2hhdFwiOiBfMywgXCJjaGVhcFwiOiBfMywgXCJjaGludGFpXCI6IF8zLCBcImNocmlzdG1hc1wiOiBfMywgXCJjaHJvbWVcIjogXzMsIFwiY2h1cmNoXCI6IF8zLCBcImNpcHJpYW5pXCI6IF8zLCBcImNpcmNsZVwiOiBfMywgXCJjaXNjb1wiOiBfMywgXCJjaXRhZGVsXCI6IF8zLCBcImNpdGlcIjogXzMsIFwiY2l0aWNcIjogXzMsIFwiY2l0eVwiOiBfMywgXCJjbGFpbXNcIjogXzMsIFwiY2xlYW5pbmdcIjogXzMsIFwiY2xpY2tcIjogXzMsIFwiY2xpbmljXCI6IF8zLCBcImNsaW5pcXVlXCI6IF8zLCBcImNsb3RoaW5nXCI6IF8zLCBcImNsb3VkXCI6IFsxLCB7IFwiZWxlbWVudG9yXCI6IF80LCBcImVuY293YXlcIjogWzAsIHsgXCJldVwiOiBfNCB9XSwgXCJzdGF0aWNzXCI6IF83LCBcInJhdmVuZGJcIjogXzQsIFwiYXhhcm5ldFwiOiBbMCwgeyBcImVzLTFcIjogXzQgfV0sIFwiZGlhZGVtXCI6IF80LCBcImplbGFzdGljXCI6IFswLCB7IFwidmlwXCI6IF80IH1dLCBcImplbGVcIjogXzQsIFwiamVudi1hcnViYVwiOiBbMCwgeyBcImFydWJhXCI6IFswLCB7IFwiZXVyXCI6IFswLCB7IFwiaXQxXCI6IF80IH1dIH1dLCBcIml0MVwiOiBfNCB9XSwgXCJrZWxpd2ViXCI6IFsyLCB7IFwiY3NcIjogXzQgfV0sIFwib3hhXCI6IFsyLCB7IFwidG5cIjogXzQsIFwidWtcIjogXzQgfV0sIFwicHJpbWV0ZWxcIjogWzIsIHsgXCJ1a1wiOiBfNCB9XSwgXCJyZWNsYWltXCI6IFswLCB7IFwiY2FcIjogXzQsIFwidWtcIjogXzQsIFwidXNcIjogXzQgfV0sIFwidHJlbmRob3N0aW5nXCI6IFswLCB7IFwiY2hcIjogXzQsIFwiZGVcIjogXzQgfV0sIFwiam90ZWx1bHVcIjogXzQsIFwia3VsZXV2ZW5cIjogXzQsIFwibGlua3lhcmRcIjogXzQsIFwibWFnZW50b3NpdGVcIjogXzcsIFwibWF0bGFiXCI6IF80LCBcIm9ic2VydmFibGVocVwiOiBfNCwgXCJwZXJzcGVjdGFcIjogXzQsIFwidmFwb3JcIjogXzQsIFwib24tcmFuY2hlclwiOiBfNywgXCJzY3dcIjogWzAsIHsgXCJiYXJlbWV0YWxcIjogWzAsIHsgXCJmci1wYXItMVwiOiBfNCwgXCJmci1wYXItMlwiOiBfNCwgXCJubC1hbXMtMVwiOiBfNCB9XSwgXCJmci1wYXJcIjogWzAsIHsgXCJjb2NrcGl0XCI6IF80LCBcImZuY1wiOiBbMiwgeyBcImZ1bmN0aW9uc1wiOiBfNCB9XSwgXCJrOHNcIjogXzIwLCBcInMzXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQsIFwid2htXCI6IF80IH1dLCBcImluc3RhbmNlc1wiOiBbMCwgeyBcInByaXZcIjogXzQsIFwicHViXCI6IF80IH1dLCBcIms4c1wiOiBfNCwgXCJubC1hbXNcIjogWzAsIHsgXCJjb2NrcGl0XCI6IF80LCBcIms4c1wiOiBfMjAsIFwiczNcIjogXzQsIFwiczMtd2Vic2l0ZVwiOiBfNCwgXCJ3aG1cIjogXzQgfV0sIFwicGwtd2F3XCI6IFswLCB7IFwiY29ja3BpdFwiOiBfNCwgXCJrOHNcIjogXzIwLCBcInMzXCI6IF80LCBcInMzLXdlYnNpdGVcIjogXzQgfV0sIFwic2NhbGVib29rXCI6IF80LCBcInNtYXJ0bGFiZWxpbmdcIjogXzQgfV0sIFwic2VydmVib2x0XCI6IF80LCBcIm9uc3RhY2tpdFwiOiBbMCwgeyBcInJ1bnNcIjogXzQgfV0sIFwidHJhZmZpY3BsZXhcIjogXzQsIFwidW5pc29uLXNlcnZpY2VzXCI6IF80LCBcInVyb3duXCI6IF80LCBcInZvb3Jsb3BlclwiOiBfNCwgXCJ6YXBcIjogXzQgfV0sIFwiY2x1YlwiOiBbMSwgeyBcImNsb3VkbnNcIjogXzQsIFwiamVsZVwiOiBfNCwgXCJiYXJzeVwiOiBfNCB9XSwgXCJjbHVibWVkXCI6IF8zLCBcImNvYWNoXCI6IF8zLCBcImNvZGVzXCI6IFsxLCB7IFwib3dvXCI6IF83IH1dLCBcImNvZmZlZVwiOiBfMywgXCJjb2xsZWdlXCI6IF8zLCBcImNvbG9nbmVcIjogXzMsIFwiY29tbWJhbmtcIjogXzMsIFwiY29tbXVuaXR5XCI6IFsxLCB7IFwibm9nXCI6IF80LCBcInJhdmVuZGJcIjogXzQsIFwibXlmb3J1bVwiOiBfNCB9XSwgXCJjb21wYW55XCI6IF8zLCBcImNvbXBhcmVcIjogXzMsIFwiY29tcHV0ZXJcIjogXzMsIFwiY29tc2VjXCI6IF8zLCBcImNvbmRvc1wiOiBfMywgXCJjb25zdHJ1Y3Rpb25cIjogXzMsIFwiY29uc3VsdGluZ1wiOiBfMywgXCJjb250YWN0XCI6IF8zLCBcImNvbnRyYWN0b3JzXCI6IF8zLCBcImNvb2tpbmdcIjogXzMsIFwiY29vbFwiOiBbMSwgeyBcImVsZW1lbnRvclwiOiBfNCwgXCJkZVwiOiBfNCB9XSwgXCJjb3JzaWNhXCI6IF8zLCBcImNvdW50cnlcIjogXzMsIFwiY291cG9uXCI6IF8zLCBcImNvdXBvbnNcIjogXzMsIFwiY291cnNlc1wiOiBfMywgXCJjcGFcIjogXzMsIFwiY3JlZGl0XCI6IF8zLCBcImNyZWRpdGNhcmRcIjogXzMsIFwiY3JlZGl0dW5pb25cIjogXzMsIFwiY3JpY2tldFwiOiBfMywgXCJjcm93blwiOiBfMywgXCJjcnNcIjogXzMsIFwiY3J1aXNlXCI6IF8zLCBcImNydWlzZXNcIjogXzMsIFwiY3Vpc2luZWxsYVwiOiBfMywgXCJjeW1ydVwiOiBfMywgXCJjeW91XCI6IF8zLCBcImRhZFwiOiBfMywgXCJkYW5jZVwiOiBfMywgXCJkYXRhXCI6IF8zLCBcImRhdGVcIjogXzMsIFwiZGF0aW5nXCI6IF8zLCBcImRhdHN1blwiOiBfMywgXCJkYXlcIjogXzMsIFwiZGNsa1wiOiBfMywgXCJkZHNcIjogXzMsIFwiZGVhbFwiOiBfMywgXCJkZWFsZXJcIjogXzMsIFwiZGVhbHNcIjogXzMsIFwiZGVncmVlXCI6IF8zLCBcImRlbGl2ZXJ5XCI6IF8zLCBcImRlbGxcIjogXzMsIFwiZGVsb2l0dGVcIjogXzMsIFwiZGVsdGFcIjogXzMsIFwiZGVtb2NyYXRcIjogXzMsIFwiZGVudGFsXCI6IF8zLCBcImRlbnRpc3RcIjogXzMsIFwiZGVzaVwiOiBfMywgXCJkZXNpZ25cIjogWzEsIHsgXCJncmFwaGljXCI6IF80LCBcImJzc1wiOiBfNCB9XSwgXCJkZXZcIjogWzEsIHsgXCIxMmNoYXJzXCI6IF80LCBcIm15YWRkclwiOiBfNCwgXCJwYW5lbFwiOiBfNCwgXCJsY2xcIjogXzcsIFwibGNsc3RhZ2VcIjogXzcsIFwic3RnXCI6IF83LCBcInN0Z3N0YWdlXCI6IF83LCBcInBhZ2VzXCI6IF80LCBcInIyXCI6IF80LCBcIndvcmtlcnNcIjogXzQsIFwiZGVub1wiOiBfNCwgXCJkZW5vLXN0YWdpbmdcIjogXzQsIFwiZGV0YVwiOiBfNCwgXCJldmVydmF1bHRcIjogXzgsIFwiZmx5XCI6IF80LCBcImdpdGh1YnByZXZpZXdcIjogXzQsIFwiZ2F0ZXdheVwiOiBfNywgXCJocnNuXCI6IFsyLCB7IFwicHNsXCI6IFswLCB7IFwic3ViXCI6IF80LCBcIndjXCI6IFswLCB7IFwiKlwiOiBfNCwgXCJzdWJcIjogXzcgfV0gfV0gfV0sIFwiYm90ZGFzaFwiOiBfNCwgXCJpcy1hLWdvb2RcIjogXzQsIFwiaXMtYVwiOiBfNCwgXCJpc2VydlwiOiBfNCwgXCJydW5jb250YWluZXJzXCI6IF80LCBcImxvY2FsY2VydFwiOiBbMCwgeyBcInVzZXJcIjogXzcgfV0sIFwibG9naW5saW5lXCI6IF80LCBcImJhcnN5XCI6IF80LCBcIm1lZGlhdGVjaFwiOiBfNCwgXCJtb2R4XCI6IF80LCBcIm5ncm9rXCI6IF80LCBcIm5ncm9rLWZyZWVcIjogXzQsIFwiaXMtYS1mdWxsc3RhY2tcIjogXzQsIFwiaXMtY29vbFwiOiBfNCwgXCJpcy1ub3QtYVwiOiBfNCwgXCJsb2NhbHBsYXllclwiOiBfNCwgXCJ4bWl0XCI6IF80LCBcInBsYXR0ZXItYXBwXCI6IF80LCBcInJlcGxpdFwiOiBbMiwgeyBcImFyY2hlclwiOiBfNCwgXCJib25lc1wiOiBfNCwgXCJjYW5hcnlcIjogXzQsIFwiZ2xvYmFsXCI6IF80LCBcImhhY2tlclwiOiBfNCwgXCJpZFwiOiBfNCwgXCJqYW5ld2F5XCI6IF80LCBcImtpbVwiOiBfNCwgXCJraXJhXCI6IF80LCBcImtpcmtcIjogXzQsIFwib2RvXCI6IF80LCBcInBhcmlzXCI6IF80LCBcInBpY2FyZFwiOiBfNCwgXCJwaWtlXCI6IF80LCBcInByZXJlbGVhc2VcIjogXzQsIFwicmVlZFwiOiBfNCwgXCJyaWtlclwiOiBfNCwgXCJzaXNrb1wiOiBfNCwgXCJzcG9ja1wiOiBfNCwgXCJzdGFnaW5nXCI6IF80LCBcInN1bHVcIjogXzQsIFwidGFycGl0XCI6IF80LCBcInRlYW1zXCI6IF80LCBcInR1Y2tlclwiOiBfNCwgXCJ3ZXNsZXlcIjogXzQsIFwid29yZlwiOiBfNCB9XSwgXCJjcm1cIjogWzAsIHsgXCJkXCI6IF83LCBcIndcIjogXzcsIFwid2FcIjogXzcsIFwid2JcIjogXzcsIFwid2NcIjogXzcsIFwid2RcIjogXzcsIFwid2VcIjogXzcsIFwid2ZcIjogXzcgfV0sIFwidmVyY2VsXCI6IF80LCBcIndlYmhhcmVcIjogXzcgfV0sIFwiZGhsXCI6IF8zLCBcImRpYW1vbmRzXCI6IF8zLCBcImRpZXRcIjogXzMsIFwiZGlnaXRhbFwiOiBbMSwgeyBcImNsb3VkYXBwc1wiOiBbMiwgeyBcImxvbmRvblwiOiBfNCB9XSB9XSwgXCJkaXJlY3RcIjogWzEsIHsgXCJsaWJwMnBcIjogXzQgfV0sIFwiZGlyZWN0b3J5XCI6IF8zLCBcImRpc2NvdW50XCI6IF8zLCBcImRpc2NvdmVyXCI6IF8zLCBcImRpc2hcIjogXzMsIFwiZGl5XCI6IF8zLCBcImRucFwiOiBfMywgXCJkb2NzXCI6IF8zLCBcImRvY3RvclwiOiBfMywgXCJkb2dcIjogXzMsIFwiZG9tYWluc1wiOiBfMywgXCJkb3RcIjogXzMsIFwiZG93bmxvYWRcIjogXzMsIFwiZHJpdmVcIjogXzMsIFwiZHR2XCI6IF8zLCBcImR1YmFpXCI6IF8zLCBcImR1bmxvcFwiOiBfMywgXCJkdXBvbnRcIjogXzMsIFwiZHVyYmFuXCI6IF8zLCBcImR2YWdcIjogXzMsIFwiZHZyXCI6IF8zLCBcImVhcnRoXCI6IF8zLCBcImVhdFwiOiBfMywgXCJlY29cIjogXzMsIFwiZWRla2FcIjogXzMsIFwiZWR1Y2F0aW9uXCI6IF8xOCwgXCJlbWFpbFwiOiBbMSwgeyBcImNyaXNwXCI6IFswLCB7IFwib25cIjogXzQgfV0sIFwidGF3a1wiOiBfNDcsIFwidGF3a3RvXCI6IF80NyB9XSwgXCJlbWVyY2tcIjogXzMsIFwiZW5lcmd5XCI6IF8zLCBcImVuZ2luZWVyXCI6IF8zLCBcImVuZ2luZWVyaW5nXCI6IF8zLCBcImVudGVycHJpc2VzXCI6IF8zLCBcImVwc29uXCI6IF8zLCBcImVxdWlwbWVudFwiOiBfMywgXCJlcmljc3NvblwiOiBfMywgXCJlcm5pXCI6IF8zLCBcImVzcVwiOiBfMywgXCJlc3RhdGVcIjogWzEsIHsgXCJjb21wdXRlXCI6IF83IH1dLCBcImV1cm92aXNpb25cIjogXzMsIFwiZXVzXCI6IFsxLCB7IFwicGFydHlcIjogXzQ4IH1dLCBcImV2ZW50c1wiOiBbMSwgeyBcImtvb2JpblwiOiBfNCwgXCJjb1wiOiBfNCB9XSwgXCJleGNoYW5nZVwiOiBfMywgXCJleHBlcnRcIjogXzMsIFwiZXhwb3NlZFwiOiBfMywgXCJleHByZXNzXCI6IF8zLCBcImV4dHJhc3BhY2VcIjogXzMsIFwiZmFnZVwiOiBfMywgXCJmYWlsXCI6IF8zLCBcImZhaXJ3aW5kc1wiOiBfMywgXCJmYWl0aFwiOiBfMywgXCJmYW1pbHlcIjogXzMsIFwiZmFuXCI6IF8zLCBcImZhbnNcIjogXzMsIFwiZmFybVwiOiBbMSwgeyBcInN0b3JqXCI6IF80IH1dLCBcImZhcm1lcnNcIjogXzMsIFwiZmFzaGlvblwiOiBfMywgXCJmYXN0XCI6IF8zLCBcImZlZGV4XCI6IF8zLCBcImZlZWRiYWNrXCI6IF8zLCBcImZlcnJhcmlcIjogXzMsIFwiZmVycmVyb1wiOiBfMywgXCJmaWRlbGl0eVwiOiBfMywgXCJmaWRvXCI6IF8zLCBcImZpbG1cIjogXzMsIFwiZmluYWxcIjogXzMsIFwiZmluYW5jZVwiOiBfMywgXCJmaW5hbmNpYWxcIjogXzE4LCBcImZpcmVcIjogXzMsIFwiZmlyZXN0b25lXCI6IF8zLCBcImZpcm1kYWxlXCI6IF8zLCBcImZpc2hcIjogXzMsIFwiZmlzaGluZ1wiOiBfMywgXCJmaXRcIjogXzMsIFwiZml0bmVzc1wiOiBfMywgXCJmbGlja3JcIjogXzMsIFwiZmxpZ2h0c1wiOiBfMywgXCJmbGlyXCI6IF8zLCBcImZsb3Jpc3RcIjogXzMsIFwiZmxvd2Vyc1wiOiBfMywgXCJmbHlcIjogXzMsIFwiZm9vXCI6IF8zLCBcImZvb2RcIjogXzMsIFwiZm9vdGJhbGxcIjogXzMsIFwiZm9yZFwiOiBfMywgXCJmb3JleFwiOiBfMywgXCJmb3JzYWxlXCI6IF8zLCBcImZvcnVtXCI6IF8zLCBcImZvdW5kYXRpb25cIjogXzMsIFwiZm94XCI6IF8zLCBcImZyZWVcIjogXzMsIFwiZnJlc2VuaXVzXCI6IF8zLCBcImZybFwiOiBfMywgXCJmcm9nYW5zXCI6IF8zLCBcImZyb250aWVyXCI6IF8zLCBcImZ0clwiOiBfMywgXCJmdWppdHN1XCI6IF8zLCBcImZ1blwiOiBfMywgXCJmdW5kXCI6IF8zLCBcImZ1cm5pdHVyZVwiOiBfMywgXCJmdXRib2xcIjogXzMsIFwiZnlpXCI6IF8zLCBcImdhbFwiOiBfMywgXCJnYWxsZXJ5XCI6IF8zLCBcImdhbGxvXCI6IF8zLCBcImdhbGx1cFwiOiBfMywgXCJnYW1lXCI6IF8zLCBcImdhbWVzXCI6IFsxLCB7IFwicGxleVwiOiBfNCwgXCJzaGVlenlcIjogXzQgfV0sIFwiZ2FwXCI6IF8zLCBcImdhcmRlblwiOiBfMywgXCJnYXlcIjogWzEsIHsgXCJwYWdlc1wiOiBfNCB9XSwgXCJnYml6XCI6IF8zLCBcImdkblwiOiBbMSwgeyBcImNucHlcIjogXzQgfV0sIFwiZ2VhXCI6IF8zLCBcImdlbnRcIjogXzMsIFwiZ2VudGluZ1wiOiBfMywgXCJnZW9yZ2VcIjogXzMsIFwiZ2dlZVwiOiBfMywgXCJnaWZ0XCI6IF8zLCBcImdpZnRzXCI6IF8zLCBcImdpdmVzXCI6IF8zLCBcImdpdmluZ1wiOiBfMywgXCJnbGFzc1wiOiBfMywgXCJnbGVcIjogXzMsIFwiZ2xvYmFsXCI6IF8zLCBcImdsb2JvXCI6IF8zLCBcImdtYWlsXCI6IF8zLCBcImdtYmhcIjogXzMsIFwiZ21vXCI6IF8zLCBcImdteFwiOiBfMywgXCJnb2RhZGR5XCI6IF8zLCBcImdvbGRcIjogXzMsIFwiZ29sZHBvaW50XCI6IF8zLCBcImdvbGZcIjogXzMsIFwiZ29vXCI6IF8zLCBcImdvb2R5ZWFyXCI6IF8zLCBcImdvb2dcIjogWzEsIHsgXCJjbG91ZFwiOiBfNCwgXCJ0cmFuc2xhdGVcIjogXzQsIFwidXNlcmNvbnRlbnRcIjogXzcgfV0sIFwiZ29vZ2xlXCI6IF8zLCBcImdvcFwiOiBfMywgXCJnb3RcIjogXzMsIFwiZ3JhaW5nZXJcIjogXzMsIFwiZ3JhcGhpY3NcIjogXzMsIFwiZ3JhdGlzXCI6IF8zLCBcImdyZWVuXCI6IF8zLCBcImdyaXBlXCI6IF8zLCBcImdyb2NlcnlcIjogXzMsIFwiZ3JvdXBcIjogWzEsIHsgXCJkaXNjb3Vyc2VcIjogXzQgfV0sIFwiZ3VjY2lcIjogXzMsIFwiZ3VnZVwiOiBfMywgXCJndWlkZVwiOiBfMywgXCJndWl0YXJzXCI6IF8zLCBcImd1cnVcIjogXzMsIFwiaGFpclwiOiBfMywgXCJoYW1idXJnXCI6IF8zLCBcImhhbmdvdXRcIjogXzMsIFwiaGF1c1wiOiBfMywgXCJoYm9cIjogXzMsIFwiaGRmY1wiOiBfMywgXCJoZGZjYmFua1wiOiBfMywgXCJoZWFsdGhcIjogWzEsIHsgXCJocmFcIjogXzQgfV0sIFwiaGVhbHRoY2FyZVwiOiBfMywgXCJoZWxwXCI6IF8zLCBcImhlbHNpbmtpXCI6IF8zLCBcImhlcmVcIjogXzMsIFwiaGVybWVzXCI6IF8zLCBcImhpcGhvcFwiOiBfMywgXCJoaXNhbWl0c3VcIjogXzMsIFwiaGl0YWNoaVwiOiBfMywgXCJoaXZcIjogXzMsIFwiaGt0XCI6IF8zLCBcImhvY2tleVwiOiBfMywgXCJob2xkaW5nc1wiOiBfMywgXCJob2xpZGF5XCI6IF8zLCBcImhvbWVkZXBvdFwiOiBfMywgXCJob21lZ29vZHNcIjogXzMsIFwiaG9tZXNcIjogXzMsIFwiaG9tZXNlbnNlXCI6IF8zLCBcImhvbmRhXCI6IF8zLCBcImhvcnNlXCI6IF8zLCBcImhvc3BpdGFsXCI6IF8zLCBcImhvc3RcIjogWzEsIHsgXCJjbG91ZGFjY2Vzc1wiOiBfNCwgXCJmcmVlc2l0ZVwiOiBfNCwgXCJlYXN5cGFuZWxcIjogXzQsIFwiZmFzdHZwc1wiOiBfNCwgXCJteWZhc3RcIjogXzQsIFwidGVtcHVybFwiOiBfNCwgXCJ3cG11ZGV2XCI6IF80LCBcImplbGVcIjogXzQsIFwibWlyY2xvdWRcIjogXzQsIFwid3AyXCI6IF80LCBcImhhbGZcIjogXzQgfV0sIFwiaG9zdGluZ1wiOiBbMSwgeyBcIm9wZW5jcmFmdFwiOiBfNCB9XSwgXCJob3RcIjogXzMsIFwiaG90ZWxzXCI6IF8zLCBcImhvdG1haWxcIjogXzMsIFwiaG91c2VcIjogXzMsIFwiaG93XCI6IF8zLCBcImhzYmNcIjogXzMsIFwiaHVnaGVzXCI6IF8zLCBcImh5YXR0XCI6IF8zLCBcImh5dW5kYWlcIjogXzMsIFwiaWJtXCI6IF8zLCBcImljYmNcIjogXzMsIFwiaWNlXCI6IF8zLCBcImljdVwiOiBfMywgXCJpZWVlXCI6IF8zLCBcImlmbVwiOiBfMywgXCJpa2Fub1wiOiBfMywgXCJpbWFtYXRcIjogXzMsIFwiaW1kYlwiOiBfMywgXCJpbW1vXCI6IF8zLCBcImltbW9iaWxpZW5cIjogXzMsIFwiaW5jXCI6IF8zLCBcImluZHVzdHJpZXNcIjogXzMsIFwiaW5maW5pdGlcIjogXzMsIFwiaW5nXCI6IF8zLCBcImlua1wiOiBfMywgXCJpbnN0aXR1dGVcIjogXzMsIFwiaW5zdXJhbmNlXCI6IF8zLCBcImluc3VyZVwiOiBfMywgXCJpbnRlcm5hdGlvbmFsXCI6IF8zLCBcImludHVpdFwiOiBfMywgXCJpbnZlc3RtZW50c1wiOiBfMywgXCJpcGlyYW5nYVwiOiBfMywgXCJpcmlzaFwiOiBfMywgXCJpc21haWxpXCI6IF8zLCBcImlzdFwiOiBfMywgXCJpc3RhbmJ1bFwiOiBfMywgXCJpdGF1XCI6IF8zLCBcIml0dlwiOiBfMywgXCJqYWd1YXJcIjogXzMsIFwiamF2YVwiOiBfMywgXCJqY2JcIjogXzMsIFwiamVlcFwiOiBfMywgXCJqZXR6dFwiOiBfMywgXCJqZXdlbHJ5XCI6IF8zLCBcImppb1wiOiBfMywgXCJqbGxcIjogXzMsIFwiam1wXCI6IF8zLCBcImpualwiOiBfMywgXCJqb2J1cmdcIjogXzMsIFwiam90XCI6IF8zLCBcImpveVwiOiBfMywgXCJqcG1vcmdhblwiOiBfMywgXCJqcHJzXCI6IF8zLCBcImp1ZWdvc1wiOiBfMywgXCJqdW5pcGVyXCI6IF8zLCBcImthdWZlblwiOiBfMywgXCJrZGRpXCI6IF8zLCBcImtlcnJ5aG90ZWxzXCI6IF8zLCBcImtlcnJ5bG9naXN0aWNzXCI6IF8zLCBcImtlcnJ5cHJvcGVydGllc1wiOiBfMywgXCJrZmhcIjogXzMsIFwia2lhXCI6IF8zLCBcImtpZHNcIjogXzMsIFwia2ltXCI6IF8zLCBcImtpbmRsZVwiOiBfMywgXCJraXRjaGVuXCI6IF8zLCBcImtpd2lcIjogXzMsIFwia29lbG5cIjogXzMsIFwia29tYXRzdVwiOiBfMywgXCJrb3NoZXJcIjogXzMsIFwia3BtZ1wiOiBfMywgXCJrcG5cIjogXzMsIFwia3JkXCI6IFsxLCB7IFwiY29cIjogXzQsIFwiZWR1XCI6IF80IH1dLCBcImtyZWRcIjogXzMsIFwia3Vva2dyb3VwXCI6IF8zLCBcImt5b3RvXCI6IF8zLCBcImxhY2FpeGFcIjogXzMsIFwibGFtYm9yZ2hpbmlcIjogXzMsIFwibGFtZXJcIjogXzMsIFwibGFuY2FzdGVyXCI6IF8zLCBcImxhbmRcIjogXzMsIFwibGFuZHJvdmVyXCI6IF8zLCBcImxhbnhlc3NcIjogXzMsIFwibGFzYWxsZVwiOiBfMywgXCJsYXRcIjogXzMsIFwibGF0aW5vXCI6IF8zLCBcImxhdHJvYmVcIjogXzMsIFwibGF3XCI6IF8zLCBcImxhd3llclwiOiBfMywgXCJsZHNcIjogXzMsIFwibGVhc2VcIjogXzMsIFwibGVjbGVyY1wiOiBfMywgXCJsZWZyYWtcIjogXzMsIFwibGVnYWxcIjogXzMsIFwibGVnb1wiOiBfMywgXCJsZXh1c1wiOiBfMywgXCJsZ2J0XCI6IF8zLCBcImxpZGxcIjogXzMsIFwibGlmZVwiOiBfMywgXCJsaWZlaW5zdXJhbmNlXCI6IF8zLCBcImxpZmVzdHlsZVwiOiBfMywgXCJsaWdodGluZ1wiOiBfMywgXCJsaWtlXCI6IF8zLCBcImxpbGx5XCI6IF8zLCBcImxpbWl0ZWRcIjogXzMsIFwibGltb1wiOiBfMywgXCJsaW5jb2xuXCI6IF8zLCBcImxpbmtcIjogWzEsIHsgXCJteWZyaXR6XCI6IF80LCBcImN5b25cIjogXzQsIFwiZHdlYlwiOiBfNywgXCJuZnRzdG9yYWdlXCI6IFswLCB7IFwiaXBmc1wiOiBfNCB9XSwgXCJteXBlcFwiOiBfNCB9XSwgXCJsaXBzeVwiOiBfMywgXCJsaXZlXCI6IFsxLCB7IFwiYWVtXCI6IF80LCBcImhseFwiOiBfNCwgXCJld3BcIjogXzcgfV0sIFwibGl2aW5nXCI6IF8zLCBcImxsY1wiOiBfMywgXCJsbHBcIjogXzMsIFwibG9hblwiOiBfMywgXCJsb2Fuc1wiOiBfMywgXCJsb2NrZXJcIjogXzMsIFwibG9jdXNcIjogXzMsIFwibG9sXCI6IFsxLCB7IFwib21nXCI6IF80IH1dLCBcImxvbmRvblwiOiBfMywgXCJsb3R0ZVwiOiBfMywgXCJsb3R0b1wiOiBfMywgXCJsb3ZlXCI6IF8zLCBcImxwbFwiOiBfMywgXCJscGxmaW5hbmNpYWxcIjogXzMsIFwibHRkXCI6IF8zLCBcImx0ZGFcIjogXzMsIFwibHVuZGJlY2tcIjogXzMsIFwibHV4ZVwiOiBfMywgXCJsdXh1cnlcIjogXzMsIFwibWFkcmlkXCI6IF8zLCBcIm1haWZcIjogXzMsIFwibWFpc29uXCI6IF8zLCBcIm1ha2V1cFwiOiBfMywgXCJtYW5cIjogXzMsIFwibWFuYWdlbWVudFwiOiBbMSwgeyBcInJvdXRlclwiOiBfNCB9XSwgXCJtYW5nb1wiOiBfMywgXCJtYXBcIjogXzMsIFwibWFya2V0XCI6IF8zLCBcIm1hcmtldGluZ1wiOiBfMywgXCJtYXJrZXRzXCI6IF8zLCBcIm1hcnJpb3R0XCI6IF8zLCBcIm1hcnNoYWxsc1wiOiBfMywgXCJtYXR0ZWxcIjogXzMsIFwibWJhXCI6IF8zLCBcIm1ja2luc2V5XCI6IF8zLCBcIm1lZFwiOiBfMywgXCJtZWRpYVwiOiBfNTQsIFwibWVldFwiOiBfMywgXCJtZWxib3VybmVcIjogXzMsIFwibWVtZVwiOiBfMywgXCJtZW1vcmlhbFwiOiBfMywgXCJtZW5cIjogXzMsIFwibWVudVwiOiBbMSwgeyBcImJhcnN5XCI6IF80LCBcImJhcnN5b25saW5lXCI6IF80IH1dLCBcIm1lcmNrXCI6IF8zLCBcIm1lcmNrbXNkXCI6IF8zLCBcIm1pYW1pXCI6IF8zLCBcIm1pY3Jvc29mdFwiOiBfMywgXCJtaW5pXCI6IF8zLCBcIm1pbnRcIjogXzMsIFwibWl0XCI6IF8zLCBcIm1pdHN1YmlzaGlcIjogXzMsIFwibWxiXCI6IF8zLCBcIm1sc1wiOiBfMywgXCJtbWFcIjogXzMsIFwibW9iaWxlXCI6IF8zLCBcIm1vZGFcIjogXzMsIFwibW9lXCI6IF8zLCBcIm1vaVwiOiBfMywgXCJtb21cIjogWzEsIHsgXCJpbmRcIjogXzQgfV0sIFwibW9uYXNoXCI6IF8zLCBcIm1vbmV5XCI6IF8zLCBcIm1vbnN0ZXJcIjogXzMsIFwibW9ybW9uXCI6IF8zLCBcIm1vcnRnYWdlXCI6IF8zLCBcIm1vc2Nvd1wiOiBfMywgXCJtb3RvXCI6IF8zLCBcIm1vdG9yY3ljbGVzXCI6IF8zLCBcIm1vdlwiOiBfMywgXCJtb3ZpZVwiOiBfMywgXCJtc2RcIjogXzMsIFwibXRuXCI6IF8zLCBcIm10clwiOiBfMywgXCJtdXNpY1wiOiBfMywgXCJuYWJcIjogXzMsIFwibmFnb3lhXCI6IF8zLCBcIm5hdnlcIjogXzMsIFwibmJhXCI6IF8zLCBcIm5lY1wiOiBfMywgXCJuZXRiYW5rXCI6IF8zLCBcIm5ldGZsaXhcIjogXzMsIFwibmV0d29ya1wiOiBbMSwgeyBcImFsY2VzXCI6IF83LCBcImNvXCI6IF80LCBcImFydm9cIjogXzQsIFwiYXppbXV0aFwiOiBfNCwgXCJ0bG9uXCI6IF80IH1dLCBcIm5ldXN0YXJcIjogXzMsIFwibmV3XCI6IF8zLCBcIm5ld3NcIjogWzEsIHsgXCJub3RpY2VhYmxlXCI6IF80IH1dLCBcIm5leHRcIjogXzMsIFwibmV4dGRpcmVjdFwiOiBfMywgXCJuZXh1c1wiOiBfMywgXCJuZmxcIjogXzMsIFwibmdvXCI6IF8zLCBcIm5oa1wiOiBfMywgXCJuaWNvXCI6IF8zLCBcIm5pa2VcIjogXzMsIFwibmlrb25cIjogXzMsIFwibmluamFcIjogXzMsIFwibmlzc2FuXCI6IF8zLCBcIm5pc3NheVwiOiBfMywgXCJub2tpYVwiOiBfMywgXCJub3J0b25cIjogXzMsIFwibm93XCI6IF8zLCBcIm5vd3J1elwiOiBfMywgXCJub3d0dlwiOiBfMywgXCJucmFcIjogXzMsIFwibnJ3XCI6IF8zLCBcIm50dFwiOiBfMywgXCJueWNcIjogXzMsIFwib2JpXCI6IF8zLCBcIm9ic2VydmVyXCI6IF8zLCBcIm9mZmljZVwiOiBfMywgXCJva2luYXdhXCI6IF8zLCBcIm9sYXlhblwiOiBfMywgXCJvbGF5YW5ncm91cFwiOiBfMywgXCJvbGxvXCI6IF8zLCBcIm9tZWdhXCI6IF8zLCBcIm9uZVwiOiBbMSwgeyBcImtpblwiOiBfNywgXCJzZXJ2aWNlXCI6IF80IH1dLCBcIm9uZ1wiOiBbMSwgeyBcIm9ibFwiOiBfNCB9XSwgXCJvbmxcIjogXzMsIFwib25saW5lXCI6IFsxLCB7IFwiZWVyb1wiOiBfNCwgXCJlZXJvLXN0YWdlXCI6IF80LCBcIndlYnNpdGVidWlsZGVyXCI6IF80LCBcImJhcnN5XCI6IF80IH1dLCBcIm9vb1wiOiBfMywgXCJvcGVuXCI6IF8zLCBcIm9yYWNsZVwiOiBfMywgXCJvcmFuZ2VcIjogWzEsIHsgXCJ0ZWNoXCI6IF80IH1dLCBcIm9yZ2FuaWNcIjogXzMsIFwib3JpZ2luc1wiOiBfMywgXCJvc2FrYVwiOiBfMywgXCJvdHN1a2FcIjogXzMsIFwib3R0XCI6IF8zLCBcIm92aFwiOiBbMSwgeyBcIm5lcmRwb2xcIjogXzQgfV0sIFwicGFnZVwiOiBbMSwgeyBcImFlbVwiOiBfNCwgXCJobHhcIjogXzQsIFwiaGx4M1wiOiBfNCwgXCJ0cmFuc2xhdGVkXCI6IF80LCBcImNvZGViZXJnXCI6IF80LCBcImhleWZsb3dcIjogXzQsIFwicHJ2Y3lcIjogXzQsIFwicm9ja3lcIjogXzQsIFwicGRuc1wiOiBfNCwgXCJwbGVza1wiOiBfNCB9XSwgXCJwYW5hc29uaWNcIjogXzMsIFwicGFyaXNcIjogXzMsIFwicGFyc1wiOiBfMywgXCJwYXJ0bmVyc1wiOiBfMywgXCJwYXJ0c1wiOiBfMywgXCJwYXJ0eVwiOiBfMywgXCJwYXlcIjogXzMsIFwicGNjd1wiOiBfMywgXCJwZXRcIjogXzMsIFwicGZpemVyXCI6IF8zLCBcInBoYXJtYWN5XCI6IF8zLCBcInBoZFwiOiBfMywgXCJwaGlsaXBzXCI6IF8zLCBcInBob25lXCI6IF8zLCBcInBob3RvXCI6IF8zLCBcInBob3RvZ3JhcGh5XCI6IF8zLCBcInBob3Rvc1wiOiBfNTQsIFwicGh5c2lvXCI6IF8zLCBcInBpY3NcIjogXzMsIFwicGljdGV0XCI6IF8zLCBcInBpY3R1cmVzXCI6IFsxLCB7IFwiMTMzN1wiOiBfNCB9XSwgXCJwaWRcIjogXzMsIFwicGluXCI6IF8zLCBcInBpbmdcIjogXzMsIFwicGlua1wiOiBfMywgXCJwaW9uZWVyXCI6IF8zLCBcInBpenphXCI6IFsxLCB7IFwibmdyb2tcIjogXzQgfV0sIFwicGxhY2VcIjogXzE4LCBcInBsYXlcIjogXzMsIFwicGxheXN0YXRpb25cIjogXzMsIFwicGx1bWJpbmdcIjogXzMsIFwicGx1c1wiOiBfMywgXCJwbmNcIjogXzMsIFwicG9obFwiOiBfMywgXCJwb2tlclwiOiBfMywgXCJwb2xpdGllXCI6IF8zLCBcInBvcm5cIjogXzMsIFwicHJhbWVyaWNhXCI6IF8zLCBcInByYXhpXCI6IF8zLCBcInByZXNzXCI6IF8zLCBcInByaW1lXCI6IF8zLCBcInByb2RcIjogXzMsIFwicHJvZHVjdGlvbnNcIjogXzMsIFwicHJvZlwiOiBfMywgXCJwcm9ncmVzc2l2ZVwiOiBfMywgXCJwcm9tb1wiOiBfMywgXCJwcm9wZXJ0aWVzXCI6IF8zLCBcInByb3BlcnR5XCI6IF8zLCBcInByb3RlY3Rpb25cIjogXzMsIFwicHJ1XCI6IF8zLCBcInBydWRlbnRpYWxcIjogXzMsIFwicHViXCI6IFsxLCB7IFwiaWRcIjogXzcsIFwia2luXCI6IF83LCBcImJhcnN5XCI6IF80IH1dLCBcInB3Y1wiOiBfMywgXCJxcG9uXCI6IF8zLCBcInF1ZWJlY1wiOiBfMywgXCJxdWVzdFwiOiBfMywgXCJyYWNpbmdcIjogXzMsIFwicmFkaW9cIjogXzMsIFwicmVhZFwiOiBfMywgXCJyZWFsZXN0YXRlXCI6IF8zLCBcInJlYWx0b3JcIjogXzMsIFwicmVhbHR5XCI6IF8zLCBcInJlY2lwZXNcIjogXzMsIFwicmVkXCI6IF8zLCBcInJlZHN0b25lXCI6IF8zLCBcInJlZHVtYnJlbGxhXCI6IF8zLCBcInJlaGFiXCI6IF8zLCBcInJlaXNlXCI6IF8zLCBcInJlaXNlblwiOiBfMywgXCJyZWl0XCI6IF8zLCBcInJlbGlhbmNlXCI6IF8zLCBcInJlblwiOiBfMywgXCJyZW50XCI6IF8zLCBcInJlbnRhbHNcIjogXzMsIFwicmVwYWlyXCI6IF8zLCBcInJlcG9ydFwiOiBfMywgXCJyZXB1YmxpY2FuXCI6IF8zLCBcInJlc3RcIjogXzMsIFwicmVzdGF1cmFudFwiOiBfMywgXCJyZXZpZXdcIjogXzMsIFwicmV2aWV3c1wiOiBfMywgXCJyZXhyb3RoXCI6IF8zLCBcInJpY2hcIjogXzMsIFwicmljaGFyZGxpXCI6IF8zLCBcInJpY29oXCI6IF8zLCBcInJpbFwiOiBfMywgXCJyaW9cIjogXzMsIFwicmlwXCI6IFsxLCB7IFwiY2xhblwiOiBfNCB9XSwgXCJyb2Nrc1wiOiBbMSwgeyBcIm15ZGRuc1wiOiBfNCwgXCJzdGFja2l0XCI6IF80LCBcImxpbWEtY2l0eVwiOiBfNCwgXCJ3ZWJzcGFjZVwiOiBfNCB9XSwgXCJyb2Rlb1wiOiBfMywgXCJyb2dlcnNcIjogXzMsIFwicm9vbVwiOiBfMywgXCJyc3ZwXCI6IF8zLCBcInJ1Z2J5XCI6IF8zLCBcInJ1aHJcIjogXzMsIFwicnVuXCI6IFsxLCB7IFwiZGV2ZWxvcG1lbnRcIjogXzQsIFwicmF2ZW5kYlwiOiBfNCwgXCJsaWFyYVwiOiBbMiwgeyBcImlyYW5cIjogXzQgfV0sIFwic2VydmVyc1wiOiBfNCwgXCJidWlsZFwiOiBfNywgXCJjb2RlXCI6IF83LCBcImRhdGFiYXNlXCI6IF83LCBcIm1pZ3JhdGlvblwiOiBfNywgXCJvbnBvcnRlclwiOiBfNCwgXCJyZXBsXCI6IF80LCBcInN0YWNraXRcIjogXzQsIFwidmFsXCI6IFswLCB7IFwiZXhwcmVzc1wiOiBfNCwgXCJ3ZWJcIjogXzQgfV0sIFwid2l4XCI6IF80IH1dLCBcInJ3ZVwiOiBfMywgXCJyeXVreXVcIjogXzMsIFwic2FhcmxhbmRcIjogXzMsIFwic2FmZVwiOiBfMywgXCJzYWZldHlcIjogXzMsIFwic2FrdXJhXCI6IF8zLCBcInNhbGVcIjogXzMsIFwic2Fsb25cIjogXzMsIFwic2Ftc2NsdWJcIjogXzMsIFwic2Ftc3VuZ1wiOiBfMywgXCJzYW5kdmlrXCI6IF8zLCBcInNhbmR2aWtjb3JvbWFudFwiOiBfMywgXCJzYW5vZmlcIjogXzMsIFwic2FwXCI6IF8zLCBcInNhcmxcIjogXzMsIFwic2FzXCI6IF8zLCBcInNhdmVcIjogXzMsIFwic2F4b1wiOiBfMywgXCJzYmlcIjogXzMsIFwic2JzXCI6IF8zLCBcInNjYlwiOiBfMywgXCJzY2hhZWZmbGVyXCI6IF8zLCBcInNjaG1pZHRcIjogXzMsIFwic2Nob2xhcnNoaXBzXCI6IF8zLCBcInNjaG9vbFwiOiBfMywgXCJzY2h1bGVcIjogXzMsIFwic2Nod2FyelwiOiBfMywgXCJzY2llbmNlXCI6IF8zLCBcInNjb3RcIjogWzEsIHsgXCJnb3ZcIjogWzIsIHsgXCJzZXJ2aWNlXCI6IF80IH1dIH1dLCBcInNlYXJjaFwiOiBfMywgXCJzZWF0XCI6IF8zLCBcInNlY3VyZVwiOiBfMywgXCJzZWN1cml0eVwiOiBfMywgXCJzZWVrXCI6IF8zLCBcInNlbGVjdFwiOiBfMywgXCJzZW5lclwiOiBfMywgXCJzZXJ2aWNlc1wiOiBbMSwgeyBcImxvZ2lubGluZVwiOiBfNCB9XSwgXCJzZXZlblwiOiBfMywgXCJzZXdcIjogXzMsIFwic2V4XCI6IF8zLCBcInNleHlcIjogXzMsIFwic2ZyXCI6IF8zLCBcInNoYW5ncmlsYVwiOiBfMywgXCJzaGFycFwiOiBfMywgXCJzaGVsbFwiOiBfMywgXCJzaGlhXCI6IF8zLCBcInNoaWtzaGFcIjogXzMsIFwic2hvZXNcIjogXzMsIFwic2hvcFwiOiBbMSwgeyBcImJhc2VcIjogXzQsIFwiaG9wbGl4XCI6IF80LCBcImJhcnN5XCI6IF80LCBcImJhcnN5b25saW5lXCI6IF80LCBcInNob3B3YXJlXCI6IF80IH1dLCBcInNob3BwaW5nXCI6IF8zLCBcInNob3VqaVwiOiBfMywgXCJzaG93XCI6IF8zLCBcInNpbGtcIjogXzMsIFwic2luYVwiOiBfMywgXCJzaW5nbGVzXCI6IF8zLCBcInNpdGVcIjogWzEsIHsgXCJjYW52YVwiOiBfMjEsIFwiY2xvdWRlcmFcIjogXzcsIFwiY29udmV4XCI6IF80LCBcImN5b25cIjogXzQsIFwiZmFzdHZwc1wiOiBfNCwgXCJoZXlmbG93XCI6IF80LCBcImplbGVcIjogXzQsIFwiam91d3dlYlwiOiBfNCwgXCJsb2dpbmxpbmVcIjogXzQsIFwiYmFyc3lcIjogXzQsIFwibm90aW9uXCI6IF80LCBcIm9tbml3ZVwiOiBfNCwgXCJvcGVuc29jaWFsXCI6IF80LCBcIm1hZGV0aGlzXCI6IF80LCBcInBsYXRmb3Jtc2hcIjogXzcsIFwidHN0XCI6IF83LCBcImJ5ZW5cIjogXzQsIFwic3JodFwiOiBfNCwgXCJub3ZlY29yZVwiOiBfNCwgXCJ3cHNxdWFyZWRcIjogXzQgfV0sIFwic2tpXCI6IF8zLCBcInNraW5cIjogXzMsIFwic2t5XCI6IF8zLCBcInNreXBlXCI6IF8zLCBcInNsaW5nXCI6IF8zLCBcInNtYXJ0XCI6IF8zLCBcInNtaWxlXCI6IF8zLCBcInNuY2ZcIjogXzMsIFwic29jY2VyXCI6IF8zLCBcInNvY2lhbFwiOiBfMywgXCJzb2Z0YmFua1wiOiBfMywgXCJzb2Z0d2FyZVwiOiBfMywgXCJzb2h1XCI6IF8zLCBcInNvbGFyXCI6IF8zLCBcInNvbHV0aW9uc1wiOiBfMywgXCJzb25nXCI6IF8zLCBcInNvbnlcIjogXzMsIFwic295XCI6IF8zLCBcInNwYVwiOiBfMywgXCJzcGFjZVwiOiBbMSwgeyBcIm15ZmFzdFwiOiBfNCwgXCJoZWl5dVwiOiBfNCwgXCJoZlwiOiBbMiwgeyBcInN0YXRpY1wiOiBfNCB9XSwgXCJhcHAtaW9ub3NcIjogXzQsIFwicHJvamVjdFwiOiBfNCwgXCJ1YmVyXCI6IF80LCBcInhzNGFsbFwiOiBfNCB9XSwgXCJzcG9ydFwiOiBfMywgXCJzcG90XCI6IF8zLCBcInNybFwiOiBfMywgXCJzdGFkYVwiOiBfMywgXCJzdGFwbGVzXCI6IF8zLCBcInN0YXJcIjogXzMsIFwic3RhdGViYW5rXCI6IF8zLCBcInN0YXRlZmFybVwiOiBfMywgXCJzdGNcIjogXzMsIFwic3RjZ3JvdXBcIjogXzMsIFwic3RvY2tob2xtXCI6IF8zLCBcInN0b3JhZ2VcIjogXzMsIFwic3RvcmVcIjogWzEsIHsgXCJiYXJzeVwiOiBfNCwgXCJzZWxsZnlcIjogXzQsIFwic2hvcHdhcmVcIjogXzQsIFwic3RvcmViYXNlXCI6IF80IH1dLCBcInN0cmVhbVwiOiBfMywgXCJzdHVkaW9cIjogXzMsIFwic3R1ZHlcIjogXzMsIFwic3R5bGVcIjogXzMsIFwic3Vja3NcIjogXzMsIFwic3VwcGxpZXNcIjogXzMsIFwic3VwcGx5XCI6IF8zLCBcInN1cHBvcnRcIjogWzEsIHsgXCJiYXJzeVwiOiBfNCB9XSwgXCJzdXJmXCI6IF8zLCBcInN1cmdlcnlcIjogXzMsIFwic3V6dWtpXCI6IF8zLCBcInN3YXRjaFwiOiBfMywgXCJzd2lzc1wiOiBfMywgXCJzeWRuZXlcIjogXzMsIFwic3lzdGVtc1wiOiBbMSwgeyBcImtuaWdodHBvaW50XCI6IF80IH1dLCBcInRhYlwiOiBfMywgXCJ0YWlwZWlcIjogXzMsIFwidGFsa1wiOiBfMywgXCJ0YW9iYW9cIjogXzMsIFwidGFyZ2V0XCI6IF8zLCBcInRhdGFtb3RvcnNcIjogXzMsIFwidGF0YXJcIjogXzMsIFwidGF0dG9vXCI6IF8zLCBcInRheFwiOiBfMywgXCJ0YXhpXCI6IF8zLCBcInRjaVwiOiBfMywgXCJ0ZGtcIjogXzMsIFwidGVhbVwiOiBbMSwgeyBcImRpc2NvdXJzZVwiOiBfNCwgXCJqZWxhc3RpY1wiOiBfNCB9XSwgXCJ0ZWNoXCI6IFsxLCB7IFwiY2xldmVyYXBwc1wiOiBfNCB9XSwgXCJ0ZWNobm9sb2d5XCI6IF8xOCwgXCJ0ZW1hc2VrXCI6IF8zLCBcInRlbm5pc1wiOiBfMywgXCJ0ZXZhXCI6IF8zLCBcInRoZFwiOiBfMywgXCJ0aGVhdGVyXCI6IF8zLCBcInRoZWF0cmVcIjogXzMsIFwidGlhYVwiOiBfMywgXCJ0aWNrZXRzXCI6IF8zLCBcInRpZW5kYVwiOiBfMywgXCJ0aXBzXCI6IF8zLCBcInRpcmVzXCI6IF8zLCBcInRpcm9sXCI6IF8zLCBcInRqbWF4eFwiOiBfMywgXCJ0anhcIjogXzMsIFwidGttYXh4XCI6IF8zLCBcInRtYWxsXCI6IF8zLCBcInRvZGF5XCI6IFsxLCB7IFwicHJlcXVhbGlmeW1lXCI6IF80IH1dLCBcInRva3lvXCI6IF8zLCBcInRvb2xzXCI6IFsxLCB7IFwiYWRkclwiOiBfNDUsIFwibXlhZGRyXCI6IF80IH1dLCBcInRvcFwiOiBbMSwgeyBcIm50ZGxsXCI6IF80LCBcIndhZGxcIjogXzcgfV0sIFwidG9yYXlcIjogXzMsIFwidG9zaGliYVwiOiBfMywgXCJ0b3RhbFwiOiBfMywgXCJ0b3Vyc1wiOiBfMywgXCJ0b3duXCI6IF8zLCBcInRveW90YVwiOiBfMywgXCJ0b3lzXCI6IF8zLCBcInRyYWRlXCI6IF8zLCBcInRyYWRpbmdcIjogXzMsIFwidHJhaW5pbmdcIjogXzMsIFwidHJhdmVsXCI6IF8zLCBcInRyYXZlbGVyc1wiOiBfMywgXCJ0cmF2ZWxlcnNpbnN1cmFuY2VcIjogXzMsIFwidHJ1c3RcIjogXzMsIFwidHJ2XCI6IF8zLCBcInR1YmVcIjogXzMsIFwidHVpXCI6IF8zLCBcInR1bmVzXCI6IF8zLCBcInR1c2h1XCI6IF8zLCBcInR2c1wiOiBfMywgXCJ1YmFua1wiOiBfMywgXCJ1YnNcIjogXzMsIFwidW5pY29tXCI6IF8zLCBcInVuaXZlcnNpdHlcIjogXzMsIFwidW5vXCI6IF8zLCBcInVvbFwiOiBfMywgXCJ1cHNcIjogXzMsIFwidmFjYXRpb25zXCI6IF8zLCBcInZhbmFcIjogXzMsIFwidmFuZ3VhcmRcIjogXzMsIFwidmVnYXNcIjogXzMsIFwidmVudHVyZXNcIjogXzMsIFwidmVyaXNpZ25cIjogXzMsIFwidmVyc2ljaGVydW5nXCI6IF8zLCBcInZldFwiOiBfMywgXCJ2aWFqZXNcIjogXzMsIFwidmlkZW9cIjogXzMsIFwidmlnXCI6IF8zLCBcInZpa2luZ1wiOiBfMywgXCJ2aWxsYXNcIjogXzMsIFwidmluXCI6IF8zLCBcInZpcFwiOiBfMywgXCJ2aXJnaW5cIjogXzMsIFwidmlzYVwiOiBfMywgXCJ2aXNpb25cIjogXzMsIFwidml2YVwiOiBfMywgXCJ2aXZvXCI6IF8zLCBcInZsYWFuZGVyZW5cIjogXzMsIFwidm9ka2FcIjogXzMsIFwidm9sdm9cIjogXzMsIFwidm90ZVwiOiBfMywgXCJ2b3RpbmdcIjogXzMsIFwidm90b1wiOiBfMywgXCJ2b3lhZ2VcIjogXzMsIFwid2FsZXNcIjogXzMsIFwid2FsbWFydFwiOiBfMywgXCJ3YWx0ZXJcIjogXzMsIFwid2FuZ1wiOiBfMywgXCJ3YW5nZ291XCI6IF8zLCBcIndhdGNoXCI6IF8zLCBcIndhdGNoZXNcIjogXzMsIFwid2VhdGhlclwiOiBfMywgXCJ3ZWF0aGVyY2hhbm5lbFwiOiBfMywgXCJ3ZWJjYW1cIjogXzMsIFwid2ViZXJcIjogXzMsIFwid2Vic2l0ZVwiOiBfNTQsIFwid2VkXCI6IF8zLCBcIndlZGRpbmdcIjogXzMsIFwid2VpYm9cIjogXzMsIFwid2VpclwiOiBfMywgXCJ3aG9zd2hvXCI6IF8zLCBcIndpZW5cIjogXzMsIFwid2lraVwiOiBfNTQsIFwid2lsbGlhbWhpbGxcIjogXzMsIFwid2luXCI6IF8zLCBcIndpbmRvd3NcIjogXzMsIFwid2luZVwiOiBfMywgXCJ3aW5uZXJzXCI6IF8zLCBcIndtZVwiOiBfMywgXCJ3b2x0ZXJza2x1d2VyXCI6IF8zLCBcIndvb2RzaWRlXCI6IF8zLCBcIndvcmtcIjogXzMsIFwid29ya3NcIjogXzMsIFwid29ybGRcIjogXzMsIFwid293XCI6IF8zLCBcInd0Y1wiOiBfMywgXCJ3dGZcIjogXzMsIFwieGJveFwiOiBfMywgXCJ4ZXJveFwiOiBfMywgXCJ4aWh1YW5cIjogXzMsIFwieGluXCI6IF8zLCBcInhuLS0xMWI0YzNkXCI6IF8zLCBcIuCkleClieCkrlwiOiBfMywgXCJ4bi0tMWNrMmUxYlwiOiBfMywgXCLjgrvjg7zjg6tcIjogXzMsIFwieG4tLTFxcXcyM2FcIjogXzMsIFwi5L2b5bGxXCI6IF8zLCBcInhuLS0zMHJyN3lcIjogXzMsIFwi5oWI5ZaEXCI6IF8zLCBcInhuLS0zYnN0MDBtXCI6IF8zLCBcIumbhuWbolwiOiBfMywgXCJ4bi0tM2RzNDQzZ1wiOiBfMywgXCLlnKjnur9cIjogXzMsIFwieG4tLTNweHU4a1wiOiBfMywgXCLngrnnnItcIjogXzMsIFwieG4tLTQyYzJkOWFcIjogXzMsIFwi4LiE4Lit4LihXCI6IF8zLCBcInhuLS00NXExMWNcIjogXzMsIFwi5YWr5Y2mXCI6IF8zLCBcInhuLS00Z2JyaW1cIjogXzMsIFwi2YXZiNmC2LlcIjogXzMsIFwieG4tLTU1cXc0MmdcIjogXzMsIFwi5YWs55uKXCI6IF8zLCBcInhuLS01NXF4NWRcIjogXzMsIFwi5YWs5Y+4XCI6IF8zLCBcInhuLS01c3UzNGo5MzZiZ3NnXCI6IF8zLCBcIummmeagvOmHjOaLiVwiOiBfMywgXCJ4bi0tNXR6bTVnXCI6IF8zLCBcIue9keermVwiOiBfMywgXCJ4bi0tNmZyejgyZ1wiOiBfMywgXCLnp7vliqhcIjogXzMsIFwieG4tLTZxcTk4NmIzeGxcIjogXzMsIFwi5oiR54ix5L2gXCI6IF8zLCBcInhuLS04MGFkeGhrc1wiOiBfMywgXCLQvNC+0YHQutCy0LBcIjogXzMsIFwieG4tLTgwYXFlY2RyMWFcIjogXzMsIFwi0LrQsNGC0L7Qu9C40LpcIjogXzMsIFwieG4tLTgwYXNlaGRiXCI6IF8zLCBcItC+0L3Qu9Cw0LnQvVwiOiBfMywgXCJ4bi0tODBhc3dnXCI6IF8zLCBcItGB0LDQudGCXCI6IF8zLCBcInhuLS04eTBhMDYzYVwiOiBfMywgXCLogZTpgJpcIjogXzMsIFwieG4tLTlkYnEyYVwiOiBfMywgXCLXp9eV151cIjogXzMsIFwieG4tLTlldDUydVwiOiBfMywgXCLml7blsJpcIjogXzMsIFwieG4tLTlrcnQwMGFcIjogXzMsIFwi5b6u5Y2aXCI6IF8zLCBcInhuLS1iNHc2MDVmZXJkXCI6IF8zLCBcIua3oemprOmUoVwiOiBfMywgXCJ4bi0tYmNrMWI5YTVkcmU0Y1wiOiBfMywgXCLjg5XjgqHjg4Pjgrfjg6fjg7NcIjogXzMsIFwieG4tLWMxYXZnXCI6IF8zLCBcItC+0YDQs1wiOiBfMywgXCJ4bi0tYzJicjdnXCI6IF8zLCBcIuCkqOClh+Ckn1wiOiBfMywgXCJ4bi0tY2NrMmIzYlwiOiBfMywgXCLjgrnjg4jjgqJcIjogXzMsIFwieG4tLWNja3djeGV0ZFwiOiBfMywgXCLjgqLjg57jgr7jg7NcIjogXzMsIFwieG4tLWNnNGJraVwiOiBfMywgXCLsgrzshLFcIjogXzMsIFwieG4tLWN6cjY5NGJcIjogXzMsIFwi5ZWG5qCHXCI6IF8zLCBcInhuLS1jenJzMHRcIjogXzMsIFwi5ZWG5bqXXCI6IF8zLCBcInhuLS1jenJ1MmRcIjogXzMsIFwi5ZWG5Z+OXCI6IF8zLCBcInhuLS1kMWFjajNiXCI6IF8zLCBcItC00LXRgtC4XCI6IF8zLCBcInhuLS1lY2t2ZHRjOWRcIjogXzMsIFwi44Od44Kk44Oz44OIXCI6IF8zLCBcInhuLS1lZnZ5ODhoXCI6IF8zLCBcIuaWsOmXu1wiOiBfMywgXCJ4bi0tZmN0NDI5a1wiOiBfMywgXCLlrrbpm7tcIjogXzMsIFwieG4tLWZoYmVpXCI6IF8zLCBcItmD2YjZhVwiOiBfMywgXCJ4bi0tZmlxMjI4YzVoc1wiOiBfMywgXCLkuK3mlofnvZFcIjogXzMsIFwieG4tLWZpcTY0YlwiOiBfMywgXCLkuK3kv6FcIjogXzMsIFwieG4tLWZqcTcyMGFcIjogXzMsIFwi5aix5LmQXCI6IF8zLCBcInhuLS1mbHczNTFlXCI6IF8zLCBcIuiwt+atjFwiOiBfMywgXCJ4bi0tZnp5czhkNjl1dmdtXCI6IF8zLCBcIumbu+ioiuebiOenkVwiOiBfMywgXCJ4bi0tZzJ4eDQ4Y1wiOiBfMywgXCLotK3nialcIjogXzMsIFwieG4tLWdja3IzZjBmXCI6IF8zLCBcIuOCr+ODqeOCpuODiVwiOiBfMywgXCJ4bi0tZ2szYXQxZVwiOiBfMywgXCLpgJrosqlcIjogXzMsIFwieG4tLWh4dDgxNGVcIjogXzMsIFwi572R5bqXXCI6IF8zLCBcInhuLS1pMWI2YjFhNmEyZVwiOiBfMywgXCLgpLjgpILgpJfgpKDgpKhcIjogXzMsIFwieG4tLWltcjUxM25cIjogXzMsIFwi6aSQ5Y6FXCI6IF8zLCBcInhuLS1pbzBhN2lcIjogXzMsIFwi572R57ucXCI6IF8zLCBcInhuLS1qMWFlZlwiOiBfMywgXCLQutC+0LxcIjogXzMsIFwieG4tLWpscTQ4MG4ycmdcIjogXzMsIFwi5Lqa6ams6YCKXCI6IF8zLCBcInhuLS1qdnIxODltXCI6IF8zLCBcIumjn+WTgVwiOiBfMywgXCJ4bi0ta2NyeDc3ZDF4NGFcIjogXzMsIFwi6aOe5Yip5rWmXCI6IF8zLCBcInhuLS1rcHV0M2lcIjogXzMsIFwi5omL5py6XCI6IF8zLCBcInhuLS1tZ2JhM2EzZWp0XCI6IF8zLCBcItin2LHYp9mF2YPZiFwiOiBfMywgXCJ4bi0tbWdiYTdjMGJibjBhXCI6IF8zLCBcItin2YTYudmE2YrYp9mGXCI6IF8zLCBcInhuLS1tZ2JhYjJiZFwiOiBfMywgXCLYqNin2LLYp9ixXCI6IF8zLCBcInhuLS1tZ2JjYTdkemRvXCI6IF8zLCBcItin2KjZiNi42KjZilwiOiBfMywgXCJ4bi0tbWdiaTRlY2V4cFwiOiBfMywgXCLZg9in2KvZiNmE2YrZg1wiOiBfMywgXCJ4bi0tbWdidDNkaGRcIjogXzMsIFwi2YfZhdix2KfZh1wiOiBfMywgXCJ4bi0tbWsxYnU0NGNcIjogXzMsIFwi64u37Lu0XCI6IF8zLCBcInhuLS1teHRxMW1cIjogXzMsIFwi5pS/5bqcXCI6IF8zLCBcInhuLS1uZ2JjNWF6ZFwiOiBfMywgXCLYtNio2YPYqVwiOiBfMywgXCJ4bi0tbmdiZTllMGFcIjogXzMsIFwi2KjZitiq2YNcIjogXzMsIFwieG4tLW5nYnJ4XCI6IF8zLCBcIti52LHYqFwiOiBfMywgXCJ4bi0tbnF2N2ZcIjogXzMsIFwi5py65p6EXCI6IF8zLCBcInhuLS1ucXY3ZnMwMGVtYVwiOiBfMywgXCLnu4Tnu4fmnLrmnoRcIjogXzMsIFwieG4tLW55cXkyNmFcIjogXzMsIFwi5YGl5bq3XCI6IF8zLCBcInhuLS1vdHU3OTZkXCI6IF8zLCBcIuaLm+iBmFwiOiBfMywgXCJ4bi0tcDFhY2ZcIjogWzEsIHsgXCJ4bi0tOTBhbWNcIjogXzQsIFwieG4tLWoxYWVmXCI6IF80LCBcInhuLS1qMWFlbDhiXCI6IF80LCBcInhuLS1oMWFoblwiOiBfNCwgXCJ4bi0tajFhZHBcIjogXzQsIFwieG4tLWMxYXZnXCI6IF80LCBcInhuLS04MGFhYTBjdmFjXCI6IF80LCBcInhuLS1oMWFsaXpcIjogXzQsIFwieG4tLTkwYTFhZlwiOiBfNCwgXCJ4bi0tNDFhXCI6IF80IH1dLCBcItGA0YPRgVwiOiBbMSwgeyBcItCx0LjQt1wiOiBfNCwgXCLQutC+0LxcIjogXzQsIFwi0LrRgNGL0LxcIjogXzQsIFwi0LzQuNGAXCI6IF80LCBcItC80YHQulwiOiBfNCwgXCLQvtGA0LNcIjogXzQsIFwi0YHQsNC80LDRgNCwXCI6IF80LCBcItGB0L7Rh9C4XCI6IF80LCBcItGB0L/QsVwiOiBfNCwgXCLRj1wiOiBfNCB9XSwgXCJ4bi0tcHNzeTJ1XCI6IF8zLCBcIuWkp+aLv1wiOiBfMywgXCJ4bi0tcTlqeWI0Y1wiOiBfMywgXCLjgb/jgpPjgapcIjogXzMsIFwieG4tLXFja2ExcG1jXCI6IF8zLCBcIuOCsOODvOOCsOODq1wiOiBfMywgXCJ4bi0tcmhxdjk2Z1wiOiBfMywgXCLkuJbnlYxcIjogXzMsIFwieG4tLXJvdnU4OGJcIjogXzMsIFwi5pu457GNXCI6IF8zLCBcInhuLS1zZXM1NTRnXCI6IF8zLCBcIue9keWdgFwiOiBfMywgXCJ4bi0tdDYwYjU2YVwiOiBfMywgXCLri7frhLdcIjogXzMsIFwieG4tLXRja3dlXCI6IF8zLCBcIuOCs+ODoFwiOiBfMywgXCJ4bi0tdGlxNDl4cXlqXCI6IF8zLCBcIuWkqeS4u+aVmVwiOiBfMywgXCJ4bi0tdW51cDR5XCI6IF8zLCBcIua4uOaIj1wiOiBfMywgXCJ4bi0tdmVybWdlbnNiZXJhdGVyLWN0YlwiOiBfMywgXCJ2ZXJtw7ZnZW5zYmVyYXRlclwiOiBfMywgXCJ4bi0tdmVybWdlbnNiZXJhdHVuZy1wd2JcIjogXzMsIFwidmVybcO2Z2Vuc2JlcmF0dW5nXCI6IF8zLCBcInhuLS12aHF1dlwiOiBfMywgXCLkvIHkuJpcIjogXzMsIFwieG4tLXZ1cTg2MWJcIjogXzMsIFwi5L+h5oGvXCI6IF8zLCBcInhuLS13NHI4NWVsOGZodTVkbnJhXCI6IF8zLCBcIuWYiemHjOWkp+mFkuW6l1wiOiBfMywgXCJ4bi0tdzRyczQwbFwiOiBfMywgXCLlmInph4xcIjogXzMsIFwieG4tLXhocTUyMWJcIjogXzMsIFwi5bm/5LicXCI6IF8zLCBcInhuLS16ZnIxNjRiXCI6IF8zLCBcIuaUv+WKoVwiOiBfMywgXCJ4eXpcIjogWzEsIHsgXCJib3RkYXNoXCI6IF80LCBcInRlbGViaXRcIjogXzcgfV0sIFwieWFjaHRzXCI6IF8zLCBcInlhaG9vXCI6IF8zLCBcInlhbWF4dW5cIjogXzMsIFwieWFuZGV4XCI6IF8zLCBcInlvZG9iYXNoaVwiOiBfMywgXCJ5b2dhXCI6IF8zLCBcInlva29oYW1hXCI6IF8zLCBcInlvdVwiOiBfMywgXCJ5b3V0dWJlXCI6IF8zLCBcInl1blwiOiBfMywgXCJ6YXBwb3NcIjogXzMsIFwiemFyYVwiOiBfMywgXCJ6ZXJvXCI6IF8zLCBcInppcFwiOiBfMywgXCJ6b25lXCI6IFsxLCB7IFwiY2xvdWQ2NlwiOiBfNCwgXCJ0cml0b25cIjogXzcsIFwic3RhY2tpdFwiOiBfNCwgXCJsaW1hXCI6IF80IH1dLCBcInp1ZXJpY2hcIjogXzMgfV07XG4gICAgcmV0dXJuIHJ1bGVzO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts/dist/es6/src/data/trie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tldts/dist/es6/src/suffix-trie.js":
/*!********************************************************!*\
  !*** ./node_modules/tldts/dist/es6/src/suffix-trie.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ suffixLookup)\n/* harmony export */ });\n/* harmony import */ var tldts_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tldts-core */ \"(app-pages-browser)/./node_modules/tldts-core/dist/es6/index.js\");\n/* harmony import */ var _data_trie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data/trie */ \"(app-pages-browser)/./node_modules/tldts/dist/es6/src/data/trie.js\");\n\n\n/**\n * Lookup parts of domain in Trie\n */\nfunction lookupInTrie(parts, trie, index, allowedMask) {\n    let result = null;\n    let node = trie;\n    while (node !== undefined) {\n        // We have a match!\n        if ((node[0] & allowedMask) !== 0) {\n            result = {\n                index: index + 1,\n                isIcann: node[0] === 1 /* RULE_TYPE.ICANN */,\n                isPrivate: node[0] === 2 /* RULE_TYPE.PRIVATE */,\n            };\n        }\n        // No more `parts` to look for\n        if (index === -1) {\n            break;\n        }\n        const succ = node[1];\n        node = Object.prototype.hasOwnProperty.call(succ, parts[index])\n            ? succ[parts[index]]\n            : succ['*'];\n        index -= 1;\n    }\n    return result;\n}\n/**\n * Check if `hostname` has a valid public suffix in `trie`.\n */\nfunction suffixLookup(hostname, options, out) {\n    var _a;\n    if ((0,tldts_core__WEBPACK_IMPORTED_MODULE_0__.fastPathLookup)(hostname, options, out)) {\n        return;\n    }\n    const hostnameParts = hostname.split('.');\n    const allowedMask = (options.allowPrivateDomains ? 2 /* RULE_TYPE.PRIVATE */ : 0) |\n        (options.allowIcannDomains ? 1 /* RULE_TYPE.ICANN */ : 0);\n    // Look for exceptions\n    const exceptionMatch = lookupInTrie(hostnameParts, _data_trie__WEBPACK_IMPORTED_MODULE_1__.exceptions, hostnameParts.length - 1, allowedMask);\n    if (exceptionMatch !== null) {\n        out.isIcann = exceptionMatch.isIcann;\n        out.isPrivate = exceptionMatch.isPrivate;\n        out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');\n        return;\n    }\n    // Look for a match in rules\n    const rulesMatch = lookupInTrie(hostnameParts, _data_trie__WEBPACK_IMPORTED_MODULE_1__.rules, hostnameParts.length - 1, allowedMask);\n    if (rulesMatch !== null) {\n        out.isIcann = rulesMatch.isIcann;\n        out.isPrivate = rulesMatch.isPrivate;\n        out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');\n        return;\n    }\n    // No match found...\n    // Prevailing rule is '*' so we consider the top-level domain to be the\n    // public suffix of `hostname` (e.g.: 'example.org' => 'org').\n    out.isIcann = false;\n    out.isPrivate = false;\n    out.publicSuffix = (_a = hostnameParts[hostnameParts.length - 1]) !== null && _a !== void 0 ? _a : null;\n}\n//# sourceMappingURL=suffix-trie.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90bGR0cy9kaXN0L2VzNi9zcmMvc3VmZml4LXRyaWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ0c7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtEQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDZDQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdGxkdHMvZGlzdC9lczYvc3JjL3N1ZmZpeC10cmllLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZhc3RQYXRoTG9va3VwLCB9IGZyb20gJ3RsZHRzLWNvcmUnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucywgcnVsZXMgfSBmcm9tICcuL2RhdGEvdHJpZSc7XG4vKipcbiAqIExvb2t1cCBwYXJ0cyBvZiBkb21haW4gaW4gVHJpZVxuICovXG5mdW5jdGlvbiBsb29rdXBJblRyaWUocGFydHMsIHRyaWUsIGluZGV4LCBhbGxvd2VkTWFzaykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGxldCBub2RlID0gdHJpZTtcbiAgICB3aGlsZSAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaCFcbiAgICAgICAgaWYgKChub2RlWzBdICYgYWxsb3dlZE1hc2spICE9PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICBpc0ljYW5uOiBub2RlWzBdID09PSAxIC8qIFJVTEVfVFlQRS5JQ0FOTiAqLyxcbiAgICAgICAgICAgICAgICBpc1ByaXZhdGU6IG5vZGVbMF0gPT09IDIgLyogUlVMRV9UWVBFLlBSSVZBVEUgKi8sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1vcmUgYHBhcnRzYCB0byBsb29rIGZvclxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWNjID0gbm9kZVsxXTtcbiAgICAgICAgbm9kZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdWNjLCBwYXJ0c1tpbmRleF0pXG4gICAgICAgICAgICA/IHN1Y2NbcGFydHNbaW5kZXhdXVxuICAgICAgICAgICAgOiBzdWNjWycqJ107XG4gICAgICAgIGluZGV4IC09IDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGBob3N0bmFtZWAgaGFzIGEgdmFsaWQgcHVibGljIHN1ZmZpeCBpbiBgdHJpZWAuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1ZmZpeExvb2t1cChob3N0bmFtZSwgb3B0aW9ucywgb3V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChmYXN0UGF0aExvb2t1cChob3N0bmFtZSwgb3B0aW9ucywgb3V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvc3RuYW1lUGFydHMgPSBob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGFsbG93ZWRNYXNrID0gKG9wdGlvbnMuYWxsb3dQcml2YXRlRG9tYWlucyA/IDIgLyogUlVMRV9UWVBFLlBSSVZBVEUgKi8gOiAwKSB8XG4gICAgICAgIChvcHRpb25zLmFsbG93SWNhbm5Eb21haW5zID8gMSAvKiBSVUxFX1RZUEUuSUNBTk4gKi8gOiAwKTtcbiAgICAvLyBMb29rIGZvciBleGNlcHRpb25zXG4gICAgY29uc3QgZXhjZXB0aW9uTWF0Y2ggPSBsb29rdXBJblRyaWUoaG9zdG5hbWVQYXJ0cywgZXhjZXB0aW9ucywgaG9zdG5hbWVQYXJ0cy5sZW5ndGggLSAxLCBhbGxvd2VkTWFzayk7XG4gICAgaWYgKGV4Y2VwdGlvbk1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIG91dC5pc0ljYW5uID0gZXhjZXB0aW9uTWF0Y2guaXNJY2FubjtcbiAgICAgICAgb3V0LmlzUHJpdmF0ZSA9IGV4Y2VwdGlvbk1hdGNoLmlzUHJpdmF0ZTtcbiAgICAgICAgb3V0LnB1YmxpY1N1ZmZpeCA9IGhvc3RuYW1lUGFydHMuc2xpY2UoZXhjZXB0aW9uTWF0Y2guaW5kZXggKyAxKS5qb2luKCcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gTG9vayBmb3IgYSBtYXRjaCBpbiBydWxlc1xuICAgIGNvbnN0IHJ1bGVzTWF0Y2ggPSBsb29rdXBJblRyaWUoaG9zdG5hbWVQYXJ0cywgcnVsZXMsIGhvc3RuYW1lUGFydHMubGVuZ3RoIC0gMSwgYWxsb3dlZE1hc2spO1xuICAgIGlmIChydWxlc01hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIG91dC5pc0ljYW5uID0gcnVsZXNNYXRjaC5pc0ljYW5uO1xuICAgICAgICBvdXQuaXNQcml2YXRlID0gcnVsZXNNYXRjaC5pc1ByaXZhdGU7XG4gICAgICAgIG91dC5wdWJsaWNTdWZmaXggPSBob3N0bmFtZVBhcnRzLnNsaWNlKHJ1bGVzTWF0Y2guaW5kZXgpLmpvaW4oJy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBObyBtYXRjaCBmb3VuZC4uLlxuICAgIC8vIFByZXZhaWxpbmcgcnVsZSBpcyAnKicgc28gd2UgY29uc2lkZXIgdGhlIHRvcC1sZXZlbCBkb21haW4gdG8gYmUgdGhlXG4gICAgLy8gcHVibGljIHN1ZmZpeCBvZiBgaG9zdG5hbWVgIChlLmcuOiAnZXhhbXBsZS5vcmcnID0+ICdvcmcnKS5cbiAgICBvdXQuaXNJY2FubiA9IGZhbHNlO1xuICAgIG91dC5pc1ByaXZhdGUgPSBmYWxzZTtcbiAgICBvdXQucHVibGljU3VmZml4ID0gKF9hID0gaG9zdG5hbWVQYXJ0c1tob3N0bmFtZVBhcnRzLmxlbmd0aCAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VmZml4LXRyaWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tldts/dist/es6/src/suffix-trie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/canonicalDomain.js":
/*!******************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/canonicalDomain.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canonicalDomain = canonicalDomain;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/constants.js\");\n/**\n * Normalizes a domain to lowercase and punycode-encoded.\n * Runtime-agnostic equivalent to node's `domainToASCII`.\n * @see https://nodejs.org/docs/latest-v22.x/api/url.html#urldomaintoasciidomain\n */\nfunction domainToASCII(domain) {\n    return new URL(`http://${domain}`).hostname;\n}\n/**\n * Transforms a domain name into a canonical domain name. The canonical domain name is a domain name\n * that has been trimmed, lowercased, stripped of leading dot, and optionally punycode-encoded\n * ({@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.2 | Section 5.1.2 of RFC 6265}). For\n * the most part, this function is idempotent (calling the function with the output from a previous call\n * returns the same output).\n *\n * @remarks\n * A canonicalized host name is the string generated by the following\n * algorithm:\n *\n * 1.  Convert the host name to a sequence of individual domain name\n *     labels.\n *\n * 2.  Convert each label that is not a Non-Reserved LDH (NR-LDH) label,\n *     to an A-label (see Section 2.3.2.1 of [RFC5890] for the former\n *     and latter), or to a \"punycode label\" (a label resulting from the\n *     \"ToASCII\" conversion in Section 4 of [RFC3490]), as appropriate\n *     (see Section 6.3 of this specification).\n *\n * 3.  Concatenate the resulting labels, separated by a %x2E (\".\")\n *     character.\n *\n * @example\n * ```\n * canonicalDomain('.EXAMPLE.com') === 'example.com'\n * ```\n *\n * @param domainName - the domain name to generate the canonical domain from\n * @public\n */\nfunction canonicalDomain(domainName) {\n    if (domainName == null) {\n        return undefined;\n    }\n    let str = domainName.trim().replace(/^\\./, ''); // S4.1.2.3 & S5.2.3: ignore leading .\n    if (constants_1.IP_V6_REGEX_OBJECT.test(str)) {\n        if (!str.startsWith('[')) {\n            str = '[' + str;\n        }\n        if (!str.endsWith(']')) {\n            str = str + ']';\n        }\n        return domainToASCII(str).slice(1, -1); // remove [ and ]\n    }\n    // convert to IDN if any non-ASCII characters\n    // eslint-disable-next-line no-control-regex\n    if (/[^\\u0001-\\u007f]/.test(str)) {\n        return domainToASCII(str);\n    }\n    // ASCII-only domain - not canonicalized with new URL() because it may be a malformed URL\n    return str.toLowerCase();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvY2Fub25pY2FsRG9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQyw2RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNEZBQTRGO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvY2Fub25pY2FsRG9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5vbmljYWxEb21haW4gPSBjYW5vbmljYWxEb21haW47XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogTm9ybWFsaXplcyBhIGRvbWFpbiB0byBsb3dlcmNhc2UgYW5kIHB1bnljb2RlLWVuY29kZWQuXG4gKiBSdW50aW1lLWFnbm9zdGljIGVxdWl2YWxlbnQgdG8gbm9kZSdzIGBkb21haW5Ub0FTQ0lJYC5cbiAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXYyMi54L2FwaS91cmwuaHRtbCN1cmxkb21haW50b2FzY2lpZG9tYWluXG4gKi9cbmZ1bmN0aW9uIGRvbWFpblRvQVNDSUkoZG9tYWluKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoYGh0dHA6Ly8ke2RvbWFpbn1gKS5ob3N0bmFtZTtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhIGRvbWFpbiBuYW1lIGludG8gYSBjYW5vbmljYWwgZG9tYWluIG5hbWUuIFRoZSBjYW5vbmljYWwgZG9tYWluIG5hbWUgaXMgYSBkb21haW4gbmFtZVxuICogdGhhdCBoYXMgYmVlbiB0cmltbWVkLCBsb3dlcmNhc2VkLCBzdHJpcHBlZCBvZiBsZWFkaW5nIGRvdCwgYW5kIG9wdGlvbmFsbHkgcHVueWNvZGUtZW5jb2RlZFxuICogKHtAbGluayBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjI2NS5odG1sI3NlY3Rpb24tNS4xLjIgfCBTZWN0aW9uIDUuMS4yIG9mIFJGQyA2MjY1fSkuIEZvclxuICogdGhlIG1vc3QgcGFydCwgdGhpcyBmdW5jdGlvbiBpcyBpZGVtcG90ZW50IChjYWxsaW5nIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBvdXRwdXQgZnJvbSBhIHByZXZpb3VzIGNhbGxcbiAqIHJldHVybnMgdGhlIHNhbWUgb3V0cHV0KS5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSBjYW5vbmljYWxpemVkIGhvc3QgbmFtZSBpcyB0aGUgc3RyaW5nIGdlbmVyYXRlZCBieSB0aGUgZm9sbG93aW5nXG4gKiBhbGdvcml0aG06XG4gKlxuICogMS4gIENvbnZlcnQgdGhlIGhvc3QgbmFtZSB0byBhIHNlcXVlbmNlIG9mIGluZGl2aWR1YWwgZG9tYWluIG5hbWVcbiAqICAgICBsYWJlbHMuXG4gKlxuICogMi4gIENvbnZlcnQgZWFjaCBsYWJlbCB0aGF0IGlzIG5vdCBhIE5vbi1SZXNlcnZlZCBMREggKE5SLUxESCkgbGFiZWwsXG4gKiAgICAgdG8gYW4gQS1sYWJlbCAoc2VlIFNlY3Rpb24gMi4zLjIuMSBvZiBbUkZDNTg5MF0gZm9yIHRoZSBmb3JtZXJcbiAqICAgICBhbmQgbGF0dGVyKSwgb3IgdG8gYSBcInB1bnljb2RlIGxhYmVsXCIgKGEgbGFiZWwgcmVzdWx0aW5nIGZyb20gdGhlXG4gKiAgICAgXCJUb0FTQ0lJXCIgY29udmVyc2lvbiBpbiBTZWN0aW9uIDQgb2YgW1JGQzM0OTBdKSwgYXMgYXBwcm9wcmlhdGVcbiAqICAgICAoc2VlIFNlY3Rpb24gNi4zIG9mIHRoaXMgc3BlY2lmaWNhdGlvbikuXG4gKlxuICogMy4gIENvbmNhdGVuYXRlIHRoZSByZXN1bHRpbmcgbGFiZWxzLCBzZXBhcmF0ZWQgYnkgYSAleDJFIChcIi5cIilcbiAqICAgICBjaGFyYWN0ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY2Fub25pY2FsRG9tYWluKCcuRVhBTVBMRS5jb20nKSA9PT0gJ2V4YW1wbGUuY29tJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGRvbWFpbk5hbWUgLSB0aGUgZG9tYWluIG5hbWUgdG8gZ2VuZXJhdGUgdGhlIGNhbm9uaWNhbCBkb21haW4gZnJvbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjYW5vbmljYWxEb21haW4oZG9tYWluTmFtZSkge1xuICAgIGlmIChkb21haW5OYW1lID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHN0ciA9IGRvbWFpbk5hbWUudHJpbSgpLnJlcGxhY2UoL15cXC4vLCAnJyk7IC8vIFM0LjEuMi4zICYgUzUuMi4zOiBpZ25vcmUgbGVhZGluZyAuXG4gICAgaWYgKGNvbnN0YW50c18xLklQX1Y2X1JFR0VYX09CSkVDVC50ZXN0KHN0cikpIHtcbiAgICAgICAgaWYgKCFzdHIuc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgICAgICBzdHIgPSAnWycgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHIuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgc3RyID0gc3RyICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW5Ub0FTQ0lJKHN0cikuc2xpY2UoMSwgLTEpOyAvLyByZW1vdmUgWyBhbmQgXVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IHRvIElETiBpZiBhbnkgbm9uLUFTQ0lJIGNoYXJhY3RlcnNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIGlmICgvW15cXHUwMDAxLVxcdTAwN2ZdLy50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpblRvQVNDSUkoc3RyKTtcbiAgICB9XG4gICAgLy8gQVNDSUktb25seSBkb21haW4gLSBub3QgY2Fub25pY2FsaXplZCB3aXRoIG5ldyBVUkwoKSBiZWNhdXNlIGl0IG1heSBiZSBhIG1hbGZvcm1lZCBVUkxcbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/canonicalDomain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IP_V6_REGEX_OBJECT = exports.PrefixSecurityEnum = void 0;\n/**\n * Cookie prefixes are a way to indicate that a given cookie was set with a set of attributes simply by inspecting the\n * first few characters of the cookie's name. These are defined in {@link https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.3 | RFC6265bis - Section 4.1.3}.\n *\n * The following values can be used to configure how a {@link CookieJar} enforces attribute restrictions for Cookie prefixes:\n *\n * - `silent` - Enable cookie prefix checking but silently ignores the cookie if conditions are not met. This is the default configuration for a {@link CookieJar}.\n *\n * - `strict` - Enables cookie prefix checking and will raise an error if conditions are not met.\n *\n * - `unsafe-disabled` - Disables cookie prefix checking.\n * @public\n */\nexports.PrefixSecurityEnum = Object.freeze({\n    SILENT: 'silent',\n    STRICT: 'strict',\n    DISABLED: 'unsafe-disabled',\n});\nconst IP_V6_REGEX = `\n\\\\[?(?:\n(?:[a-fA-F\\\\d]{1,4}:){7}(?:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,2}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){4}(?:(?::[a-fA-F\\\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,3}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){3}(?:(?::[a-fA-F\\\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){2}(?:(?::[a-fA-F\\\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,5}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){1}(?:(?::[a-fA-F\\\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,6}|:)|\n(?::(?:(?::[a-fA-F\\\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,7}|:))\n)(?:%[0-9a-zA-Z]{1,})?\\\\]?\n`\n    .replace(/\\s*\\/\\/.*$/gm, '')\n    .replace(/\\n/g, '')\n    .trim();\nexports.IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0Esb0VBQW9FLHdIQUF3SDtBQUM1TDtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQSxrSkFBa0osZ0JBQWdCO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJO0FBQzNDLGVBQWUsSUFBSSxHQUFHLEVBQUUsK0ZBQStGLEVBQUUsY0FBYyxJQUFJO0FBQzNJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZ0dBQWdHLEVBQUUsaUJBQWlCLElBQUksRUFBRSxJQUFJO0FBQ3JKLGVBQWUsSUFBSSxHQUFHLEVBQUUsbUJBQW1CLElBQUksRUFBRSxJQUFJLDZGQUE2RixFQUFFLGlCQUFpQixJQUFJLEVBQUUsSUFBSTtBQUMvSyxlQUFlLElBQUksR0FBRyxFQUFFLG1CQUFtQixJQUFJLEVBQUUsSUFBSSw2RkFBNkYsRUFBRSxpQkFBaUIsSUFBSSxFQUFFLElBQUk7QUFDL0ssZUFBZSxJQUFJLEdBQUcsRUFBRSxtQkFBbUIsSUFBSSxFQUFFLElBQUksNkZBQTZGLEVBQUUsaUJBQWlCLElBQUksRUFBRSxJQUFJO0FBQy9LLGVBQWUsSUFBSSxHQUFHLEVBQUUsbUJBQW1CLElBQUksRUFBRSxJQUFJLDZGQUE2RixFQUFFLGlCQUFpQixJQUFJLEVBQUUsSUFBSTtBQUMvSyx1QkFBdUIsSUFBSSxFQUFFLElBQUksNkZBQTZGLEVBQUUsaUJBQWlCLElBQUksRUFBRSxJQUFJO0FBQzNKLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQixZQUFZIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L2Nvb2tpZS9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklQX1Y2X1JFR0VYX09CSkVDVCA9IGV4cG9ydHMuUHJlZml4U2VjdXJpdHlFbnVtID0gdm9pZCAwO1xuLyoqXG4gKiBDb29raWUgcHJlZml4ZXMgYXJlIGEgd2F5IHRvIGluZGljYXRlIHRoYXQgYSBnaXZlbiBjb29raWUgd2FzIHNldCB3aXRoIGEgc2V0IG9mIGF0dHJpYnV0ZXMgc2ltcGx5IGJ5IGluc3BlY3RpbmcgdGhlXG4gKiBmaXJzdCBmZXcgY2hhcmFjdGVycyBvZiB0aGUgY29va2llJ3MgbmFtZS4gVGhlc2UgYXJlIGRlZmluZWQgaW4ge0BsaW5rIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMtMTMjc2VjdGlvbi00LjEuMyB8IFJGQzYyNjViaXMgLSBTZWN0aW9uIDQuMS4zfS5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHZhbHVlcyBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgaG93IGEge0BsaW5rIENvb2tpZUphcn0gZW5mb3JjZXMgYXR0cmlidXRlIHJlc3RyaWN0aW9ucyBmb3IgQ29va2llIHByZWZpeGVzOlxuICpcbiAqIC0gYHNpbGVudGAgLSBFbmFibGUgY29va2llIHByZWZpeCBjaGVja2luZyBidXQgc2lsZW50bHkgaWdub3JlcyB0aGUgY29va2llIGlmIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoaXMgaXMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgYSB7QGxpbmsgQ29va2llSmFyfS5cbiAqXG4gKiAtIGBzdHJpY3RgIC0gRW5hYmxlcyBjb29raWUgcHJlZml4IGNoZWNraW5nIGFuZCB3aWxsIHJhaXNlIGFuIGVycm9yIGlmIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuXG4gKlxuICogLSBgdW5zYWZlLWRpc2FibGVkYCAtIERpc2FibGVzIGNvb2tpZSBwcmVmaXggY2hlY2tpbmcuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuUHJlZml4U2VjdXJpdHlFbnVtID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgU0lMRU5UOiAnc2lsZW50JyxcbiAgICBTVFJJQ1Q6ICdzdHJpY3QnLFxuICAgIERJU0FCTEVEOiAndW5zYWZlLWRpc2FibGVkJyxcbn0pO1xuY29uc3QgSVBfVjZfUkVHRVggPSBgXG5cXFxcWz8oPzpcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezd9KD86W2EtZkEtRlxcXFxkXXsxLDR9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7Nn0oPzooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXw6W2EtZkEtRlxcXFxkXXsxLDR9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7NX0oPzo6KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSwyfXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezR9KD86KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MCwxfTooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDN9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7M30oPzooPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXswLDJ9Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fCg/OjpbYS1mQS1GXFxcXGRdezEsNH0pezEsNH18Oil8XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXsyfSg/Oig/OjpbYS1mQS1GXFxcXGRdezEsNH0pezAsM306KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSw1fXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezF9KD86KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MCw0fTooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDZ9fDopfFxuKD86Oig/Oig/OjpbYS1mQS1GXFxcXGRdezEsNH0pezAsNX06KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSw3fXw6KSlcbikoPzolWzAtOWEtekEtWl17MSx9KT9cXFxcXT9cbmBcbiAgICAucmVwbGFjZSgvXFxzKlxcL1xcLy4qJC9nbSwgJycpXG4gICAgLnJlcGxhY2UoL1xcbi9nLCAnJylcbiAgICAudHJpbSgpO1xuZXhwb3J0cy5JUF9WNl9SRUdFWF9PQkpFQ1QgPSBuZXcgUmVnRXhwKGBeJHtJUF9WNl9SRUdFWH0kYCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookie.js":
/*!*********************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/cookie.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cookie = void 0;\n/*!\n * Copyright (c) 2015-2020, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst getPublicSuffix_1 = __webpack_require__(/*! ../getPublicSuffix */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/getPublicSuffix.js\");\nconst validators = __importStar(__webpack_require__(/*! ../validators */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/validators.js\"));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/utils.js\");\nconst formatDate_1 = __webpack_require__(/*! ./formatDate */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/formatDate.js\");\nconst parseDate_1 = __webpack_require__(/*! ./parseDate */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/parseDate.js\");\nconst canonicalDomain_1 = __webpack_require__(/*! ./canonicalDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/canonicalDomain.js\");\n// From RFC6265 S4.1.1\n// note that it excludes \\x3B \";\"\nconst COOKIE_OCTETS = /^[\\x21\\x23-\\x2B\\x2D-\\x3A\\x3C-\\x5B\\x5D-\\x7E]+$/;\n// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or \";\"'\n// Note ';' is \\x3B\nconst PATH_VALUE = /[\\x20-\\x3A\\x3C-\\x7E]+/;\n// eslint-disable-next-line no-control-regex\nconst CONTROL_CHARS = /[\\x00-\\x1F]/;\n// From Chromium // '\\r', '\\n' and '\\0' should be treated as a terminator in\n// the \"relaxed\" mode, see:\n// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60\nconst TERMINATORS = ['\\n', '\\r', '\\0'];\nfunction trimTerminator(str) {\n    if (validators.isEmptyString(str))\n        return str;\n    for (let t = 0; t < TERMINATORS.length; t++) {\n        const terminator = TERMINATORS[t];\n        const terminatorIdx = terminator ? str.indexOf(terminator) : -1;\n        if (terminatorIdx !== -1) {\n            str = str.slice(0, terminatorIdx);\n        }\n    }\n    return str;\n}\nfunction parseCookiePair(cookiePair, looseMode) {\n    cookiePair = trimTerminator(cookiePair);\n    let firstEq = cookiePair.indexOf('=');\n    if (looseMode) {\n        if (firstEq === 0) {\n            // '=' is immediately at start\n            cookiePair = cookiePair.substring(1);\n            firstEq = cookiePair.indexOf('='); // might still need to split on '='\n        }\n    }\n    else {\n        // non-loose mode\n        if (firstEq <= 0) {\n            // no '=' or is at start\n            return undefined; // needs to have non-empty \"cookie-name\"\n        }\n    }\n    let cookieName, cookieValue;\n    if (firstEq <= 0) {\n        cookieName = '';\n        cookieValue = cookiePair.trim();\n    }\n    else {\n        cookieName = cookiePair.slice(0, firstEq).trim();\n        cookieValue = cookiePair.slice(firstEq + 1).trim();\n    }\n    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {\n        return undefined;\n    }\n    const c = new Cookie();\n    c.key = cookieName;\n    c.value = cookieValue;\n    return c;\n}\nfunction parse(str, options) {\n    if (validators.isEmptyString(str) || !validators.isString(str)) {\n        return undefined;\n    }\n    str = str.trim();\n    // We use a regex to parse the \"name-value-pair\" part of S5.2\n    const firstSemi = str.indexOf(';'); // S5.2 step 1\n    const cookiePair = firstSemi === -1 ? str : str.slice(0, firstSemi);\n    const c = parseCookiePair(cookiePair, options?.loose ?? false);\n    if (!c) {\n        return undefined;\n    }\n    if (firstSemi === -1) {\n        return c;\n    }\n    // S5.2.3 \"unparsed-attributes consist of the remainder of the set-cookie-string\n    // (including the %x3B (\";\") in question).\" plus later on in the same section\n    // \"discard the first \";\" and trim\".\n    const unparsed = str.slice(firstSemi + 1).trim();\n    // \"If the unparsed-attributes string is empty, skip the rest of these\n    // steps.\"\n    if (unparsed.length === 0) {\n        return c;\n    }\n    /*\n     * S5.2 says that when looping over the items \"[p]rocess the attribute-name\n     * and attribute-value according to the requirements in the following\n     * subsections\" for every item.  Plus, for many of the individual attributes\n     * in S5.3 it says to use the \"attribute-value of the last attribute in the\n     * cookie-attribute-list\".  Therefore, in this implementation, we overwrite\n     * the previous value.\n     */\n    const cookie_avs = unparsed.split(';');\n    while (cookie_avs.length) {\n        const av = (cookie_avs.shift() ?? '').trim();\n        if (av.length === 0) {\n            // happens if \";;\" appears\n            continue;\n        }\n        const av_sep = av.indexOf('=');\n        let av_key, av_value;\n        if (av_sep === -1) {\n            av_key = av;\n            av_value = null;\n        }\n        else {\n            av_key = av.slice(0, av_sep);\n            av_value = av.slice(av_sep + 1);\n        }\n        av_key = av_key.trim().toLowerCase();\n        if (av_value) {\n            av_value = av_value.trim();\n        }\n        switch (av_key) {\n            case 'expires': // S5.2.1\n                if (av_value) {\n                    const exp = (0, parseDate_1.parseDate)(av_value);\n                    // \"If the attribute-value failed to parse as a cookie date, ignore the\n                    // cookie-av.\"\n                    if (exp) {\n                        // over and underflow not realistically a concern: V8's getTime() seems to\n                        // store something larger than a 32-bit time_t (even with 32-bit node)\n                        c.expires = exp;\n                    }\n                }\n                break;\n            case 'max-age': // S5.2.2\n                if (av_value) {\n                    // \"If the first character of the attribute-value is not a DIGIT or a \"-\"\n                    // character ...[or]... If the remainder of attribute-value contains a\n                    // non-DIGIT character, ignore the cookie-av.\"\n                    if (/^-?[0-9]+$/.test(av_value)) {\n                        const delta = parseInt(av_value, 10);\n                        // \"If delta-seconds is less than or equal to zero (0), let expiry-time\n                        // be the earliest representable date and time.\"\n                        c.setMaxAge(delta);\n                    }\n                }\n                break;\n            case 'domain': // S5.2.3\n                // \"If the attribute-value is empty, the behavior is undefined.  However,\n                // the user agent SHOULD ignore the cookie-av entirely.\"\n                if (av_value) {\n                    // S5.2.3 \"Let cookie-domain be the attribute-value without the leading %x2E\n                    // (\".\") character.\"\n                    const domain = av_value.trim().replace(/^\\./, '');\n                    if (domain) {\n                        // \"Convert the cookie-domain to lower case.\"\n                        c.domain = domain.toLowerCase();\n                    }\n                }\n                break;\n            case 'path': // S5.2.4\n                /*\n                 * \"If the attribute-value is empty or if the first character of the\n                 * attribute-value is not %x2F (\"/\"):\n                 *   Let cookie-path be the default-path.\n                 * Otherwise:\n                 *   Let cookie-path be the attribute-value.\"\n                 *\n                 * We'll represent the default-path as null since it depends on the\n                 * context of the parsing.\n                 */\n                c.path = av_value && av_value[0] === '/' ? av_value : null;\n                break;\n            case 'secure': // S5.2.5\n                /*\n                 * \"If the attribute-name case-insensitively matches the string \"Secure\",\n                 * the user agent MUST append an attribute to the cookie-attribute-list\n                 * with an attribute-name of Secure and an empty attribute-value.\"\n                 */\n                c.secure = true;\n                break;\n            case 'httponly': // S5.2.6 -- effectively the same as 'secure'\n                c.httpOnly = true;\n                break;\n            case 'samesite': // RFC6265bis-02 S5.3.7\n                switch (av_value ? av_value.toLowerCase() : '') {\n                    case 'strict':\n                        c.sameSite = 'strict';\n                        break;\n                    case 'lax':\n                        c.sameSite = 'lax';\n                        break;\n                    case 'none':\n                        c.sameSite = 'none';\n                        break;\n                    default:\n                        c.sameSite = undefined;\n                        break;\n                }\n                break;\n            default:\n                c.extensions = c.extensions || [];\n                c.extensions.push(av);\n                break;\n        }\n    }\n    return c;\n}\nfunction fromJSON(str) {\n    if (!str || validators.isEmptyString(str)) {\n        return undefined;\n    }\n    let obj;\n    if (typeof str === 'string') {\n        try {\n            obj = JSON.parse(str);\n        }\n        catch {\n            return undefined;\n        }\n    }\n    else {\n        // assume it's an Object\n        obj = str;\n    }\n    const c = new Cookie();\n    Cookie.serializableProperties.forEach((prop) => {\n        if (obj && typeof obj === 'object' && (0, utils_1.inOperator)(prop, obj)) {\n            const val = obj[prop];\n            if (val === undefined) {\n                return;\n            }\n            if ((0, utils_1.inOperator)(prop, cookieDefaults) && val === cookieDefaults[prop]) {\n                return;\n            }\n            switch (prop) {\n                case 'key':\n                case 'value':\n                case 'sameSite':\n                    if (typeof val === 'string') {\n                        c[prop] = val;\n                    }\n                    break;\n                case 'expires':\n                case 'creation':\n                case 'lastAccessed':\n                    if (typeof val === 'number' ||\n                        typeof val === 'string' ||\n                        val instanceof Date) {\n                        c[prop] = obj[prop] == 'Infinity' ? 'Infinity' : new Date(val);\n                    }\n                    else if (val === null) {\n                        c[prop] = null;\n                    }\n                    break;\n                case 'maxAge':\n                    if (typeof val === 'number' ||\n                        val === 'Infinity' ||\n                        val === '-Infinity') {\n                        c[prop] = val;\n                    }\n                    break;\n                case 'domain':\n                case 'path':\n                    if (typeof val === 'string' || val === null) {\n                        c[prop] = val;\n                    }\n                    break;\n                case 'secure':\n                case 'httpOnly':\n                    if (typeof val === 'boolean') {\n                        c[prop] = val;\n                    }\n                    break;\n                case 'extensions':\n                    if (Array.isArray(val) &&\n                        val.every((item) => typeof item === 'string')) {\n                        c[prop] = val;\n                    }\n                    break;\n                case 'hostOnly':\n                case 'pathIsDefault':\n                    if (typeof val === 'boolean' || val === null) {\n                        c[prop] = val;\n                    }\n                    break;\n            }\n        }\n    });\n    return c;\n}\nconst cookieDefaults = {\n    // the order in which the RFC has them:\n    key: '',\n    value: '',\n    expires: 'Infinity',\n    maxAge: null,\n    domain: null,\n    path: null,\n    secure: false,\n    httpOnly: false,\n    extensions: null,\n    // set by the CookieJar:\n    hostOnly: null,\n    pathIsDefault: null,\n    creation: null,\n    lastAccessed: null,\n    sameSite: undefined,\n};\n/**\n * An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to a user's web browser.\n * It is defined in {@link https://www.rfc-editor.org/rfc/rfc6265.html | RFC6265}.\n * @public\n */\nclass Cookie {\n    /**\n     * Create a new Cookie instance.\n     * @public\n     * @param options - The attributes to set on the cookie\n     */\n    constructor(options = {}) {\n        this.key = options.key ?? cookieDefaults.key;\n        this.value = options.value ?? cookieDefaults.value;\n        this.expires = options.expires ?? cookieDefaults.expires;\n        this.maxAge = options.maxAge ?? cookieDefaults.maxAge;\n        this.domain = options.domain ?? cookieDefaults.domain;\n        this.path = options.path ?? cookieDefaults.path;\n        this.secure = options.secure ?? cookieDefaults.secure;\n        this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;\n        this.extensions = options.extensions ?? cookieDefaults.extensions;\n        this.creation = options.creation ?? cookieDefaults.creation;\n        this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;\n        this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;\n        this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;\n        this.sameSite = options.sameSite ?? cookieDefaults.sameSite;\n        this.creation = options.creation ?? new Date();\n        // used to break creation ties in cookieCompare():\n        Object.defineProperty(this, 'creationIndex', {\n            configurable: false,\n            enumerable: false, // important for assert.deepEqual checks\n            writable: true,\n            value: ++Cookie.cookiesCreated,\n        });\n        // Duplicate operation, but it makes TypeScript happy...\n        this.creationIndex = Cookie.cookiesCreated;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        const now = Date.now();\n        const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : '?';\n        const createAge = this.creation && this.creation !== 'Infinity'\n            ? `${String(now - this.creation.getTime())}ms`\n            : '?';\n        const accessAge = this.lastAccessed && this.lastAccessed !== 'Infinity'\n            ? `${String(now - this.lastAccessed.getTime())}ms`\n            : '?';\n        return `Cookie=\"${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}\"`;\n    }\n    /**\n     * For convenience in using `JSON.stringify(cookie)`. Returns a plain-old Object that can be JSON-serialized.\n     *\n     * @remarks\n     * - Any `Date` properties (such as {@link Cookie.expires}, {@link Cookie.creation}, and {@link Cookie.lastAccessed}) are exported in ISO format (`Date.toISOString()`).\n     *\n     *  - Custom Cookie properties are discarded. In tough-cookie 1.x, since there was no {@link Cookie.toJSON} method explicitly defined, all enumerable properties were captured.\n     *      If you want a property to be serialized, add the property name to {@link Cookie.serializableProperties}.\n     */\n    toJSON() {\n        const obj = {};\n        for (const prop of Cookie.serializableProperties) {\n            const val = this[prop];\n            if (val === cookieDefaults[prop]) {\n                continue; // leave as prototype default\n            }\n            switch (prop) {\n                case 'key':\n                case 'value':\n                case 'sameSite':\n                    if (typeof val === 'string') {\n                        obj[prop] = val;\n                    }\n                    break;\n                case 'expires':\n                case 'creation':\n                case 'lastAccessed':\n                    if (typeof val === 'number' ||\n                        typeof val === 'string' ||\n                        val instanceof Date) {\n                        obj[prop] =\n                            val == 'Infinity' ? 'Infinity' : new Date(val).toISOString();\n                    }\n                    else if (val === null) {\n                        obj[prop] = null;\n                    }\n                    break;\n                case 'maxAge':\n                    if (typeof val === 'number' ||\n                        val === 'Infinity' ||\n                        val === '-Infinity') {\n                        obj[prop] = val;\n                    }\n                    break;\n                case 'domain':\n                case 'path':\n                    if (typeof val === 'string' || val === null) {\n                        obj[prop] = val;\n                    }\n                    break;\n                case 'secure':\n                case 'httpOnly':\n                    if (typeof val === 'boolean') {\n                        obj[prop] = val;\n                    }\n                    break;\n                case 'extensions':\n                    if (Array.isArray(val)) {\n                        obj[prop] = val;\n                    }\n                    break;\n                case 'hostOnly':\n                case 'pathIsDefault':\n                    if (typeof val === 'boolean' || val === null) {\n                        obj[prop] = val;\n                    }\n                    break;\n            }\n        }\n        return obj;\n    }\n    /**\n     * Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.\n     * @public\n     */\n    clone() {\n        return fromJSON(this.toJSON());\n    }\n    /**\n     * Validates cookie attributes for semantic correctness. Useful for \"lint\" checking any `Set-Cookie` headers you generate.\n     * For now, it returns a boolean, but eventually could return a reason string.\n     *\n     * @remarks\n     * Works for a few things, but is by no means comprehensive.\n     *\n     * @beta\n     */\n    validate() {\n        if (!this.value || !COOKIE_OCTETS.test(this.value)) {\n            return false;\n        }\n        if (this.expires != 'Infinity' &&\n            !(this.expires instanceof Date) &&\n            !(0, parseDate_1.parseDate)(this.expires)) {\n            return false;\n        }\n        if (this.maxAge != null &&\n            this.maxAge !== 'Infinity' &&\n            (this.maxAge === '-Infinity' || this.maxAge <= 0)) {\n            return false; // \"Max-Age=\" non-zero-digit *DIGIT\n        }\n        if (this.path != null && !PATH_VALUE.test(this.path)) {\n            return false;\n        }\n        const cdomain = this.cdomain();\n        if (cdomain) {\n            if (cdomain.match(/\\.$/)) {\n                return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this\n            }\n            const suffix = (0, getPublicSuffix_1.getPublicSuffix)(cdomain);\n            if (suffix == null) {\n                // it's a public suffix\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sets the 'Expires' attribute on a cookie.\n     *\n     * @remarks\n     * When given a `string` value it will be parsed with {@link parseDate}. If the value can't be parsed as a cookie date\n     * then the 'Expires' attribute will be set to `\"Infinity\"`.\n     *\n     * @param exp - the new value for the 'Expires' attribute of the cookie.\n     */\n    setExpires(exp) {\n        if (exp instanceof Date) {\n            this.expires = exp;\n        }\n        else {\n            this.expires = (0, parseDate_1.parseDate)(exp) || 'Infinity';\n        }\n    }\n    /**\n     * Sets the 'Max-Age' attribute (in seconds) on a cookie.\n     *\n     * @remarks\n     * Coerces `-Infinity` to `\"-Infinity\"` and `Infinity` to `\"Infinity\"` so it can be serialized to JSON.\n     *\n     * @param age - the new value for the 'Max-Age' attribute (in seconds).\n     */\n    setMaxAge(age) {\n        if (age === Infinity) {\n            this.maxAge = 'Infinity';\n        }\n        else if (age === -Infinity) {\n            this.maxAge = '-Infinity';\n        }\n        else {\n            this.maxAge = age;\n        }\n    }\n    /**\n     * Encodes to a `Cookie` header value (specifically, the {@link Cookie.key} and {@link Cookie.value} properties joined with \"=\").\n     * @public\n     */\n    cookieString() {\n        const val = this.value || '';\n        if (this.key) {\n            return `${this.key}=${val}`;\n        }\n        return val;\n    }\n    /**\n     * Encodes to a `Set-Cookie header` value.\n     * @public\n     */\n    toString() {\n        let str = this.cookieString();\n        if (this.expires != 'Infinity') {\n            if (this.expires instanceof Date) {\n                str += `; Expires=${(0, formatDate_1.formatDate)(this.expires)}`;\n            }\n        }\n        if (this.maxAge != null && this.maxAge != Infinity) {\n            str += `; Max-Age=${String(this.maxAge)}`;\n        }\n        if (this.domain && !this.hostOnly) {\n            str += `; Domain=${this.domain}`;\n        }\n        if (this.path) {\n            str += `; Path=${this.path}`;\n        }\n        if (this.secure) {\n            str += '; Secure';\n        }\n        if (this.httpOnly) {\n            str += '; HttpOnly';\n        }\n        if (this.sameSite && this.sameSite !== 'none') {\n            if (this.sameSite.toLowerCase() ===\n                Cookie.sameSiteCanonical.lax.toLowerCase()) {\n                str += `; SameSite=${Cookie.sameSiteCanonical.lax}`;\n            }\n            else if (this.sameSite.toLowerCase() ===\n                Cookie.sameSiteCanonical.strict.toLowerCase()) {\n                str += `; SameSite=${Cookie.sameSiteCanonical.strict}`;\n            }\n            else {\n                str += `; SameSite=${this.sameSite}`;\n            }\n        }\n        if (this.extensions) {\n            this.extensions.forEach((ext) => {\n                str += `; ${ext}`;\n            });\n        }\n        return str;\n    }\n    /**\n     * Computes the TTL relative to now (milliseconds).\n     *\n     * @remarks\n     * - `Infinity` is returned for cookies without an explicit expiry\n     *\n     * - `0` is returned if the cookie is expired.\n     *\n     * - Otherwise a time-to-live in milliseconds is returned.\n     *\n     * @param now - passing an explicit value is mostly used for testing purposes since this defaults to the `Date.now()`\n     * @public\n     */\n    TTL(now = Date.now()) {\n        // TTL() partially replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\n        // elsewhere)\n        // S5.3 says to give the \"latest representable date\" for which we use Infinity\n        // For \"expired\" we use 0\n        // -----\n        // RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires\n        // attribute, the Max-Age attribute has precedence and controls the\n        // expiration date of the cookie.\n        // (Concurs with S5.3 step 3)\n        if (this.maxAge != null && typeof this.maxAge === 'number') {\n            return this.maxAge <= 0 ? 0 : this.maxAge * 1000;\n        }\n        const expires = this.expires;\n        if (expires === 'Infinity') {\n            return Infinity;\n        }\n        return (expires?.getTime() ?? now) - (now || Date.now());\n    }\n    /**\n     * Computes the absolute unix-epoch milliseconds that this cookie expires.\n     *\n     * The \"Max-Age\" attribute takes precedence over \"Expires\" (as per the RFC). The {@link Cookie.lastAccessed} attribute\n     * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.\n     *\n     * If Expires ({@link Cookie.expires}) is set, that's returned.\n     *\n     * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the \"Max-Age\" value\n     */\n    expiryTime(now) {\n        // expiryTime() replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie() elsewhere)\n        if (this.maxAge != null) {\n            const relativeTo = now || this.lastAccessed || new Date();\n            const maxAge = typeof this.maxAge === 'number' ? this.maxAge : -Infinity;\n            const age = maxAge <= 0 ? -Infinity : maxAge * 1000;\n            if (relativeTo === 'Infinity') {\n                return Infinity;\n            }\n            return relativeTo.getTime() + age;\n        }\n        if (this.expires == 'Infinity') {\n            return Infinity;\n        }\n        return this.expires ? this.expires.getTime() : undefined;\n    }\n    /**\n     * Similar to {@link Cookie.expiryTime}, computes the absolute unix-epoch milliseconds that this cookie expires and returns it as a Date.\n     *\n     * The \"Max-Age\" attribute takes precedence over \"Expires\" (as per the RFC). The {@link Cookie.lastAccessed} attribute\n     * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.\n     *\n     * If Expires ({@link Cookie.expires}) is set, that's returned.\n     *\n     * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the \"Max-Age\" value\n     */\n    expiryDate(now) {\n        const millisec = this.expiryTime(now);\n        if (millisec == Infinity) {\n            // The 31-bit value of 2147483647000 was chosen to be the MAX_TIME representable\n            // in tough-cookie though MDN states that the actual maximum value for a Date is 8.64e15.\n            // I'm guessing this is due to the Y2038 problem that would affect systems that store\n            // unix time as 32-bit integers.\n            // See:\n            // - https://github.com/salesforce/tough-cookie/commit/0616f70bf725e00c63d442544ad230c4f8b23357\n            // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#the_epoch_timestamps_and_invalid_date\n            // - https://en.wikipedia.org/wiki/Year_2038_problem\n            return new Date(2147483647000);\n        }\n        else if (millisec == -Infinity) {\n            return new Date(0);\n        }\n        else {\n            return millisec == undefined ? undefined : new Date(millisec);\n        }\n    }\n    /**\n     * Indicates if the cookie has been persisted to a store or not.\n     * @public\n     */\n    isPersistent() {\n        // This replaces the \"persistent-flag\" parts of S5.3 step 3\n        return this.maxAge != null || this.expires != 'Infinity';\n    }\n    /**\n     * Calls {@link canonicalDomain} with the {@link Cookie.domain} property.\n     * @public\n     */\n    canonicalizedDomain() {\n        // Mostly S5.1.2 and S5.2.3:\n        return (0, canonicalDomain_1.canonicalDomain)(this.domain);\n    }\n    /**\n     * Alias for {@link Cookie.canonicalizedDomain}\n     * @public\n     */\n    cdomain() {\n        return (0, canonicalDomain_1.canonicalDomain)(this.domain);\n    }\n    /**\n     * Parses a string into a Cookie object.\n     *\n     * @remarks\n     * Note: when parsing a `Cookie` header it must be split by ';' before each Cookie string can be parsed.\n     *\n     * @example\n     * ```\n     * // parse a `Set-Cookie` header\n     * const setCookieHeader = 'a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT'\n     * const cookie = Cookie.parse(setCookieHeader)\n     * cookie.key === 'a'\n     * cookie.value === 'bcd'\n     * cookie.expires === new Date(Date.parse('Tue, 18 Oct 2011 07:05:03 GMT'))\n     * ```\n     *\n     * @example\n     * ```\n     * // parse a `Cookie` header\n     * const cookieHeader = 'name=value; name2=value2; name3=value3'\n     * const cookies = cookieHeader.split(';').map(Cookie.parse)\n     * cookies[0].name === 'name'\n     * cookies[0].value === 'value'\n     * cookies[1].name === 'name2'\n     * cookies[1].value === 'value2'\n     * cookies[2].name === 'name3'\n     * cookies[2].value === 'value3'\n     * ```\n     *\n     * @param str - The `Set-Cookie` header or a Cookie string to parse.\n     * @param options - Configures `strict` or `loose` mode for cookie parsing\n     */\n    static parse(str, options) {\n        return parse(str, options);\n    }\n    /**\n     * Does the reverse of {@link Cookie.toJSON}.\n     *\n     * @remarks\n     * Any Date properties (such as .expires, .creation, and .lastAccessed) are parsed via Date.parse, not tough-cookie's parseDate, since ISO timestamps are being handled at this layer.\n     *\n     * @example\n     * ```\n     * const json = JSON.stringify({\n     *   key: 'alpha',\n     *   value: 'beta',\n     *   domain: 'example.com',\n     *   path: '/foo',\n     *   expires: '2038-01-19T03:14:07.000Z',\n     * })\n     * const cookie = Cookie.fromJSON(json)\n     * cookie.key === 'alpha'\n     * cookie.value === 'beta'\n     * cookie.domain === 'example.com'\n     * cookie.path === '/foo'\n     * cookie.expires === new Date(Date.parse('2038-01-19T03:14:07.000Z'))\n     * ```\n     *\n     * @param str - An unparsed JSON string or a value that has already been parsed as JSON\n     */\n    static fromJSON(str) {\n        return fromJSON(str);\n    }\n}\nexports.Cookie = Cookie;\nCookie.cookiesCreated = 0;\n/**\n * @internal\n */\nCookie.sameSiteLevel = {\n    strict: 3,\n    lax: 2,\n    none: 1,\n};\n/**\n * @internal\n */\nCookie.sameSiteCanonical = {\n    strict: 'Strict',\n    lax: 'Lax',\n};\n/**\n * Cookie properties that will be serialized when using {@link Cookie.fromJSON} and {@link Cookie.toJSON}.\n * @public\n */\nCookie.serializableProperties = [\n    'key',\n    'value',\n    'expires',\n    'maxAge',\n    'domain',\n    'path',\n    'secure',\n    'httpOnly',\n    'extensions',\n    'hostOnly',\n    'pathIsDefault',\n    'creation',\n    'lastAccessed',\n    'sameSite',\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvY29va2llLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsbUdBQW9CO0FBQ3RELGdDQUFnQyxtQkFBTyxDQUFDLHlGQUFlO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLCtFQUFVO0FBQ2xDLHFCQUFxQixtQkFBTyxDQUFDLCtGQUFjO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUFhO0FBQ3pDLDBCQUEwQixtQkFBTyxDQUFDLHlHQUFtQjtBQUNyRDtBQUNBLGdDQUFnQztBQUNoQztBQUNBLG1FQUFtRTtBQUNuRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBNEQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0NBQXNDO0FBQ3ZEO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDO0FBQzNEO0FBQ0EsMEJBQTBCLGtCQUFrQixXQUFXLFdBQVcsT0FBTyxZQUFZLE9BQU8sVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQixHQUFHLHNCQUFzQixPQUFPLDBCQUEwQjtBQUN4SDtBQUNBLDJGQUEyRixxQkFBcUI7QUFDaEgsK0VBQStFLG9DQUFvQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGtCQUFrQixLQUFLLG9CQUFvQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVMsR0FBRyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVSwyQ0FBMkM7QUFDL0U7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUyxZQUFZO0FBQzNDO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxVQUFVO0FBQ3ZDO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXLDZCQUE2QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxnQ0FBZ0M7QUFDckU7QUFDQTtBQUNBLDBCQUEwQixXQUFXLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRSxJQUFJO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDJCQUEyQjtBQUNqSCxnRUFBZ0UscUJBQXFCO0FBQ3JGO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHNFQUFzRSwwQkFBMEI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBLHNGQUFzRiwyQkFBMkI7QUFDakgsZ0VBQWdFLHFCQUFxQjtBQUNyRjtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzRUFBc0UsMEJBQTBCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCLFVBQVUscUJBQXFCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHVCQUF1QixLQUFLLG9CQUFvQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvY29va2llL2Nvb2tpZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db29raWUgPSB2b2lkIDA7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDIwLCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuY29uc3QgZ2V0UHVibGljU3VmZml4XzEgPSByZXF1aXJlKFwiLi4vZ2V0UHVibGljU3VmZml4XCIpO1xuY29uc3QgdmFsaWRhdG9ycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdmFsaWRhdG9yc1wiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgZm9ybWF0RGF0ZV8xID0gcmVxdWlyZShcIi4vZm9ybWF0RGF0ZVwiKTtcbmNvbnN0IHBhcnNlRGF0ZV8xID0gcmVxdWlyZShcIi4vcGFyc2VEYXRlXCIpO1xuY29uc3QgY2Fub25pY2FsRG9tYWluXzEgPSByZXF1aXJlKFwiLi9jYW5vbmljYWxEb21haW5cIik7XG4vLyBGcm9tIFJGQzYyNjUgUzQuMS4xXG4vLyBub3RlIHRoYXQgaXQgZXhjbHVkZXMgXFx4M0IgXCI7XCJcbmNvbnN0IENPT0tJRV9PQ1RFVFMgPSAvXltcXHgyMVxceDIzLVxceDJCXFx4MkQtXFx4M0FcXHgzQy1cXHg1QlxceDVELVxceDdFXSskLztcbi8vIFJGQzYyNjUgUzQuMS4xIGRlZmluZXMgcGF0aCB2YWx1ZSBhcyAnYW55IENIQVIgZXhjZXB0IENUTHMgb3IgXCI7XCInXG4vLyBOb3RlICc7JyBpcyBcXHgzQlxuY29uc3QgUEFUSF9WQUxVRSA9IC9bXFx4MjAtXFx4M0FcXHgzQy1cXHg3RV0rLztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCBDT05UUk9MX0NIQVJTID0gL1tcXHgwMC1cXHgxRl0vO1xuLy8gRnJvbSBDaHJvbWl1bSAvLyAnXFxyJywgJ1xcbicgYW5kICdcXDAnIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdGVybWluYXRvciBpblxuLy8gdGhlIFwicmVsYXhlZFwiIG1vZGUsIHNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9DaHJvbWl1bVdlYkFwcHMvY2hyb21pdW0vYmxvYi9iM2QzYjRkYThiYjk0YzFiMmUwNjE2MDBkZjEwNmQ1OTBmZGEzNjIwL25ldC9jb29raWVzL3BhcnNlZF9jb29raWUuY2MjTDYwXG5jb25zdCBURVJNSU5BVE9SUyA9IFsnXFxuJywgJ1xccicsICdcXDAnXTtcbmZ1bmN0aW9uIHRyaW1UZXJtaW5hdG9yKHN0cikge1xuICAgIGlmICh2YWxpZGF0b3JzLmlzRW1wdHlTdHJpbmcoc3RyKSlcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IFRFUk1JTkFUT1JTLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIGNvbnN0IHRlcm1pbmF0b3IgPSBURVJNSU5BVE9SU1t0XTtcbiAgICAgICAgY29uc3QgdGVybWluYXRvcklkeCA9IHRlcm1pbmF0b3IgPyBzdHIuaW5kZXhPZih0ZXJtaW5hdG9yKSA6IC0xO1xuICAgICAgICBpZiAodGVybWluYXRvcklkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCB0ZXJtaW5hdG9ySWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gcGFyc2VDb29raWVQYWlyKGNvb2tpZVBhaXIsIGxvb3NlTW9kZSkge1xuICAgIGNvb2tpZVBhaXIgPSB0cmltVGVybWluYXRvcihjb29raWVQYWlyKTtcbiAgICBsZXQgZmlyc3RFcSA9IGNvb2tpZVBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChsb29zZU1vZGUpIHtcbiAgICAgICAgaWYgKGZpcnN0RXEgPT09IDApIHtcbiAgICAgICAgICAgIC8vICc9JyBpcyBpbW1lZGlhdGVseSBhdCBzdGFydFxuICAgICAgICAgICAgY29va2llUGFpciA9IGNvb2tpZVBhaXIuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgZmlyc3RFcSA9IGNvb2tpZVBhaXIuaW5kZXhPZignPScpOyAvLyBtaWdodCBzdGlsbCBuZWVkIHRvIHNwbGl0IG9uICc9J1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBub24tbG9vc2UgbW9kZVxuICAgICAgICBpZiAoZmlyc3RFcSA8PSAwKSB7XG4gICAgICAgICAgICAvLyBubyAnPScgb3IgaXMgYXQgc3RhcnRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIG5lZWRzIHRvIGhhdmUgbm9uLWVtcHR5IFwiY29va2llLW5hbWVcIlxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb29raWVOYW1lLCBjb29raWVWYWx1ZTtcbiAgICBpZiAoZmlyc3RFcSA8PSAwKSB7XG4gICAgICAgIGNvb2tpZU5hbWUgPSAnJztcbiAgICAgICAgY29va2llVmFsdWUgPSBjb29raWVQYWlyLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvb2tpZU5hbWUgPSBjb29raWVQYWlyLnNsaWNlKDAsIGZpcnN0RXEpLnRyaW0oKTtcbiAgICAgICAgY29va2llVmFsdWUgPSBjb29raWVQYWlyLnNsaWNlKGZpcnN0RXEgKyAxKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChDT05UUk9MX0NIQVJTLnRlc3QoY29va2llTmFtZSkgfHwgQ09OVFJPTF9DSEFSUy50ZXN0KGNvb2tpZVZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjID0gbmV3IENvb2tpZSgpO1xuICAgIGMua2V5ID0gY29va2llTmFtZTtcbiAgICBjLnZhbHVlID0gY29va2llVmFsdWU7XG4gICAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsaWRhdG9ycy5pc0VtcHR5U3RyaW5nKHN0cikgfHwgIXZhbGlkYXRvcnMuaXNTdHJpbmcoc3RyKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIC8vIFdlIHVzZSBhIHJlZ2V4IHRvIHBhcnNlIHRoZSBcIm5hbWUtdmFsdWUtcGFpclwiIHBhcnQgb2YgUzUuMlxuICAgIGNvbnN0IGZpcnN0U2VtaSA9IHN0ci5pbmRleE9mKCc7Jyk7IC8vIFM1LjIgc3RlcCAxXG4gICAgY29uc3QgY29va2llUGFpciA9IGZpcnN0U2VtaSA9PT0gLTEgPyBzdHIgOiBzdHIuc2xpY2UoMCwgZmlyc3RTZW1pKTtcbiAgICBjb25zdCBjID0gcGFyc2VDb29raWVQYWlyKGNvb2tpZVBhaXIsIG9wdGlvbnM/Lmxvb3NlID8/IGZhbHNlKTtcbiAgICBpZiAoIWMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGZpcnN0U2VtaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIC8vIFM1LjIuMyBcInVucGFyc2VkLWF0dHJpYnV0ZXMgY29uc2lzdCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzZXQtY29va2llLXN0cmluZ1xuICAgIC8vIChpbmNsdWRpbmcgdGhlICV4M0IgKFwiO1wiKSBpbiBxdWVzdGlvbikuXCIgcGx1cyBsYXRlciBvbiBpbiB0aGUgc2FtZSBzZWN0aW9uXG4gICAgLy8gXCJkaXNjYXJkIHRoZSBmaXJzdCBcIjtcIiBhbmQgdHJpbVwiLlxuICAgIGNvbnN0IHVucGFyc2VkID0gc3RyLnNsaWNlKGZpcnN0U2VtaSArIDEpLnRyaW0oKTtcbiAgICAvLyBcIklmIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHN0cmluZyBpcyBlbXB0eSwgc2tpcCB0aGUgcmVzdCBvZiB0aGVzZVxuICAgIC8vIHN0ZXBzLlwiXG4gICAgaWYgKHVucGFyc2VkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgLypcbiAgICAgKiBTNS4yIHNheXMgdGhhdCB3aGVuIGxvb3Bpbmcgb3ZlciB0aGUgaXRlbXMgXCJbcF1yb2Nlc3MgdGhlIGF0dHJpYnV0ZS1uYW1lXG4gICAgICogYW5kIGF0dHJpYnV0ZS12YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIHJlcXVpcmVtZW50cyBpbiB0aGUgZm9sbG93aW5nXG4gICAgICogc3Vic2VjdGlvbnNcIiBmb3IgZXZlcnkgaXRlbS4gIFBsdXMsIGZvciBtYW55IG9mIHRoZSBpbmRpdmlkdWFsIGF0dHJpYnV0ZXNcbiAgICAgKiBpbiBTNS4zIGl0IHNheXMgdG8gdXNlIHRoZSBcImF0dHJpYnV0ZS12YWx1ZSBvZiB0aGUgbGFzdCBhdHRyaWJ1dGUgaW4gdGhlXG4gICAgICogY29va2llLWF0dHJpYnV0ZS1saXN0XCIuICBUaGVyZWZvcmUsIGluIHRoaXMgaW1wbGVtZW50YXRpb24sIHdlIG92ZXJ3cml0ZVxuICAgICAqIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgKi9cbiAgICBjb25zdCBjb29raWVfYXZzID0gdW5wYXJzZWQuc3BsaXQoJzsnKTtcbiAgICB3aGlsZSAoY29va2llX2F2cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYXYgPSAoY29va2llX2F2cy5zaGlmdCgpID8/ICcnKS50cmltKCk7XG4gICAgICAgIGlmIChhdi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgaWYgXCI7O1wiIGFwcGVhcnNcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF2X3NlcCA9IGF2LmluZGV4T2YoJz0nKTtcbiAgICAgICAgbGV0IGF2X2tleSwgYXZfdmFsdWU7XG4gICAgICAgIGlmIChhdl9zZXAgPT09IC0xKSB7XG4gICAgICAgICAgICBhdl9rZXkgPSBhdjtcbiAgICAgICAgICAgIGF2X3ZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF2X2tleSA9IGF2LnNsaWNlKDAsIGF2X3NlcCk7XG4gICAgICAgICAgICBhdl92YWx1ZSA9IGF2LnNsaWNlKGF2X3NlcCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGF2X2tleSA9IGF2X2tleS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgICAgICBhdl92YWx1ZSA9IGF2X3ZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGF2X2tleSkge1xuICAgICAgICAgICAgY2FzZSAnZXhwaXJlcyc6IC8vIFM1LjIuMVxuICAgICAgICAgICAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHAgPSAoMCwgcGFyc2VEYXRlXzEucGFyc2VEYXRlKShhdl92YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBmYWlsZWQgdG8gcGFyc2UgYXMgYSBjb29raWUgZGF0ZSwgaWdub3JlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb29raWUtYXYuXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3ZlciBhbmQgdW5kZXJmbG93IG5vdCByZWFsaXN0aWNhbGx5IGEgY29uY2VybjogVjgncyBnZXRUaW1lKCkgc2VlbXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHNvbWV0aGluZyBsYXJnZXIgdGhhbiBhIDMyLWJpdCB0aW1lX3QgKGV2ZW4gd2l0aCAzMi1iaXQgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZXhwaXJlcyA9IGV4cDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21heC1hZ2UnOiAvLyBTNS4yLjJcbiAgICAgICAgICAgICAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90IGEgRElHSVQgb3IgYSBcIi1cIlxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgLi4uW29yXS4uLiBJZiB0aGUgcmVtYWluZGVyIG9mIGF0dHJpYnV0ZS12YWx1ZSBjb250YWlucyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbi1ESUdJVCBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlwiXG4gICAgICAgICAgICAgICAgICAgIGlmICgvXi0/WzAtOV0rJC8udGVzdChhdl92YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gcGFyc2VJbnQoYXZfdmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgZGVsdGEtc2Vjb25kcyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyAoMCksIGxldCBleHBpcnktdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGVhcmxpZXN0IHJlcHJlc2VudGFibGUgZGF0ZSBhbmQgdGltZS5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zZXRNYXhBZ2UoZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9tYWluJzogLy8gUzUuMi4zXG4gICAgICAgICAgICAgICAgLy8gXCJJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5LCB0aGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkLiAgSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBhZ2VudCBTSE9VTEQgaWdub3JlIHRoZSBjb29raWUtYXYgZW50aXJlbHkuXCJcbiAgICAgICAgICAgICAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUzUuMi4zIFwiTGV0IGNvb2tpZS1kb21haW4gYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZSB3aXRob3V0IHRoZSBsZWFkaW5nICV4MkVcbiAgICAgICAgICAgICAgICAgICAgLy8gKFwiLlwiKSBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gYXZfdmFsdWUudHJpbSgpLnJlcGxhY2UoL15cXC4vLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiQ29udmVydCB0aGUgY29va2llLWRvbWFpbiB0byBsb3dlciBjYXNlLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmRvbWFpbiA9IGRvbWFpbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGF0aCc6IC8vIFM1LjIuNFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogXCJJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gICAgICAgICAgICAgICAgICogYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gICAgICAgICAgICAgICAgICogICBMZXQgY29va2llLXBhdGggYmUgdGhlIGRlZmF1bHQtcGF0aC5cbiAgICAgICAgICAgICAgICAgKiBPdGhlcndpc2U6XG4gICAgICAgICAgICAgICAgICogICBMZXQgY29va2llLXBhdGggYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cIlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogV2UnbGwgcmVwcmVzZW50IHRoZSBkZWZhdWx0LXBhdGggYXMgbnVsbCBzaW5jZSBpdCBkZXBlbmRzIG9uIHRoZVxuICAgICAgICAgICAgICAgICAqIGNvbnRleHQgb2YgdGhlIHBhcnNpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYy5wYXRoID0gYXZfdmFsdWUgJiYgYXZfdmFsdWVbMF0gPT09ICcvJyA/IGF2X3ZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY3VyZSc6IC8vIFM1LjIuNVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogXCJJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlNlY3VyZVwiLFxuICAgICAgICAgICAgICAgICAqIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0XG4gICAgICAgICAgICAgICAgICogd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBTZWN1cmUgYW5kIGFuIGVtcHR5IGF0dHJpYnV0ZS12YWx1ZS5cIlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGMuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2h0dHBvbmx5JzogLy8gUzUuMi42IC0tIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzICdzZWN1cmUnXG4gICAgICAgICAgICAgICAgYy5odHRwT25seSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzYW1lc2l0ZSc6IC8vIFJGQzYyNjViaXMtMDIgUzUuMy43XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdl92YWx1ZSA/IGF2X3ZhbHVlLnRvTG93ZXJDYXNlKCkgOiAnJykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zYW1lU2l0ZSA9ICdzdHJpY3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xheCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnNhbWVTaXRlID0gJ2xheCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnNhbWVTaXRlID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnNhbWVTaXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjLmV4dGVuc2lvbnMgPSBjLmV4dGVuc2lvbnMgfHwgW107XG4gICAgICAgICAgICAgICAgYy5leHRlbnNpb25zLnB1c2goYXYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuZnVuY3Rpb24gZnJvbUpTT04oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgdmFsaWRhdG9ycy5pc0VtcHR5U3RyaW5nKHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG9iajtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9iaiA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhc3N1bWUgaXQncyBhbiBPYmplY3RcbiAgICAgICAgb2JqID0gc3RyO1xuICAgIH1cbiAgICBjb25zdCBjID0gbmV3IENvb2tpZSgpO1xuICAgIENvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAoMCwgdXRpbHNfMS5pbk9wZXJhdG9yKShwcm9wLCBvYmopKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBvYmpbcHJvcF07XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaW5PcGVyYXRvcikocHJvcCwgY29va2llRGVmYXVsdHMpICYmIHZhbCA9PT0gY29va2llRGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzYW1lU2l0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleHBpcmVzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGlvbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFzdEFjY2Vzc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY1twcm9wXSA9IG9ialtwcm9wXSA9PSAnSW5maW5pdHknID8gJ0luZmluaXR5JyA6IG5ldyBEYXRlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjW3Byb3BdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtYXhBZ2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9PT0gJ0luZmluaXR5JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkb21haW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY3VyZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaHR0cE9ubHknOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVuc2lvbnMnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG9zdE9ubHknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGhJc0RlZmF1bHQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjO1xufVxuY29uc3QgY29va2llRGVmYXVsdHMgPSB7XG4gICAgLy8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBSRkMgaGFzIHRoZW06XG4gICAga2V5OiAnJyxcbiAgICB2YWx1ZTogJycsXG4gICAgZXhwaXJlczogJ0luZmluaXR5JyxcbiAgICBtYXhBZ2U6IG51bGwsXG4gICAgZG9tYWluOiBudWxsLFxuICAgIHBhdGg6IG51bGwsXG4gICAgc2VjdXJlOiBmYWxzZSxcbiAgICBodHRwT25seTogZmFsc2UsXG4gICAgZXh0ZW5zaW9uczogbnVsbCxcbiAgICAvLyBzZXQgYnkgdGhlIENvb2tpZUphcjpcbiAgICBob3N0T25seTogbnVsbCxcbiAgICBwYXRoSXNEZWZhdWx0OiBudWxsLFxuICAgIGNyZWF0aW9uOiBudWxsLFxuICAgIGxhc3RBY2Nlc3NlZDogbnVsbCxcbiAgICBzYW1lU2l0ZTogdW5kZWZpbmVkLFxufTtcbi8qKlxuICogQW4gSFRUUCBjb29raWUgKHdlYiBjb29raWUsIGJyb3dzZXIgY29va2llKSBpcyBhIHNtYWxsIHBpZWNlIG9mIGRhdGEgdGhhdCBhIHNlcnZlciBzZW5kcyB0byBhIHVzZXIncyB3ZWIgYnJvd3Nlci5cbiAqIEl0IGlzIGRlZmluZWQgaW4ge0BsaW5rIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1Lmh0bWwgfCBSRkM2MjY1fS5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ29va2llIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQ29va2llIGluc3RhbmNlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBhdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgY29va2llXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMua2V5ID0gb3B0aW9ucy5rZXkgPz8gY29va2llRGVmYXVsdHMua2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZSA/PyBjb29raWVEZWZhdWx0cy52YWx1ZTtcbiAgICAgICAgdGhpcy5leHBpcmVzID0gb3B0aW9ucy5leHBpcmVzID8/IGNvb2tpZURlZmF1bHRzLmV4cGlyZXM7XG4gICAgICAgIHRoaXMubWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgPz8gY29va2llRGVmYXVsdHMubWF4QWdlO1xuICAgICAgICB0aGlzLmRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8/IGNvb2tpZURlZmF1bHRzLmRvbWFpbjtcbiAgICAgICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoID8/IGNvb2tpZURlZmF1bHRzLnBhdGg7XG4gICAgICAgIHRoaXMuc2VjdXJlID0gb3B0aW9ucy5zZWN1cmUgPz8gY29va2llRGVmYXVsdHMuc2VjdXJlO1xuICAgICAgICB0aGlzLmh0dHBPbmx5ID0gb3B0aW9ucy5odHRwT25seSA/PyBjb29raWVEZWZhdWx0cy5odHRwT25seTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zID8/IGNvb2tpZURlZmF1bHRzLmV4dGVuc2lvbnM7XG4gICAgICAgIHRoaXMuY3JlYXRpb24gPSBvcHRpb25zLmNyZWF0aW9uID8/IGNvb2tpZURlZmF1bHRzLmNyZWF0aW9uO1xuICAgICAgICB0aGlzLmhvc3RPbmx5ID0gb3B0aW9ucy5ob3N0T25seSA/PyBjb29raWVEZWZhdWx0cy5ob3N0T25seTtcbiAgICAgICAgdGhpcy5wYXRoSXNEZWZhdWx0ID0gb3B0aW9ucy5wYXRoSXNEZWZhdWx0ID8/IGNvb2tpZURlZmF1bHRzLnBhdGhJc0RlZmF1bHQ7XG4gICAgICAgIHRoaXMubGFzdEFjY2Vzc2VkID0gb3B0aW9ucy5sYXN0QWNjZXNzZWQgPz8gY29va2llRGVmYXVsdHMubGFzdEFjY2Vzc2VkO1xuICAgICAgICB0aGlzLnNhbWVTaXRlID0gb3B0aW9ucy5zYW1lU2l0ZSA/PyBjb29raWVEZWZhdWx0cy5zYW1lU2l0ZTtcbiAgICAgICAgdGhpcy5jcmVhdGlvbiA9IG9wdGlvbnMuY3JlYXRpb24gPz8gbmV3IERhdGUoKTtcbiAgICAgICAgLy8gdXNlZCB0byBicmVhayBjcmVhdGlvbiB0aWVzIGluIGNvb2tpZUNvbXBhcmUoKTpcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjcmVhdGlvbkluZGV4Jywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLCAvLyBpbXBvcnRhbnQgZm9yIGFzc2VydC5kZWVwRXF1YWwgY2hlY2tzXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiArK0Nvb2tpZS5jb29raWVzQ3JlYXRlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIER1cGxpY2F0ZSBvcGVyYXRpb24sIGJ1dCBpdCBtYWtlcyBUeXBlU2NyaXB0IGhhcHB5Li4uXG4gICAgICAgIHRoaXMuY3JlYXRpb25JbmRleCA9IENvb2tpZS5jb29raWVzQ3JlYXRlZDtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBob3N0T25seSA9IHRoaXMuaG9zdE9ubHkgIT0gbnVsbCA/IHRoaXMuaG9zdE9ubHkudG9TdHJpbmcoKSA6ICc/JztcbiAgICAgICAgY29uc3QgY3JlYXRlQWdlID0gdGhpcy5jcmVhdGlvbiAmJiB0aGlzLmNyZWF0aW9uICE9PSAnSW5maW5pdHknXG4gICAgICAgICAgICA/IGAke1N0cmluZyhub3cgLSB0aGlzLmNyZWF0aW9uLmdldFRpbWUoKSl9bXNgXG4gICAgICAgICAgICA6ICc/JztcbiAgICAgICAgY29uc3QgYWNjZXNzQWdlID0gdGhpcy5sYXN0QWNjZXNzZWQgJiYgdGhpcy5sYXN0QWNjZXNzZWQgIT09ICdJbmZpbml0eSdcbiAgICAgICAgICAgID8gYCR7U3RyaW5nKG5vdyAtIHRoaXMubGFzdEFjY2Vzc2VkLmdldFRpbWUoKSl9bXNgXG4gICAgICAgICAgICA6ICc/JztcbiAgICAgICAgcmV0dXJuIGBDb29raWU9XCIke3RoaXMudG9TdHJpbmcoKX07IGhvc3RPbmx5PSR7aG9zdE9ubHl9OyBhQWdlPSR7YWNjZXNzQWdlfTsgY0FnZT0ke2NyZWF0ZUFnZX1cImA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBjb252ZW5pZW5jZSBpbiB1c2luZyBgSlNPTi5zdHJpbmdpZnkoY29va2llKWAuIFJldHVybnMgYSBwbGFpbi1vbGQgT2JqZWN0IHRoYXQgY2FuIGJlIEpTT04tc2VyaWFsaXplZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogLSBBbnkgYERhdGVgIHByb3BlcnRpZXMgKHN1Y2ggYXMge0BsaW5rIENvb2tpZS5leHBpcmVzfSwge0BsaW5rIENvb2tpZS5jcmVhdGlvbn0sIGFuZCB7QGxpbmsgQ29va2llLmxhc3RBY2Nlc3NlZH0pIGFyZSBleHBvcnRlZCBpbiBJU08gZm9ybWF0IChgRGF0ZS50b0lTT1N0cmluZygpYCkuXG4gICAgICpcbiAgICAgKiAgLSBDdXN0b20gQ29va2llIHByb3BlcnRpZXMgYXJlIGRpc2NhcmRlZC4gSW4gdG91Z2gtY29va2llIDEueCwgc2luY2UgdGhlcmUgd2FzIG5vIHtAbGluayBDb29raWUudG9KU09OfSBtZXRob2QgZXhwbGljaXRseSBkZWZpbmVkLCBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHdlcmUgY2FwdHVyZWQuXG4gICAgICogICAgICBJZiB5b3Ugd2FudCBhIHByb3BlcnR5IHRvIGJlIHNlcmlhbGl6ZWQsIGFkZCB0aGUgcHJvcGVydHkgbmFtZSB0byB7QGxpbmsgQ29va2llLnNlcmlhbGl6YWJsZVByb3BlcnRpZXN9LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcykge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpc1twcm9wXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IGNvb2tpZURlZmF1bHRzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIGxlYXZlIGFzIHByb3RvdHlwZSBkZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzYW1lU2l0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGlyZXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdsYXN0QWNjZXNzZWQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9PSAnSW5maW5pdHknID8gJ0luZmluaXR5JyA6IG5ldyBEYXRlKHZhbCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWF4QWdlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPT09ICdJbmZpbml0eScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9PT0gJy1JbmZpbml0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkb21haW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VjdXJlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdodHRwT25seSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleHRlbnNpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvc3RPbmx5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdwYXRoSXNEZWZhdWx0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIGEgZGVlcCBjbG9uZSBvZiB0aGlzIGNvb2tpZSwgaW1wbGVtZW50ZWQgZXhhY3RseSBhcyBgQ29va2llLmZyb21KU09OKGNvb2tpZS50b0pTT04oKSlgLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KU09OKHRoaXMudG9KU09OKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgY29va2llIGF0dHJpYnV0ZXMgZm9yIHNlbWFudGljIGNvcnJlY3RuZXNzLiBVc2VmdWwgZm9yIFwibGludFwiIGNoZWNraW5nIGFueSBgU2V0LUNvb2tpZWAgaGVhZGVycyB5b3UgZ2VuZXJhdGUuXG4gICAgICogRm9yIG5vdywgaXQgcmV0dXJucyBhIGJvb2xlYW4sIGJ1dCBldmVudHVhbGx5IGNvdWxkIHJldHVybiBhIHJlYXNvbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFdvcmtzIGZvciBhIGZldyB0aGluZ3MsIGJ1dCBpcyBieSBubyBtZWFucyBjb21wcmVoZW5zaXZlLlxuICAgICAqXG4gICAgICogQGJldGFcbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlIHx8ICFDT09LSUVfT0NURVRTLnRlc3QodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHBpcmVzICE9ICdJbmZpbml0eScgJiZcbiAgICAgICAgICAgICEodGhpcy5leHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICAgICAgICEoMCwgcGFyc2VEYXRlXzEucGFyc2VEYXRlKSh0aGlzLmV4cGlyZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMubWF4QWdlICE9PSAnSW5maW5pdHknICYmXG4gICAgICAgICAgICAodGhpcy5tYXhBZ2UgPT09ICctSW5maW5pdHknIHx8IHRoaXMubWF4QWdlIDw9IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFwiTWF4LUFnZT1cIiBub24temVyby1kaWdpdCAqRElHSVRcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRoICE9IG51bGwgJiYgIVBBVEhfVkFMVUUudGVzdCh0aGlzLnBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2RvbWFpbiA9IHRoaXMuY2RvbWFpbigpO1xuICAgICAgICBpZiAoY2RvbWFpbikge1xuICAgICAgICAgICAgaWYgKGNkb21haW4ubWF0Y2goL1xcLiQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gUzQuMS4yLjMgc3VnZ2VzdHMgdGhhdCB0aGlzIGlzIGJhZC4gZG9tYWluTWF0Y2goKSB0ZXN0cyBjb25maXJtIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9ICgwLCBnZXRQdWJsaWNTdWZmaXhfMS5nZXRQdWJsaWNTdWZmaXgpKGNkb21haW4pO1xuICAgICAgICAgICAgaWYgKHN1ZmZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaXQncyBhIHB1YmxpYyBzdWZmaXhcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlICdFeHBpcmVzJyBhdHRyaWJ1dGUgb24gYSBjb29raWUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFdoZW4gZ2l2ZW4gYSBgc3RyaW5nYCB2YWx1ZSBpdCB3aWxsIGJlIHBhcnNlZCB3aXRoIHtAbGluayBwYXJzZURhdGV9LiBJZiB0aGUgdmFsdWUgY2FuJ3QgYmUgcGFyc2VkIGFzIGEgY29va2llIGRhdGVcbiAgICAgKiB0aGVuIHRoZSAnRXhwaXJlcycgYXR0cmlidXRlIHdpbGwgYmUgc2V0IHRvIGBcIkluZmluaXR5XCJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4cCAtIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSAnRXhwaXJlcycgYXR0cmlidXRlIG9mIHRoZSBjb29raWUuXG4gICAgICovXG4gICAgc2V0RXhwaXJlcyhleHApIHtcbiAgICAgICAgaWYgKGV4cCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJlcyA9IGV4cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJlcyA9ICgwLCBwYXJzZURhdGVfMS5wYXJzZURhdGUpKGV4cCkgfHwgJ0luZmluaXR5JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSAnTWF4LUFnZScgYXR0cmlidXRlIChpbiBzZWNvbmRzKSBvbiBhIGNvb2tpZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQ29lcmNlcyBgLUluZmluaXR5YCB0byBgXCItSW5maW5pdHlcImAgYW5kIGBJbmZpbml0eWAgdG8gYFwiSW5maW5pdHlcImAgc28gaXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2UgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgJ01heC1BZ2UnIGF0dHJpYnV0ZSAoaW4gc2Vjb25kcykuXG4gICAgICovXG4gICAgc2V0TWF4QWdlKGFnZSkge1xuICAgICAgICBpZiAoYWdlID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhpcy5tYXhBZ2UgPSAnSW5maW5pdHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFnZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICB0aGlzLm1heEFnZSA9ICctSW5maW5pdHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXhBZ2UgPSBhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0byBhIGBDb29raWVgIGhlYWRlciB2YWx1ZSAoc3BlY2lmaWNhbGx5LCB0aGUge0BsaW5rIENvb2tpZS5rZXl9IGFuZCB7QGxpbmsgQ29va2llLnZhbHVlfSBwcm9wZXJ0aWVzIGpvaW5lZCB3aXRoIFwiPVwiKS5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY29va2llU3RyaW5nKCkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlIHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmtleX09JHt2YWx9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRvIGEgYFNldC1Db29raWUgaGVhZGVyYCB2YWx1ZS5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLmNvb2tpZVN0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5leHBpcmVzICE9ICdJbmZpbml0eScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGA7IEV4cGlyZXM9JHsoMCwgZm9ybWF0RGF0ZV8xLmZvcm1hdERhdGUpKHRoaXMuZXhwaXJlcyl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCAmJiB0aGlzLm1heEFnZSAhPSBJbmZpbml0eSkge1xuICAgICAgICAgICAgc3RyICs9IGA7IE1heC1BZ2U9JHtTdHJpbmcodGhpcy5tYXhBZ2UpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9tYWluICYmICF0aGlzLmhvc3RPbmx5KSB7XG4gICAgICAgICAgICBzdHIgKz0gYDsgRG9tYWluPSR7dGhpcy5kb21haW59YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgICAgICBzdHIgKz0gYDsgUGF0aD0ke3RoaXMucGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlY3VyZSkge1xuICAgICAgICAgICAgc3RyICs9ICc7IFNlY3VyZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaHR0cE9ubHkpIHtcbiAgICAgICAgICAgIHN0ciArPSAnOyBIdHRwT25seSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2FtZVNpdGUgJiYgdGhpcy5zYW1lU2l0ZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgIENvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbC5sYXgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBgOyBTYW1lU2l0ZT0ke0Nvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbC5sYXh9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2FtZVNpdGUudG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICBDb29raWUuc2FtZVNpdGVDYW5vbmljYWwuc3RyaWN0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gYDsgU2FtZVNpdGU9JHtDb29raWUuc2FtZVNpdGVDYW5vbmljYWwuc3RyaWN0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gYDsgU2FtZVNpdGU9JHt0aGlzLnNhbWVTaXRlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0ciArPSBgOyAke2V4dH1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIFRUTCByZWxhdGl2ZSB0byBub3cgKG1pbGxpc2Vjb25kcykuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIC0gYEluZmluaXR5YCBpcyByZXR1cm5lZCBmb3IgY29va2llcyB3aXRob3V0IGFuIGV4cGxpY2l0IGV4cGlyeVxuICAgICAqXG4gICAgICogLSBgMGAgaXMgcmV0dXJuZWQgaWYgdGhlIGNvb2tpZSBpcyBleHBpcmVkLlxuICAgICAqXG4gICAgICogLSBPdGhlcndpc2UgYSB0aW1lLXRvLWxpdmUgaW4gbWlsbGlzZWNvbmRzIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vdyAtIHBhc3NpbmcgYW4gZXhwbGljaXQgdmFsdWUgaXMgbW9zdGx5IHVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgc2luY2UgdGhpcyBkZWZhdWx0cyB0byB0aGUgYERhdGUubm93KClgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIFRUTChub3cgPSBEYXRlLm5vdygpKSB7XG4gICAgICAgIC8vIFRUTCgpIHBhcnRpYWxseSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuICAgICAgICAvLyBlbHNld2hlcmUpXG4gICAgICAgIC8vIFM1LjMgc2F5cyB0byBnaXZlIHRoZSBcImxhdGVzdCByZXByZXNlbnRhYmxlIGRhdGVcIiBmb3Igd2hpY2ggd2UgdXNlIEluZmluaXR5XG4gICAgICAgIC8vIEZvciBcImV4cGlyZWRcIiB3ZSB1c2UgMFxuICAgICAgICAvLyAtLS0tLVxuICAgICAgICAvLyBSRkM2MjY1IFM0LjEuMi4yIElmIGEgY29va2llIGhhcyBib3RoIHRoZSBNYXgtQWdlIGFuZCB0aGUgRXhwaXJlc1xuICAgICAgICAvLyBhdHRyaWJ1dGUsIHRoZSBNYXgtQWdlIGF0dHJpYnV0ZSBoYXMgcHJlY2VkZW5jZSBhbmQgY29udHJvbHMgdGhlXG4gICAgICAgIC8vIGV4cGlyYXRpb24gZGF0ZSBvZiB0aGUgY29va2llLlxuICAgICAgICAvLyAoQ29uY3VycyB3aXRoIFM1LjMgc3RlcCAzKVxuICAgICAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCAmJiB0eXBlb2YgdGhpcy5tYXhBZ2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhBZ2UgPD0gMCA/IDAgOiB0aGlzLm1heEFnZSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwaXJlcyA9IHRoaXMuZXhwaXJlcztcbiAgICAgICAgaWYgKGV4cGlyZXMgPT09ICdJbmZpbml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGV4cGlyZXM/LmdldFRpbWUoKSA/PyBub3cpIC0gKG5vdyB8fCBEYXRlLm5vdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGFic29sdXRlIHVuaXgtZXBvY2ggbWlsbGlzZWNvbmRzIHRoYXQgdGhpcyBjb29raWUgZXhwaXJlcy5cbiAgICAgKlxuICAgICAqIFRoZSBcIk1heC1BZ2VcIiBhdHRyaWJ1dGUgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIFwiRXhwaXJlc1wiIChhcyBwZXIgdGhlIFJGQykuIFRoZSB7QGxpbmsgQ29va2llLmxhc3RBY2Nlc3NlZH0gYXR0cmlidXRlXG4gICAgICogKG9yIHRoZSBgbm93YCBwYXJhbWV0ZXIgaWYgZ2l2ZW4pIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB7QGxpbmsgQ29va2llLm1heEFnZX0gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSWYgRXhwaXJlcyAoe0BsaW5rIENvb2tpZS5leHBpcmVzfSkgaXMgc2V0LCB0aGF0J3MgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm93IC0gY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhIHRpbWUgb2Zmc2V0IChpbnN0ZWFkIG9mIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSkgdG8gdXNlIHdoZW4gY2FsY3VsYXRpbmcgdGhlIFwiTWF4LUFnZVwiIHZhbHVlXG4gICAgICovXG4gICAgZXhwaXJ5VGltZShub3cpIHtcbiAgICAgICAgLy8gZXhwaXJ5VGltZSgpIHJlcGxhY2VzIHRoZSBcImV4cGlyeS10aW1lXCIgcGFydHMgb2YgUzUuMyBzdGVwIDMgKHNldENvb2tpZSgpIGVsc2V3aGVyZSlcbiAgICAgICAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBub3cgfHwgdGhpcy5sYXN0QWNjZXNzZWQgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEFnZSA9IHR5cGVvZiB0aGlzLm1heEFnZSA9PT0gJ251bWJlcicgPyB0aGlzLm1heEFnZSA6IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGNvbnN0IGFnZSA9IG1heEFnZSA8PSAwID8gLUluZmluaXR5IDogbWF4QWdlICogMTAwMDtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVRvID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVG8uZ2V0VGltZSgpICsgYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cGlyZXMgPT0gJ0luZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGlyZXMgPyB0aGlzLmV4cGlyZXMuZ2V0VGltZSgpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIHtAbGluayBDb29raWUuZXhwaXJ5VGltZX0sIGNvbXB1dGVzIHRoZSBhYnNvbHV0ZSB1bml4LWVwb2NoIG1pbGxpc2Vjb25kcyB0aGF0IHRoaXMgY29va2llIGV4cGlyZXMgYW5kIHJldHVybnMgaXQgYXMgYSBEYXRlLlxuICAgICAqXG4gICAgICogVGhlIFwiTWF4LUFnZVwiIGF0dHJpYnV0ZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgXCJFeHBpcmVzXCIgKGFzIHBlciB0aGUgUkZDKS4gVGhlIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSBhdHRyaWJ1dGVcbiAgICAgKiAob3IgdGhlIGBub3dgIHBhcmFtZXRlciBpZiBnaXZlbikgaXMgdXNlZCB0byBvZmZzZXQgdGhlIHtAbGluayBDb29raWUubWF4QWdlfSBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBJZiBFeHBpcmVzICh7QGxpbmsgQ29va2llLmV4cGlyZXN9KSBpcyBzZXQsIHRoYXQncyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub3cgLSBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGEgdGltZSBvZmZzZXQgKGluc3RlYWQgb2Yge0BsaW5rIENvb2tpZS5sYXN0QWNjZXNzZWR9KSB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB0aGUgXCJNYXgtQWdlXCIgdmFsdWVcbiAgICAgKi9cbiAgICBleHBpcnlEYXRlKG5vdykge1xuICAgICAgICBjb25zdCBtaWxsaXNlYyA9IHRoaXMuZXhwaXJ5VGltZShub3cpO1xuICAgICAgICBpZiAobWlsbGlzZWMgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8vIFRoZSAzMS1iaXQgdmFsdWUgb2YgMjE0NzQ4MzY0NzAwMCB3YXMgY2hvc2VuIHRvIGJlIHRoZSBNQVhfVElNRSByZXByZXNlbnRhYmxlXG4gICAgICAgICAgICAvLyBpbiB0b3VnaC1jb29raWUgdGhvdWdoIE1ETiBzdGF0ZXMgdGhhdCB0aGUgYWN0dWFsIG1heGltdW0gdmFsdWUgZm9yIGEgRGF0ZSBpcyA4LjY0ZTE1LlxuICAgICAgICAgICAgLy8gSSdtIGd1ZXNzaW5nIHRoaXMgaXMgZHVlIHRvIHRoZSBZMjAzOCBwcm9ibGVtIHRoYXQgd291bGQgYWZmZWN0IHN5c3RlbXMgdGhhdCBzdG9yZVxuICAgICAgICAgICAgLy8gdW5peCB0aW1lIGFzIDMyLWJpdCBpbnRlZ2Vycy5cbiAgICAgICAgICAgIC8vIFNlZTpcbiAgICAgICAgICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL3NhbGVzZm9yY2UvdG91Z2gtY29va2llL2NvbW1pdC8wNjE2ZjcwYmY3MjVlMDBjNjNkNDQyNTQ0YWQyMzBjNGY4YjIzMzU3XG4gICAgICAgICAgICAvLyAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUjdGhlX2Vwb2NoX3RpbWVzdGFtcHNfYW5kX2ludmFsaWRfZGF0ZVxuICAgICAgICAgICAgLy8gLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ZZWFyXzIwMzhfcHJvYmxlbVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKDIxNDc0ODM2NDcwMDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pbGxpc2VjID09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1pbGxpc2VjID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG5ldyBEYXRlKG1pbGxpc2VjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvb2tpZSBoYXMgYmVlbiBwZXJzaXN0ZWQgdG8gYSBzdG9yZSBvciBub3QuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGlzUGVyc2lzdGVudCgpIHtcbiAgICAgICAgLy8gVGhpcyByZXBsYWNlcyB0aGUgXCJwZXJzaXN0ZW50LWZsYWdcIiBwYXJ0cyBvZiBTNS4zIHN0ZXAgM1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhBZ2UgIT0gbnVsbCB8fCB0aGlzLmV4cGlyZXMgIT0gJ0luZmluaXR5JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMge0BsaW5rIGNhbm9uaWNhbERvbWFpbn0gd2l0aCB0aGUge0BsaW5rIENvb2tpZS5kb21haW59IHByb3BlcnR5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjYW5vbmljYWxpemVkRG9tYWluKCkge1xuICAgICAgICAvLyBNb3N0bHkgUzUuMS4yIGFuZCBTNS4yLjM6XG4gICAgICAgIHJldHVybiAoMCwgY2Fub25pY2FsRG9tYWluXzEuY2Fub25pY2FsRG9tYWluKSh0aGlzLmRvbWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgQ29va2llLmNhbm9uaWNhbGl6ZWREb21haW59XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNkb21haW4oKSB7XG4gICAgICAgIHJldHVybiAoMCwgY2Fub25pY2FsRG9tYWluXzEuY2Fub25pY2FsRG9tYWluKSh0aGlzLmRvbWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0cmluZyBpbnRvIGEgQ29va2llIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogTm90ZTogd2hlbiBwYXJzaW5nIGEgYENvb2tpZWAgaGVhZGVyIGl0IG11c3QgYmUgc3BsaXQgYnkgJzsnIGJlZm9yZSBlYWNoIENvb2tpZSBzdHJpbmcgY2FuIGJlIHBhcnNlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogLy8gcGFyc2UgYSBgU2V0LUNvb2tpZWAgaGVhZGVyXG4gICAgICogY29uc3Qgc2V0Q29va2llSGVhZGVyID0gJ2E9YmNkOyBFeHBpcmVzPVR1ZSwgMTggT2N0IDIwMTEgMDc6MDU6MDMgR01UJ1xuICAgICAqIGNvbnN0IGNvb2tpZSA9IENvb2tpZS5wYXJzZShzZXRDb29raWVIZWFkZXIpXG4gICAgICogY29va2llLmtleSA9PT0gJ2EnXG4gICAgICogY29va2llLnZhbHVlID09PSAnYmNkJ1xuICAgICAqIGNvb2tpZS5leHBpcmVzID09PSBuZXcgRGF0ZShEYXRlLnBhcnNlKCdUdWUsIDE4IE9jdCAyMDExIDA3OjA1OjAzIEdNVCcpKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBwYXJzZSBhIGBDb29raWVgIGhlYWRlclxuICAgICAqIGNvbnN0IGNvb2tpZUhlYWRlciA9ICduYW1lPXZhbHVlOyBuYW1lMj12YWx1ZTI7IG5hbWUzPXZhbHVlMydcbiAgICAgKiBjb25zdCBjb29raWVzID0gY29va2llSGVhZGVyLnNwbGl0KCc7JykubWFwKENvb2tpZS5wYXJzZSlcbiAgICAgKiBjb29raWVzWzBdLm5hbWUgPT09ICduYW1lJ1xuICAgICAqIGNvb2tpZXNbMF0udmFsdWUgPT09ICd2YWx1ZSdcbiAgICAgKiBjb29raWVzWzFdLm5hbWUgPT09ICduYW1lMidcbiAgICAgKiBjb29raWVzWzFdLnZhbHVlID09PSAndmFsdWUyJ1xuICAgICAqIGNvb2tpZXNbMl0ubmFtZSA9PT0gJ25hbWUzJ1xuICAgICAqIGNvb2tpZXNbMl0udmFsdWUgPT09ICd2YWx1ZTMnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyIC0gVGhlIGBTZXQtQ29va2llYCBoZWFkZXIgb3IgYSBDb29raWUgc3RyaW5nIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJlcyBgc3RyaWN0YCBvciBgbG9vc2VgIG1vZGUgZm9yIGNvb2tpZSBwYXJzaW5nXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcGFyc2Uoc3RyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgcmV2ZXJzZSBvZiB7QGxpbmsgQ29va2llLnRvSlNPTn0uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFueSBEYXRlIHByb3BlcnRpZXMgKHN1Y2ggYXMgLmV4cGlyZXMsIC5jcmVhdGlvbiwgYW5kIC5sYXN0QWNjZXNzZWQpIGFyZSBwYXJzZWQgdmlhIERhdGUucGFyc2UsIG5vdCB0b3VnaC1jb29raWUncyBwYXJzZURhdGUsIHNpbmNlIElTTyB0aW1lc3RhbXBzIGFyZSBiZWluZyBoYW5kbGVkIGF0IHRoaXMgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICogICBrZXk6ICdhbHBoYScsXG4gICAgICogICB2YWx1ZTogJ2JldGEnLFxuICAgICAqICAgZG9tYWluOiAnZXhhbXBsZS5jb20nLFxuICAgICAqICAgcGF0aDogJy9mb28nLFxuICAgICAqICAgZXhwaXJlczogJzIwMzgtMDEtMTlUMDM6MTQ6MDcuMDAwWicsXG4gICAgICogfSlcbiAgICAgKiBjb25zdCBjb29raWUgPSBDb29raWUuZnJvbUpTT04oanNvbilcbiAgICAgKiBjb29raWUua2V5ID09PSAnYWxwaGEnXG4gICAgICogY29va2llLnZhbHVlID09PSAnYmV0YSdcbiAgICAgKiBjb29raWUuZG9tYWluID09PSAnZXhhbXBsZS5jb20nXG4gICAgICogY29va2llLnBhdGggPT09ICcvZm9vJ1xuICAgICAqIGNvb2tpZS5leHBpcmVzID09PSBuZXcgRGF0ZShEYXRlLnBhcnNlKCcyMDM4LTAxLTE5VDAzOjE0OjA3LjAwMFonKSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHIgLSBBbiB1bnBhcnNlZCBKU09OIHN0cmluZyBvciBhIHZhbHVlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBwYXJzZWQgYXMgSlNPTlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzdHIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KU09OKHN0cik7XG4gICAgfVxufVxuZXhwb3J0cy5Db29raWUgPSBDb29raWU7XG5Db29raWUuY29va2llc0NyZWF0ZWQgPSAwO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuQ29va2llLnNhbWVTaXRlTGV2ZWwgPSB7XG4gICAgc3RyaWN0OiAzLFxuICAgIGxheDogMixcbiAgICBub25lOiAxLFxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbkNvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbCA9IHtcbiAgICBzdHJpY3Q6ICdTdHJpY3QnLFxuICAgIGxheDogJ0xheCcsXG59O1xuLyoqXG4gKiBDb29raWUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VyaWFsaXplZCB3aGVuIHVzaW5nIHtAbGluayBDb29raWUuZnJvbUpTT059IGFuZCB7QGxpbmsgQ29va2llLnRvSlNPTn0uXG4gKiBAcHVibGljXG4gKi9cbkNvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzID0gW1xuICAgICdrZXknLFxuICAgICd2YWx1ZScsXG4gICAgJ2V4cGlyZXMnLFxuICAgICdtYXhBZ2UnLFxuICAgICdkb21haW4nLFxuICAgICdwYXRoJyxcbiAgICAnc2VjdXJlJyxcbiAgICAnaHR0cE9ubHknLFxuICAgICdleHRlbnNpb25zJyxcbiAgICAnaG9zdE9ubHknLFxuICAgICdwYXRoSXNEZWZhdWx0JyxcbiAgICAnY3JlYXRpb24nLFxuICAgICdsYXN0QWNjZXNzZWQnLFxuICAgICdzYW1lU2l0ZScsXG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookieCompare.js":
/*!****************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/cookieCompare.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cookieCompare = cookieCompare;\n/**\n * The maximum timestamp a cookie, in milliseconds. The value is (2^31 - 1) seconds since the Unix\n * epoch, corresponding to 2038-01-19.\n */\nconst MAX_TIME = 2147483647000;\n/**\n * A comparison function that can be used with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort | Array.sort()},\n * which orders a list of cookies into the recommended order given in Step 2 of {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.4 | RFC6265 - Section 5.4}.\n *\n * The sort algorithm is, in order of precedence:\n *\n * - Longest {@link Cookie.path}\n *\n * - Oldest {@link Cookie.creation} (which has a 1-ms precision, same as Date)\n *\n * - Lowest {@link Cookie.creationIndex} (to get beyond the 1-ms precision)\n *\n * @remarks\n * ### RFC6265 - Section 5.4 - Step 2\n *\n * The user agent SHOULD sort the cookie-list in the following order:\n *\n * - Cookies with longer paths are listed before cookies with shorter paths.\n *\n * - Among cookies that have equal-length path fields, cookies with\n *    earlier creation-times are listed before cookies with later\n *    creation-times.\n *\n * NOTE: Not all user agents sort the cookie-list in this order, but\n * this order reflects common practice when this document was\n * written, and, historically, there have been servers that\n * (erroneously) depended on this order.\n *\n * ### Custom Store Implementors\n *\n * Since the JavaScript Date is limited to a 1-ms precision, cookies within the same millisecond are entirely possible.\n * This is especially true when using the `now` option to `CookieJar.setCookie(...)`. The {@link Cookie.creationIndex}\n * property is a per-process global counter, assigned during construction with `new Cookie()`, which preserves the spirit\n * of the RFC sorting: older cookies go first. This works great for {@link MemoryCookieStore} since `Set-Cookie` headers\n * are parsed in order, but is not so great for distributed systems.\n *\n * Sophisticated Stores may wish to set this to some other\n * logical clock so that if cookies `A` and `B` are created in the same millisecond, but cookie `A` is created before\n * cookie `B`, then `A.creationIndex < B.creationIndex`.\n *\n * @example\n * ```\n * const cookies = [\n *   new Cookie({ key: 'a', value: '' }),\n *   new Cookie({ key: 'b', value: '' }),\n *   new Cookie({ key: 'c', value: '', path: '/path' }),\n *   new Cookie({ key: 'd', value: '', path: '/path' }),\n * ]\n * cookies.sort(cookieCompare)\n * // cookie sort order would be ['c', 'd', 'a', 'b']\n * ```\n *\n * @param a - the first Cookie for comparison\n * @param b - the second Cookie for comparison\n * @public\n */\nfunction cookieCompare(a, b) {\n    let cmp;\n    // descending for length: b CMP a\n    const aPathLen = a.path ? a.path.length : 0;\n    const bPathLen = b.path ? b.path.length : 0;\n    cmp = bPathLen - aPathLen;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    // ascending for time: a CMP b\n    const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;\n    const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;\n    cmp = aTime - bTime;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    // break ties for the same millisecond (precision of JavaScript's clock)\n    cmp = (a.creationIndex || 0) - (b.creationIndex || 0);\n    return cmp;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvY29va2llQ29tcGFyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlIQUFpSDtBQUNqSyxpRkFBaUYsc0ZBQXNGO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBLHFFQUFxRSx5QkFBeUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QyxrQkFBa0IscUJBQXFCO0FBQ3ZDLGtCQUFrQixvQ0FBb0M7QUFDdEQsa0JBQWtCLG9DQUFvQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L2Nvb2tpZS9jb29raWVDb21wYXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb29raWVDb21wYXJlID0gY29va2llQ29tcGFyZTtcbi8qKlxuICogVGhlIG1heGltdW0gdGltZXN0YW1wIGEgY29va2llLCBpbiBtaWxsaXNlY29uZHMuIFRoZSB2YWx1ZSBpcyAoMl4zMSAtIDEpIHNlY29uZHMgc2luY2UgdGhlIFVuaXhcbiAqIGVwb2NoLCBjb3JyZXNwb25kaW5nIHRvIDIwMzgtMDEtMTkuXG4gKi9cbmNvbnN0IE1BWF9USU1FID0gMjE0NzQ4MzY0NzAwMDtcbi8qKlxuICogQSBjb21wYXJpc29uIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCB8IEFycmF5LnNvcnQoKX0sXG4gKiB3aGljaCBvcmRlcnMgYSBsaXN0IG9mIGNvb2tpZXMgaW50byB0aGUgcmVjb21tZW5kZWQgb3JkZXIgZ2l2ZW4gaW4gU3RlcCAyIG9mIHtAbGluayBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjI2NS5odG1sI3NlY3Rpb24tNS40IHwgUkZDNjI2NSAtIFNlY3Rpb24gNS40fS5cbiAqXG4gKiBUaGUgc29ydCBhbGdvcml0aG0gaXMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2U6XG4gKlxuICogLSBMb25nZXN0IHtAbGluayBDb29raWUucGF0aH1cbiAqXG4gKiAtIE9sZGVzdCB7QGxpbmsgQ29va2llLmNyZWF0aW9ufSAod2hpY2ggaGFzIGEgMS1tcyBwcmVjaXNpb24sIHNhbWUgYXMgRGF0ZSlcbiAqXG4gKiAtIExvd2VzdCB7QGxpbmsgQ29va2llLmNyZWF0aW9uSW5kZXh9ICh0byBnZXQgYmV5b25kIHRoZSAxLW1zIHByZWNpc2lvbilcbiAqXG4gKiBAcmVtYXJrc1xuICogIyMjIFJGQzYyNjUgLSBTZWN0aW9uIDUuNCAtIFN0ZXAgMlxuICpcbiAqIFRoZSB1c2VyIGFnZW50IFNIT1VMRCBzb3J0IHRoZSBjb29raWUtbGlzdCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICpcbiAqIC0gQ29va2llcyB3aXRoIGxvbmdlciBwYXRocyBhcmUgbGlzdGVkIGJlZm9yZSBjb29raWVzIHdpdGggc2hvcnRlciBwYXRocy5cbiAqXG4gKiAtIEFtb25nIGNvb2tpZXMgdGhhdCBoYXZlIGVxdWFsLWxlbmd0aCBwYXRoIGZpZWxkcywgY29va2llcyB3aXRoXG4gKiAgICBlYXJsaWVyIGNyZWF0aW9uLXRpbWVzIGFyZSBsaXN0ZWQgYmVmb3JlIGNvb2tpZXMgd2l0aCBsYXRlclxuICogICAgY3JlYXRpb24tdGltZXMuXG4gKlxuICogTk9URTogTm90IGFsbCB1c2VyIGFnZW50cyBzb3J0IHRoZSBjb29raWUtbGlzdCBpbiB0aGlzIG9yZGVyLCBidXRcbiAqIHRoaXMgb3JkZXIgcmVmbGVjdHMgY29tbW9uIHByYWN0aWNlIHdoZW4gdGhpcyBkb2N1bWVudCB3YXNcbiAqIHdyaXR0ZW4sIGFuZCwgaGlzdG9yaWNhbGx5LCB0aGVyZSBoYXZlIGJlZW4gc2VydmVycyB0aGF0XG4gKiAoZXJyb25lb3VzbHkpIGRlcGVuZGVkIG9uIHRoaXMgb3JkZXIuXG4gKlxuICogIyMjIEN1c3RvbSBTdG9yZSBJbXBsZW1lbnRvcnNcbiAqXG4gKiBTaW5jZSB0aGUgSmF2YVNjcmlwdCBEYXRlIGlzIGxpbWl0ZWQgdG8gYSAxLW1zIHByZWNpc2lvbiwgY29va2llcyB3aXRoaW4gdGhlIHNhbWUgbWlsbGlzZWNvbmQgYXJlIGVudGlyZWx5IHBvc3NpYmxlLlxuICogVGhpcyBpcyBlc3BlY2lhbGx5IHRydWUgd2hlbiB1c2luZyB0aGUgYG5vd2Agb3B0aW9uIHRvIGBDb29raWVKYXIuc2V0Q29va2llKC4uLilgLiBUaGUge0BsaW5rIENvb2tpZS5jcmVhdGlvbkluZGV4fVxuICogcHJvcGVydHkgaXMgYSBwZXItcHJvY2VzcyBnbG9iYWwgY291bnRlciwgYXNzaWduZWQgZHVyaW5nIGNvbnN0cnVjdGlvbiB3aXRoIGBuZXcgQ29va2llKClgLCB3aGljaCBwcmVzZXJ2ZXMgdGhlIHNwaXJpdFxuICogb2YgdGhlIFJGQyBzb3J0aW5nOiBvbGRlciBjb29raWVzIGdvIGZpcnN0LiBUaGlzIHdvcmtzIGdyZWF0IGZvciB7QGxpbmsgTWVtb3J5Q29va2llU3RvcmV9IHNpbmNlIGBTZXQtQ29va2llYCBoZWFkZXJzXG4gKiBhcmUgcGFyc2VkIGluIG9yZGVyLCBidXQgaXMgbm90IHNvIGdyZWF0IGZvciBkaXN0cmlidXRlZCBzeXN0ZW1zLlxuICpcbiAqIFNvcGhpc3RpY2F0ZWQgU3RvcmVzIG1heSB3aXNoIHRvIHNldCB0aGlzIHRvIHNvbWUgb3RoZXJcbiAqIGxvZ2ljYWwgY2xvY2sgc28gdGhhdCBpZiBjb29raWVzIGBBYCBhbmQgYEJgIGFyZSBjcmVhdGVkIGluIHRoZSBzYW1lIG1pbGxpc2Vjb25kLCBidXQgY29va2llIGBBYCBpcyBjcmVhdGVkIGJlZm9yZVxuICogY29va2llIGBCYCwgdGhlbiBgQS5jcmVhdGlvbkluZGV4IDwgQi5jcmVhdGlvbkluZGV4YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBjb29raWVzID0gW1xuICogICBuZXcgQ29va2llKHsga2V5OiAnYScsIHZhbHVlOiAnJyB9KSxcbiAqICAgbmV3IENvb2tpZSh7IGtleTogJ2InLCB2YWx1ZTogJycgfSksXG4gKiAgIG5ldyBDb29raWUoeyBrZXk6ICdjJywgdmFsdWU6ICcnLCBwYXRoOiAnL3BhdGgnIH0pLFxuICogICBuZXcgQ29va2llKHsga2V5OiAnZCcsIHZhbHVlOiAnJywgcGF0aDogJy9wYXRoJyB9KSxcbiAqIF1cbiAqIGNvb2tpZXMuc29ydChjb29raWVDb21wYXJlKVxuICogLy8gY29va2llIHNvcnQgb3JkZXIgd291bGQgYmUgWydjJywgJ2QnLCAnYScsICdiJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhIC0gdGhlIGZpcnN0IENvb2tpZSBmb3IgY29tcGFyaXNvblxuICogQHBhcmFtIGIgLSB0aGUgc2Vjb25kIENvb2tpZSBmb3IgY29tcGFyaXNvblxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb29raWVDb21wYXJlKGEsIGIpIHtcbiAgICBsZXQgY21wO1xuICAgIC8vIGRlc2NlbmRpbmcgZm9yIGxlbmd0aDogYiBDTVAgYVxuICAgIGNvbnN0IGFQYXRoTGVuID0gYS5wYXRoID8gYS5wYXRoLmxlbmd0aCA6IDA7XG4gICAgY29uc3QgYlBhdGhMZW4gPSBiLnBhdGggPyBiLnBhdGgubGVuZ3RoIDogMDtcbiAgICBjbXAgPSBiUGF0aExlbiAtIGFQYXRoTGVuO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgLy8gYXNjZW5kaW5nIGZvciB0aW1lOiBhIENNUCBiXG4gICAgY29uc3QgYVRpbWUgPSBhLmNyZWF0aW9uICYmIGEuY3JlYXRpb24gaW5zdGFuY2VvZiBEYXRlID8gYS5jcmVhdGlvbi5nZXRUaW1lKCkgOiBNQVhfVElNRTtcbiAgICBjb25zdCBiVGltZSA9IGIuY3JlYXRpb24gJiYgYi5jcmVhdGlvbiBpbnN0YW5jZW9mIERhdGUgPyBiLmNyZWF0aW9uLmdldFRpbWUoKSA6IE1BWF9USU1FO1xuICAgIGNtcCA9IGFUaW1lIC0gYlRpbWU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICAvLyBicmVhayB0aWVzIGZvciB0aGUgc2FtZSBtaWxsaXNlY29uZCAocHJlY2lzaW9uIG9mIEphdmFTY3JpcHQncyBjbG9jaylcbiAgICBjbXAgPSAoYS5jcmVhdGlvbkluZGV4IHx8IDApIC0gKGIuY3JlYXRpb25JbmRleCB8fCAwKTtcbiAgICByZXR1cm4gY21wO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookieCompare.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookieJar.js":
/*!************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/cookieJar.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CookieJar = void 0;\nconst getPublicSuffix_1 = __webpack_require__(/*! ../getPublicSuffix */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/getPublicSuffix.js\");\nconst validators = __importStar(__webpack_require__(/*! ../validators */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/validators.js\"));\nconst validators_1 = __webpack_require__(/*! ../validators */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/validators.js\");\nconst store_1 = __webpack_require__(/*! ../store */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/store.js\");\nconst memstore_1 = __webpack_require__(/*! ../memstore */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/memstore.js\");\nconst pathMatch_1 = __webpack_require__(/*! ../pathMatch */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/pathMatch.js\");\nconst cookie_1 = __webpack_require__(/*! ./cookie */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookie.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/utils.js\");\nconst canonicalDomain_1 = __webpack_require__(/*! ./canonicalDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/canonicalDomain.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/constants.js\");\nconst defaultPath_1 = __webpack_require__(/*! ./defaultPath */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/defaultPath.js\");\nconst domainMatch_1 = __webpack_require__(/*! ./domainMatch */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/domainMatch.js\");\nconst cookieCompare_1 = __webpack_require__(/*! ./cookieCompare */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookieCompare.js\");\nconst version_1 = __webpack_require__(/*! ../version */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/version.js\");\nconst defaultSetCookieOptions = {\n    loose: false,\n    sameSiteContext: undefined,\n    ignoreError: false,\n    http: true,\n};\nconst defaultGetCookieOptions = {\n    http: true,\n    expire: true,\n    allPaths: false,\n    sameSiteContext: undefined,\n    sort: undefined,\n};\nconst SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of \"strict\", \"lax\", or \"none\"';\nfunction getCookieContext(url) {\n    if (url &&\n        typeof url === 'object' &&\n        'hostname' in url &&\n        typeof url.hostname === 'string' &&\n        'pathname' in url &&\n        typeof url.pathname === 'string' &&\n        'protocol' in url &&\n        typeof url.protocol === 'string') {\n        return {\n            hostname: url.hostname,\n            pathname: url.pathname,\n            protocol: url.protocol,\n        };\n    }\n    else if (typeof url === 'string') {\n        try {\n            return new URL(decodeURI(url));\n        }\n        catch {\n            return new URL(url);\n        }\n    }\n    else {\n        throw new validators_1.ParameterError('`url` argument is not a string or URL.');\n    }\n}\nfunction checkSameSiteContext(value) {\n    const context = String(value).toLowerCase();\n    if (context === 'none' || context === 'lax' || context === 'strict') {\n        return context;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Secure-\", abort these steps and ignore the cookie\n *  entirely unless the cookie's secure-only-flag is true.\n * @param cookie\n * @returns boolean\n */\nfunction isSecurePrefixConditionMet(cookie) {\n    const startsWithSecurePrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Secure-');\n    return !startsWithSecurePrefix || cookie.secure;\n}\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Host-\", abort these steps and ignore the cookie\n *  entirely unless the cookie meets all the following criteria:\n *    1.  The cookie's secure-only-flag is true.\n *    2.  The cookie's host-only-flag is true.\n *    3.  The cookie-attribute-list contains an attribute with an\n *        attribute-name of \"Path\", and the cookie's path is \"/\".\n * @param cookie\n * @returns boolean\n */\nfunction isHostPrefixConditionMet(cookie) {\n    const startsWithHostPrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Host-');\n    return (!startsWithHostPrefix ||\n        Boolean(cookie.secure &&\n            cookie.hostOnly &&\n            cookie.path != null &&\n            cookie.path === '/'));\n}\nfunction getNormalizedPrefixSecurity(prefixSecurity) {\n    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();\n    /* The three supported options */\n    switch (normalizedPrefixSecurity) {\n        case constants_1.PrefixSecurityEnum.STRICT:\n        case constants_1.PrefixSecurityEnum.SILENT:\n        case constants_1.PrefixSecurityEnum.DISABLED:\n            return normalizedPrefixSecurity;\n        default:\n            return constants_1.PrefixSecurityEnum.SILENT;\n    }\n}\n/**\n * A CookieJar is for storage and retrieval of {@link Cookie} objects as defined in\n * {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.3 | RFC6265 - Section 5.3}.\n *\n * It also supports a pluggable persistence layer via {@link Store}.\n * @public\n */\nclass CookieJar {\n    /**\n     * Creates a new `CookieJar` instance.\n     *\n     * @remarks\n     * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.\n     * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`\n     *\n     * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})\n     * @param options - configures how cookies are processed by the cookie jar\n     */\n    constructor(store, options) {\n        if (typeof options === 'boolean') {\n            options = { rejectPublicSuffixes: options };\n        }\n        this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;\n        this.enableLooseMode = options?.looseMode ?? false;\n        this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;\n        this.prefixSecurity = getNormalizedPrefixSecurity(options?.prefixSecurity ?? 'silent');\n        this.store = store ?? new memstore_1.MemoryCookieStore();\n    }\n    callSync(fn) {\n        if (!this.store.synchronous) {\n            throw new Error('CookieJar store is not synchronous; use async API instead.');\n        }\n        let syncErr = null;\n        let syncResult = undefined;\n        try {\n            fn.call(this, (error, result) => {\n                syncErr = error;\n                syncResult = result;\n            });\n        }\n        catch (err) {\n            syncErr = err;\n        }\n        if (syncErr)\n            throw syncErr;\n        return syncResult;\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    setCookie(cookie, url, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        let context;\n        try {\n            if (typeof url === 'string') {\n                validators.validate(validators.isNonEmptyString(url), callback, (0, utils_1.safeToString)(options));\n            }\n            context = getCookieContext(url);\n            if (typeof url === 'function') {\n                return promiseCallback.reject(new Error('No URL was specified'));\n            }\n            if (typeof options === 'function') {\n                options = defaultSetCookieOptions;\n            }\n            validators.validate(typeof cb === 'function', cb);\n            if (!validators.isNonEmptyString(cookie) &&\n                !validators.isObject(cookie) &&\n                cookie instanceof String &&\n                cookie.length == 0) {\n                return promiseCallback.resolve(undefined);\n            }\n        }\n        catch (err) {\n            return promiseCallback.reject(err);\n        }\n        const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname) ?? null;\n        const loose = options?.loose || this.enableLooseMode;\n        let sameSiteContext = null;\n        if (options?.sameSiteContext) {\n            sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n            if (!sameSiteContext) {\n                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n            }\n        }\n        // S5.3 step 1\n        if (typeof cookie === 'string' || cookie instanceof String) {\n            const parsedCookie = cookie_1.Cookie.parse(cookie.toString(), { loose: loose });\n            if (!parsedCookie) {\n                const err = new Error('Cookie failed to parse');\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(err);\n            }\n            cookie = parsedCookie;\n        }\n        else if (!(cookie instanceof cookie_1.Cookie)) {\n            // If you're seeing this error, and are passing in a Cookie object,\n            // it *might* be a Cookie object from another loaded version of tough-cookie.\n            const err = new Error('First argument to setCookie must be a Cookie object or string');\n            return options?.ignoreError\n                ? promiseCallback.resolve(undefined)\n                : promiseCallback.reject(err);\n        }\n        // S5.3 step 2\n        const now = options?.now || new Date(); // will assign later to save effort in the face of errors\n        // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()\n        // S5.3 step 4: NOOP; domain is null by default\n        // S5.3 step 5: public suffixes\n        if (this.rejectPublicSuffixes && cookie.domain) {\n            try {\n                const cdomain = cookie.cdomain();\n                const suffix = typeof cdomain === 'string'\n                    ? (0, getPublicSuffix_1.getPublicSuffix)(cdomain, {\n                        allowSpecialUseDomain: this.allowSpecialUseDomain,\n                        ignoreError: options?.ignoreError,\n                    })\n                    : null;\n                if (suffix == null && !constants_1.IP_V6_REGEX_OBJECT.test(cookie.domain)) {\n                    // e.g. \"com\"\n                    const err = new Error('Cookie has domain set to a public suffix');\n                    return options?.ignoreError\n                        ? promiseCallback.resolve(undefined)\n                        : promiseCallback.reject(err);\n                }\n                // Using `any` here rather than `unknown` to avoid a type assertion, at the cost of needing\n                // to disable eslint directives. It's easier to have this one spot of technically incorrect\n                // types, rather than having to deal with _all_ callback errors being `unknown`.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (err) {\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                        promiseCallback.reject(err);\n            }\n        }\n        // S5.3 step 6:\n        if (cookie.domain) {\n            if (!(0, domainMatch_1.domainMatch)(host ?? undefined, cookie.cdomain() ?? undefined, false)) {\n                const err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? 'null'} Request:${host ?? 'null'}`);\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(err);\n            }\n            if (cookie.hostOnly == null) {\n                // don't reset if already set\n                cookie.hostOnly = false;\n            }\n        }\n        else {\n            cookie.hostOnly = true;\n            cookie.domain = host;\n        }\n        //S5.2.4 If the attribute-value is empty or if the first character of the\n        //attribute-value is not %x2F (\"/\"):\n        //Let cookie-path be the default-path.\n        if (!cookie.path || cookie.path[0] !== '/') {\n            cookie.path = (0, defaultPath_1.defaultPath)(context.pathname);\n            cookie.pathIsDefault = true;\n        }\n        // S5.3 step 8: NOOP; secure attribute\n        // S5.3 step 9: NOOP; httpOnly attribute\n        // S5.3 step 10\n        if (options?.http === false && cookie.httpOnly) {\n            const err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\n            return options.ignoreError\n                ? promiseCallback.resolve(undefined)\n                : promiseCallback.reject(err);\n        }\n        // 6252bis-02 S5.4 Step 13 & 14:\n        if (cookie.sameSite !== 'none' &&\n            cookie.sameSite !== undefined &&\n            sameSiteContext) {\n            // \"If the cookie's \"same-site-flag\" is not \"None\", and the cookie\n            //  is being set from a context whose \"site for cookies\" is not an\n            //  exact match for request-uri's host's registered domain, then\n            //  abort these steps and ignore the newly created cookie entirely.\"\n            if (sameSiteContext === 'none') {\n                const err = new Error('Cookie is SameSite but this is a cross-origin request');\n                return options?.ignoreError\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(err);\n            }\n        }\n        /* 6265bis-02 S5.4 Steps 15 & 16 */\n        const ignoreErrorForPrefixSecurity = this.prefixSecurity === constants_1.PrefixSecurityEnum.SILENT;\n        const prefixSecurityDisabled = this.prefixSecurity === constants_1.PrefixSecurityEnum.DISABLED;\n        /* If prefix checking is not disabled ...*/\n        if (!prefixSecurityDisabled) {\n            let errorFound = false;\n            let errorMsg;\n            /* Check secure prefix condition */\n            if (!isSecurePrefixConditionMet(cookie)) {\n                errorFound = true;\n                errorMsg = 'Cookie has __Secure prefix but Secure attribute is not set';\n            }\n            else if (!isHostPrefixConditionMet(cookie)) {\n                /* Check host prefix condition */\n                errorFound = true;\n                errorMsg =\n                    \"Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'\";\n            }\n            if (errorFound) {\n                return options?.ignoreError || ignoreErrorForPrefixSecurity\n                    ? promiseCallback.resolve(undefined)\n                    : promiseCallback.reject(new Error(errorMsg));\n            }\n        }\n        const store = this.store;\n        // TODO: It feels weird to be manipulating the store as a side effect of a method.\n        // We should either do it in the constructor or not at all.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!store.updateCookie) {\n            store.updateCookie = async function (_oldCookie, newCookie, cb) {\n                return this.putCookie(newCookie).then(() => cb?.(null), (error) => cb?.(error));\n            };\n        }\n        const withCookie = function withCookie(err, oldCookie) {\n            if (err) {\n                cb(err);\n                return;\n            }\n            const next = function (err) {\n                if (err) {\n                    cb(err);\n                }\n                else if (typeof cookie === 'string') {\n                    cb(null, undefined);\n                }\n                else {\n                    cb(null, cookie);\n                }\n            };\n            if (oldCookie) {\n                // S5.3 step 11 - \"If the cookie store contains a cookie with the same name,\n                // domain, and path as the newly created cookie:\"\n                if (options &&\n                    'http' in options &&\n                    options.http === false &&\n                    oldCookie.httpOnly) {\n                    // step 11.2\n                    err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\n                    if (options.ignoreError)\n                        cb(null, undefined);\n                    else\n                        cb(err);\n                    return;\n                }\n                if (cookie instanceof cookie_1.Cookie) {\n                    cookie.creation = oldCookie.creation;\n                    // step 11.3\n                    cookie.creationIndex = oldCookie.creationIndex;\n                    // preserve tie-breaker\n                    cookie.lastAccessed = now;\n                    // Step 11.4 (delete cookie) is implied by just setting the new one:\n                    store.updateCookie(oldCookie, cookie, next); // step 12\n                }\n            }\n            else {\n                if (cookie instanceof cookie_1.Cookie) {\n                    cookie.creation = cookie.lastAccessed = now;\n                    store.putCookie(cookie, next); // step 12\n                }\n            }\n        };\n        // TODO: Refactor to avoid using a callback\n        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.\n     *\n     * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.\n     *\n     * @remarks\n     * - If successfully persisted, the {@link Cookie} will have updated\n     *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}\n     *     properties.\n     *\n     * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`\n     *     atttribute on the cookie string. The {@link Cookie.domain} property is set to the\n     *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an\n     *     exact hostname match (not a {@link domainMatch} as per usual)\n     *\n     * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when storing the cookie.\n     * @public\n     */\n    setCookieSync(cookie, url, options) {\n        const setCookieFn = options\n            ? this.setCookie.bind(this, cookie, url, options)\n            : this.setCookie.bind(this, cookie, url);\n        return this.callSync(setCookieFn);\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    getCookies(url, options, callback) {\n        // RFC6365 S5.4\n        if (typeof options === 'function') {\n            callback = options;\n            options = defaultGetCookieOptions;\n        }\n        else if (options === undefined) {\n            options = defaultGetCookieOptions;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        let context;\n        try {\n            if (typeof url === 'string') {\n                validators.validate(validators.isNonEmptyString(url), cb, url);\n            }\n            context = getCookieContext(url);\n            validators.validate(validators.isObject(options), cb, (0, utils_1.safeToString)(options));\n            validators.validate(typeof cb === 'function', cb);\n        }\n        catch (parameterError) {\n            return promiseCallback.reject(parameterError);\n        }\n        const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname);\n        const path = context.pathname || '/';\n        const secure = context.protocol &&\n            (context.protocol == 'https:' || context.protocol == 'wss:');\n        let sameSiteLevel = 0;\n        if (options.sameSiteContext) {\n            const sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n            if (sameSiteContext == null) {\n                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n            }\n            sameSiteLevel = cookie_1.Cookie.sameSiteLevel[sameSiteContext];\n            if (!sameSiteLevel) {\n                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n            }\n        }\n        const http = options.http ?? true;\n        const now = Date.now();\n        const expireCheck = options.expire ?? true;\n        const allPaths = options.allPaths ?? false;\n        const store = this.store;\n        function matchingCookie(c) {\n            // \"Either:\n            //   The cookie's host-only-flag is true and the canonicalized\n            //   request-host is identical to the cookie's domain.\n            // Or:\n            //   The cookie's host-only-flag is false and the canonicalized\n            //   request-host domain-matches the cookie's domain.\"\n            if (c.hostOnly) {\n                if (c.domain != host) {\n                    return false;\n                }\n            }\n            else {\n                if (!(0, domainMatch_1.domainMatch)(host ?? undefined, c.domain ?? undefined, false)) {\n                    return false;\n                }\n            }\n            // \"The request-uri's path path-matches the cookie's path.\"\n            if (!allPaths && typeof c.path === 'string' && !(0, pathMatch_1.pathMatch)(path, c.path)) {\n                return false;\n            }\n            // \"If the cookie's secure-only-flag is true, then the request-uri's\n            // scheme must denote a \"secure\" protocol\"\n            if (c.secure && !secure) {\n                return false;\n            }\n            // \"If the cookie's http-only-flag is true, then exclude the cookie if the\n            // cookie-string is being generated for a \"non-HTTP\" API\"\n            if (c.httpOnly && !http) {\n                return false;\n            }\n            // RFC6265bis-02 S5.3.7\n            if (sameSiteLevel) {\n                let cookieLevel;\n                if (c.sameSite === 'lax') {\n                    cookieLevel = cookie_1.Cookie.sameSiteLevel.lax;\n                }\n                else if (c.sameSite === 'strict') {\n                    cookieLevel = cookie_1.Cookie.sameSiteLevel.strict;\n                }\n                else {\n                    cookieLevel = cookie_1.Cookie.sameSiteLevel.none;\n                }\n                if (cookieLevel > sameSiteLevel) {\n                    // only allow cookies at or below the request level\n                    return false;\n                }\n            }\n            // deferred from S5.3\n            // non-RFC: allow retention of expired cookies by choice\n            const expiryTime = c.expiryTime();\n            if (expireCheck && expiryTime != undefined && expiryTime <= now) {\n                store.removeCookie(c.domain, c.path, c.key, () => { }); // result ignored\n                return false;\n            }\n            return true;\n        }\n        store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies) => {\n            if (err) {\n                cb(err);\n                return;\n            }\n            if (cookies == null) {\n                cb(null, []);\n                return;\n            }\n            cookies = cookies.filter(matchingCookie);\n            // sorting of S5.4 part 2\n            if ('sort' in options && options.sort !== false) {\n                cookies = cookies.sort(cookieCompare_1.cookieCompare);\n            }\n            // S5.4 part 3\n            const now = new Date();\n            for (const cookie of cookies) {\n                cookie.lastAccessed = now;\n            }\n            // TODO persist lastAccessed\n            cb(null, cookies);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the\n     * current URL.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @remarks\n     * - The array of cookies returned will be sorted according to {@link cookieCompare}.\n     *\n     * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.\n     *\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when retrieving the cookies.\n     */\n    getCookiesSync(url, options) {\n        return this.callSync(this.getCookies.bind(this, url, options)) ?? [];\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    getCookieString(url, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const next = function (err, cookies) {\n            if (err) {\n                promiseCallback.callback(err);\n            }\n            else {\n                promiseCallback.callback(null, cookies\n                    ?.sort(cookieCompare_1.cookieCompare)\n                    .map((c) => c.cookieString())\n                    .join('; '));\n            }\n        };\n        this.getCookies(url, options, next);\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a\n     * `Cookie` header rather than an Array.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when retrieving the cookies.\n     */\n    getCookieStringSync(url, options) {\n        return (this.callSync(options\n            ? this.getCookieString.bind(this, url, options)\n            : this.getCookieString.bind(this, url)) ?? '');\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    getSetCookieStrings(url, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const next = function (err, cookies) {\n            if (err) {\n                promiseCallback.callback(err);\n            }\n            else {\n                promiseCallback.callback(null, cookies?.map((c) => {\n                    return c.toString();\n                }));\n            }\n        };\n        this.getCookies(url, options, next);\n        return promiseCallback.promise;\n    }\n    /**\n     * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.\n     * Accepts the same options as `.getCookies()`.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @param url - The domain to store the cookie with.\n     * @param options - Configuration settings to use when retrieving the cookies.\n     */\n    getSetCookieStringsSync(url, options = {}) {\n        return (this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? []);\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    serialize(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        let type = this.store.constructor.name;\n        if (validators.isObject(type)) {\n            type = null;\n        }\n        // update README.md \"Serialization Format\" if you change this, please!\n        const serialized = {\n            // The version of tough-cookie that serialized this jar. Generally a good\n            // practice since future versions can make data import decisions based on\n            // known past behavior. When/if this matters, use `semver`.\n            version: `tough-cookie@${version_1.version}`,\n            // add the store type, to make humans happy:\n            storeType: type,\n            // CookieJar configuration:\n            rejectPublicSuffixes: this.rejectPublicSuffixes,\n            enableLooseMode: this.enableLooseMode,\n            allowSpecialUseDomain: this.allowSpecialUseDomain,\n            prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),\n            // this gets filled from getAllCookies:\n            cookies: [],\n        };\n        if (typeof this.store.getAllCookies !== 'function') {\n            return promiseCallback.reject(new Error('store does not support getAllCookies and cannot be serialized'));\n        }\n        this.store.getAllCookies((err, cookies) => {\n            if (err) {\n                promiseCallback.callback(err);\n                return;\n            }\n            if (cookies == null) {\n                promiseCallback.callback(null, serialized);\n                return;\n            }\n            serialized.cookies = cookies.map((cookie) => {\n                // convert to serialized 'raw' cookies\n                const serializedCookie = cookie.toJSON();\n                // Remove the index so new ones get assigned during deserialization\n                delete serializedCookie.creationIndex;\n                return serializedCookie;\n            });\n            promiseCallback.callback(null, serialized);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * Serialize the CookieJar if the underlying store supports `.getAllCookies`.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     */\n    serializeSync() {\n        return this.callSync((callback) => {\n            this.serialize(callback);\n        });\n    }\n    /**\n     * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized\n     * with `JSON.stringify(cookieJar)`.\n     */\n    toJSON() {\n        return this.serializeSync();\n    }\n    /**\n     * Use the class method CookieJar.deserialize instead of calling this directly\n     * @internal\n     */\n    _importCookies(serialized, callback) {\n        let cookies = undefined;\n        if (serialized &&\n            typeof serialized === 'object' &&\n            (0, utils_1.inOperator)('cookies', serialized) &&\n            Array.isArray(serialized.cookies)) {\n            cookies = serialized.cookies;\n        }\n        if (!cookies) {\n            callback(new Error('serialized jar has no cookies array'), undefined);\n            return;\n        }\n        cookies = cookies.slice(); // do not modify the original\n        const putNext = (err) => {\n            if (err) {\n                callback(err, undefined);\n                return;\n            }\n            if (Array.isArray(cookies)) {\n                if (!cookies.length) {\n                    callback(err, this);\n                    return;\n                }\n                let cookie;\n                try {\n                    cookie = cookie_1.Cookie.fromJSON(cookies.shift());\n                }\n                catch (e) {\n                    callback(e instanceof Error ? e : new Error(), undefined);\n                    return;\n                }\n                if (cookie === undefined) {\n                    putNext(null); // skip this cookie\n                    return;\n                }\n                this.store.putCookie(cookie, putNext);\n            }\n        };\n        putNext(null);\n    }\n    /**\n     * @internal\n     */\n    _importCookiesSync(serialized) {\n        this.callSync(this._importCookies.bind(this, serialized));\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    clone(newStore, callback) {\n        if (typeof newStore === 'function') {\n            callback = newStore;\n            newStore = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        this.serialize((err, serialized) => {\n            if (err) {\n                return promiseCallback.reject(err);\n            }\n            return CookieJar.deserialize(serialized ?? '', newStore, cb);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * @internal\n     */\n    _cloneSync(newStore) {\n        const cloneFn = newStore && typeof newStore !== 'function'\n            ? this.clone.bind(this, newStore)\n            : this.clone.bind(this);\n        return this.callSync((callback) => {\n            cloneFn(callback);\n        });\n    }\n    /**\n     * Produces a deep clone of this CookieJar. Modifications to the original do\n     * not affect the clone, and vice versa.\n     *\n     * <strong>Note</strong>: Only works if both the configured Store and destination\n     * Store are synchronous.\n     *\n     * @remarks\n     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n     *\n     * - Transferring between store types is supported so long as the source\n     *     implements `.getAllCookies()` and the destination implements `.putCookie()`.\n     *\n     * @param newStore - The target {@link Store} to clone cookies into.\n     */\n    cloneSync(newStore) {\n        if (!newStore) {\n            return this._cloneSync();\n        }\n        if (!newStore.synchronous) {\n            throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');\n        }\n        return this._cloneSync(newStore);\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    removeAllCookies(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cb = promiseCallback.callback;\n        const store = this.store;\n        // Check that the store implements its own removeAllCookies(). The default\n        // implementation in Store will immediately call the callback with a \"not\n        // implemented\" Error.\n        if (typeof store.removeAllCookies === 'function' &&\n            store.removeAllCookies !== store_1.Store.prototype.removeAllCookies) {\n            // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the\n            // standard implementation `cb = (err, result) => {}`, they're essentially the same.\n            store.removeAllCookies(cb);\n            return promiseCallback.promise;\n        }\n        store.getAllCookies((err, cookies) => {\n            if (err) {\n                cb(err);\n                return;\n            }\n            if (!cookies) {\n                cookies = [];\n            }\n            if (cookies.length === 0) {\n                cb(null, undefined);\n                return;\n            }\n            let completedCount = 0;\n            const removeErrors = [];\n            // TODO: Refactor to avoid using callback\n            const removeCookieCb = function removeCookieCb(removeErr) {\n                if (removeErr) {\n                    removeErrors.push(removeErr);\n                }\n                completedCount++;\n                if (completedCount === cookies.length) {\n                    if (removeErrors[0])\n                        cb(removeErrors[0]);\n                    else\n                        cb(null, undefined);\n                    return;\n                }\n            };\n            cookies.forEach((cookie) => {\n                store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);\n            });\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * Removes all cookies from the CookieJar.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @remarks\n     * - This is a new backwards-compatible feature of tough-cookie version 2.5,\n     *     so not all Stores will implement it efficiently. For Stores that do not\n     *     implement `removeAllCookies`, the fallback is to call `removeCookie` after\n     *     `getAllCookies`.\n     *\n     * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.\n     *\n     * - If one or more of the `removeCookie` calls fail, only the first error is returned.\n     */\n    removeAllCookiesSync() {\n        this.callSync((callback) => {\n            // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the\n            // standard implementation `cb = (err, result) => {}`, they're essentially the same.\n            this.removeAllCookies(callback);\n        });\n    }\n    /**\n     * @internal No doc because this is the overload implementation\n     */\n    static deserialize(strOrObj, store, callback) {\n        if (typeof store === 'function') {\n            callback = store;\n            store = undefined;\n        }\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        let serialized;\n        if (typeof strOrObj === 'string') {\n            try {\n                serialized = JSON.parse(strOrObj);\n            }\n            catch (e) {\n                return promiseCallback.reject(e instanceof Error ? e : new Error());\n            }\n        }\n        else {\n            serialized = strOrObj;\n        }\n        const readSerializedProperty = (property) => {\n            return serialized &&\n                typeof serialized === 'object' &&\n                (0, utils_1.inOperator)(property, serialized)\n                ? serialized[property]\n                : undefined;\n        };\n        const readSerializedBoolean = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'boolean' ? value : undefined;\n        };\n        const readSerializedString = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'string' ? value : undefined;\n        };\n        const jar = new CookieJar(store, {\n            rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),\n            looseMode: readSerializedBoolean('enableLooseMode'),\n            allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),\n            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent'),\n        });\n        jar._importCookies(serialized, (err) => {\n            if (err) {\n                promiseCallback.callback(err);\n                return;\n            }\n            promiseCallback.callback(null, jar);\n        });\n        return promiseCallback.promise;\n    }\n    /**\n     * A new CookieJar is created and the serialized {@link Cookie} values are added to\n     * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in\n     * the order in which they appear in the serialization.\n     *\n     * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n     *\n     * @remarks\n     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n     *\n     * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n     *\n     * @param strOrObj - A JSON string or object representing the deserialized cookies.\n     * @param store - The underlying store to persist the deserialized cookies into.\n     */\n    static deserializeSync(strOrObj, store) {\n        const serialized = typeof strOrObj === 'string' ? JSON.parse(strOrObj) : strOrObj;\n        const readSerializedProperty = (property) => {\n            return serialized &&\n                typeof serialized === 'object' &&\n                (0, utils_1.inOperator)(property, serialized)\n                ? serialized[property]\n                : undefined;\n        };\n        const readSerializedBoolean = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'boolean' ? value : undefined;\n        };\n        const readSerializedString = (property) => {\n            const value = readSerializedProperty(property);\n            return typeof value === 'string' ? value : undefined;\n        };\n        const jar = new CookieJar(store, {\n            rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),\n            looseMode: readSerializedBoolean('enableLooseMode'),\n            allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),\n            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent'),\n        });\n        // catch this mistake early:\n        if (!jar.store.synchronous) {\n            throw new Error('CookieJar store is not synchronous; use async API instead.');\n        }\n        jar._importCookiesSync(serialized);\n        return jar;\n    }\n    /**\n     * Alias of {@link CookieJar.deserializeSync}.\n     *\n     * @remarks\n     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n     *\n     * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n     *\n     * @param jsonString - A JSON string or object representing the deserialized cookies.\n     * @param store - The underlying store to persist the deserialized cookies into.\n     */\n    static fromJSON(jsonString, store) {\n        return CookieJar.deserializeSync(jsonString, store);\n    }\n}\nexports.CookieJar = CookieJar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvY29va2llSmFyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsMEJBQTBCLG1CQUFPLENBQUMsbUdBQW9CO0FBQ3RELGdDQUFnQyxtQkFBTyxDQUFDLHlGQUFlO0FBQ3ZELHFCQUFxQixtQkFBTyxDQUFDLHlGQUFlO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFVO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFjO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHVGQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFVO0FBQ2xDLDBCQUEwQixtQkFBTyxDQUFDLHlHQUFtQjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyw2RkFBYTtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBZTtBQUM3QyxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBZTtBQUM3Qyx3QkFBd0IsbUJBQU8sQ0FBQyxxR0FBaUI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsbUZBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RCxJQUFJLHNGQUFzRjtBQUMxRjtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHlCQUF5QjtBQUMzRyxtR0FBbUcsK0JBQStCO0FBQ2xJO0FBQ0EsZ0NBQWdDLGFBQWEsNkJBQTZCLHdCQUF3QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsY0FBYztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDRCQUE0QixVQUFVLGVBQWU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjLFFBQVEsZ0JBQWdCO0FBQy9FO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZELFlBQVksc0JBQXNCLEdBQUcsMkJBQTJCLEtBQUs7QUFDckU7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUIscUNBQXFDLE1BQU07QUFDaEcsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQSx1SEFBdUgsbUJBQW1CO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxvQkFBb0I7QUFDeEY7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxvQkFBb0IseUJBQXlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxvQkFBb0IseUJBQXlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQixhQUFhLG9CQUFvQix5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvY29va2llL2Nvb2tpZUphci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db29raWVKYXIgPSB2b2lkIDA7XG5jb25zdCBnZXRQdWJsaWNTdWZmaXhfMSA9IHJlcXVpcmUoXCIuLi9nZXRQdWJsaWNTdWZmaXhcIik7XG5jb25zdCB2YWxpZGF0b3JzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzXCIpKTtcbmNvbnN0IHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzXCIpO1xuY29uc3Qgc3RvcmVfMSA9IHJlcXVpcmUoXCIuLi9zdG9yZVwiKTtcbmNvbnN0IG1lbXN0b3JlXzEgPSByZXF1aXJlKFwiLi4vbWVtc3RvcmVcIik7XG5jb25zdCBwYXRoTWF0Y2hfMSA9IHJlcXVpcmUoXCIuLi9wYXRoTWF0Y2hcIik7XG5jb25zdCBjb29raWVfMSA9IHJlcXVpcmUoXCIuL2Nvb2tpZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBjYW5vbmljYWxEb21haW5fMSA9IHJlcXVpcmUoXCIuL2Nhbm9uaWNhbERvbWFpblwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGVmYXVsdFBhdGhfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRQYXRoXCIpO1xuY29uc3QgZG9tYWluTWF0Y2hfMSA9IHJlcXVpcmUoXCIuL2RvbWFpbk1hdGNoXCIpO1xuY29uc3QgY29va2llQ29tcGFyZV8xID0gcmVxdWlyZShcIi4vY29va2llQ29tcGFyZVwiKTtcbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuLi92ZXJzaW9uXCIpO1xuY29uc3QgZGVmYXVsdFNldENvb2tpZU9wdGlvbnMgPSB7XG4gICAgbG9vc2U6IGZhbHNlLFxuICAgIHNhbWVTaXRlQ29udGV4dDogdW5kZWZpbmVkLFxuICAgIGlnbm9yZUVycm9yOiBmYWxzZSxcbiAgICBodHRwOiB0cnVlLFxufTtcbmNvbnN0IGRlZmF1bHRHZXRDb29raWVPcHRpb25zID0ge1xuICAgIGh0dHA6IHRydWUsXG4gICAgZXhwaXJlOiB0cnVlLFxuICAgIGFsbFBhdGhzOiBmYWxzZSxcbiAgICBzYW1lU2l0ZUNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICBzb3J0OiB1bmRlZmluZWQsXG59O1xuY29uc3QgU0FNRV9TSVRFX0NPTlRFWFRfVkFMX0VSUiA9ICdJbnZhbGlkIHNhbWVTaXRlQ29udGV4dCBvcHRpb24gZm9yIGdldENvb2tpZXMoKTsgZXhwZWN0ZWQgb25lIG9mIFwic3RyaWN0XCIsIFwibGF4XCIsIG9yIFwibm9uZVwiJztcbmZ1bmN0aW9uIGdldENvb2tpZUNvbnRleHQodXJsKSB7XG4gICAgaWYgKHVybCAmJlxuICAgICAgICB0eXBlb2YgdXJsID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnaG9zdG5hbWUnIGluIHVybCAmJlxuICAgICAgICB0eXBlb2YgdXJsLmhvc3RuYW1lID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAncGF0aG5hbWUnIGluIHVybCAmJlxuICAgICAgICB0eXBlb2YgdXJsLnBhdGhuYW1lID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAncHJvdG9jb2wnIGluIHVybCAmJlxuICAgICAgICB0eXBlb2YgdXJsLnByb3RvY29sID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgICAgICBwcm90b2NvbDogdXJsLnByb3RvY29sLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoZGVjb2RlVVJJKHVybCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyB2YWxpZGF0b3JzXzEuUGFyYW1ldGVyRXJyb3IoJ2B1cmxgIGFyZ3VtZW50IGlzIG5vdCBhIHN0cmluZyBvciBVUkwuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tTYW1lU2l0ZUNvbnRleHQodmFsdWUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChjb250ZXh0ID09PSAnbm9uZScgfHwgY29udGV4dCA9PT0gJ2xheCcgfHwgY29udGV4dCA9PT0gJ3N0cmljdCcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogIElmIHRoZSBjb29raWUtbmFtZSBiZWdpbnMgd2l0aCBhIGNhc2Utc2Vuc2l0aXZlIG1hdGNoIGZvciB0aGVcbiAqICBzdHJpbmcgXCJfX1NlY3VyZS1cIiwgYWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGlnbm9yZSB0aGUgY29va2llXG4gKiAgZW50aXJlbHkgdW5sZXNzIHRoZSBjb29raWUncyBzZWN1cmUtb25seS1mbGFnIGlzIHRydWUuXG4gKiBAcGFyYW0gY29va2llXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzU2VjdXJlUHJlZml4Q29uZGl0aW9uTWV0KGNvb2tpZSkge1xuICAgIGNvbnN0IHN0YXJ0c1dpdGhTZWN1cmVQcmVmaXggPSB0eXBlb2YgY29va2llLmtleSA9PT0gJ3N0cmluZycgJiYgY29va2llLmtleS5zdGFydHNXaXRoKCdfX1NlY3VyZS0nKTtcbiAgICByZXR1cm4gIXN0YXJ0c1dpdGhTZWN1cmVQcmVmaXggfHwgY29va2llLnNlY3VyZTtcbn1cbi8qKlxuICogIElmIHRoZSBjb29raWUtbmFtZSBiZWdpbnMgd2l0aCBhIGNhc2Utc2Vuc2l0aXZlIG1hdGNoIGZvciB0aGVcbiAqICBzdHJpbmcgXCJfX0hvc3QtXCIsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIGNvb2tpZVxuICogIGVudGlyZWx5IHVubGVzcyB0aGUgY29va2llIG1lZXRzIGFsbCB0aGUgZm9sbG93aW5nIGNyaXRlcmlhOlxuICogICAgMS4gIFRoZSBjb29raWUncyBzZWN1cmUtb25seS1mbGFnIGlzIHRydWUuXG4gKiAgICAyLiAgVGhlIGNvb2tpZSdzIGhvc3Qtb25seS1mbGFnIGlzIHRydWUuXG4gKiAgICAzLiAgVGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCBjb250YWlucyBhbiBhdHRyaWJ1dGUgd2l0aCBhblxuICogICAgICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFwiUGF0aFwiLCBhbmQgdGhlIGNvb2tpZSdzIHBhdGggaXMgXCIvXCIuXG4gKiBAcGFyYW0gY29va2llXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdFByZWZpeENvbmRpdGlvbk1ldChjb29raWUpIHtcbiAgICBjb25zdCBzdGFydHNXaXRoSG9zdFByZWZpeCA9IHR5cGVvZiBjb29raWUua2V5ID09PSAnc3RyaW5nJyAmJiBjb29raWUua2V5LnN0YXJ0c1dpdGgoJ19fSG9zdC0nKTtcbiAgICByZXR1cm4gKCFzdGFydHNXaXRoSG9zdFByZWZpeCB8fFxuICAgICAgICBCb29sZWFuKGNvb2tpZS5zZWN1cmUgJiZcbiAgICAgICAgICAgIGNvb2tpZS5ob3N0T25seSAmJlxuICAgICAgICAgICAgY29va2llLnBhdGggIT0gbnVsbCAmJlxuICAgICAgICAgICAgY29va2llLnBhdGggPT09ICcvJykpO1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KHByZWZpeFNlY3VyaXR5KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFByZWZpeFNlY3VyaXR5ID0gcHJlZml4U2VjdXJpdHkudG9Mb3dlckNhc2UoKTtcbiAgICAvKiBUaGUgdGhyZWUgc3VwcG9ydGVkIG9wdGlvbnMgKi9cbiAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRQcmVmaXhTZWN1cml0eSkge1xuICAgICAgICBjYXNlIGNvbnN0YW50c18xLlByZWZpeFNlY3VyaXR5RW51bS5TVFJJQ1Q6XG4gICAgICAgIGNhc2UgY29uc3RhbnRzXzEuUHJlZml4U2VjdXJpdHlFbnVtLlNJTEVOVDpcbiAgICAgICAgY2FzZSBjb25zdGFudHNfMS5QcmVmaXhTZWN1cml0eUVudW0uRElTQUJMRUQ6XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZFByZWZpeFNlY3VyaXR5O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLlByZWZpeFNlY3VyaXR5RW51bS5TSUxFTlQ7XG4gICAgfVxufVxuLyoqXG4gKiBBIENvb2tpZUphciBpcyBmb3Igc3RvcmFnZSBhbmQgcmV0cmlldmFsIG9mIHtAbGluayBDb29raWV9IG9iamVjdHMgYXMgZGVmaW5lZCBpblxuICoge0BsaW5rIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1Lmh0bWwjc2VjdGlvbi01LjMgfCBSRkM2MjY1IC0gU2VjdGlvbiA1LjN9LlxuICpcbiAqIEl0IGFsc28gc3VwcG9ydHMgYSBwbHVnZ2FibGUgcGVyc2lzdGVuY2UgbGF5ZXIgdmlhIHtAbGluayBTdG9yZX0uXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIENvb2tpZUphciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQ29va2llSmFyYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogLSBJZiBhIGN1c3RvbSBzdG9yZSBpcyBub3QgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciwgYW4gaW4tbWVtb3J5IHN0b3JlICh7QGxpbmsgTWVtb3J5Q29va2llU3RvcmV9IHdpbGwgYmUgY3JlYXRlZCBhbmQgdXNlZC5cbiAgICAgKiAtIElmIGEgYm9vbGVhbiB2YWx1ZSBpcyBwYXNzZWQgYXMgdGhlIGBvcHRpb25zYCBwYXJhbWV0ZXIsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBwYXNzaW5nIGB7IHJlamVjdFB1YmxpY1N1ZmZpeGVzOiA8dmFsdWU+IH1gXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcmUgLSBhIGN1c3RvbSB7QGxpbmsgU3RvcmV9IGltcGxlbWVudGF0aW9uIChkZWZhdWx0cyB0byB7QGxpbmsgTWVtb3J5Q29va2llU3RvcmV9KVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gY29uZmlndXJlcyBob3cgY29va2llcyBhcmUgcHJvY2Vzc2VkIGJ5IHRoZSBjb29raWUgamFyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RvcmUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHJlamVjdFB1YmxpY1N1ZmZpeGVzOiBvcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyA9IG9wdGlvbnM/LnJlamVjdFB1YmxpY1N1ZmZpeGVzID8/IHRydWU7XG4gICAgICAgIHRoaXMuZW5hYmxlTG9vc2VNb2RlID0gb3B0aW9ucz8ubG9vc2VNb2RlID8/IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93U3BlY2lhbFVzZURvbWFpbiA9IG9wdGlvbnM/LmFsbG93U3BlY2lhbFVzZURvbWFpbiA/PyB0cnVlO1xuICAgICAgICB0aGlzLnByZWZpeFNlY3VyaXR5ID0gZ2V0Tm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KG9wdGlvbnM/LnByZWZpeFNlY3VyaXR5ID8/ICdzaWxlbnQnKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlID8/IG5ldyBtZW1zdG9yZV8xLk1lbW9yeUNvb2tpZVN0b3JlKCk7XG4gICAgfVxuICAgIGNhbGxTeW5jKGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5zdG9yZS5zeW5jaHJvbm91cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVKYXIgc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN5bmNFcnIgPSBudWxsO1xuICAgICAgICBsZXQgc3luY1Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBzeW5jRXJyID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgc3luY1Jlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN5bmNFcnIgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bmNFcnIpXG4gICAgICAgICAgICB0aHJvdyBzeW5jRXJyO1xuICAgICAgICByZXR1cm4gc3luY1Jlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgc2V0Q29va2llKGNvb2tpZSwgdXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvbWlzZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IGNiID0gcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrO1xuICAgICAgICBsZXQgY29udGV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc05vbkVtcHR5U3RyaW5nKHVybCksIGNhbGxiYWNrLCAoMCwgdXRpbHNfMS5zYWZlVG9TdHJpbmcpKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQgPSBnZXRDb29raWVDb250ZXh0KHVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KG5ldyBFcnJvcignTm8gVVJMIHdhcyBzcGVjaWZpZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdFNldENvb2tpZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0b3JzLnZhbGlkYXRlKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJywgY2IpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3JzLmlzTm9uRW1wdHlTdHJpbmcoY29va2llKSAmJlxuICAgICAgICAgICAgICAgICF2YWxpZGF0b3JzLmlzT2JqZWN0KGNvb2tpZSkgJiZcbiAgICAgICAgICAgICAgICBjb29raWUgaW5zdGFuY2VvZiBTdHJpbmcgJiZcbiAgICAgICAgICAgICAgICBjb29raWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3QgPSAoMCwgY2Fub25pY2FsRG9tYWluXzEuY2Fub25pY2FsRG9tYWluKShjb250ZXh0Lmhvc3RuYW1lKSA/PyBudWxsO1xuICAgICAgICBjb25zdCBsb29zZSA9IG9wdGlvbnM/Lmxvb3NlIHx8IHRoaXMuZW5hYmxlTG9vc2VNb2RlO1xuICAgICAgICBsZXQgc2FtZVNpdGVDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnNhbWVTaXRlQ29udGV4dCkge1xuICAgICAgICAgICAgc2FtZVNpdGVDb250ZXh0ID0gY2hlY2tTYW1lU2l0ZUNvbnRleHQob3B0aW9ucy5zYW1lU2l0ZUNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFzYW1lU2l0ZUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChuZXcgRXJyb3IoU0FNRV9TSVRFX0NPTlRFWFRfVkFMX0VSUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFM1LjMgc3RlcCAxXG4gICAgICAgIGlmICh0eXBlb2YgY29va2llID09PSAnc3RyaW5nJyB8fCBjb29raWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZENvb2tpZSA9IGNvb2tpZV8xLkNvb2tpZS5wYXJzZShjb29raWUudG9TdHJpbmcoKSwgeyBsb29zZTogbG9vc2UgfSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZENvb2tpZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQ29va2llIGZhaWxlZCB0byBwYXJzZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zPy5pZ25vcmVFcnJvclxuICAgICAgICAgICAgICAgICAgICA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgOiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb29raWUgPSBwYXJzZWRDb29raWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShjb29raWUgaW5zdGFuY2VvZiBjb29raWVfMS5Db29raWUpKSB7XG4gICAgICAgICAgICAvLyBJZiB5b3UncmUgc2VlaW5nIHRoaXMgZXJyb3IsIGFuZCBhcmUgcGFzc2luZyBpbiBhIENvb2tpZSBvYmplY3QsXG4gICAgICAgICAgICAvLyBpdCAqbWlnaHQqIGJlIGEgQ29va2llIG9iamVjdCBmcm9tIGFub3RoZXIgbG9hZGVkIHZlcnNpb24gb2YgdG91Z2gtY29va2llLlxuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBzZXRDb29raWUgbXVzdCBiZSBhIENvb2tpZSBvYmplY3Qgb3Igc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3JcbiAgICAgICAgICAgICAgICA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICA6IHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTNS4zIHN0ZXAgMlxuICAgICAgICBjb25zdCBub3cgPSBvcHRpb25zPy5ub3cgfHwgbmV3IERhdGUoKTsgLy8gd2lsbCBhc3NpZ24gbGF0ZXIgdG8gc2F2ZSBlZmZvcnQgaW4gdGhlIGZhY2Ugb2YgZXJyb3JzXG4gICAgICAgIC8vIFM1LjMgc3RlcCAzOiBOT09QOyBwZXJzaXN0ZW50LWZsYWcgYW5kIGV4cGlyeS10aW1lIGlzIGhhbmRsZWQgYnkgZ2V0Q29va2llKClcbiAgICAgICAgLy8gUzUuMyBzdGVwIDQ6IE5PT1A7IGRvbWFpbiBpcyBudWxsIGJ5IGRlZmF1bHRcbiAgICAgICAgLy8gUzUuMyBzdGVwIDU6IHB1YmxpYyBzdWZmaXhlc1xuICAgICAgICBpZiAodGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyAmJiBjb29raWUuZG9tYWluKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNkb21haW4gPSBjb29raWUuY2RvbWFpbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHR5cGVvZiBjZG9tYWluID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBnZXRQdWJsaWNTdWZmaXhfMS5nZXRQdWJsaWNTdWZmaXgpKGNkb21haW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogdGhpcy5hbGxvd1NwZWNpYWxVc2VEb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVFcnJvcjogb3B0aW9ucz8uaWdub3JlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3VmZml4ID09IG51bGwgJiYgIWNvbnN0YW50c18xLklQX1Y2X1JFR0VYX09CSkVDVC50ZXN0KGNvb2tpZS5kb21haW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gXCJjb21cIlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0Nvb2tpZSBoYXMgZG9tYWluIHNldCB0byBhIHB1YmxpYyBzdWZmaXgnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM/Lmlnbm9yZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBgYW55YCBoZXJlIHJhdGhlciB0aGFuIGB1bmtub3duYCB0byBhdm9pZCBhIHR5cGUgYXNzZXJ0aW9uLCBhdCB0aGUgY29zdCBvZiBuZWVkaW5nXG4gICAgICAgICAgICAgICAgLy8gdG8gZGlzYWJsZSBlc2xpbnQgZGlyZWN0aXZlcy4gSXQncyBlYXNpZXIgdG8gaGF2ZSB0aGlzIG9uZSBzcG90IG9mIHRlY2huaWNhbGx5IGluY29ycmVjdFxuICAgICAgICAgICAgICAgIC8vIHR5cGVzLCByYXRoZXIgdGhhbiBoYXZpbmcgdG8gZGVhbCB3aXRoIF9hbGxfIGNhbGxiYWNrIGVycm9ycyBiZWluZyBgdW5rbm93bmAuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTNS4zIHN0ZXAgNjpcbiAgICAgICAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICAgICAgICAgIGlmICghKDAsIGRvbWFpbk1hdGNoXzEuZG9tYWluTWF0Y2gpKGhvc3QgPz8gdW5kZWZpbmVkLCBjb29raWUuY2RvbWFpbigpID8/IHVuZGVmaW5lZCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBDb29raWUgbm90IGluIHRoaXMgaG9zdCdzIGRvbWFpbi4gQ29va2llOiR7Y29va2llLmNkb21haW4oKSA/PyAnbnVsbCd9IFJlcXVlc3Q6JHtob3N0ID8/ICdudWxsJ31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIDogcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb2tpZS5ob3N0T25seSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgcmVzZXQgaWYgYWxyZWFkeSBzZXRcbiAgICAgICAgICAgICAgICBjb29raWUuaG9zdE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvb2tpZS5ob3N0T25seSA9IHRydWU7XG4gICAgICAgICAgICBjb29raWUuZG9tYWluID0gaG9zdDtcbiAgICAgICAgfVxuICAgICAgICAvL1M1LjIuNCBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gICAgICAgIC8vYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gICAgICAgIC8vTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBkZWZhdWx0LXBhdGguXG4gICAgICAgIGlmICghY29va2llLnBhdGggfHwgY29va2llLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgICAgY29va2llLnBhdGggPSAoMCwgZGVmYXVsdFBhdGhfMS5kZWZhdWx0UGF0aCkoY29udGV4dC5wYXRobmFtZSk7XG4gICAgICAgICAgICBjb29raWUucGF0aElzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUzUuMyBzdGVwIDg6IE5PT1A7IHNlY3VyZSBhdHRyaWJ1dGVcbiAgICAgICAgLy8gUzUuMyBzdGVwIDk6IE5PT1A7IGh0dHBPbmx5IGF0dHJpYnV0ZVxuICAgICAgICAvLyBTNS4zIHN0ZXAgMTBcbiAgICAgICAgaWYgKG9wdGlvbnM/Lmh0dHAgPT09IGZhbHNlICYmIGNvb2tpZS5odHRwT25seSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaWdub3JlRXJyb3JcbiAgICAgICAgICAgICAgICA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICA6IHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA2MjUyYmlzLTAyIFM1LjQgU3RlcCAxMyAmIDE0OlxuICAgICAgICBpZiAoY29va2llLnNhbWVTaXRlICE9PSAnbm9uZScgJiZcbiAgICAgICAgICAgIGNvb2tpZS5zYW1lU2l0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzYW1lU2l0ZUNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIFwiSWYgdGhlIGNvb2tpZSdzIFwic2FtZS1zaXRlLWZsYWdcIiBpcyBub3QgXCJOb25lXCIsIGFuZCB0aGUgY29va2llXG4gICAgICAgICAgICAvLyAgaXMgYmVpbmcgc2V0IGZyb20gYSBjb250ZXh0IHdob3NlIFwic2l0ZSBmb3IgY29va2llc1wiIGlzIG5vdCBhblxuICAgICAgICAgICAgLy8gIGV4YWN0IG1hdGNoIGZvciByZXF1ZXN0LXVyaSdzIGhvc3QncyByZWdpc3RlcmVkIGRvbWFpbiwgdGhlblxuICAgICAgICAgICAgLy8gIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIG5ld2x5IGNyZWF0ZWQgY29va2llIGVudGlyZWx5LlwiXG4gICAgICAgICAgICBpZiAoc2FtZVNpdGVDb250ZXh0ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0Nvb2tpZSBpcyBTYW1lU2l0ZSBidXQgdGhpcyBpcyBhIGNyb3NzLW9yaWdpbiByZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM/Lmlnbm9yZUVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICA6IHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiA2MjY1YmlzLTAyIFM1LjQgU3RlcHMgMTUgJiAxNiAqL1xuICAgICAgICBjb25zdCBpZ25vcmVFcnJvckZvclByZWZpeFNlY3VyaXR5ID0gdGhpcy5wcmVmaXhTZWN1cml0eSA9PT0gY29uc3RhbnRzXzEuUHJlZml4U2VjdXJpdHlFbnVtLlNJTEVOVDtcbiAgICAgICAgY29uc3QgcHJlZml4U2VjdXJpdHlEaXNhYmxlZCA9IHRoaXMucHJlZml4U2VjdXJpdHkgPT09IGNvbnN0YW50c18xLlByZWZpeFNlY3VyaXR5RW51bS5ESVNBQkxFRDtcbiAgICAgICAgLyogSWYgcHJlZml4IGNoZWNraW5nIGlzIG5vdCBkaXNhYmxlZCAuLi4qL1xuICAgICAgICBpZiAoIXByZWZpeFNlY3VyaXR5RGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGxldCBlcnJvckZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZXJyb3JNc2c7XG4gICAgICAgICAgICAvKiBDaGVjayBzZWN1cmUgcHJlZml4IGNvbmRpdGlvbiAqL1xuICAgICAgICAgICAgaWYgKCFpc1NlY3VyZVByZWZpeENvbmRpdGlvbk1ldChjb29raWUpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JNc2cgPSAnQ29va2llIGhhcyBfX1NlY3VyZSBwcmVmaXggYnV0IFNlY3VyZSBhdHRyaWJ1dGUgaXMgbm90IHNldCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNIb3N0UHJlZml4Q29uZGl0aW9uTWV0KGNvb2tpZSkpIHtcbiAgICAgICAgICAgICAgICAvKiBDaGVjayBob3N0IHByZWZpeCBjb25kaXRpb24gKi9cbiAgICAgICAgICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvck1zZyA9XG4gICAgICAgICAgICAgICAgICAgIFwiQ29va2llIGhhcyBfX0hvc3QgcHJlZml4IGJ1dCBlaXRoZXIgU2VjdXJlIG9yIEhvc3RPbmx5IGF0dHJpYnV0ZSBpcyBub3Qgc2V0IG9yIFBhdGggaXMgbm90ICcvJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yRm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3IgfHwgaWdub3JlRXJyb3JGb3JQcmVmaXhTZWN1cml0eVxuICAgICAgICAgICAgICAgICAgICA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgOiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KG5ldyBFcnJvcihlcnJvck1zZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgLy8gVE9ETzogSXQgZmVlbHMgd2VpcmQgdG8gYmUgbWFuaXB1bGF0aW5nIHRoZSBzdG9yZSBhcyBhIHNpZGUgZWZmZWN0IG9mIGEgbWV0aG9kLlxuICAgICAgICAvLyBXZSBzaG91bGQgZWl0aGVyIGRvIGl0IGluIHRoZSBjb25zdHJ1Y3RvciBvciBub3QgYXQgYWxsLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIXN0b3JlLnVwZGF0ZUNvb2tpZSkge1xuICAgICAgICAgICAgc3RvcmUudXBkYXRlQ29va2llID0gYXN5bmMgZnVuY3Rpb24gKF9vbGRDb29raWUsIG5ld0Nvb2tpZSwgY2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXRDb29raWUobmV3Q29va2llKS50aGVuKCgpID0+IGNiPy4obnVsbCksIChlcnJvcikgPT4gY2I/LihlcnJvcikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aXRoQ29va2llID0gZnVuY3Rpb24gd2l0aENvb2tpZShlcnIsIG9sZENvb2tpZSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb29raWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBjb29raWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob2xkQ29va2llKSB7XG4gICAgICAgICAgICAgICAgLy8gUzUuMyBzdGVwIDExIC0gXCJJZiB0aGUgY29va2llIHN0b3JlIGNvbnRhaW5zIGEgY29va2llIHdpdGggdGhlIHNhbWUgbmFtZSxcbiAgICAgICAgICAgICAgICAvLyBkb21haW4sIGFuZCBwYXRoIGFzIHRoZSBuZXdseSBjcmVhdGVkIGNvb2tpZTpcIlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICAgICdodHRwJyBpbiBvcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cCA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkQ29va2llLmh0dHBPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0ZXAgMTEuMlxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJvbGQgQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvb2tpZSBpbnN0YW5jZW9mIGNvb2tpZV8xLkNvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICBjb29raWUuY3JlYXRpb24gPSBvbGRDb29raWUuY3JlYXRpb247XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0ZXAgMTEuM1xuICAgICAgICAgICAgICAgICAgICBjb29raWUuY3JlYXRpb25JbmRleCA9IG9sZENvb2tpZS5jcmVhdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSB0aWUtYnJlYWtlclxuICAgICAgICAgICAgICAgICAgICBjb29raWUubGFzdEFjY2Vzc2VkID0gbm93O1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDExLjQgKGRlbGV0ZSBjb29raWUpIGlzIGltcGxpZWQgYnkganVzdCBzZXR0aW5nIHRoZSBuZXcgb25lOlxuICAgICAgICAgICAgICAgICAgICBzdG9yZS51cGRhdGVDb29raWUob2xkQ29va2llLCBjb29raWUsIG5leHQpOyAvLyBzdGVwIDEyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvb2tpZSBpbnN0YW5jZW9mIGNvb2tpZV8xLkNvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICBjb29raWUuY3JlYXRpb24gPSBjb29raWUubGFzdEFjY2Vzc2VkID0gbm93O1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXRDb29raWUoY29va2llLCBuZXh0KTsgLy8gc3RlcCAxMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgdG8gYXZvaWQgdXNpbmcgYSBjYWxsYmFja1xuICAgICAgICBzdG9yZS5maW5kQ29va2llKGNvb2tpZS5kb21haW4sIGNvb2tpZS5wYXRoLCBjb29raWUua2V5LCB3aXRoQ29va2llKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IGF0dGVtcHQgdG8gc2V0IHRoZSB7QGxpbmsgQ29va2llfSBpbiB0aGUge0BsaW5rIENvb2tpZUphcn0uXG4gICAgICpcbiAgICAgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQge0BsaW5rIFN0b3JlfSBpcyBhbHNvIHN5bmNocm9ub3VzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiAtIElmIHN1Y2Nlc3NmdWxseSBwZXJzaXN0ZWQsIHRoZSB7QGxpbmsgQ29va2llfSB3aWxsIGhhdmUgdXBkYXRlZFxuICAgICAqICAgICB7QGxpbmsgQ29va2llLmNyZWF0aW9ufSwge0BsaW5rIENvb2tpZS5sYXN0QWNjZXNzZWR9IGFuZCB7QGxpbmsgQ29va2llLmhvc3RPbmx5fVxuICAgICAqICAgICBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogLSBBcyBwZXIgdGhlIFJGQywgdGhlIHtAbGluayBDb29raWUuaG9zdE9ubHl9IGZsYWcgaXMgc2V0IGlmIHRoZXJlIHdhcyBubyBgRG9tYWluPXt2YWx1ZX1gXG4gICAgICogICAgIGF0dHRyaWJ1dGUgb24gdGhlIGNvb2tpZSBzdHJpbmcuIFRoZSB7QGxpbmsgQ29va2llLmRvbWFpbn0gcHJvcGVydHkgaXMgc2V0IHRvIHRoZVxuICAgICAqICAgICBmdWxseS1xdWFsaWZpZWQgaG9zdG5hbWUgb2YgYGN1cnJlbnRVcmxgIGluIHRoaXMgY2FzZS4gTWF0Y2hpbmcgdGhpcyBjb29raWUgcmVxdWlyZXMgYW5cbiAgICAgKiAgICAgZXhhY3QgaG9zdG5hbWUgbWF0Y2ggKG5vdCBhIHtAbGluayBkb21haW5NYXRjaH0gYXMgcGVyIHVzdWFsKVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvb2tpZSAtIFRoZSBjb29raWUgb2JqZWN0IG9yIGNvb2tpZSBzdHJpbmcgdG8gc3RvcmUuIEEgc3RyaW5nIHZhbHVlIHdpbGwgYmUgcGFyc2VkIGludG8gYSBjb29raWUgdXNpbmcge0BsaW5rIENvb2tpZS5wYXJzZX0uXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBkb21haW4gdG8gc3RvcmUgdGhlIGNvb2tpZSB3aXRoLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5ncyB0byB1c2Ugd2hlbiBzdG9yaW5nIHRoZSBjb29raWUuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldENvb2tpZVN5bmMoY29va2llLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2V0Q29va2llRm4gPSBvcHRpb25zXG4gICAgICAgICAgICA/IHRoaXMuc2V0Q29va2llLmJpbmQodGhpcywgY29va2llLCB1cmwsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRoaXMuc2V0Q29va2llLmJpbmQodGhpcywgY29va2llLCB1cmwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3luYyhzZXRDb29raWVGbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIHRoZSBvdmVybG9hZCBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGdldENvb2tpZXModXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBSRkM2MzY1IFM1LjRcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdEdldENvb2tpZU9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdEdldENvb2tpZU9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvbWlzZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IGNiID0gcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrO1xuICAgICAgICBsZXQgY29udGV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc05vbkVtcHR5U3RyaW5nKHVybCksIGNiLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dCA9IGdldENvb2tpZUNvbnRleHQodXJsKTtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc09iamVjdChvcHRpb25zKSwgY2IsICgwLCB1dGlsc18xLnNhZmVUb1N0cmluZykob3B0aW9ucykpO1xuICAgICAgICAgICAgdmFsaWRhdG9ycy52YWxpZGF0ZSh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicsIGNiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAocGFyYW1ldGVyRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KHBhcmFtZXRlckVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0ID0gKDAsIGNhbm9uaWNhbERvbWFpbl8xLmNhbm9uaWNhbERvbWFpbikoY29udGV4dC5ob3N0bmFtZSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBjb250ZXh0LnBhdGhuYW1lIHx8ICcvJztcbiAgICAgICAgY29uc3Qgc2VjdXJlID0gY29udGV4dC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgKGNvbnRleHQucHJvdG9jb2wgPT0gJ2h0dHBzOicgfHwgY29udGV4dC5wcm90b2NvbCA9PSAnd3NzOicpO1xuICAgICAgICBsZXQgc2FtZVNpdGVMZXZlbCA9IDA7XG4gICAgICAgIGlmIChvcHRpb25zLnNhbWVTaXRlQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3Qgc2FtZVNpdGVDb250ZXh0ID0gY2hlY2tTYW1lU2l0ZUNvbnRleHQob3B0aW9ucy5zYW1lU2l0ZUNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHNhbWVTaXRlQ29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QobmV3IEVycm9yKFNBTUVfU0lURV9DT05URVhUX1ZBTF9FUlIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhbWVTaXRlTGV2ZWwgPSBjb29raWVfMS5Db29raWUuc2FtZVNpdGVMZXZlbFtzYW1lU2l0ZUNvbnRleHRdO1xuICAgICAgICAgICAgaWYgKCFzYW1lU2l0ZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QobmV3IEVycm9yKFNBTUVfU0lURV9DT05URVhUX1ZBTF9FUlIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBodHRwID0gb3B0aW9ucy5odHRwID8/IHRydWU7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGV4cGlyZUNoZWNrID0gb3B0aW9ucy5leHBpcmUgPz8gdHJ1ZTtcbiAgICAgICAgY29uc3QgYWxsUGF0aHMgPSBvcHRpb25zLmFsbFBhdGhzID8/IGZhbHNlO1xuICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoaW5nQ29va2llKGMpIHtcbiAgICAgICAgICAgIC8vIFwiRWl0aGVyOlxuICAgICAgICAgICAgLy8gICBUaGUgY29va2llJ3MgaG9zdC1vbmx5LWZsYWcgaXMgdHJ1ZSBhbmQgdGhlIGNhbm9uaWNhbGl6ZWRcbiAgICAgICAgICAgIC8vICAgcmVxdWVzdC1ob3N0IGlzIGlkZW50aWNhbCB0byB0aGUgY29va2llJ3MgZG9tYWluLlxuICAgICAgICAgICAgLy8gT3I6XG4gICAgICAgICAgICAvLyAgIFRoZSBjb29raWUncyBob3N0LW9ubHktZmxhZyBpcyBmYWxzZSBhbmQgdGhlIGNhbm9uaWNhbGl6ZWRcbiAgICAgICAgICAgIC8vICAgcmVxdWVzdC1ob3N0IGRvbWFpbi1tYXRjaGVzIHRoZSBjb29raWUncyBkb21haW4uXCJcbiAgICAgICAgICAgIGlmIChjLmhvc3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZG9tYWluICE9IGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIGRvbWFpbk1hdGNoXzEuZG9tYWluTWF0Y2gpKGhvc3QgPz8gdW5kZWZpbmVkLCBjLmRvbWFpbiA/PyB1bmRlZmluZWQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJUaGUgcmVxdWVzdC11cmkncyBwYXRoIHBhdGgtbWF0Y2hlcyB0aGUgY29va2llJ3MgcGF0aC5cIlxuICAgICAgICAgICAgaWYgKCFhbGxQYXRocyAmJiB0eXBlb2YgYy5wYXRoID09PSAnc3RyaW5nJyAmJiAhKDAsIHBhdGhNYXRjaF8xLnBhdGhNYXRjaCkocGF0aCwgYy5wYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwiSWYgdGhlIGNvb2tpZSdzIHNlY3VyZS1vbmx5LWZsYWcgaXMgdHJ1ZSwgdGhlbiB0aGUgcmVxdWVzdC11cmknc1xuICAgICAgICAgICAgLy8gc2NoZW1lIG11c3QgZGVub3RlIGEgXCJzZWN1cmVcIiBwcm90b2NvbFwiXG4gICAgICAgICAgICBpZiAoYy5zZWN1cmUgJiYgIXNlY3VyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwiSWYgdGhlIGNvb2tpZSdzIGh0dHAtb25seS1mbGFnIGlzIHRydWUsIHRoZW4gZXhjbHVkZSB0aGUgY29va2llIGlmIHRoZVxuICAgICAgICAgICAgLy8gY29va2llLXN0cmluZyBpcyBiZWluZyBnZW5lcmF0ZWQgZm9yIGEgXCJub24tSFRUUFwiIEFQSVwiXG4gICAgICAgICAgICBpZiAoYy5odHRwT25seSAmJiAhaHR0cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJGQzYyNjViaXMtMDIgUzUuMy43XG4gICAgICAgICAgICBpZiAoc2FtZVNpdGVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb29raWVMZXZlbDtcbiAgICAgICAgICAgICAgICBpZiAoYy5zYW1lU2l0ZSA9PT0gJ2xheCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29va2llTGV2ZWwgPSBjb29raWVfMS5Db29raWUuc2FtZVNpdGVMZXZlbC5sYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMuc2FtZVNpdGUgPT09ICdzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZUxldmVsID0gY29va2llXzEuQ29va2llLnNhbWVTaXRlTGV2ZWwuc3RyaWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29va2llTGV2ZWwgPSBjb29raWVfMS5Db29raWUuc2FtZVNpdGVMZXZlbC5ub25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29va2llTGV2ZWwgPiBzYW1lU2l0ZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWxsb3cgY29va2llcyBhdCBvciBiZWxvdyB0aGUgcmVxdWVzdCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmZXJyZWQgZnJvbSBTNS4zXG4gICAgICAgICAgICAvLyBub24tUkZDOiBhbGxvdyByZXRlbnRpb24gb2YgZXhwaXJlZCBjb29raWVzIGJ5IGNob2ljZVxuICAgICAgICAgICAgY29uc3QgZXhwaXJ5VGltZSA9IGMuZXhwaXJ5VGltZSgpO1xuICAgICAgICAgICAgaWYgKGV4cGlyZUNoZWNrICYmIGV4cGlyeVRpbWUgIT0gdW5kZWZpbmVkICYmIGV4cGlyeVRpbWUgPD0gbm93KSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucmVtb3ZlQ29va2llKGMuZG9tYWluLCBjLnBhdGgsIGMua2V5LCAoKSA9PiB7IH0pOyAvLyByZXN1bHQgaWdub3JlZFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLmZpbmRDb29raWVzKGhvc3QsIGFsbFBhdGhzID8gbnVsbCA6IHBhdGgsIHRoaXMuYWxsb3dTcGVjaWFsVXNlRG9tYWluLCAoZXJyLCBjb29raWVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29va2llcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgW10pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvb2tpZXMgPSBjb29raWVzLmZpbHRlcihtYXRjaGluZ0Nvb2tpZSk7XG4gICAgICAgICAgICAvLyBzb3J0aW5nIG9mIFM1LjQgcGFydCAyXG4gICAgICAgICAgICBpZiAoJ3NvcnQnIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvb2tpZXMgPSBjb29raWVzLnNvcnQoY29va2llQ29tcGFyZV8xLmNvb2tpZUNvbXBhcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUzUuNCBwYXJ0IDNcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgICAgICAgY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gcGVyc2lzdCBsYXN0QWNjZXNzZWRcbiAgICAgICAgICAgIGNiKG51bGwsIGNvb2tpZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IHJldHJpZXZlIHRoZSBsaXN0IG9mIGNvb2tpZXMgdGhhdCBjYW4gYmUgc2VudCBpbiBhIENvb2tpZSBoZWFkZXIgZm9yIHRoZVxuICAgICAqIGN1cnJlbnQgVVJMLlxuICAgICAqXG4gICAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIHRoZSBjb25maWd1cmVkIFN0b3JlIGlzIGFsc28gc3luY2hyb25vdXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIC0gVGhlIGFycmF5IG9mIGNvb2tpZXMgcmV0dXJuZWQgd2lsbCBiZSBzb3J0ZWQgYWNjb3JkaW5nIHRvIHtAbGluayBjb29raWVDb21wYXJlfS5cbiAgICAgKlxuICAgICAqIC0gVGhlIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSBwcm9wZXJ0eSB3aWxsIGJlIHVwZGF0ZWQgb24gYWxsIHJldHVybmVkIGNvb2tpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIGRvbWFpbiB0byBzdG9yZSB0aGUgY29va2llIHdpdGguXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIHNldHRpbmdzIHRvIHVzZSB3aGVuIHJldHJpZXZpbmcgdGhlIGNvb2tpZXMuXG4gICAgICovXG4gICAgZ2V0Q29va2llc1N5bmModXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTeW5jKHRoaXMuZ2V0Q29va2llcy5iaW5kKHRoaXMsIHVybCwgb3B0aW9ucykpID8/IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBnZXRDb29raWVTdHJpbmcodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvbWlzZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbiAoZXJyLCBjb29raWVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2sobnVsbCwgY29va2llc1xuICAgICAgICAgICAgICAgICAgICA/LnNvcnQoY29va2llQ29tcGFyZV8xLmNvb2tpZUNvbXBhcmUpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IGMuY29va2llU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDb29raWVzKHVybCwgb3B0aW9ucywgbmV4dCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiBgLmdldENvb2tpZVN0cmluZygpYC4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIGAuZ2V0Q29va2llcygpYCBidXQgcmV0dXJucyBhIHN0cmluZyBzdWl0YWJsZSBmb3IgYVxuICAgICAqIGBDb29raWVgIGhlYWRlciByYXRoZXIgdGhhbiBhbiBBcnJheS5cbiAgICAgKlxuICAgICAqIDxzdHJvbmc+Tm90ZTwvc3Ryb25nPjogT25seSB3b3JrcyBpZiB0aGUgY29uZmlndXJlZCBTdG9yZSBpcyBhbHNvIHN5bmNocm9ub3VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBkb21haW4gdG8gc3RvcmUgdGhlIGNvb2tpZSB3aXRoLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5ncyB0byB1c2Ugd2hlbiByZXRyaWV2aW5nIHRoZSBjb29raWVzLlxuICAgICAqL1xuICAgIGdldENvb2tpZVN0cmluZ1N5bmModXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jYWxsU3luYyhvcHRpb25zXG4gICAgICAgICAgICA/IHRoaXMuZ2V0Q29va2llU3RyaW5nLmJpbmQodGhpcywgdXJsLCBvcHRpb25zKVxuICAgICAgICAgICAgOiB0aGlzLmdldENvb2tpZVN0cmluZy5iaW5kKHRoaXMsIHVybCkpID8/ICcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgZ2V0U2V0Q29va2llU3RyaW5ncyh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSAoMCwgdXRpbHNfMS5jcmVhdGVQcm9taXNlQ2FsbGJhY2spKGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGZ1bmN0aW9uIChlcnIsIGNvb2tpZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhudWxsLCBjb29raWVzPy5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29va2llcyh1cmwsIG9wdGlvbnMsIG5leHQpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgYC5nZXRTZXRDb29raWVTdHJpbmdzKClgLiBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3Mgc3VpdGFibGUgZm9yIGBTZXQtQ29va2llYCBoZWFkZXJzLlxuICAgICAqIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyBgLmdldENvb2tpZXMoKWAuXG4gICAgICpcbiAgICAgKiA8c3Ryb25nPk5vdGU8L3N0cm9uZz46IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQgU3RvcmUgaXMgYWxzbyBzeW5jaHJvbm91cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgZG9tYWluIHRvIHN0b3JlIHRoZSBjb29raWUgd2l0aC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gc2V0dGluZ3MgdG8gdXNlIHdoZW4gcmV0cmlldmluZyB0aGUgY29va2llcy5cbiAgICAgKi9cbiAgICBnZXRTZXRDb29raWVTdHJpbmdzU3luYyh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY2FsbFN5bmModGhpcy5nZXRTZXRDb29raWVTdHJpbmdzLmJpbmQodGhpcywgdXJsLCBvcHRpb25zKSkgPz8gW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvbWlzZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zdG9yZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBpZiAodmFsaWRhdG9ycy5pc09iamVjdCh0eXBlKSkge1xuICAgICAgICAgICAgdHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIFJFQURNRS5tZCBcIlNlcmlhbGl6YXRpb24gRm9ybWF0XCIgaWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UhXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgICAgICAvLyBUaGUgdmVyc2lvbiBvZiB0b3VnaC1jb29raWUgdGhhdCBzZXJpYWxpemVkIHRoaXMgamFyLiBHZW5lcmFsbHkgYSBnb29kXG4gICAgICAgICAgICAvLyBwcmFjdGljZSBzaW5jZSBmdXR1cmUgdmVyc2lvbnMgY2FuIG1ha2UgZGF0YSBpbXBvcnQgZGVjaXNpb25zIGJhc2VkIG9uXG4gICAgICAgICAgICAvLyBrbm93biBwYXN0IGJlaGF2aW9yLiBXaGVuL2lmIHRoaXMgbWF0dGVycywgdXNlIGBzZW12ZXJgLlxuICAgICAgICAgICAgdmVyc2lvbjogYHRvdWdoLWNvb2tpZUAke3ZlcnNpb25fMS52ZXJzaW9ufWAsXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHN0b3JlIHR5cGUsIHRvIG1ha2UgaHVtYW5zIGhhcHB5OlxuICAgICAgICAgICAgc3RvcmVUeXBlOiB0eXBlLFxuICAgICAgICAgICAgLy8gQ29va2llSmFyIGNvbmZpZ3VyYXRpb246XG4gICAgICAgICAgICByZWplY3RQdWJsaWNTdWZmaXhlczogdGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyxcbiAgICAgICAgICAgIGVuYWJsZUxvb3NlTW9kZTogdGhpcy5lbmFibGVMb29zZU1vZGUsXG4gICAgICAgICAgICBhbGxvd1NwZWNpYWxVc2VEb21haW46IHRoaXMuYWxsb3dTcGVjaWFsVXNlRG9tYWluLFxuICAgICAgICAgICAgcHJlZml4U2VjdXJpdHk6IGdldE5vcm1hbGl6ZWRQcmVmaXhTZWN1cml0eSh0aGlzLnByZWZpeFNlY3VyaXR5KSxcbiAgICAgICAgICAgIC8vIHRoaXMgZ2V0cyBmaWxsZWQgZnJvbSBnZXRBbGxDb29raWVzOlxuICAgICAgICAgICAgY29va2llczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdG9yZS5nZXRBbGxDb29raWVzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChuZXcgRXJyb3IoJ3N0b3JlIGRvZXMgbm90IHN1cHBvcnQgZ2V0QWxsQ29va2llcyBhbmQgY2Fubm90IGJlIHNlcmlhbGl6ZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZS5nZXRBbGxDb29raWVzKChlcnIsIGNvb2tpZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29va2llcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKG51bGwsIHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuY29va2llcyA9IGNvb2tpZXMubWFwKChjb29raWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRvIHNlcmlhbGl6ZWQgJ3JhdycgY29va2llc1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDb29raWUgPSBjb29raWUudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpbmRleCBzbyBuZXcgb25lcyBnZXQgYXNzaWduZWQgZHVyaW5nIGRlc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkQ29va2llLmNyZWF0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDb29raWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhudWxsLCBzZXJpYWxpemVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBDb29raWVKYXIgaWYgdGhlIHVuZGVybHlpbmcgc3RvcmUgc3VwcG9ydHMgYC5nZXRBbGxDb29raWVzYC5cbiAgICAgKlxuICAgICAqIDxzdHJvbmc+Tm90ZTwvc3Ryb25nPjogT25seSB3b3JrcyBpZiB0aGUgY29uZmlndXJlZCBTdG9yZSBpcyBhbHNvIHN5bmNocm9ub3VzLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZVN5bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTeW5jKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemUoY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2Yge0BsaW5rIENvb2tpZUphci5zZXJpYWxpemVTeW5jfS4gQWxsb3dzIHRoZSBjb29raWUgdG8gYmUgc2VyaWFsaXplZFxuICAgICAqIHdpdGggYEpTT04uc3RyaW5naWZ5KGNvb2tpZUphcilgLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplU3luYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGNsYXNzIG1ldGhvZCBDb29raWVKYXIuZGVzZXJpYWxpemUgaW5zdGVhZCBvZiBjYWxsaW5nIHRoaXMgZGlyZWN0bHlcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW1wb3J0Q29va2llcyhzZXJpYWxpemVkLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY29va2llcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZXJpYWxpemVkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKDAsIHV0aWxzXzEuaW5PcGVyYXRvcikoJ2Nvb2tpZXMnLCBzZXJpYWxpemVkKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzZXJpYWxpemVkLmNvb2tpZXMpKSB7XG4gICAgICAgICAgICBjb29raWVzID0gc2VyaWFsaXplZC5jb29raWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29va2llcykge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdzZXJpYWxpemVkIGphciBoYXMgbm8gY29va2llcyBhcnJheScpLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvb2tpZXMgPSBjb29raWVzLnNsaWNlKCk7IC8vIGRvIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gICAgICAgIGNvbnN0IHB1dE5leHQgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvb2tpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb29raWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb29raWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29va2llID0gY29va2llXzEuQ29va2llLmZyb21KU09OKGNvb2tpZXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoKSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29va2llID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHV0TmV4dChudWxsKTsgLy8gc2tpcCB0aGlzIGNvb2tpZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUucHV0Q29va2llKGNvb2tpZSwgcHV0TmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHB1dE5leHQobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9pbXBvcnRDb29raWVzU3luYyhzZXJpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuY2FsbFN5bmModGhpcy5faW1wb3J0Q29va2llcy5iaW5kKHRoaXMsIHNlcmlhbGl6ZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgY2xvbmUobmV3U3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3U3RvcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbmV3U3RvcmU7XG4gICAgICAgICAgICBuZXdTdG9yZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSAoMCwgdXRpbHNfMS5jcmVhdGVQcm9taXNlQ2FsbGJhY2spKGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgY2IgPSBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplKChlcnIsIHNlcmlhbGl6ZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENvb2tpZUphci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkID8/ICcnLCBuZXdTdG9yZSwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY2xvbmVTeW5jKG5ld1N0b3JlKSB7XG4gICAgICAgIGNvbnN0IGNsb25lRm4gPSBuZXdTdG9yZSAmJiB0eXBlb2YgbmV3U3RvcmUgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gdGhpcy5jbG9uZS5iaW5kKHRoaXMsIG5ld1N0b3JlKVxuICAgICAgICAgICAgOiB0aGlzLmNsb25lLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTeW5jKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY2xvbmVGbihjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGRlZXAgY2xvbmUgb2YgdGhpcyBDb29raWVKYXIuIE1vZGlmaWNhdGlvbnMgdG8gdGhlIG9yaWdpbmFsIGRvXG4gICAgICogbm90IGFmZmVjdCB0aGUgY2xvbmUsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAqXG4gICAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIGJvdGggdGhlIGNvbmZpZ3VyZWQgU3RvcmUgYW5kIGRlc3RpbmF0aW9uXG4gICAgICogU3RvcmUgYXJlIHN5bmNocm9ub3VzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiAtIFdoZW4gbm8ge0BsaW5rIFN0b3JlfSBpcyBwcm92aWRlZCwgYSBuZXcge0BsaW5rIE1lbW9yeUNvb2tpZVN0b3JlfSB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiAtIFRyYW5zZmVycmluZyBiZXR3ZWVuIHN0b3JlIHR5cGVzIGlzIHN1cHBvcnRlZCBzbyBsb25nIGFzIHRoZSBzb3VyY2VcbiAgICAgKiAgICAgaW1wbGVtZW50cyBgLmdldEFsbENvb2tpZXMoKWAgYW5kIHRoZSBkZXN0aW5hdGlvbiBpbXBsZW1lbnRzIGAucHV0Q29va2llKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld1N0b3JlIC0gVGhlIHRhcmdldCB7QGxpbmsgU3RvcmV9IHRvIGNsb25lIGNvb2tpZXMgaW50by5cbiAgICAgKi9cbiAgICBjbG9uZVN5bmMobmV3U3RvcmUpIHtcbiAgICAgICAgaWYgKCFuZXdTdG9yZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lU3luYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29va2llSmFyIGNsb25lIGRlc3RpbmF0aW9uIHN0b3JlIGlzIG5vdCBzeW5jaHJvbm91czsgdXNlIGFzeW5jIEFQSSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZVN5bmMobmV3U3RvcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICByZW1vdmVBbGxDb29raWVzKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9ICgwLCB1dGlsc18xLmNyZWF0ZVByb21pc2VDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBjYiA9IHByb21pc2VDYWxsYmFjay5jYWxsYmFjaztcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzdG9yZSBpbXBsZW1lbnRzIGl0cyBvd24gcmVtb3ZlQWxsQ29va2llcygpLiBUaGUgZGVmYXVsdFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBpbiBTdG9yZSB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggYSBcIm5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZFwiIEVycm9yLlxuICAgICAgICBpZiAodHlwZW9mIHN0b3JlLnJlbW92ZUFsbENvb2tpZXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIHN0b3JlLnJlbW92ZUFsbENvb2tpZXMgIT09IHN0b3JlXzEuU3RvcmUucHJvdG90eXBlLnJlbW92ZUFsbENvb2tpZXMpIHtcbiAgICAgICAgICAgIC8vIGBDYWxsYmFjazx1bmRlZmluZWQ+YCBhbmQgYEVycm9yQ2FsbGJhY2tgIGFyZSAqdGVjaG5pY2FsbHkqIGluY29tcGF0aWJsZSwgYnV0IGZvciB0aGVcbiAgICAgICAgICAgIC8vIHN0YW5kYXJkIGltcGxlbWVudGF0aW9uIGBjYiA9IChlcnIsIHJlc3VsdCkgPT4ge31gLCB0aGV5J3JlIGVzc2VudGlhbGx5IHRoZSBzYW1lLlxuICAgICAgICAgICAgc3RvcmUucmVtb3ZlQWxsQ29va2llcyhjYik7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuZ2V0QWxsQ29va2llcygoZXJyLCBjb29raWVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBjb29raWVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29va2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb21wbGV0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRvIGF2b2lkIHVzaW5nIGNhbGxiYWNrXG4gICAgICAgICAgICBjb25zdCByZW1vdmVDb29raWVDYiA9IGZ1bmN0aW9uIHJlbW92ZUNvb2tpZUNiKHJlbW92ZUVycikge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXJyb3JzLnB1c2gocmVtb3ZlRXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcGxldGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkQ291bnQgPT09IGNvb2tpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVFcnJvcnNbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihyZW1vdmVFcnJvcnNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihudWxsLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvb2tpZXMuZm9yRWFjaCgoY29va2llKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmUucmVtb3ZlQ29va2llKGNvb2tpZS5kb21haW4sIGNvb2tpZS5wYXRoLCBjb29raWUua2V5LCByZW1vdmVDb29raWVDYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgY29va2llcyBmcm9tIHRoZSBDb29raWVKYXIuXG4gICAgICpcbiAgICAgKiA8c3Ryb25nPk5vdGU8L3N0cm9uZz46IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQgU3RvcmUgaXMgYWxzbyBzeW5jaHJvbm91cy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogLSBUaGlzIGlzIGEgbmV3IGJhY2t3YXJkcy1jb21wYXRpYmxlIGZlYXR1cmUgb2YgdG91Z2gtY29va2llIHZlcnNpb24gMi41LFxuICAgICAqICAgICBzbyBub3QgYWxsIFN0b3JlcyB3aWxsIGltcGxlbWVudCBpdCBlZmZpY2llbnRseS4gRm9yIFN0b3JlcyB0aGF0IGRvIG5vdFxuICAgICAqICAgICBpbXBsZW1lbnQgYHJlbW92ZUFsbENvb2tpZXNgLCB0aGUgZmFsbGJhY2sgaXMgdG8gY2FsbCBgcmVtb3ZlQ29va2llYCBhZnRlclxuICAgICAqICAgICBgZ2V0QWxsQ29va2llc2AuXG4gICAgICpcbiAgICAgKiAtIElmIGBnZXRBbGxDb29raWVzYCBmYWlscyBvciBpc24ndCBpbXBsZW1lbnRlZCBpbiB0aGUgU3RvcmUsIGFuIGVycm9yIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogLSBJZiBvbmUgb3IgbW9yZSBvZiB0aGUgYHJlbW92ZUNvb2tpZWAgY2FsbHMgZmFpbCwgb25seSB0aGUgZmlyc3QgZXJyb3IgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsQ29va2llc1N5bmMoKSB7XG4gICAgICAgIHRoaXMuY2FsbFN5bmMoKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAvLyBgQ2FsbGJhY2s8dW5kZWZpbmVkPmAgYW5kIGBFcnJvckNhbGxiYWNrYCBhcmUgKnRlY2huaWNhbGx5KiBpbmNvbXBhdGlibGUsIGJ1dCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBzdGFuZGFyZCBpbXBsZW1lbnRhdGlvbiBgY2IgPSAoZXJyLCByZXN1bHQpID0+IHt9YCwgdGhleSdyZSBlc3NlbnRpYWxseSB0aGUgc2FtZS5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsQ29va2llcyhjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3RyT3JPYmosIHN0b3JlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHN0b3JlO1xuICAgICAgICAgICAgc3RvcmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvbWlzZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xuICAgICAgICBpZiAodHlwZW9mIHN0ck9yT2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkID0gSlNPTi5wYXJzZShzdHJPck9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0gc3RyT3JPYmo7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhZFNlcmlhbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2VyaWFsaXplZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5pbk9wZXJhdG9yKShwcm9wZXJ0eSwgc2VyaWFsaXplZClcbiAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZWRbcHJvcGVydHldXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlYWRTZXJpYWxpemVkQm9vbGVhbiA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkU2VyaWFsaXplZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWFkU2VyaWFsaXplZFN0cmluZyA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkU2VyaWFsaXplZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGphciA9IG5ldyBDb29raWVKYXIoc3RvcmUsIHtcbiAgICAgICAgICAgIHJlamVjdFB1YmxpY1N1ZmZpeGVzOiByZWFkU2VyaWFsaXplZEJvb2xlYW4oJ3JlamVjdFB1YmxpY1N1ZmZpeGVzJyksXG4gICAgICAgICAgICBsb29zZU1vZGU6IHJlYWRTZXJpYWxpemVkQm9vbGVhbignZW5hYmxlTG9vc2VNb2RlJyksXG4gICAgICAgICAgICBhbGxvd1NwZWNpYWxVc2VEb21haW46IHJlYWRTZXJpYWxpemVkQm9vbGVhbignYWxsb3dTcGVjaWFsVXNlRG9tYWluJyksXG4gICAgICAgICAgICBwcmVmaXhTZWN1cml0eTogZ2V0Tm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KHJlYWRTZXJpYWxpemVkU3RyaW5nKCdwcmVmaXhTZWN1cml0eScpID8/ICdzaWxlbnQnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGphci5faW1wb3J0Q29va2llcyhzZXJpYWxpemVkLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKG51bGwsIGphcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbmV3IENvb2tpZUphciBpcyBjcmVhdGVkIGFuZCB0aGUgc2VyaWFsaXplZCB7QGxpbmsgQ29va2llfSB2YWx1ZXMgYXJlIGFkZGVkIHRvXG4gICAgICogdGhlIHVuZGVybHlpbmcgc3RvcmUuIEVhY2gge0BsaW5rIENvb2tpZX0gaXMgYWRkZWQgdmlhIGBzdG9yZS5wdXRDb29raWUoLi4uKWAgaW5cbiAgICAgKiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcHBlYXIgaW4gdGhlIHNlcmlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiA8c3Ryb25nPk5vdGU8L3N0cm9uZz46IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQgU3RvcmUgaXMgYWxzbyBzeW5jaHJvbm91cy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogLSBXaGVuIG5vIHtAbGluayBTdG9yZX0gaXMgcHJvdmlkZWQsIGEgbmV3IHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0gd2lsbCBiZSB1c2VkLlxuICAgICAqXG4gICAgICogLSBBcyBhIGNvbnZlbmllbmNlLCBpZiBgc3RyT3JPYmpgIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXNzZWQgdGhyb3VnaCBgSlNPTi5wYXJzZWAgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyT3JPYmogLSBBIEpTT04gc3RyaW5nIG9yIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRlc2VyaWFsaXplZCBjb29raWVzLlxuICAgICAqIEBwYXJhbSBzdG9yZSAtIFRoZSB1bmRlcmx5aW5nIHN0b3JlIHRvIHBlcnNpc3QgdGhlIGRlc2VyaWFsaXplZCBjb29raWVzIGludG8uXG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplU3luYyhzdHJPck9iaiwgc3RvcmUpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHR5cGVvZiBzdHJPck9iaiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKHN0ck9yT2JqKSA6IHN0ck9yT2JqO1xuICAgICAgICBjb25zdCByZWFkU2VyaWFsaXplZFByb3BlcnR5ID0gKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZXJpYWxpemVkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLmluT3BlcmF0b3IpKHByb3BlcnR5LCBzZXJpYWxpemVkKVxuICAgICAgICAgICAgICAgID8gc2VyaWFsaXplZFtwcm9wZXJ0eV1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVhZFNlcmlhbGl6ZWRCb29sZWFuID0gKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlYWRTZXJpYWxpemVkUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlYWRTZXJpYWxpemVkU3RyaW5nID0gKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlYWRTZXJpYWxpemVkUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgamFyID0gbmV3IENvb2tpZUphcihzdG9yZSwge1xuICAgICAgICAgICAgcmVqZWN0UHVibGljU3VmZml4ZXM6IHJlYWRTZXJpYWxpemVkQm9vbGVhbigncmVqZWN0UHVibGljU3VmZml4ZXMnKSxcbiAgICAgICAgICAgIGxvb3NlTW9kZTogcmVhZFNlcmlhbGl6ZWRCb29sZWFuKCdlbmFibGVMb29zZU1vZGUnKSxcbiAgICAgICAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogcmVhZFNlcmlhbGl6ZWRCb29sZWFuKCdhbGxvd1NwZWNpYWxVc2VEb21haW4nKSxcbiAgICAgICAgICAgIHByZWZpeFNlY3VyaXR5OiBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkocmVhZFNlcmlhbGl6ZWRTdHJpbmcoJ3ByZWZpeFNlY3VyaXR5JykgPz8gJ3NpbGVudCcpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2F0Y2ggdGhpcyBtaXN0YWtlIGVhcmx5OlxuICAgICAgICBpZiAoIWphci5zdG9yZS5zeW5jaHJvbm91cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVKYXIgc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgamFyLl9pbXBvcnRDb29raWVzU3luYyhzZXJpYWxpemVkKTtcbiAgICAgICAgcmV0dXJuIGphcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2Yge0BsaW5rIENvb2tpZUphci5kZXNlcmlhbGl6ZVN5bmN9LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiAtIFdoZW4gbm8ge0BsaW5rIFN0b3JlfSBpcyBwcm92aWRlZCwgYSBuZXcge0BsaW5rIE1lbW9yeUNvb2tpZVN0b3JlfSB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiAtIEFzIGEgY29udmVuaWVuY2UsIGlmIGBzdHJPck9iamAgaXMgYSBzdHJpbmcsIGl0IGlzIHBhc3NlZCB0aHJvdWdoIGBKU09OLnBhcnNlYCBmaXJzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqc29uU3RyaW5nIC0gQSBKU09OIHN0cmluZyBvciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgY29va2llcy5cbiAgICAgKiBAcGFyYW0gc3RvcmUgLSBUaGUgdW5kZXJseWluZyBzdG9yZSB0byBwZXJzaXN0IHRoZSBkZXNlcmlhbGl6ZWQgY29va2llcyBpbnRvLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uU3RyaW5nLCBzdG9yZSkge1xuICAgICAgICByZXR1cm4gQ29va2llSmFyLmRlc2VyaWFsaXplU3luYyhqc29uU3RyaW5nLCBzdG9yZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db29raWVKYXIgPSBDb29raWVKYXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookieJar.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/defaultPath.js":
/*!**************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/defaultPath.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultPath = defaultPath;\n/**\n * Given a current request/response path, gives the path appropriate for storing\n * in a cookie. This is basically the \"directory\" of a \"file\" in the path, but\n * is specified by {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.4 | RFC6265 - Section 5.1.4}.\n *\n * @remarks\n * ### RFC6265 - Section 5.1.4\n *\n * The user agent MUST use an algorithm equivalent to the following algorithm to compute the default-path of a cookie:\n *\n * 1. Let uri-path be the path portion of the request-uri if such a\n *     portion exists (and empty otherwise).  For example, if the\n *     request-uri contains just a path (and optional query string),\n *     then the uri-path is that path (without the %x3F (\"?\") character\n *     or query string), and if the request-uri contains a full\n *     absoluteURI, the uri-path is the path component of that URI.\n *\n * 2. If the uri-path is empty or if the first character of the uri-\n *     path is not a %x2F (\"/\") character, output %x2F (\"/\") and skip\n *     the remaining steps.\n *\n * 3. If the uri-path contains no more than one %x2F (\"/\") character,\n *     output %x2F (\"/\") and skip the remaining step.\n *\n * 4. Output the characters of the uri-path from the first character up\n *     to, but not including, the right-most %x2F (\"/\").\n *\n * @example\n * ```\n * defaultPath('') === '/'\n * defaultPath('/some-path') === '/'\n * defaultPath('/some-parent-path/some-path') === '/some-parent-path'\n * defaultPath('relative-path') === '/'\n * ```\n *\n * @param path - the path portion of the request-uri (excluding the hostname, query, fragment, and so on)\n * @public\n */\nfunction defaultPath(path) {\n    // \"2. If the uri-path is empty or if the first character of the uri-path is not\n    // a %x2F (\"/\") character, output %x2F (\"/\") and skip the remaining steps.\n    if (!path || path.slice(0, 1) !== '/') {\n        return '/';\n    }\n    // \"3. If the uri-path contains no more than one %x2F (\"/\") character, output\n    // %x2F (\"/\") and skip the remaining step.\"\n    if (path === '/') {\n        return path;\n    }\n    const rightSlash = path.lastIndexOf('/');\n    if (rightSlash === 0) {\n        return '/';\n    }\n    // \"4. Output the characters of the uri-path from the first character up to,\n    // but not including, the right-most %x2F (\"/\").\"\n    return path.slice(0, rightSlash);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvZGVmYXVsdFBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwRkFBMEY7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvZGVmYXVsdFBhdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRQYXRoID0gZGVmYXVsdFBhdGg7XG4vKipcbiAqIEdpdmVuIGEgY3VycmVudCByZXF1ZXN0L3Jlc3BvbnNlIHBhdGgsIGdpdmVzIHRoZSBwYXRoIGFwcHJvcHJpYXRlIGZvciBzdG9yaW5nXG4gKiBpbiBhIGNvb2tpZS4gVGhpcyBpcyBiYXNpY2FsbHkgdGhlIFwiZGlyZWN0b3J5XCIgb2YgYSBcImZpbGVcIiBpbiB0aGUgcGF0aCwgYnV0XG4gKiBpcyBzcGVjaWZpZWQgYnkge0BsaW5rIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1Lmh0bWwjc2VjdGlvbi01LjEuNCB8IFJGQzYyNjUgLSBTZWN0aW9uIDUuMS40fS5cbiAqXG4gKiBAcmVtYXJrc1xuICogIyMjIFJGQzYyNjUgLSBTZWN0aW9uIDUuMS40XG4gKlxuICogVGhlIHVzZXIgYWdlbnQgTVVTVCB1c2UgYW4gYWxnb3JpdGhtIGVxdWl2YWxlbnQgdG8gdGhlIGZvbGxvd2luZyBhbGdvcml0aG0gdG8gY29tcHV0ZSB0aGUgZGVmYXVsdC1wYXRoIG9mIGEgY29va2llOlxuICpcbiAqIDEuIExldCB1cmktcGF0aCBiZSB0aGUgcGF0aCBwb3J0aW9uIG9mIHRoZSByZXF1ZXN0LXVyaSBpZiBzdWNoIGFcbiAqICAgICBwb3J0aW9uIGV4aXN0cyAoYW5kIGVtcHR5IG90aGVyd2lzZSkuICBGb3IgZXhhbXBsZSwgaWYgdGhlXG4gKiAgICAgcmVxdWVzdC11cmkgY29udGFpbnMganVzdCBhIHBhdGggKGFuZCBvcHRpb25hbCBxdWVyeSBzdHJpbmcpLFxuICogICAgIHRoZW4gdGhlIHVyaS1wYXRoIGlzIHRoYXQgcGF0aCAod2l0aG91dCB0aGUgJXgzRiAoXCI/XCIpIGNoYXJhY3RlclxuICogICAgIG9yIHF1ZXJ5IHN0cmluZyksIGFuZCBpZiB0aGUgcmVxdWVzdC11cmkgY29udGFpbnMgYSBmdWxsXG4gKiAgICAgYWJzb2x1dGVVUkksIHRoZSB1cmktcGF0aCBpcyB0aGUgcGF0aCBjb21wb25lbnQgb2YgdGhhdCBVUkkuXG4gKlxuICogMi4gSWYgdGhlIHVyaS1wYXRoIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHVyaS1cbiAqICAgICBwYXRoIGlzIG5vdCBhICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIsIG91dHB1dCAleDJGIChcIi9cIikgYW5kIHNraXBcbiAqICAgICB0aGUgcmVtYWluaW5nIHN0ZXBzLlxuICpcbiAqIDMuIElmIHRoZSB1cmktcGF0aCBjb250YWlucyBubyBtb3JlIHRoYW4gb25lICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIsXG4gKiAgICAgb3V0cHV0ICV4MkYgKFwiL1wiKSBhbmQgc2tpcCB0aGUgcmVtYWluaW5nIHN0ZXAuXG4gKlxuICogNC4gT3V0cHV0IHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1cmktcGF0aCBmcm9tIHRoZSBmaXJzdCBjaGFyYWN0ZXIgdXBcbiAqICAgICB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSByaWdodC1tb3N0ICV4MkYgKFwiL1wiKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBkZWZhdWx0UGF0aCgnJykgPT09ICcvJ1xuICogZGVmYXVsdFBhdGgoJy9zb21lLXBhdGgnKSA9PT0gJy8nXG4gKiBkZWZhdWx0UGF0aCgnL3NvbWUtcGFyZW50LXBhdGgvc29tZS1wYXRoJykgPT09ICcvc29tZS1wYXJlbnQtcGF0aCdcbiAqIGRlZmF1bHRQYXRoKCdyZWxhdGl2ZS1wYXRoJykgPT09ICcvJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHBhdGggLSB0aGUgcGF0aCBwb3J0aW9uIG9mIHRoZSByZXF1ZXN0LXVyaSAoZXhjbHVkaW5nIHRoZSBob3N0bmFtZSwgcXVlcnksIGZyYWdtZW50LCBhbmQgc28gb24pXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQYXRoKHBhdGgpIHtcbiAgICAvLyBcIjIuIElmIHRoZSB1cmktcGF0aCBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSB1cmktcGF0aCBpcyBub3RcbiAgICAvLyBhICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIsIG91dHB1dCAleDJGIChcIi9cIikgYW5kIHNraXAgdGhlIHJlbWFpbmluZyBzdGVwcy5cbiAgICBpZiAoIXBhdGggfHwgcGF0aC5zbGljZSgwLCAxKSAhPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgfVxuICAgIC8vIFwiMy4gSWYgdGhlIHVyaS1wYXRoIGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBvbmUgJXgyRiAoXCIvXCIpIGNoYXJhY3Rlciwgb3V0cHV0XG4gICAgLy8gJXgyRiAoXCIvXCIpIGFuZCBza2lwIHRoZSByZW1haW5pbmcgc3RlcC5cIlxuICAgIGlmIChwYXRoID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHJpZ2h0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgaWYgKHJpZ2h0U2xhc2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9XG4gICAgLy8gXCI0LiBPdXRwdXQgdGhlIGNoYXJhY3RlcnMgb2YgdGhlIHVyaS1wYXRoIGZyb20gdGhlIGZpcnN0IGNoYXJhY3RlciB1cCB0byxcbiAgICAvLyBidXQgbm90IGluY2x1ZGluZywgdGhlIHJpZ2h0LW1vc3QgJXgyRiAoXCIvXCIpLlwiXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgcmlnaHRTbGFzaCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/defaultPath.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/domainMatch.js":
/*!**************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/domainMatch.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.domainMatch = domainMatch;\nconst canonicalDomain_1 = __webpack_require__(/*! ./canonicalDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/canonicalDomain.js\");\n// Dumped from ip-regex@4.0.0, with the following changes:\n// * all capturing groups converted to non-capturing -- \"(?:)\"\n// * support for IPv6 Scoped Literal (\"%eth1\") removed\n// * lowercase hexadecimal only\nconst IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$)|(?:^(?:(?:[a-f\\d]{1,4}:){7}(?:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,2}|:)|(?:[a-f\\d]{1,4}:){4}(?:(?::[a-f\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,3}|:)|(?:[a-f\\d]{1,4}:){3}(?:(?::[a-f\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,4}|:)|(?:[a-f\\d]{1,4}:){2}(?:(?::[a-f\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,5}|:)|(?:[a-f\\d]{1,4}:){1}(?:(?::[a-f\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,7}|:)))$)/;\n/**\n * Answers \"does this real domain match the domain in a cookie?\". The `domain` is the \"current\" domain name and the\n * `cookieDomain` is the \"cookie\" domain name. Matches according to {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.3 | RFC6265 - Section 5.1.3},\n * but it helps to think of it as a \"suffix match\".\n *\n * @remarks\n * ### 5.1.3.  Domain Matching\n *\n * A string domain-matches a given domain string if at least one of the\n * following conditions hold:\n *\n * - The domain string and the string are identical.  (Note that both\n *     the domain string and the string will have been canonicalized to\n *     lower case at this point.)\n *\n * - All of the following conditions hold:\n *\n *     - The domain string is a suffix of the string.\n *\n *     - The last character of the string that is not included in the\n *         domain string is a %x2E (\".\") character.\n *\n *     - The string is a host name (i.e., not an IP address).\n *\n * @example\n * ```\n * domainMatch('example.com', 'example.com') === true\n * domainMatch('eXaMpLe.cOm', 'ExAmPlE.CoM') === true\n * domainMatch('no.ca', 'yes.ca') === false\n * ```\n *\n * @param domain - The domain string to test\n * @param cookieDomain - The cookie domain string to match against\n * @param canonicalize - The canonicalize parameter toggles whether the domain parameters get normalized with canonicalDomain or not\n * @public\n */\nfunction domainMatch(domain, cookieDomain, canonicalize) {\n    if (domain == null || cookieDomain == null) {\n        return undefined;\n    }\n    let _str;\n    let _domStr;\n    if (canonicalize !== false) {\n        _str = (0, canonicalDomain_1.canonicalDomain)(domain);\n        _domStr = (0, canonicalDomain_1.canonicalDomain)(cookieDomain);\n    }\n    else {\n        _str = domain;\n        _domStr = cookieDomain;\n    }\n    if (_str == null || _domStr == null) {\n        return undefined;\n    }\n    /*\n     * S5.1.3:\n     * \"A string domain-matches a given domain string if at least one of the\n     * following conditions hold:\"\n     *\n     * \" o The domain string and the string are identical. (Note that both the\n     * domain string and the string will have been canonicalized to lower case at\n     * this point)\"\n     */\n    if (_str == _domStr) {\n        return true;\n    }\n    /* \" o All of the following [three] conditions hold:\" */\n    /* \"* The domain string is a suffix of the string\" */\n    const idx = _str.lastIndexOf(cookieDomain);\n    if (idx <= 0) {\n        return false; // it's a non-match (-1) or prefix (0)\n    }\n    // next, check it's a proper suffix\n    // e.g., \"a.b.c\".indexOf(\"b.c\") === 2\n    // 5 === 3+2\n    if (_str.length !== _domStr.length + idx) {\n        return false; // it's not a suffix\n    }\n    /* \"  * The last character of the string that is not included in the\n     * domain string is a %x2E (\".\") character.\" */\n    if (_str.substring(idx - 1, idx) !== '.') {\n        return false; // doesn't align on \".\"\n    }\n    /* \"  * The string is a host name (i.e., not an IP address).\" */\n    return !IP_REGEX_LOWERCASE.test(_str);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvZG9tYWluTWF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLDBCQUEwQixtQkFBTyxDQUFDLHlHQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCxFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUksZUFBZSxJQUFJLEdBQUcsRUFBRSxvRkFBb0YsRUFBRSxVQUFVLElBQUksZUFBZSxJQUFJLEdBQUcsRUFBRSxxRkFBcUYsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLHVCQUF1QixJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJO0FBQzlwQztBQUNBO0FBQ0EscUVBQXFFLDBGQUEwRjtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvZG9tYWluTWF0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRvbWFpbk1hdGNoID0gZG9tYWluTWF0Y2g7XG5jb25zdCBjYW5vbmljYWxEb21haW5fMSA9IHJlcXVpcmUoXCIuL2Nhbm9uaWNhbERvbWFpblwiKTtcbi8vIER1bXBlZCBmcm9tIGlwLXJlZ2V4QDQuMC4wLCB3aXRoIHRoZSBmb2xsb3dpbmcgY2hhbmdlczpcbi8vICogYWxsIGNhcHR1cmluZyBncm91cHMgY29udmVydGVkIHRvIG5vbi1jYXB0dXJpbmcgLS0gXCIoPzopXCJcbi8vICogc3VwcG9ydCBmb3IgSVB2NiBTY29wZWQgTGl0ZXJhbCAoXCIlZXRoMVwiKSByZW1vdmVkXG4vLyAqIGxvd2VyY2FzZSBoZXhhZGVjaW1hbCBvbmx5XG5jb25zdCBJUF9SRUdFWF9MT1dFUkNBU0UgPSAvKD86Xig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M30kKXwoPzpeKD86KD86W2EtZlxcZF17MSw0fTopezd9KD86W2EtZlxcZF17MSw0fXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7Nn0oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fDpbYS1mXFxkXXsxLDR9fDopfCg/OlthLWZcXGRdezEsNH06KXs1fSg/OjooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDJ9fDopfCg/OlthLWZcXGRdezEsNH06KXs0fSg/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDF9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsM318Oil8KD86W2EtZlxcZF17MSw0fTopezN9KD86KD86OlthLWZcXGRdezEsNH0pezAsMn06KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXwoPzo6W2EtZlxcZF17MSw0fSl7MSw0fXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7Mn0oPzooPzo6W2EtZlxcZF17MSw0fSl7MCwzfTooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDV9fDopfCg/OlthLWZcXGRdezEsNH06KXsxfSg/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDR9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsNn18Oil8KD86Oig/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDV9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsN318OikpKSQpLztcbi8qKlxuICogQW5zd2VycyBcImRvZXMgdGhpcyByZWFsIGRvbWFpbiBtYXRjaCB0aGUgZG9tYWluIGluIGEgY29va2llP1wiLiBUaGUgYGRvbWFpbmAgaXMgdGhlIFwiY3VycmVudFwiIGRvbWFpbiBuYW1lIGFuZCB0aGVcbiAqIGBjb29raWVEb21haW5gIGlzIHRoZSBcImNvb2tpZVwiIGRvbWFpbiBuYW1lLiBNYXRjaGVzIGFjY29yZGluZyB0byB7QGxpbmsgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzYyNjUuaHRtbCNzZWN0aW9uLTUuMS4zIHwgUkZDNjI2NSAtIFNlY3Rpb24gNS4xLjN9LFxuICogYnV0IGl0IGhlbHBzIHRvIHRoaW5rIG9mIGl0IGFzIGEgXCJzdWZmaXggbWF0Y2hcIi5cbiAqXG4gKiBAcmVtYXJrc1xuICogIyMjIDUuMS4zLiAgRG9tYWluIE1hdGNoaW5nXG4gKlxuICogQSBzdHJpbmcgZG9tYWluLW1hdGNoZXMgYSBnaXZlbiBkb21haW4gc3RyaW5nIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGVcbiAqIGZvbGxvd2luZyBjb25kaXRpb25zIGhvbGQ6XG4gKlxuICogLSBUaGUgZG9tYWluIHN0cmluZyBhbmQgdGhlIHN0cmluZyBhcmUgaWRlbnRpY2FsLiAgKE5vdGUgdGhhdCBib3RoXG4gKiAgICAgdGhlIGRvbWFpbiBzdHJpbmcgYW5kIHRoZSBzdHJpbmcgd2lsbCBoYXZlIGJlZW4gY2Fub25pY2FsaXplZCB0b1xuICogICAgIGxvd2VyIGNhc2UgYXQgdGhpcyBwb2ludC4pXG4gKlxuICogLSBBbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGhvbGQ6XG4gKlxuICogICAgIC0gVGhlIGRvbWFpbiBzdHJpbmcgaXMgYSBzdWZmaXggb2YgdGhlIHN0cmluZy5cbiAqXG4gKiAgICAgLSBUaGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyB0aGF0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGVcbiAqICAgICAgICAgZG9tYWluIHN0cmluZyBpcyBhICV4MkUgKFwiLlwiKSBjaGFyYWN0ZXIuXG4gKlxuICogICAgIC0gVGhlIHN0cmluZyBpcyBhIGhvc3QgbmFtZSAoaS5lLiwgbm90IGFuIElQIGFkZHJlc3MpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGRvbWFpbk1hdGNoKCdleGFtcGxlLmNvbScsICdleGFtcGxlLmNvbScpID09PSB0cnVlXG4gKiBkb21haW5NYXRjaCgnZVhhTXBMZS5jT20nLCAnRXhBbVBsRS5Db00nKSA9PT0gdHJ1ZVxuICogZG9tYWluTWF0Y2goJ25vLmNhJywgJ3llcy5jYScpID09PSBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGRvbWFpbiAtIFRoZSBkb21haW4gc3RyaW5nIHRvIHRlc3RcbiAqIEBwYXJhbSBjb29raWVEb21haW4gLSBUaGUgY29va2llIGRvbWFpbiBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdFxuICogQHBhcmFtIGNhbm9uaWNhbGl6ZSAtIFRoZSBjYW5vbmljYWxpemUgcGFyYW1ldGVyIHRvZ2dsZXMgd2hldGhlciB0aGUgZG9tYWluIHBhcmFtZXRlcnMgZ2V0IG5vcm1hbGl6ZWQgd2l0aCBjYW5vbmljYWxEb21haW4gb3Igbm90XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRvbWFpbk1hdGNoKGRvbWFpbiwgY29va2llRG9tYWluLCBjYW5vbmljYWxpemUpIHtcbiAgICBpZiAoZG9tYWluID09IG51bGwgfHwgY29va2llRG9tYWluID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IF9zdHI7XG4gICAgbGV0IF9kb21TdHI7XG4gICAgaWYgKGNhbm9uaWNhbGl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3N0ciA9ICgwLCBjYW5vbmljYWxEb21haW5fMS5jYW5vbmljYWxEb21haW4pKGRvbWFpbik7XG4gICAgICAgIF9kb21TdHIgPSAoMCwgY2Fub25pY2FsRG9tYWluXzEuY2Fub25pY2FsRG9tYWluKShjb29raWVEb21haW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX3N0ciA9IGRvbWFpbjtcbiAgICAgICAgX2RvbVN0ciA9IGNvb2tpZURvbWFpbjtcbiAgICB9XG4gICAgaWYgKF9zdHIgPT0gbnVsbCB8fCBfZG9tU3RyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLypcbiAgICAgKiBTNS4xLjM6XG4gICAgICogXCJBIHN0cmluZyBkb21haW4tbWF0Y2hlcyBhIGdpdmVuIGRvbWFpbiBzdHJpbmcgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZVxuICAgICAqIGZvbGxvd2luZyBjb25kaXRpb25zIGhvbGQ6XCJcbiAgICAgKlxuICAgICAqIFwiIG8gVGhlIGRvbWFpbiBzdHJpbmcgYW5kIHRoZSBzdHJpbmcgYXJlIGlkZW50aWNhbC4gKE5vdGUgdGhhdCBib3RoIHRoZVxuICAgICAqIGRvbWFpbiBzdHJpbmcgYW5kIHRoZSBzdHJpbmcgd2lsbCBoYXZlIGJlZW4gY2Fub25pY2FsaXplZCB0byBsb3dlciBjYXNlIGF0XG4gICAgICogdGhpcyBwb2ludClcIlxuICAgICAqL1xuICAgIGlmIChfc3RyID09IF9kb21TdHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIFwiIG8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgW3RocmVlXSBjb25kaXRpb25zIGhvbGQ6XCIgKi9cbiAgICAvKiBcIiogVGhlIGRvbWFpbiBzdHJpbmcgaXMgYSBzdWZmaXggb2YgdGhlIHN0cmluZ1wiICovXG4gICAgY29uc3QgaWR4ID0gX3N0ci5sYXN0SW5kZXhPZihjb29raWVEb21haW4pO1xuICAgIGlmIChpZHggPD0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGl0J3MgYSBub24tbWF0Y2ggKC0xKSBvciBwcmVmaXggKDApXG4gICAgfVxuICAgIC8vIG5leHQsIGNoZWNrIGl0J3MgYSBwcm9wZXIgc3VmZml4XG4gICAgLy8gZS5nLiwgXCJhLmIuY1wiLmluZGV4T2YoXCJiLmNcIikgPT09IDJcbiAgICAvLyA1ID09PSAzKzJcbiAgICBpZiAoX3N0ci5sZW5ndGggIT09IF9kb21TdHIubGVuZ3RoICsgaWR4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gaXQncyBub3QgYSBzdWZmaXhcbiAgICB9XG4gICAgLyogXCIgICogVGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgdGhhdCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICogZG9tYWluIHN0cmluZyBpcyBhICV4MkUgKFwiLlwiKSBjaGFyYWN0ZXIuXCIgKi9cbiAgICBpZiAoX3N0ci5zdWJzdHJpbmcoaWR4IC0gMSwgaWR4KSAhPT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gZG9lc24ndCBhbGlnbiBvbiBcIi5cIlxuICAgIH1cbiAgICAvKiBcIiAgKiBUaGUgc3RyaW5nIGlzIGEgaG9zdCBuYW1lIChpLmUuLCBub3QgYW4gSVAgYWRkcmVzcykuXCIgKi9cbiAgICByZXR1cm4gIUlQX1JFR0VYX0xPV0VSQ0FTRS50ZXN0KF9zdHIpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/domainMatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/formatDate.js":
/*!*************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/formatDate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatDate = formatDate;\n/**\n * Format a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date | Date} into\n * the {@link https://www.rfc-editor.org/rfc/rfc2616#section-3.3.1 | preferred Internet standard format}\n * defined in {@link https://www.rfc-editor.org/rfc/rfc822#section-5 | RFC822} and\n * updated in {@link https://www.rfc-editor.org/rfc/rfc1123#page-55 | RFC1123}.\n *\n * @example\n * ```\n * formatDate(new Date(0)) === 'Thu, 01 Jan 1970 00:00:00 GMT`\n * ```\n *\n * @param date - the date value to format\n * @public\n */\nfunction formatDate(date) {\n    return date.toUTCString();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvZm9ybWF0RGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQSxhQUFhLG9HQUFvRztBQUNqSCxRQUFRO0FBQ1IsZUFBZSxnRUFBZ0U7QUFDL0UsZUFBZSwrREFBK0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L2Nvb2tpZS9mb3JtYXREYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbi8qKlxuICogRm9ybWF0IGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUgfCBEYXRlfSBpbnRvXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmMyNjE2I3NlY3Rpb24tMy4zLjEgfCBwcmVmZXJyZWQgSW50ZXJuZXQgc3RhbmRhcmQgZm9ybWF0fVxuICogZGVmaW5lZCBpbiB7QGxpbmsgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzgyMiNzZWN0aW9uLTUgfCBSRkM4MjJ9IGFuZFxuICogdXBkYXRlZCBpbiB7QGxpbmsgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzExMjMjcGFnZS01NSB8IFJGQzExMjN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGZvcm1hdERhdGUobmV3IERhdGUoMCkpID09PSAnVGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBHTVRgXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIHRoZSBkYXRlIHZhbHVlIHRvIGZvcm1hdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS50b1VUQ1N0cmluZygpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/formatDate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/index.js":
/*!********************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.permutePath = exports.parseDate = exports.formatDate = exports.domainMatch = exports.defaultPath = exports.CookieJar = exports.cookieCompare = exports.Cookie = exports.PrefixSecurityEnum = exports.canonicalDomain = exports.version = exports.ParameterError = exports.Store = exports.getPublicSuffix = exports.permuteDomain = exports.pathMatch = exports.MemoryCookieStore = void 0;\nexports.parse = parse;\nexports.fromJSON = fromJSON;\nvar memstore_1 = __webpack_require__(/*! ../memstore */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/memstore.js\");\nObject.defineProperty(exports, \"MemoryCookieStore\", ({ enumerable: true, get: function () { return memstore_1.MemoryCookieStore; } }));\nvar pathMatch_1 = __webpack_require__(/*! ../pathMatch */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/pathMatch.js\");\nObject.defineProperty(exports, \"pathMatch\", ({ enumerable: true, get: function () { return pathMatch_1.pathMatch; } }));\nvar permuteDomain_1 = __webpack_require__(/*! ../permuteDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/permuteDomain.js\");\nObject.defineProperty(exports, \"permuteDomain\", ({ enumerable: true, get: function () { return permuteDomain_1.permuteDomain; } }));\nvar getPublicSuffix_1 = __webpack_require__(/*! ../getPublicSuffix */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/getPublicSuffix.js\");\nObject.defineProperty(exports, \"getPublicSuffix\", ({ enumerable: true, get: function () { return getPublicSuffix_1.getPublicSuffix; } }));\nvar store_1 = __webpack_require__(/*! ../store */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/store.js\");\nObject.defineProperty(exports, \"Store\", ({ enumerable: true, get: function () { return store_1.Store; } }));\nvar validators_1 = __webpack_require__(/*! ../validators */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/validators.js\");\nObject.defineProperty(exports, \"ParameterError\", ({ enumerable: true, get: function () { return validators_1.ParameterError; } }));\nvar version_1 = __webpack_require__(/*! ../version */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/version.js\");\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return version_1.version; } }));\nvar canonicalDomain_1 = __webpack_require__(/*! ./canonicalDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/canonicalDomain.js\");\nObject.defineProperty(exports, \"canonicalDomain\", ({ enumerable: true, get: function () { return canonicalDomain_1.canonicalDomain; } }));\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/constants.js\");\nObject.defineProperty(exports, \"PrefixSecurityEnum\", ({ enumerable: true, get: function () { return constants_1.PrefixSecurityEnum; } }));\nvar cookie_1 = __webpack_require__(/*! ./cookie */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookie.js\");\nObject.defineProperty(exports, \"Cookie\", ({ enumerable: true, get: function () { return cookie_1.Cookie; } }));\nvar cookieCompare_1 = __webpack_require__(/*! ./cookieCompare */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookieCompare.js\");\nObject.defineProperty(exports, \"cookieCompare\", ({ enumerable: true, get: function () { return cookieCompare_1.cookieCompare; } }));\nvar cookieJar_1 = __webpack_require__(/*! ./cookieJar */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookieJar.js\");\nObject.defineProperty(exports, \"CookieJar\", ({ enumerable: true, get: function () { return cookieJar_1.CookieJar; } }));\nvar defaultPath_1 = __webpack_require__(/*! ./defaultPath */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/defaultPath.js\");\nObject.defineProperty(exports, \"defaultPath\", ({ enumerable: true, get: function () { return defaultPath_1.defaultPath; } }));\nvar domainMatch_1 = __webpack_require__(/*! ./domainMatch */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/domainMatch.js\");\nObject.defineProperty(exports, \"domainMatch\", ({ enumerable: true, get: function () { return domainMatch_1.domainMatch; } }));\nvar formatDate_1 = __webpack_require__(/*! ./formatDate */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/formatDate.js\");\nObject.defineProperty(exports, \"formatDate\", ({ enumerable: true, get: function () { return formatDate_1.formatDate; } }));\nvar parseDate_1 = __webpack_require__(/*! ./parseDate */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/parseDate.js\");\nObject.defineProperty(exports, \"parseDate\", ({ enumerable: true, get: function () { return parseDate_1.parseDate; } }));\nvar permutePath_1 = __webpack_require__(/*! ./permutePath */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/permutePath.js\");\nObject.defineProperty(exports, \"permutePath\", ({ enumerable: true, get: function () { return permutePath_1.permutePath; } }));\nconst cookie_2 = __webpack_require__(/*! ./cookie */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/cookie.js\");\n/**\n * {@inheritDoc Cookie.parse}\n * @public\n */\nfunction parse(str, options) {\n    return cookie_2.Cookie.parse(str, options);\n}\n/**\n * {@inheritDoc Cookie.fromJSON}\n * @public\n */\nfunction fromJSON(str) {\n    return cookie_2.Cookie.fromJSON(str);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxzQkFBc0IsR0FBRyxhQUFhLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCO0FBQ3pYLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsaUJBQWlCLG1CQUFPLENBQUMscUZBQWE7QUFDdEMscURBQW9ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3BJLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFjO0FBQ3hDLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBa0I7QUFDaEQsaURBQWdELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2pJLHdCQUF3QixtQkFBTyxDQUFDLG1HQUFvQjtBQUNwRCxtREFBa0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDdkksY0FBYyxtQkFBTyxDQUFDLCtFQUFVO0FBQ2hDLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBZTtBQUMxQyxrREFBaUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDaEksZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVk7QUFDcEMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLHdCQUF3QixtQkFBTyxDQUFDLHlHQUFtQjtBQUNuRCxtREFBa0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDdkksa0JBQWtCLG1CQUFPLENBQUMsNkZBQWE7QUFDdkMsc0RBQXFELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3ZJLGVBQWUsbUJBQU8sQ0FBQyx1RkFBVTtBQUNqQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsc0JBQXNCLG1CQUFPLENBQUMscUdBQWlCO0FBQy9DLGlEQUFnRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNqSSxrQkFBa0IsbUJBQU8sQ0FBQyw2RkFBYTtBQUN2Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsb0JBQW9CLG1CQUFPLENBQUMsaUdBQWU7QUFDM0MsK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILG9CQUFvQixtQkFBTyxDQUFDLGlHQUFlO0FBQzNDLCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBYztBQUN6Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsa0JBQWtCLG1CQUFPLENBQUMsNkZBQWE7QUFDdkMsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILG9CQUFvQixtQkFBTyxDQUFDLGlHQUFlO0FBQzNDLCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCxpQkFBaUIsbUJBQU8sQ0FBQyx1RkFBVTtBQUNuQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBlcm11dGVQYXRoID0gZXhwb3J0cy5wYXJzZURhdGUgPSBleHBvcnRzLmZvcm1hdERhdGUgPSBleHBvcnRzLmRvbWFpbk1hdGNoID0gZXhwb3J0cy5kZWZhdWx0UGF0aCA9IGV4cG9ydHMuQ29va2llSmFyID0gZXhwb3J0cy5jb29raWVDb21wYXJlID0gZXhwb3J0cy5Db29raWUgPSBleHBvcnRzLlByZWZpeFNlY3VyaXR5RW51bSA9IGV4cG9ydHMuY2Fub25pY2FsRG9tYWluID0gZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy5QYXJhbWV0ZXJFcnJvciA9IGV4cG9ydHMuU3RvcmUgPSBleHBvcnRzLmdldFB1YmxpY1N1ZmZpeCA9IGV4cG9ydHMucGVybXV0ZURvbWFpbiA9IGV4cG9ydHMucGF0aE1hdGNoID0gZXhwb3J0cy5NZW1vcnlDb29raWVTdG9yZSA9IHZvaWQgMDtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcbnZhciBtZW1zdG9yZV8xID0gcmVxdWlyZShcIi4uL21lbXN0b3JlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVtb3J5Q29va2llU3RvcmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lbXN0b3JlXzEuTWVtb3J5Q29va2llU3RvcmU7IH0gfSk7XG52YXIgcGF0aE1hdGNoXzEgPSByZXF1aXJlKFwiLi4vcGF0aE1hdGNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGF0aE1hdGNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXRoTWF0Y2hfMS5wYXRoTWF0Y2g7IH0gfSk7XG52YXIgcGVybXV0ZURvbWFpbl8xID0gcmVxdWlyZShcIi4uL3Blcm11dGVEb21haW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwZXJtdXRlRG9tYWluXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJtdXRlRG9tYWluXzEucGVybXV0ZURvbWFpbjsgfSB9KTtcbnZhciBnZXRQdWJsaWNTdWZmaXhfMSA9IHJlcXVpcmUoXCIuLi9nZXRQdWJsaWNTdWZmaXhcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQdWJsaWNTdWZmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldFB1YmxpY1N1ZmZpeF8xLmdldFB1YmxpY1N1ZmZpeDsgfSB9KTtcbnZhciBzdG9yZV8xID0gcmVxdWlyZShcIi4uL3N0b3JlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RvcmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlXzEuU3RvcmU7IH0gfSk7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdG9yc18xLlBhcmFtZXRlckVycm9yOyB9IH0pO1xudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuLi92ZXJzaW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmVyc2lvbl8xLnZlcnNpb247IH0gfSk7XG52YXIgY2Fub25pY2FsRG9tYWluXzEgPSByZXF1aXJlKFwiLi9jYW5vbmljYWxEb21haW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5vbmljYWxEb21haW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbm9uaWNhbERvbWFpbl8xLmNhbm9uaWNhbERvbWFpbjsgfSB9KTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByZWZpeFNlY3VyaXR5RW51bVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuUHJlZml4U2VjdXJpdHlFbnVtOyB9IH0pO1xudmFyIGNvb2tpZV8xID0gcmVxdWlyZShcIi4vY29va2llXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29va2llXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb29raWVfMS5Db29raWU7IH0gfSk7XG52YXIgY29va2llQ29tcGFyZV8xID0gcmVxdWlyZShcIi4vY29va2llQ29tcGFyZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvb2tpZUNvbXBhcmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvb2tpZUNvbXBhcmVfMS5jb29raWVDb21wYXJlOyB9IH0pO1xudmFyIGNvb2tpZUphcl8xID0gcmVxdWlyZShcIi4vY29va2llSmFyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29va2llSmFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb29raWVKYXJfMS5Db29raWVKYXI7IH0gfSk7XG52YXIgZGVmYXVsdFBhdGhfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRQYXRoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZmF1bHRQYXRoXzEuZGVmYXVsdFBhdGg7IH0gfSk7XG52YXIgZG9tYWluTWF0Y2hfMSA9IHJlcXVpcmUoXCIuL2RvbWFpbk1hdGNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG9tYWluTWF0Y2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWFpbk1hdGNoXzEuZG9tYWluTWF0Y2g7IH0gfSk7XG52YXIgZm9ybWF0RGF0ZV8xID0gcmVxdWlyZShcIi4vZm9ybWF0RGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdERhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcm1hdERhdGVfMS5mb3JtYXREYXRlOyB9IH0pO1xudmFyIHBhcnNlRGF0ZV8xID0gcmVxdWlyZShcIi4vcGFyc2VEYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VEYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZURhdGVfMS5wYXJzZURhdGU7IH0gfSk7XG52YXIgcGVybXV0ZVBhdGhfMSA9IHJlcXVpcmUoXCIuL3Blcm11dGVQYXRoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGVybXV0ZVBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcm11dGVQYXRoXzEucGVybXV0ZVBhdGg7IH0gfSk7XG5jb25zdCBjb29raWVfMiA9IHJlcXVpcmUoXCIuL2Nvb2tpZVwiKTtcbi8qKlxuICoge0Bpbmhlcml0RG9jIENvb2tpZS5wYXJzZX1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvb2tpZV8yLkNvb2tpZS5wYXJzZShzdHIsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiB7QGluaGVyaXREb2MgQ29va2llLmZyb21KU09OfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBmcm9tSlNPTihzdHIpIHtcbiAgICByZXR1cm4gY29va2llXzIuQ29va2llLmZyb21KU09OKHN0cik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/parseDate.js":
/*!************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/parseDate.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n// date-time parsing constants (RFC6265 S5.1.1)\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseDate = parseDate;\n// eslint-disable-next-line no-control-regex\nconst DATE_DELIM = /[\\x09\\x20-\\x2F\\x3B-\\x40\\x5B-\\x60\\x7B-\\x7E]/;\nconst MONTH_TO_NUM = {\n    jan: 0,\n    feb: 1,\n    mar: 2,\n    apr: 3,\n    may: 4,\n    jun: 5,\n    jul: 6,\n    aug: 7,\n    sep: 8,\n    oct: 9,\n    nov: 10,\n    dec: 11,\n};\n/*\n * Parses a Natural number (i.e., non-negative integer) with either the\n *    <min>*<max>DIGIT ( non-digit *OCTET )\n * or\n *    <min>*<max>DIGIT\n * grammar (RFC6265 S5.1.1).\n *\n * The \"trailingOK\" boolean controls if the grammar accepts a\n * \"( non-digit *OCTET )\" trailer.\n */\nfunction parseDigits(token, minDigits, maxDigits, trailingOK) {\n    let count = 0;\n    while (count < token.length) {\n        const c = token.charCodeAt(count);\n        // \"non-digit = %x00-2F / %x3A-FF\"\n        if (c <= 0x2f || c >= 0x3a) {\n            break;\n        }\n        count++;\n    }\n    // constrain to a minimum and maximum number of digits.\n    if (count < minDigits || count > maxDigits) {\n        return;\n    }\n    if (!trailingOK && count != token.length) {\n        return;\n    }\n    return parseInt(token.slice(0, count), 10);\n}\nfunction parseTime(token) {\n    const parts = token.split(':');\n    const result = [0, 0, 0];\n    /* RF6256 S5.1.1:\n     *      time            = hms-time ( non-digit *OCTET )\n     *      hms-time        = time-field \":\" time-field \":\" time-field\n     *      time-field      = 1*2DIGIT\n     */\n    if (parts.length !== 3) {\n        return;\n    }\n    for (let i = 0; i < 3; i++) {\n        // \"time-field\" must be strictly \"1*2DIGIT\", HOWEVER, \"hms-time\" can be\n        // followed by \"( non-digit *OCTET )\" therefore the last time-field can\n        // have a trailer\n        const trailingOK = i == 2;\n        const numPart = parts[i];\n        if (numPart === undefined) {\n            return;\n        }\n        const num = parseDigits(numPart, 1, 2, trailingOK);\n        if (num === undefined) {\n            return;\n        }\n        result[i] = num;\n    }\n    return result;\n}\nfunction parseMonth(token) {\n    token = String(token).slice(0, 3).toLowerCase();\n    switch (token) {\n        case 'jan':\n            return MONTH_TO_NUM.jan;\n        case 'feb':\n            return MONTH_TO_NUM.feb;\n        case 'mar':\n            return MONTH_TO_NUM.mar;\n        case 'apr':\n            return MONTH_TO_NUM.apr;\n        case 'may':\n            return MONTH_TO_NUM.may;\n        case 'jun':\n            return MONTH_TO_NUM.jun;\n        case 'jul':\n            return MONTH_TO_NUM.jul;\n        case 'aug':\n            return MONTH_TO_NUM.aug;\n        case 'sep':\n            return MONTH_TO_NUM.sep;\n        case 'oct':\n            return MONTH_TO_NUM.oct;\n        case 'nov':\n            return MONTH_TO_NUM.nov;\n        case 'dec':\n            return MONTH_TO_NUM.dec;\n        default:\n            return;\n    }\n}\n/**\n * Parse a cookie date string into a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date | Date}. Parses according to\n * {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.1 | RFC6265 - Section 5.1.1}, not\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse | Date.parse()}.\n *\n * @remarks\n *\n * ### RFC6265 - 5.1.1. Dates\n *\n * The user agent MUST use an algorithm equivalent to the following\n * algorithm to parse a cookie-date.  Note that the various boolean\n * flags defined as a part of the algorithm (i.e., found-time, found-\n * day-of-month, found-month, found-year) are initially \"not set\".\n *\n * 1.  Using the grammar below, divide the cookie-date into date-tokens.\n *\n * ```\n *     cookie-date     = *delimiter date-token-list *delimiter\n *     date-token-list = date-token *( 1*delimiter date-token )\n *     date-token      = 1*non-delimiter\n *\n *     delimiter       = %x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E\n *     non-delimiter   = %x00-08 / %x0A-1F / DIGIT / \":\" / ALPHA / %x7F-FF\n *     non-digit       = %x00-2F / %x3A-FF\n *\n *     day-of-month    = 1*2DIGIT ( non-digit *OCTET )\n *     month           = ( \"jan\" / \"feb\" / \"mar\" / \"apr\" /\n *                        \"may\" / \"jun\" / \"jul\" / \"aug\" /\n *                        \"sep\" / \"oct\" / \"nov\" / \"dec\" ) *OCTET\n *     year            = 2*4DIGIT ( non-digit *OCTET )\n *     time            = hms-time ( non-digit *OCTET )\n *     hms-time        = time-field \":\" time-field \":\" time-field\n *     time-field      = 1*2DIGIT\n * ```\n *\n * 2. Process each date-token sequentially in the order the date-tokens\n *     appear in the cookie-date:\n *\n *     1. If the found-time flag is not set and the token matches the\n *         time production, set the found-time flag and set the hour-\n *         value, minute-value, and second-value to the numbers denoted\n *         by the digits in the date-token, respectively.  Skip the\n *         remaining sub-steps and continue to the next date-token.\n *\n *     2. If the found-day-of-month flag is not set and the date-token\n *         matches the day-of-month production, set the found-day-of-\n *         month flag and set the day-of-month-value to the number\n *         denoted by the date-token.  Skip the remaining sub-steps and\n *         continue to the next date-token.\n *\n *     3. If the found-month flag is not set and the date-token matches\n *         the month production, set the found-month flag and set the\n *         month-value to the month denoted by the date-token.  Skip the\n *         remaining sub-steps and continue to the next date-token.\n *\n *     4. If the found-year flag is not set and the date-token matches\n *         the year production, set the found-year flag and set the\n *         year-value to the number denoted by the date-token.  Skip the\n *         remaining sub-steps and continue to the next date-token.\n *\n *  3. If the year-value is greater than or equal to 70 and less than or\n *      equal to 99, increment the year-value by 1900.\n *\n *  4. If the year-value is greater than or equal to 0 and less than or\n *      equal to 69, increment the year-value by 2000.\n *\n *      1. NOTE: Some existing user agents interpret two-digit years differently.\n *\n *  5. Abort these steps and fail to parse the cookie-date if:\n *\n *      - at least one of the found-day-of-month, found-month, found-\n *          year, or found-time flags is not set,\n *\n *      - the day-of-month-value is less than 1 or greater than 31,\n *\n *      - the year-value is less than 1601,\n *\n *      - the hour-value is greater than 23,\n *\n *      - the minute-value is greater than 59, or\n *\n *      - the second-value is greater than 59.\n *\n *      (Note that leap seconds cannot be represented in this syntax.)\n *\n *  6. Let the parsed-cookie-date be the date whose day-of-month, month,\n *      year, hour, minute, and second (in UTC) are the day-of-month-\n *      value, the month-value, the year-value, the hour-value, the\n *      minute-value, and the second-value, respectively.  If no such\n *      date exists, abort these steps and fail to parse the cookie-date.\n *\n *  7. Return the parsed-cookie-date as the result of this algorithm.\n *\n * @example\n * ```\n * parseDate('Wed, 09 Jun 2021 10:18:14 GMT')\n * ```\n *\n * @param cookieDate - the cookie date string\n * @public\n */\nfunction parseDate(cookieDate) {\n    if (!cookieDate) {\n        return;\n    }\n    /* RFC6265 S5.1.1:\n     * 2. Process each date-token sequentially in the order the date-tokens\n     * appear in the cookie-date\n     */\n    const tokens = cookieDate.split(DATE_DELIM);\n    let hour;\n    let minute;\n    let second;\n    let dayOfMonth;\n    let month;\n    let year;\n    for (let i = 0; i < tokens.length; i++) {\n        const token = (tokens[i] ?? '').trim();\n        if (!token.length) {\n            continue;\n        }\n        /* 2.1. If the found-time flag is not set and the token matches the time\n         * production, set the found-time flag and set the hour- value,\n         * minute-value, and second-value to the numbers denoted by the digits in\n         * the date-token, respectively.  Skip the remaining sub-steps and continue\n         * to the next date-token.\n         */\n        if (second === undefined) {\n            const result = parseTime(token);\n            if (result) {\n                hour = result[0];\n                minute = result[1];\n                second = result[2];\n                continue;\n            }\n        }\n        /* 2.2. If the found-day-of-month flag is not set and the date-token matches\n         * the day-of-month production, set the found-day-of- month flag and set\n         * the day-of-month-value to the number denoted by the date-token.  Skip\n         * the remaining sub-steps and continue to the next date-token.\n         */\n        if (dayOfMonth === undefined) {\n            // \"day-of-month = 1*2DIGIT ( non-digit *OCTET )\"\n            const result = parseDigits(token, 1, 2, true);\n            if (result !== undefined) {\n                dayOfMonth = result;\n                continue;\n            }\n        }\n        /* 2.3. If the found-month flag is not set and the date-token matches the\n         * month production, set the found-month flag and set the month-value to\n         * the month denoted by the date-token.  Skip the remaining sub-steps and\n         * continue to the next date-token.\n         */\n        if (month === undefined) {\n            const result = parseMonth(token);\n            if (result !== undefined) {\n                month = result;\n                continue;\n            }\n        }\n        /* 2.4. If the found-year flag is not set and the date-token matches the\n         * year production, set the found-year flag and set the year-value to the\n         * number denoted by the date-token.  Skip the remaining sub-steps and\n         * continue to the next date-token.\n         */\n        if (year === undefined) {\n            // \"year = 2*4DIGIT ( non-digit *OCTET )\"\n            const result = parseDigits(token, 2, 4, true);\n            if (result !== undefined) {\n                year = result;\n                /* From S5.1.1:\n                 * 3.  If the year-value is greater than or equal to 70 and less\n                 * than or equal to 99, increment the year-value by 1900.\n                 * 4.  If the year-value is greater than or equal to 0 and less\n                 * than or equal to 69, increment the year-value by 2000.\n                 */\n                if (year >= 70 && year <= 99) {\n                    year += 1900;\n                }\n                else if (year >= 0 && year <= 69) {\n                    year += 2000;\n                }\n            }\n        }\n    }\n    /* RFC 6265 S5.1.1\n     * \"5. Abort these steps and fail to parse the cookie-date if:\n     *     *  at least one of the found-day-of-month, found-month, found-\n     *        year, or found-time flags is not set,\n     *     *  the day-of-month-value is less than 1 or greater than 31,\n     *     *  the year-value is less than 1601,\n     *     *  the hour-value is greater than 23,\n     *     *  the minute-value is greater than 59, or\n     *     *  the second-value is greater than 59.\n     *     (Note that leap seconds cannot be represented in this syntax.)\"\n     *\n     * So, in order as above:\n     */\n    if (dayOfMonth === undefined ||\n        month === undefined ||\n        year === undefined ||\n        hour === undefined ||\n        minute === undefined ||\n        second === undefined ||\n        dayOfMonth < 1 ||\n        dayOfMonth > 31 ||\n        year < 1601 ||\n        hour > 23 ||\n        minute > 59 ||\n        second > 59) {\n        return;\n    }\n    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvcGFyc2VEYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUdBQW1HO0FBQ3pJLElBQUksMEZBQTBGO0FBQzlGLElBQUksaUhBQWlIO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L2Nvb2tpZS9wYXJzZURhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBkYXRlLXRpbWUgcGFyc2luZyBjb25zdGFudHMgKFJGQzYyNjUgUzUuMS4xKVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZURhdGUgPSBwYXJzZURhdGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgREFURV9ERUxJTSA9IC9bXFx4MDlcXHgyMC1cXHgyRlxceDNCLVxceDQwXFx4NUItXFx4NjBcXHg3Qi1cXHg3RV0vO1xuY29uc3QgTU9OVEhfVE9fTlVNID0ge1xuICAgIGphbjogMCxcbiAgICBmZWI6IDEsXG4gICAgbWFyOiAyLFxuICAgIGFwcjogMyxcbiAgICBtYXk6IDQsXG4gICAganVuOiA1LFxuICAgIGp1bDogNixcbiAgICBhdWc6IDcsXG4gICAgc2VwOiA4LFxuICAgIG9jdDogOSxcbiAgICBub3Y6IDEwLFxuICAgIGRlYzogMTEsXG59O1xuLypcbiAqIFBhcnNlcyBhIE5hdHVyYWwgbnVtYmVyIChpLmUuLCBub24tbmVnYXRpdmUgaW50ZWdlcikgd2l0aCBlaXRoZXIgdGhlXG4gKiAgICA8bWluPio8bWF4PkRJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXG4gKiBvclxuICogICAgPG1pbj4qPG1heD5ESUdJVFxuICogZ3JhbW1hciAoUkZDNjI2NSBTNS4xLjEpLlxuICpcbiAqIFRoZSBcInRyYWlsaW5nT0tcIiBib29sZWFuIGNvbnRyb2xzIGlmIHRoZSBncmFtbWFyIGFjY2VwdHMgYVxuICogXCIoIG5vbi1kaWdpdCAqT0NURVQgKVwiIHRyYWlsZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGlnaXRzKHRva2VuLCBtaW5EaWdpdHMsIG1heERpZ2l0cywgdHJhaWxpbmdPSykge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGNvdW50IDwgdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0b2tlbi5jaGFyQ29kZUF0KGNvdW50KTtcbiAgICAgICAgLy8gXCJub24tZGlnaXQgPSAleDAwLTJGIC8gJXgzQS1GRlwiXG4gICAgICAgIGlmIChjIDw9IDB4MmYgfHwgYyA+PSAweDNhKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudCsrO1xuICAgIH1cbiAgICAvLyBjb25zdHJhaW4gdG8gYSBtaW5pbXVtIGFuZCBtYXhpbXVtIG51bWJlciBvZiBkaWdpdHMuXG4gICAgaWYgKGNvdW50IDwgbWluRGlnaXRzIHx8IGNvdW50ID4gbWF4RGlnaXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0cmFpbGluZ09LICYmIGNvdW50ICE9IHRva2VuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh0b2tlbi5zbGljZSgwLCBjb3VudCksIDEwKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZSh0b2tlbikge1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJzonKTtcbiAgICBjb25zdCByZXN1bHQgPSBbMCwgMCwgMF07XG4gICAgLyogUkY2MjU2IFM1LjEuMTpcbiAgICAgKiAgICAgIHRpbWUgICAgICAgICAgICA9IGhtcy10aW1lICggbm9uLWRpZ2l0ICpPQ1RFVCApXG4gICAgICogICAgICBobXMtdGltZSAgICAgICAgPSB0aW1lLWZpZWxkIFwiOlwiIHRpbWUtZmllbGQgXCI6XCIgdGltZS1maWVsZFxuICAgICAqICAgICAgdGltZS1maWVsZCAgICAgID0gMSoyRElHSVRcbiAgICAgKi9cbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgLy8gXCJ0aW1lLWZpZWxkXCIgbXVzdCBiZSBzdHJpY3RseSBcIjEqMkRJR0lUXCIsIEhPV0VWRVIsIFwiaG1zLXRpbWVcIiBjYW4gYmVcbiAgICAgICAgLy8gZm9sbG93ZWQgYnkgXCIoIG5vbi1kaWdpdCAqT0NURVQgKVwiIHRoZXJlZm9yZSB0aGUgbGFzdCB0aW1lLWZpZWxkIGNhblxuICAgICAgICAvLyBoYXZlIGEgdHJhaWxlclxuICAgICAgICBjb25zdCB0cmFpbGluZ09LID0gaSA9PSAyO1xuICAgICAgICBjb25zdCBudW1QYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChudW1QYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBwYXJzZURpZ2l0cyhudW1QYXJ0LCAxLCAyLCB0cmFpbGluZ09LKTtcbiAgICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldID0gbnVtO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VNb250aCh0b2tlbikge1xuICAgIHRva2VuID0gU3RyaW5nKHRva2VuKS5zbGljZSgwLCAzKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSAnamFuJzpcbiAgICAgICAgICAgIHJldHVybiBNT05USF9UT19OVU0uamFuO1xuICAgICAgICBjYXNlICdmZWInOlxuICAgICAgICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5mZWI7XG4gICAgICAgIGNhc2UgJ21hcic6XG4gICAgICAgICAgICByZXR1cm4gTU9OVEhfVE9fTlVNLm1hcjtcbiAgICAgICAgY2FzZSAnYXByJzpcbiAgICAgICAgICAgIHJldHVybiBNT05USF9UT19OVU0uYXByO1xuICAgICAgICBjYXNlICdtYXknOlxuICAgICAgICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5tYXk7XG4gICAgICAgIGNhc2UgJ2p1bic6XG4gICAgICAgICAgICByZXR1cm4gTU9OVEhfVE9fTlVNLmp1bjtcbiAgICAgICAgY2FzZSAnanVsJzpcbiAgICAgICAgICAgIHJldHVybiBNT05USF9UT19OVU0uanVsO1xuICAgICAgICBjYXNlICdhdWcnOlxuICAgICAgICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5hdWc7XG4gICAgICAgIGNhc2UgJ3NlcCc6XG4gICAgICAgICAgICByZXR1cm4gTU9OVEhfVE9fTlVNLnNlcDtcbiAgICAgICAgY2FzZSAnb2N0JzpcbiAgICAgICAgICAgIHJldHVybiBNT05USF9UT19OVU0ub2N0O1xuICAgICAgICBjYXNlICdub3YnOlxuICAgICAgICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5ub3Y7XG4gICAgICAgIGNhc2UgJ2RlYyc6XG4gICAgICAgICAgICByZXR1cm4gTU9OVEhfVE9fTlVNLmRlYztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlIGEgY29va2llIGRhdGUgc3RyaW5nIGludG8gYSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZSB8IERhdGV9LiBQYXJzZXMgYWNjb3JkaW5nIHRvXG4gKiB7QGxpbmsgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzYyNjUuaHRtbCNzZWN0aW9uLTUuMS4xIHwgUkZDNjI2NSAtIFNlY3Rpb24gNS4xLjF9LCBub3RcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3BhcnNlIHwgRGF0ZS5wYXJzZSgpfS5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqICMjIyBSRkM2MjY1IC0gNS4xLjEuIERhdGVzXG4gKlxuICogVGhlIHVzZXIgYWdlbnQgTVVTVCB1c2UgYW4gYWxnb3JpdGhtIGVxdWl2YWxlbnQgdG8gdGhlIGZvbGxvd2luZ1xuICogYWxnb3JpdGhtIHRvIHBhcnNlIGEgY29va2llLWRhdGUuICBOb3RlIHRoYXQgdGhlIHZhcmlvdXMgYm9vbGVhblxuICogZmxhZ3MgZGVmaW5lZCBhcyBhIHBhcnQgb2YgdGhlIGFsZ29yaXRobSAoaS5lLiwgZm91bmQtdGltZSwgZm91bmQtXG4gKiBkYXktb2YtbW9udGgsIGZvdW5kLW1vbnRoLCBmb3VuZC15ZWFyKSBhcmUgaW5pdGlhbGx5IFwibm90IHNldFwiLlxuICpcbiAqIDEuICBVc2luZyB0aGUgZ3JhbW1hciBiZWxvdywgZGl2aWRlIHRoZSBjb29raWUtZGF0ZSBpbnRvIGRhdGUtdG9rZW5zLlxuICpcbiAqIGBgYFxuICogICAgIGNvb2tpZS1kYXRlICAgICA9ICpkZWxpbWl0ZXIgZGF0ZS10b2tlbi1saXN0ICpkZWxpbWl0ZXJcbiAqICAgICBkYXRlLXRva2VuLWxpc3QgPSBkYXRlLXRva2VuICooIDEqZGVsaW1pdGVyIGRhdGUtdG9rZW4gKVxuICogICAgIGRhdGUtdG9rZW4gICAgICA9IDEqbm9uLWRlbGltaXRlclxuICpcbiAqICAgICBkZWxpbWl0ZXIgICAgICAgPSAleDA5IC8gJXgyMC0yRiAvICV4M0ItNDAgLyAleDVCLTYwIC8gJXg3Qi03RVxuICogICAgIG5vbi1kZWxpbWl0ZXIgICA9ICV4MDAtMDggLyAleDBBLTFGIC8gRElHSVQgLyBcIjpcIiAvIEFMUEhBIC8gJXg3Ri1GRlxuICogICAgIG5vbi1kaWdpdCAgICAgICA9ICV4MDAtMkYgLyAleDNBLUZGXG4gKlxuICogICAgIGRheS1vZi1tb250aCAgICA9IDEqMkRJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXG4gKiAgICAgbW9udGggICAgICAgICAgID0gKCBcImphblwiIC8gXCJmZWJcIiAvIFwibWFyXCIgLyBcImFwclwiIC9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXlcIiAvIFwianVuXCIgLyBcImp1bFwiIC8gXCJhdWdcIiAvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFwic2VwXCIgLyBcIm9jdFwiIC8gXCJub3ZcIiAvIFwiZGVjXCIgKSAqT0NURVRcbiAqICAgICB5ZWFyICAgICAgICAgICAgPSAyKjRESUdJVCAoIG5vbi1kaWdpdCAqT0NURVQgKVxuICogICAgIHRpbWUgICAgICAgICAgICA9IGhtcy10aW1lICggbm9uLWRpZ2l0ICpPQ1RFVCApXG4gKiAgICAgaG1zLXRpbWUgICAgICAgID0gdGltZS1maWVsZCBcIjpcIiB0aW1lLWZpZWxkIFwiOlwiIHRpbWUtZmllbGRcbiAqICAgICB0aW1lLWZpZWxkICAgICAgPSAxKjJESUdJVFxuICogYGBgXG4gKlxuICogMi4gUHJvY2VzcyBlYWNoIGRhdGUtdG9rZW4gc2VxdWVudGlhbGx5IGluIHRoZSBvcmRlciB0aGUgZGF0ZS10b2tlbnNcbiAqICAgICBhcHBlYXIgaW4gdGhlIGNvb2tpZS1kYXRlOlxuICpcbiAqICAgICAxLiBJZiB0aGUgZm91bmQtdGltZSBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSB0b2tlbiBtYXRjaGVzIHRoZVxuICogICAgICAgICB0aW1lIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtdGltZSBmbGFnIGFuZCBzZXQgdGhlIGhvdXItXG4gKiAgICAgICAgIHZhbHVlLCBtaW51dGUtdmFsdWUsIGFuZCBzZWNvbmQtdmFsdWUgdG8gdGhlIG51bWJlcnMgZGVub3RlZFxuICogICAgICAgICBieSB0aGUgZGlnaXRzIGluIHRoZSBkYXRlLXRva2VuLCByZXNwZWN0aXZlbHkuICBTa2lwIHRoZVxuICogICAgICAgICByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZCBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICpcbiAqICAgICAyLiBJZiB0aGUgZm91bmQtZGF5LW9mLW1vbnRoIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW5cbiAqICAgICAgICAgbWF0Y2hlcyB0aGUgZGF5LW9mLW1vbnRoIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtZGF5LW9mLVxuICogICAgICAgICBtb250aCBmbGFnIGFuZCBzZXQgdGhlIGRheS1vZi1tb250aC12YWx1ZSB0byB0aGUgbnVtYmVyXG4gKiAgICAgICAgIGRlbm90ZWQgYnkgdGhlIGRhdGUtdG9rZW4uICBTa2lwIHRoZSByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZFxuICogICAgICAgICBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICpcbiAqICAgICAzLiBJZiB0aGUgZm91bmQtbW9udGggZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgZGF0ZS10b2tlbiBtYXRjaGVzXG4gKiAgICAgICAgIHRoZSBtb250aCBwcm9kdWN0aW9uLCBzZXQgdGhlIGZvdW5kLW1vbnRoIGZsYWcgYW5kIHNldCB0aGVcbiAqICAgICAgICAgbW9udGgtdmFsdWUgdG8gdGhlIG1vbnRoIGRlbm90ZWQgYnkgdGhlIGRhdGUtdG9rZW4uICBTa2lwIHRoZVxuICogICAgICAgICByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZCBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICpcbiAqICAgICA0LiBJZiB0aGUgZm91bmQteWVhciBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSBkYXRlLXRva2VuIG1hdGNoZXNcbiAqICAgICAgICAgdGhlIHllYXIgcHJvZHVjdGlvbiwgc2V0IHRoZSBmb3VuZC15ZWFyIGZsYWcgYW5kIHNldCB0aGVcbiAqICAgICAgICAgeWVhci12YWx1ZSB0byB0aGUgbnVtYmVyIGRlbm90ZWQgYnkgdGhlIGRhdGUtdG9rZW4uICBTa2lwIHRoZVxuICogICAgICAgICByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZCBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICpcbiAqICAzLiBJZiB0aGUgeWVhci12YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gNzAgYW5kIGxlc3MgdGhhbiBvclxuICogICAgICBlcXVhbCB0byA5OSwgaW5jcmVtZW50IHRoZSB5ZWFyLXZhbHVlIGJ5IDE5MDAuXG4gKlxuICogIDQuIElmIHRoZSB5ZWFyLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIGFuZCBsZXNzIHRoYW4gb3JcbiAqICAgICAgZXF1YWwgdG8gNjksIGluY3JlbWVudCB0aGUgeWVhci12YWx1ZSBieSAyMDAwLlxuICpcbiAqICAgICAgMS4gTk9URTogU29tZSBleGlzdGluZyB1c2VyIGFnZW50cyBpbnRlcnByZXQgdHdvLWRpZ2l0IHllYXJzIGRpZmZlcmVudGx5LlxuICpcbiAqICA1LiBBYm9ydCB0aGVzZSBzdGVwcyBhbmQgZmFpbCB0byBwYXJzZSB0aGUgY29va2llLWRhdGUgaWY6XG4gKlxuICogICAgICAtIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm91bmQtZGF5LW9mLW1vbnRoLCBmb3VuZC1tb250aCwgZm91bmQtXG4gKiAgICAgICAgICB5ZWFyLCBvciBmb3VuZC10aW1lIGZsYWdzIGlzIG5vdCBzZXQsXG4gKlxuICogICAgICAtIHRoZSBkYXktb2YtbW9udGgtdmFsdWUgaXMgbGVzcyB0aGFuIDEgb3IgZ3JlYXRlciB0aGFuIDMxLFxuICpcbiAqICAgICAgLSB0aGUgeWVhci12YWx1ZSBpcyBsZXNzIHRoYW4gMTYwMSxcbiAqXG4gKiAgICAgIC0gdGhlIGhvdXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDIzLFxuICpcbiAqICAgICAgLSB0aGUgbWludXRlLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiA1OSwgb3JcbiAqXG4gKiAgICAgIC0gdGhlIHNlY29uZC12YWx1ZSBpcyBncmVhdGVyIHRoYW4gNTkuXG4gKlxuICogICAgICAoTm90ZSB0aGF0IGxlYXAgc2Vjb25kcyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gdGhpcyBzeW50YXguKVxuICpcbiAqICA2LiBMZXQgdGhlIHBhcnNlZC1jb29raWUtZGF0ZSBiZSB0aGUgZGF0ZSB3aG9zZSBkYXktb2YtbW9udGgsIG1vbnRoLFxuICogICAgICB5ZWFyLCBob3VyLCBtaW51dGUsIGFuZCBzZWNvbmQgKGluIFVUQykgYXJlIHRoZSBkYXktb2YtbW9udGgtXG4gKiAgICAgIHZhbHVlLCB0aGUgbW9udGgtdmFsdWUsIHRoZSB5ZWFyLXZhbHVlLCB0aGUgaG91ci12YWx1ZSwgdGhlXG4gKiAgICAgIG1pbnV0ZS12YWx1ZSwgYW5kIHRoZSBzZWNvbmQtdmFsdWUsIHJlc3BlY3RpdmVseS4gIElmIG5vIHN1Y2hcbiAqICAgICAgZGF0ZSBleGlzdHMsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBmYWlsIHRvIHBhcnNlIHRoZSBjb29raWUtZGF0ZS5cbiAqXG4gKiAgNy4gUmV0dXJuIHRoZSBwYXJzZWQtY29va2llLWRhdGUgYXMgdGhlIHJlc3VsdCBvZiB0aGlzIGFsZ29yaXRobS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBwYXJzZURhdGUoJ1dlZCwgMDkgSnVuIDIwMjEgMTA6MTg6MTQgR01UJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb29raWVEYXRlIC0gdGhlIGNvb2tpZSBkYXRlIHN0cmluZ1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZURhdGUoY29va2llRGF0ZSkge1xuICAgIGlmICghY29va2llRGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIFJGQzYyNjUgUzUuMS4xOlxuICAgICAqIDIuIFByb2Nlc3MgZWFjaCBkYXRlLXRva2VuIHNlcXVlbnRpYWxseSBpbiB0aGUgb3JkZXIgdGhlIGRhdGUtdG9rZW5zXG4gICAgICogYXBwZWFyIGluIHRoZSBjb29raWUtZGF0ZVxuICAgICAqL1xuICAgIGNvbnN0IHRva2VucyA9IGNvb2tpZURhdGUuc3BsaXQoREFURV9ERUxJTSk7XG4gICAgbGV0IGhvdXI7XG4gICAgbGV0IG1pbnV0ZTtcbiAgICBsZXQgc2Vjb25kO1xuICAgIGxldCBkYXlPZk1vbnRoO1xuICAgIGxldCBtb250aDtcbiAgICBsZXQgeWVhcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9ICh0b2tlbnNbaV0gPz8gJycpLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qIDIuMS4gSWYgdGhlIGZvdW5kLXRpbWUgZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgdG9rZW4gbWF0Y2hlcyB0aGUgdGltZVxuICAgICAgICAgKiBwcm9kdWN0aW9uLCBzZXQgdGhlIGZvdW5kLXRpbWUgZmxhZyBhbmQgc2V0IHRoZSBob3VyLSB2YWx1ZSxcbiAgICAgICAgICogbWludXRlLXZhbHVlLCBhbmQgc2Vjb25kLXZhbHVlIHRvIHRoZSBudW1iZXJzIGRlbm90ZWQgYnkgdGhlIGRpZ2l0cyBpblxuICAgICAgICAgKiB0aGUgZGF0ZS10b2tlbiwgcmVzcGVjdGl2ZWx5LiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmQgY29udGludWVcbiAgICAgICAgICogdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChzZWNvbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VUaW1lKHRva2VuKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gcmVzdWx0WzBdO1xuICAgICAgICAgICAgICAgIG1pbnV0ZSA9IHJlc3VsdFsxXTtcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSByZXN1bHRbMl07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogMi4yLiBJZiB0aGUgZm91bmQtZGF5LW9mLW1vbnRoIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW4gbWF0Y2hlc1xuICAgICAgICAgKiB0aGUgZGF5LW9mLW1vbnRoIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtZGF5LW9mLSBtb250aCBmbGFnIGFuZCBzZXRcbiAgICAgICAgICogdGhlIGRheS1vZi1tb250aC12YWx1ZSB0byB0aGUgbnVtYmVyIGRlbm90ZWQgYnkgdGhlIGRhdGUtdG9rZW4uICBTa2lwXG4gICAgICAgICAqIHRoZSByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZCBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGRheU9mTW9udGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gXCJkYXktb2YtbW9udGggPSAxKjJESUdJVCAoIG5vbi1kaWdpdCAqT0NURVQgKVwiXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZURpZ2l0cyh0b2tlbiwgMSwgMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkYXlPZk1vbnRoID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIDIuMy4gSWYgdGhlIGZvdW5kLW1vbnRoIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW4gbWF0Y2hlcyB0aGVcbiAgICAgICAgICogbW9udGggcHJvZHVjdGlvbiwgc2V0IHRoZSBmb3VuZC1tb250aCBmbGFnIGFuZCBzZXQgdGhlIG1vbnRoLXZhbHVlIHRvXG4gICAgICAgICAqIHRoZSBtb250aCBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmRcbiAgICAgICAgICogY29udGludWUgdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChtb250aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZU1vbnRoKHRva2VuKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1vbnRoID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIDIuNC4gSWYgdGhlIGZvdW5kLXllYXIgZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgZGF0ZS10b2tlbiBtYXRjaGVzIHRoZVxuICAgICAgICAgKiB5ZWFyIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQteWVhciBmbGFnIGFuZCBzZXQgdGhlIHllYXItdmFsdWUgdG8gdGhlXG4gICAgICAgICAqIG51bWJlciBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmRcbiAgICAgICAgICogY29udGludWUgdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFwieWVhciA9IDIqNERJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXCJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlRGlnaXRzKHRva2VuLCAyLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHllYXIgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgLyogRnJvbSBTNS4xLjE6XG4gICAgICAgICAgICAgICAgICogMy4gIElmIHRoZSB5ZWFyLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA3MCBhbmQgbGVzc1xuICAgICAgICAgICAgICAgICAqIHRoYW4gb3IgZXF1YWwgdG8gOTksIGluY3JlbWVudCB0aGUgeWVhci12YWx1ZSBieSAxOTAwLlxuICAgICAgICAgICAgICAgICAqIDQuICBJZiB0aGUgeWVhci12YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzc1xuICAgICAgICAgICAgICAgICAqIHRoYW4gb3IgZXF1YWwgdG8gNjksIGluY3JlbWVudCB0aGUgeWVhci12YWx1ZSBieSAyMDAwLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh5ZWFyID49IDcwICYmIHllYXIgPD0gOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWVhciArPSAxOTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5ZWFyID49IDAgJiYgeWVhciA8PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICB5ZWFyICs9IDIwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qIFJGQyA2MjY1IFM1LjEuMVxuICAgICAqIFwiNS4gQWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGZhaWwgdG8gcGFyc2UgdGhlIGNvb2tpZS1kYXRlIGlmOlxuICAgICAqICAgICAqICBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvdW5kLWRheS1vZi1tb250aCwgZm91bmQtbW9udGgsIGZvdW5kLVxuICAgICAqICAgICAgICB5ZWFyLCBvciBmb3VuZC10aW1lIGZsYWdzIGlzIG5vdCBzZXQsXG4gICAgICogICAgICogIHRoZSBkYXktb2YtbW9udGgtdmFsdWUgaXMgbGVzcyB0aGFuIDEgb3IgZ3JlYXRlciB0aGFuIDMxLFxuICAgICAqICAgICAqICB0aGUgeWVhci12YWx1ZSBpcyBsZXNzIHRoYW4gMTYwMSxcbiAgICAgKiAgICAgKiAgdGhlIGhvdXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDIzLFxuICAgICAqICAgICAqICB0aGUgbWludXRlLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiA1OSwgb3JcbiAgICAgKiAgICAgKiAgdGhlIHNlY29uZC12YWx1ZSBpcyBncmVhdGVyIHRoYW4gNTkuXG4gICAgICogICAgIChOb3RlIHRoYXQgbGVhcCBzZWNvbmRzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiB0aGlzIHN5bnRheC4pXCJcbiAgICAgKlxuICAgICAqIFNvLCBpbiBvcmRlciBhcyBhYm92ZTpcbiAgICAgKi9cbiAgICBpZiAoZGF5T2ZNb250aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIG1vbnRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgeWVhciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGhvdXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBtaW51dGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBzZWNvbmQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBkYXlPZk1vbnRoIDwgMSB8fFxuICAgICAgICBkYXlPZk1vbnRoID4gMzEgfHxcbiAgICAgICAgeWVhciA8IDE2MDEgfHxcbiAgICAgICAgaG91ciA+IDIzIHx8XG4gICAgICAgIG1pbnV0ZSA+IDU5IHx8XG4gICAgICAgIHNlY29uZCA+IDU5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/parseDate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/permutePath.js":
/*!**************************************************************!*\
  !*** ./node_modules/tough-cookie/dist/cookie/permutePath.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.permutePath = permutePath;\n/**\n * Generates the permutation of all possible values that {@link pathMatch} the `path` parameter.\n * The array is in longest-to-shortest order.  Useful when building custom {@link Store} implementations.\n *\n * @example\n * ```\n * permutePath('/foo/bar/')\n * // ['/foo/bar/', '/foo/bar', '/foo', '/']\n * ```\n *\n * @param path - the path to generate permutations for\n * @public\n */\nfunction permutePath(path) {\n    if (path === '/') {\n        return ['/'];\n    }\n    const permutations = [path];\n    while (path.length > 1) {\n        const lindex = path.lastIndexOf('/');\n        if (lindex === 0) {\n            break;\n        }\n        path = path.slice(0, lindex);\n        permutations.push(path);\n    }\n    permutations.push('/');\n    return permutations;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9jb29raWUvcGVybXV0ZVBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L2Nvb2tpZS9wZXJtdXRlUGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGVybXV0ZVBhdGggPSBwZXJtdXRlUGF0aDtcbi8qKlxuICogR2VuZXJhdGVzIHRoZSBwZXJtdXRhdGlvbiBvZiBhbGwgcG9zc2libGUgdmFsdWVzIHRoYXQge0BsaW5rIHBhdGhNYXRjaH0gdGhlIGBwYXRoYCBwYXJhbWV0ZXIuXG4gKiBUaGUgYXJyYXkgaXMgaW4gbG9uZ2VzdC10by1zaG9ydGVzdCBvcmRlci4gIFVzZWZ1bCB3aGVuIGJ1aWxkaW5nIGN1c3RvbSB7QGxpbmsgU3RvcmV9IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBwZXJtdXRlUGF0aCgnL2Zvby9iYXIvJylcbiAqIC8vIFsnL2Zvby9iYXIvJywgJy9mb28vYmFyJywgJy9mb28nLCAnLyddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIHRvIGdlbmVyYXRlIHBlcm11dGF0aW9ucyBmb3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGVybXV0ZVBhdGgocGF0aCkge1xuICAgIGlmIChwYXRoID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIFsnLyddO1xuICAgIH1cbiAgICBjb25zdCBwZXJtdXRhdGlvbnMgPSBbcGF0aF07XG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBsaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChsaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGxpbmRleCk7XG4gICAgICAgIHBlcm11dGF0aW9ucy5wdXNoKHBhdGgpO1xuICAgIH1cbiAgICBwZXJtdXRhdGlvbnMucHVzaCgnLycpO1xuICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/permutePath.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/getPublicSuffix.js":
/*!***********************************************************!*\
  !*** ./node_modules/tough-cookie/dist/getPublicSuffix.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPublicSuffix = getPublicSuffix;\nconst tldts_1 = __webpack_require__(/*! tldts */ \"(app-pages-browser)/./node_modules/tldts/dist/es6/index.js\");\n// RFC 6761\nconst SPECIAL_USE_DOMAINS = ['local', 'example', 'invalid', 'localhost', 'test'];\nconst SPECIAL_TREATMENT_DOMAINS = ['localhost', 'invalid'];\nconst defaultGetPublicSuffixOptions = {\n    allowSpecialUseDomain: false,\n    ignoreError: false,\n};\n/**\n * Returns the public suffix of this hostname. The public suffix is the shortest domain\n * name upon which a cookie can be set.\n *\n * @remarks\n * A \"public suffix\" is a domain that is controlled by a\n * public registry, such as \"com\", \"co.uk\", and \"pvt.k12.wy.us\".\n * This step is essential for preventing attacker.com from\n * disrupting the integrity of example.com by setting a cookie\n * with a Domain attribute of \"com\".  Unfortunately, the set of\n * public suffixes (also known as \"registry controlled domains\")\n * changes over time.  If feasible, user agents SHOULD use an\n * up-to-date public suffix list, such as the one maintained by\n * the Mozilla project at http://publicsuffix.org/.\n * (See {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.3 | RFC6265 - Section 5.3})\n *\n * @example\n * ```\n * getPublicSuffix('www.example.com') === 'example.com'\n * getPublicSuffix('www.subdomain.example.com') === 'example.com'\n * ```\n *\n * @param domain - the domain attribute of a cookie\n * @param options - optional configuration for controlling how the public suffix is determined\n * @public\n */\nfunction getPublicSuffix(domain, options = {}) {\n    options = { ...defaultGetPublicSuffixOptions, ...options };\n    const domainParts = domain.split('.');\n    const topLevelDomain = domainParts[domainParts.length - 1];\n    const allowSpecialUseDomain = !!options.allowSpecialUseDomain;\n    const ignoreError = !!options.ignoreError;\n    if (allowSpecialUseDomain &&\n        topLevelDomain !== undefined &&\n        SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n        if (domainParts.length > 1) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const secondLevelDomain = domainParts[domainParts.length - 2];\n            // In aforementioned example, the eTLD/pubSuf will be apple.localhost\n            return `${secondLevelDomain}.${topLevelDomain}`;\n        }\n        else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {\n            // For a single word special use domain, e.g. 'localhost' or 'invalid', per RFC 6761,\n            // \"Application software MAY recognize {localhost/invalid} names as special, or\n            // MAY pass them to name resolution APIs as they would for other domain names.\"\n            return topLevelDomain;\n        }\n    }\n    if (!ignoreError &&\n        topLevelDomain !== undefined &&\n        SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n        throw new Error(`Cookie has domain set to the public suffix \"${topLevelDomain}\" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`);\n    }\n    const publicSuffix = (0, tldts_1.getDomain)(domain, {\n        allowIcannDomains: true,\n        allowPrivateDomains: true,\n    });\n    if (publicSuffix)\n        return publicSuffix;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9nZXRQdWJsaWNTdWZmaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0ZBQXNGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCLEdBQUcsZUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGVBQWUsK0VBQStFLHlEQUF5RDtBQUM5TjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvZ2V0UHVibGljU3VmZml4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQdWJsaWNTdWZmaXggPSBnZXRQdWJsaWNTdWZmaXg7XG5jb25zdCB0bGR0c18xID0gcmVxdWlyZShcInRsZHRzXCIpO1xuLy8gUkZDIDY3NjFcbmNvbnN0IFNQRUNJQUxfVVNFX0RPTUFJTlMgPSBbJ2xvY2FsJywgJ2V4YW1wbGUnLCAnaW52YWxpZCcsICdsb2NhbGhvc3QnLCAndGVzdCddO1xuY29uc3QgU1BFQ0lBTF9UUkVBVE1FTlRfRE9NQUlOUyA9IFsnbG9jYWxob3N0JywgJ2ludmFsaWQnXTtcbmNvbnN0IGRlZmF1bHRHZXRQdWJsaWNTdWZmaXhPcHRpb25zID0ge1xuICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogZmFsc2UsXG4gICAgaWdub3JlRXJyb3I6IGZhbHNlLFxufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcHVibGljIHN1ZmZpeCBvZiB0aGlzIGhvc3RuYW1lLiBUaGUgcHVibGljIHN1ZmZpeCBpcyB0aGUgc2hvcnRlc3QgZG9tYWluXG4gKiBuYW1lIHVwb24gd2hpY2ggYSBjb29raWUgY2FuIGJlIHNldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSBcInB1YmxpYyBzdWZmaXhcIiBpcyBhIGRvbWFpbiB0aGF0IGlzIGNvbnRyb2xsZWQgYnkgYVxuICogcHVibGljIHJlZ2lzdHJ5LCBzdWNoIGFzIFwiY29tXCIsIFwiY28udWtcIiwgYW5kIFwicHZ0LmsxMi53eS51c1wiLlxuICogVGhpcyBzdGVwIGlzIGVzc2VudGlhbCBmb3IgcHJldmVudGluZyBhdHRhY2tlci5jb20gZnJvbVxuICogZGlzcnVwdGluZyB0aGUgaW50ZWdyaXR5IG9mIGV4YW1wbGUuY29tIGJ5IHNldHRpbmcgYSBjb29raWVcbiAqIHdpdGggYSBEb21haW4gYXR0cmlidXRlIG9mIFwiY29tXCIuICBVbmZvcnR1bmF0ZWx5LCB0aGUgc2V0IG9mXG4gKiBwdWJsaWMgc3VmZml4ZXMgKGFsc28ga25vd24gYXMgXCJyZWdpc3RyeSBjb250cm9sbGVkIGRvbWFpbnNcIilcbiAqIGNoYW5nZXMgb3ZlciB0aW1lLiAgSWYgZmVhc2libGUsIHVzZXIgYWdlbnRzIFNIT1VMRCB1c2UgYW5cbiAqIHVwLXRvLWRhdGUgcHVibGljIHN1ZmZpeCBsaXN0LCBzdWNoIGFzIHRoZSBvbmUgbWFpbnRhaW5lZCBieVxuICogdGhlIE1vemlsbGEgcHJvamVjdCBhdCBodHRwOi8vcHVibGljc3VmZml4Lm9yZy8uXG4gKiAoU2VlIHtAbGluayBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjI2NS5odG1sI3NlY3Rpb24tNS4zIHwgUkZDNjI2NSAtIFNlY3Rpb24gNS4zfSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBnZXRQdWJsaWNTdWZmaXgoJ3d3dy5leGFtcGxlLmNvbScpID09PSAnZXhhbXBsZS5jb20nXG4gKiBnZXRQdWJsaWNTdWZmaXgoJ3d3dy5zdWJkb21haW4uZXhhbXBsZS5jb20nKSA9PT0gJ2V4YW1wbGUuY29tJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGRvbWFpbiAtIHRoZSBkb21haW4gYXR0cmlidXRlIG9mIGEgY29va2llXG4gKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIGNvbnRyb2xsaW5nIGhvdyB0aGUgcHVibGljIHN1ZmZpeCBpcyBkZXRlcm1pbmVkXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldFB1YmxpY1N1ZmZpeChkb21haW4sIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRHZXRQdWJsaWNTdWZmaXhPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZG9tYWluUGFydHMgPSBkb21haW4uc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0b3BMZXZlbERvbWFpbiA9IGRvbWFpblBhcnRzW2RvbWFpblBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGFsbG93U3BlY2lhbFVzZURvbWFpbiA9ICEhb3B0aW9ucy5hbGxvd1NwZWNpYWxVc2VEb21haW47XG4gICAgY29uc3QgaWdub3JlRXJyb3IgPSAhIW9wdGlvbnMuaWdub3JlRXJyb3I7XG4gICAgaWYgKGFsbG93U3BlY2lhbFVzZURvbWFpbiAmJlxuICAgICAgICB0b3BMZXZlbERvbWFpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIFNQRUNJQUxfVVNFX0RPTUFJTlMuaW5jbHVkZXModG9wTGV2ZWxEb21haW4pKSB7XG4gICAgICAgIGlmIChkb21haW5QYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kTGV2ZWxEb21haW4gPSBkb21haW5QYXJ0c1tkb21haW5QYXJ0cy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIC8vIEluIGFmb3JlbWVudGlvbmVkIGV4YW1wbGUsIHRoZSBlVExEL3B1YlN1ZiB3aWxsIGJlIGFwcGxlLmxvY2FsaG9zdFxuICAgICAgICAgICAgcmV0dXJuIGAke3NlY29uZExldmVsRG9tYWlufS4ke3RvcExldmVsRG9tYWlufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoU1BFQ0lBTF9UUkVBVE1FTlRfRE9NQUlOUy5pbmNsdWRlcyh0b3BMZXZlbERvbWFpbikpIHtcbiAgICAgICAgICAgIC8vIEZvciBhIHNpbmdsZSB3b3JkIHNwZWNpYWwgdXNlIGRvbWFpbiwgZS5nLiAnbG9jYWxob3N0JyBvciAnaW52YWxpZCcsIHBlciBSRkMgNjc2MSxcbiAgICAgICAgICAgIC8vIFwiQXBwbGljYXRpb24gc29mdHdhcmUgTUFZIHJlY29nbml6ZSB7bG9jYWxob3N0L2ludmFsaWR9IG5hbWVzIGFzIHNwZWNpYWwsIG9yXG4gICAgICAgICAgICAvLyBNQVkgcGFzcyB0aGVtIHRvIG5hbWUgcmVzb2x1dGlvbiBBUElzIGFzIHRoZXkgd291bGQgZm9yIG90aGVyIGRvbWFpbiBuYW1lcy5cIlxuICAgICAgICAgICAgcmV0dXJuIHRvcExldmVsRG9tYWluO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaWdub3JlRXJyb3IgJiZcbiAgICAgICAgdG9wTGV2ZWxEb21haW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBTUEVDSUFMX1VTRV9ET01BSU5TLmluY2x1ZGVzKHRvcExldmVsRG9tYWluKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvb2tpZSBoYXMgZG9tYWluIHNldCB0byB0aGUgcHVibGljIHN1ZmZpeCBcIiR7dG9wTGV2ZWxEb21haW59XCIgd2hpY2ggaXMgYSBzcGVjaWFsIHVzZSBkb21haW4uIFRvIGFsbG93IHRoaXMsIGNvbmZpZ3VyZSB5b3VyIENvb2tpZUphciB3aXRoIHthbGxvd1NwZWNpYWxVc2VEb21haW46IHRydWUsIHJlamVjdFB1YmxpY1N1ZmZpeGVzOiBmYWxzZX0uYCk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY1N1ZmZpeCA9ICgwLCB0bGR0c18xLmdldERvbWFpbikoZG9tYWluLCB7XG4gICAgICAgIGFsbG93SWNhbm5Eb21haW5zOiB0cnVlLFxuICAgICAgICBhbGxvd1ByaXZhdGVEb21haW5zOiB0cnVlLFxuICAgIH0pO1xuICAgIGlmIChwdWJsaWNTdWZmaXgpXG4gICAgICAgIHJldHVybiBwdWJsaWNTdWZmaXg7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/getPublicSuffix.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/memstore.js":
/*!****************************************************!*\
  !*** ./node_modules/tough-cookie/dist/memstore.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MemoryCookieStore = void 0;\nconst pathMatch_1 = __webpack_require__(/*! ./pathMatch */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/pathMatch.js\");\nconst permuteDomain_1 = __webpack_require__(/*! ./permuteDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/permuteDomain.js\");\nconst store_1 = __webpack_require__(/*! ./store */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/store.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/utils.js\");\n/**\n * An in-memory {@link Store} implementation for {@link CookieJar}. This is the default implementation used by\n * {@link CookieJar} and supports both async and sync operations. Also supports serialization, getAllCookies, and removeAllCookies.\n * @public\n */\nclass MemoryCookieStore extends store_1.Store {\n    /**\n     * Create a new {@link MemoryCookieStore}.\n     */\n    constructor() {\n        super();\n        this.synchronous = true;\n        this.idx = Object.create(null);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    findCookie(domain, path, key, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        if (domain == null || path == null || key == null) {\n            return promiseCallback.resolve(undefined);\n        }\n        const result = this.idx[domain]?.[path]?.[key];\n        return promiseCallback.resolve(result);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    findCookies(domain, path, allowSpecialUseDomain = false, callback) {\n        if (typeof allowSpecialUseDomain === 'function') {\n            callback = allowSpecialUseDomain;\n            // TODO: It's weird that `allowSpecialUseDomain` defaults to false with no callback,\n            // but true with a callback. This is legacy behavior from v4.\n            allowSpecialUseDomain = true;\n        }\n        const results = [];\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        if (!domain) {\n            return promiseCallback.resolve([]);\n        }\n        let pathMatcher;\n        if (!path) {\n            // null means \"all paths\"\n            pathMatcher = function matchAll(domainIndex) {\n                for (const curPath in domainIndex) {\n                    const pathIndex = domainIndex[curPath];\n                    for (const key in pathIndex) {\n                        const value = pathIndex[key];\n                        if (value) {\n                            results.push(value);\n                        }\n                    }\n                }\n            };\n        }\n        else {\n            pathMatcher = function matchRFC(domainIndex) {\n                //NOTE: we should use path-match algorithm from S5.1.4 here\n                //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n                for (const cookiePath in domainIndex) {\n                    if ((0, pathMatch_1.pathMatch)(path, cookiePath)) {\n                        const pathIndex = domainIndex[cookiePath];\n                        for (const key in pathIndex) {\n                            const value = pathIndex[key];\n                            if (value) {\n                                results.push(value);\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        const domains = (0, permuteDomain_1.permuteDomain)(domain, allowSpecialUseDomain) || [domain];\n        const idx = this.idx;\n        domains.forEach((curDomain) => {\n            const domainIndex = idx[curDomain];\n            if (!domainIndex) {\n                return;\n            }\n            pathMatcher(domainIndex);\n        });\n        return promiseCallback.resolve(results);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    putCookie(cookie, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const { domain, path, key } = cookie;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (domain == null || path == null || key == null) {\n            return promiseCallback.resolve(undefined);\n        }\n        const domainEntry = this.idx[domain] ??\n            Object.create(null);\n        this.idx[domain] = domainEntry;\n        const pathEntry = domainEntry[path] ??\n            Object.create(null);\n        domainEntry[path] = pathEntry;\n        pathEntry[key] = cookie;\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    updateCookie(_oldCookie, newCookie, callback) {\n        // updateCookie() may avoid updating cookies that are identical.  For example,\n        // lastAccessed may not be important to some stores and an equality\n        // comparison could exclude that field.\n        // Don't return a value when using a callback, so that the return type is truly \"void\"\n        if (callback)\n            this.putCookie(newCookie, callback);\n        else\n            return this.putCookie(newCookie);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeCookie(domain, path, key, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        delete this.idx[domain]?.[path]?.[key];\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeCookies(domain, path, callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const domainEntry = this.idx[domain];\n        if (domainEntry) {\n            if (path) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete domainEntry[path];\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this.idx[domain];\n            }\n        }\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeAllCookies(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        this.idx = Object.create(null);\n        return promiseCallback.resolve(undefined);\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    getAllCookies(callback) {\n        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);\n        const cookies = [];\n        const idx = this.idx;\n        const domains = Object.keys(idx);\n        domains.forEach((domain) => {\n            const domainEntry = idx[domain] ?? {};\n            const paths = Object.keys(domainEntry);\n            paths.forEach((path) => {\n                const pathEntry = domainEntry[path] ?? {};\n                const keys = Object.keys(pathEntry);\n                keys.forEach((key) => {\n                    const keyEntry = pathEntry[key];\n                    if (keyEntry != null) {\n                        cookies.push(keyEntry);\n                    }\n                });\n            });\n        });\n        // Sort by creationIndex so deserializing retains the creation order.\n        // When implementing your own store, this SHOULD retain the order too\n        cookies.sort((a, b) => {\n            return (a.creationIndex || 0) - (b.creationIndex || 0);\n        });\n        return promiseCallback.resolve(cookies);\n    }\n}\nexports.MemoryCookieStore = MemoryCookieStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9tZW1zdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsb0JBQW9CLG1CQUFPLENBQUMsc0ZBQWE7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsOEZBQWlCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDO0FBQ0EsaUJBQWlCLGFBQWEsb0JBQW9CLGdCQUFnQjtBQUNsRSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9tZW1zdG9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVtb3J5Q29va2llU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBwYXRoTWF0Y2hfMSA9IHJlcXVpcmUoXCIuL3BhdGhNYXRjaFwiKTtcbmNvbnN0IHBlcm11dGVEb21haW5fMSA9IHJlcXVpcmUoXCIuL3Blcm11dGVEb21haW5cIik7XG5jb25zdCBzdG9yZV8xID0gcmVxdWlyZShcIi4vc3RvcmVcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEFuIGluLW1lbW9yeSB7QGxpbmsgU3RvcmV9IGltcGxlbWVudGF0aW9uIGZvciB7QGxpbmsgQ29va2llSmFyfS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5XG4gKiB7QGxpbmsgQ29va2llSmFyfSBhbmQgc3VwcG9ydHMgYm90aCBhc3luYyBhbmQgc3luYyBvcGVyYXRpb25zLiBBbHNvIHN1cHBvcnRzIHNlcmlhbGl6YXRpb24sIGdldEFsbENvb2tpZXMsIGFuZCByZW1vdmVBbGxDb29raWVzLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBNZW1vcnlDb29raWVTdG9yZSBleHRlbmRzIHN0b3JlXzEuU3RvcmUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB7QGxpbmsgTWVtb3J5Q29va2llU3RvcmV9LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pZHggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZpbmRDb29raWUoZG9tYWluLCBwYXRoLCBrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9ICgwLCB1dGlsc18xLmNyZWF0ZVByb21pc2VDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICBpZiAoZG9tYWluID09IG51bGwgfHwgcGF0aCA9PSBudWxsIHx8IGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmlkeFtkb21haW5dPy5bcGF0aF0/LltrZXldO1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmaW5kQ29va2llcyhkb21haW4sIHBhdGgsIGFsbG93U3BlY2lhbFVzZURvbWFpbiA9IGZhbHNlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGFsbG93U3BlY2lhbFVzZURvbWFpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhbGxvd1NwZWNpYWxVc2VEb21haW47XG4gICAgICAgICAgICAvLyBUT0RPOiBJdCdzIHdlaXJkIHRoYXQgYGFsbG93U3BlY2lhbFVzZURvbWFpbmAgZGVmYXVsdHMgdG8gZmFsc2Ugd2l0aCBubyBjYWxsYmFjayxcbiAgICAgICAgICAgIC8vIGJ1dCB0cnVlIHdpdGggYSBjYWxsYmFjay4gVGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSB2NC5cbiAgICAgICAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSAoMCwgdXRpbHNfMS5jcmVhdGVQcm9taXNlQ2FsbGJhY2spKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGhNYXRjaGVyO1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIC8vIG51bGwgbWVhbnMgXCJhbGwgcGF0aHNcIlxuICAgICAgICAgICAgcGF0aE1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaEFsbChkb21haW5JbmRleCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VyUGF0aCBpbiBkb21haW5JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoSW5kZXggPSBkb21haW5JbmRleFtjdXJQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGhJbmRleFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoTWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoUkZDKGRvbWFpbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy9OT1RFOiB3ZSBzaG91bGQgdXNlIHBhdGgtbWF0Y2ggYWxnb3JpdGhtIGZyb20gUzUuMS40IGhlcmVcbiAgICAgICAgICAgICAgICAvLyhzZWUgOiBodHRwczovL2dpdGh1Yi5jb20vQ2hyb21pdW1XZWJBcHBzL2Nocm9taXVtL2Jsb2IvYjNkM2I0ZGE4YmI5NGMxYjJlMDYxNjAwZGYxMDZkNTkwZmRhMzYyMC9uZXQvY29va2llcy9jYW5vbmljYWxfY29va2llLmNjI0wyOTkpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb29raWVQYXRoIGluIGRvbWFpbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgcGF0aE1hdGNoXzEucGF0aE1hdGNoKShwYXRoLCBjb29raWVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aEluZGV4ID0gZG9tYWluSW5kZXhbY29va2llUGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGhJbmRleFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tYWlucyA9ICgwLCBwZXJtdXRlRG9tYWluXzEucGVybXV0ZURvbWFpbikoZG9tYWluLCBhbGxvd1NwZWNpYWxVc2VEb21haW4pIHx8IFtkb21haW5dO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmlkeDtcbiAgICAgICAgZG9tYWlucy5mb3JFYWNoKChjdXJEb21haW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbkluZGV4ID0gaWR4W2N1ckRvbWFpbl07XG4gICAgICAgICAgICBpZiAoIWRvbWFpbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aE1hdGNoZXIoZG9tYWluSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIHB1dENvb2tpZShjb29raWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9ICgwLCB1dGlsc18xLmNyZWF0ZVByb21pc2VDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICBjb25zdCB7IGRvbWFpbiwgcGF0aCwga2V5IH0gPSBjb29raWU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmIChkb21haW4gPT0gbnVsbCB8fCBwYXRoID09IG51bGwgfHwga2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbWFpbkVudHJ5ID0gdGhpcy5pZHhbZG9tYWluXSA/P1xuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5pZHhbZG9tYWluXSA9IGRvbWFpbkVudHJ5O1xuICAgICAgICBjb25zdCBwYXRoRW50cnkgPSBkb21haW5FbnRyeVtwYXRoXSA/P1xuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZG9tYWluRW50cnlbcGF0aF0gPSBwYXRoRW50cnk7XG4gICAgICAgIHBhdGhFbnRyeVtrZXldID0gY29va2llO1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICB1cGRhdGVDb29raWUoX29sZENvb2tpZSwgbmV3Q29va2llLCBjYWxsYmFjaykge1xuICAgICAgICAvLyB1cGRhdGVDb29raWUoKSBtYXkgYXZvaWQgdXBkYXRpbmcgY29va2llcyB0aGF0IGFyZSBpZGVudGljYWwuICBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gbGFzdEFjY2Vzc2VkIG1heSBub3QgYmUgaW1wb3J0YW50IHRvIHNvbWUgc3RvcmVzIGFuZCBhbiBlcXVhbGl0eVxuICAgICAgICAvLyBjb21wYXJpc29uIGNvdWxkIGV4Y2x1ZGUgdGhhdCBmaWVsZC5cbiAgICAgICAgLy8gRG9uJ3QgcmV0dXJuIGEgdmFsdWUgd2hlbiB1c2luZyBhIGNhbGxiYWNrLCBzbyB0aGF0IHRoZSByZXR1cm4gdHlwZSBpcyB0cnVseSBcInZvaWRcIlxuICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICB0aGlzLnB1dENvb2tpZShuZXdDb29raWUsIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlQ29va2llKGRvbWFpbiwgcGF0aCwga2V5LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSAoMCwgdXRpbHNfMS5jcmVhdGVQcm9taXNlQ2FsbGJhY2spKGNhbGxiYWNrKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWR4W2RvbWFpbl0/LltwYXRoXT8uW2tleV07XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIHJlbW92ZUNvb2tpZXMoZG9tYWluLCBwYXRoLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSAoMCwgdXRpbHNfMS5jcmVhdGVQcm9taXNlQ2FsbGJhY2spKGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgZG9tYWluRW50cnkgPSB0aGlzLmlkeFtkb21haW5dO1xuICAgICAgICBpZiAoZG9tYWluRW50cnkpIHtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5FbnRyeVtwYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICByZW1vdmVBbGxDb29raWVzKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9ICgwLCB1dGlsc18xLmNyZWF0ZVByb21pc2VDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmlkeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGdldEFsbENvb2tpZXMoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvbWlzZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IGNvb2tpZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5pZHg7XG4gICAgICAgIGNvbnN0IGRvbWFpbnMgPSBPYmplY3Qua2V5cyhpZHgpO1xuICAgICAgICBkb21haW5zLmZvckVhY2goKGRvbWFpbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluRW50cnkgPSBpZHhbZG9tYWluXSA/PyB7fTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoZG9tYWluRW50cnkpO1xuICAgICAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhFbnRyeSA9IGRvbWFpbkVudHJ5W3BhdGhdID8/IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXRoRW50cnkpO1xuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVudHJ5ID0gcGF0aEVudHJ5W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlFbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29raWVzLnB1c2goa2V5RW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNvcnQgYnkgY3JlYXRpb25JbmRleCBzbyBkZXNlcmlhbGl6aW5nIHJldGFpbnMgdGhlIGNyZWF0aW9uIG9yZGVyLlxuICAgICAgICAvLyBXaGVuIGltcGxlbWVudGluZyB5b3VyIG93biBzdG9yZSwgdGhpcyBTSE9VTEQgcmV0YWluIHRoZSBvcmRlciB0b29cbiAgICAgICAgY29va2llcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGEuY3JlYXRpb25JbmRleCB8fCAwKSAtIChiLmNyZWF0aW9uSW5kZXggfHwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUoY29va2llcyk7XG4gICAgfVxufVxuZXhwb3J0cy5NZW1vcnlDb29raWVTdG9yZSA9IE1lbW9yeUNvb2tpZVN0b3JlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/memstore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/pathMatch.js":
/*!*****************************************************!*\
  !*** ./node_modules/tough-cookie/dist/pathMatch.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pathMatch = pathMatch;\n/**\n * Answers \"does the request-path path-match a given cookie-path?\" as per {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.4 | RFC6265 Section 5.1.4}.\n * This is essentially a prefix-match where cookiePath is a prefix of reqPath.\n *\n * @remarks\n * A request-path path-matches a given cookie-path if at least one of\n * the following conditions holds:\n *\n * - The cookie-path and the request-path are identical.\n * - The cookie-path is a prefix of the request-path, and the last character of the cookie-path is %x2F (\"/\").\n * - The cookie-path is a prefix of the request-path, and the first character of the request-path that is not included in the cookie-path is a %x2F (\"/\") character.\n *\n * @param reqPath - the path of the request\n * @param cookiePath - the path of the cookie\n * @public\n */\nfunction pathMatch(reqPath, cookiePath) {\n    // \"o  The cookie-path and the request-path are identical.\"\n    if (cookiePath === reqPath) {\n        return true;\n    }\n    const idx = reqPath.indexOf(cookiePath);\n    if (idx === 0) {\n        // \"o  The cookie-path is a prefix of the request-path, and the last\n        // character of the cookie-path is %x2F (\"/\").\"\n        if (cookiePath[cookiePath.length - 1] === '/') {\n            return true;\n        }\n        // \" o  The cookie-path is a prefix of the request-path, and the first\n        // character of the request-path that is not included in the cookie- path\n        // is a %x2F (\"/\") character.\"\n        if (reqPath.startsWith(cookiePath) && reqPath[cookiePath.length] === '/') {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9wYXRoTWF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0EsMkVBQTJFLHdGQUF3RjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L3BhdGhNYXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGF0aE1hdGNoID0gcGF0aE1hdGNoO1xuLyoqXG4gKiBBbnN3ZXJzIFwiZG9lcyB0aGUgcmVxdWVzdC1wYXRoIHBhdGgtbWF0Y2ggYSBnaXZlbiBjb29raWUtcGF0aD9cIiBhcyBwZXIge0BsaW5rIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1Lmh0bWwjc2VjdGlvbi01LjEuNCB8IFJGQzYyNjUgU2VjdGlvbiA1LjEuNH0uXG4gKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgcHJlZml4LW1hdGNoIHdoZXJlIGNvb2tpZVBhdGggaXMgYSBwcmVmaXggb2YgcmVxUGF0aC5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSByZXF1ZXN0LXBhdGggcGF0aC1tYXRjaGVzIGEgZ2l2ZW4gY29va2llLXBhdGggaWYgYXQgbGVhc3Qgb25lIG9mXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgaG9sZHM6XG4gKlxuICogLSBUaGUgY29va2llLXBhdGggYW5kIHRoZSByZXF1ZXN0LXBhdGggYXJlIGlkZW50aWNhbC5cbiAqIC0gVGhlIGNvb2tpZS1wYXRoIGlzIGEgcHJlZml4IG9mIHRoZSByZXF1ZXN0LXBhdGgsIGFuZCB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGNvb2tpZS1wYXRoIGlzICV4MkYgKFwiL1wiKS5cbiAqIC0gVGhlIGNvb2tpZS1wYXRoIGlzIGEgcHJlZml4IG9mIHRoZSByZXF1ZXN0LXBhdGgsIGFuZCB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSByZXF1ZXN0LXBhdGggdGhhdCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGNvb2tpZS1wYXRoIGlzIGEgJXgyRiAoXCIvXCIpIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gcmVxUGF0aCAtIHRoZSBwYXRoIG9mIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0gY29va2llUGF0aCAtIHRoZSBwYXRoIG9mIHRoZSBjb29raWVcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoKHJlcVBhdGgsIGNvb2tpZVBhdGgpIHtcbiAgICAvLyBcIm8gIFRoZSBjb29raWUtcGF0aCBhbmQgdGhlIHJlcXVlc3QtcGF0aCBhcmUgaWRlbnRpY2FsLlwiXG4gICAgaWYgKGNvb2tpZVBhdGggPT09IHJlcVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlkeCA9IHJlcVBhdGguaW5kZXhPZihjb29raWVQYXRoKTtcbiAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgIC8vIFwibyAgVGhlIGNvb2tpZS1wYXRoIGlzIGEgcHJlZml4IG9mIHRoZSByZXF1ZXN0LXBhdGgsIGFuZCB0aGUgbGFzdFxuICAgICAgICAvLyBjaGFyYWN0ZXIgb2YgdGhlIGNvb2tpZS1wYXRoIGlzICV4MkYgKFwiL1wiKS5cIlxuICAgICAgICBpZiAoY29va2llUGF0aFtjb29raWVQYXRoLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiIG8gIFRoZSBjb29raWUtcGF0aCBpcyBhIHByZWZpeCBvZiB0aGUgcmVxdWVzdC1wYXRoLCBhbmQgdGhlIGZpcnN0XG4gICAgICAgIC8vIGNoYXJhY3RlciBvZiB0aGUgcmVxdWVzdC1wYXRoIHRoYXQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBjb29raWUtIHBhdGhcbiAgICAgICAgLy8gaXMgYSAleDJGIChcIi9cIikgY2hhcmFjdGVyLlwiXG4gICAgICAgIGlmIChyZXFQYXRoLnN0YXJ0c1dpdGgoY29va2llUGF0aCkgJiYgcmVxUGF0aFtjb29raWVQYXRoLmxlbmd0aF0gPT09ICcvJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/pathMatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/permuteDomain.js":
/*!*********************************************************!*\
  !*** ./node_modules/tough-cookie/dist/permuteDomain.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.permuteDomain = permuteDomain;\nconst getPublicSuffix_1 = __webpack_require__(/*! ./getPublicSuffix */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/getPublicSuffix.js\");\n/**\n * Generates the permutation of all possible values that {@link domainMatch} the given `domain` parameter. The\n * array is in shortest-to-longest order. Useful when building custom {@link Store} implementations.\n *\n * @example\n * ```\n * permuteDomain('foo.bar.example.com')\n * // ['example.com', 'bar.example.com', 'foo.bar.example.com']\n * ```\n *\n * @public\n * @param domain - the domain to generate permutations for\n * @param allowSpecialUseDomain - flag to control if {@link https://www.rfc-editor.org/rfc/rfc6761.html | Special Use Domains} such as `localhost` should be allowed\n */\nfunction permuteDomain(domain, allowSpecialUseDomain) {\n    const pubSuf = (0, getPublicSuffix_1.getPublicSuffix)(domain, {\n        allowSpecialUseDomain: allowSpecialUseDomain,\n    });\n    if (!pubSuf) {\n        return undefined;\n    }\n    if (pubSuf == domain) {\n        return [domain];\n    }\n    // Nuke trailing dot\n    if (domain.slice(-1) == '.') {\n        domain = domain.slice(0, -1);\n    }\n    const prefix = domain.slice(0, -(pubSuf.length + 1)); // \".example.com\"\n    const parts = prefix.split('.').reverse();\n    let cur = pubSuf;\n    const permutations = [cur];\n    while (parts.length) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const part = parts.shift();\n        cur = `${part}.${cur}`;\n        permutations.push(cur);\n    }\n    return permutations;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9wZXJtdXRlRG9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQiwwQkFBMEIsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDckQ7QUFDQSwwREFBMEQsbUJBQW1CO0FBQzdFLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5RUFBeUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUssR0FBRyxJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L3Blcm11dGVEb21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBlcm11dGVEb21haW4gPSBwZXJtdXRlRG9tYWluO1xuY29uc3QgZ2V0UHVibGljU3VmZml4XzEgPSByZXF1aXJlKFwiLi9nZXRQdWJsaWNTdWZmaXhcIik7XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgcGVybXV0YXRpb24gb2YgYWxsIHBvc3NpYmxlIHZhbHVlcyB0aGF0IHtAbGluayBkb21haW5NYXRjaH0gdGhlIGdpdmVuIGBkb21haW5gIHBhcmFtZXRlci4gVGhlXG4gKiBhcnJheSBpcyBpbiBzaG9ydGVzdC10by1sb25nZXN0IG9yZGVyLiBVc2VmdWwgd2hlbiBidWlsZGluZyBjdXN0b20ge0BsaW5rIFN0b3JlfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogcGVybXV0ZURvbWFpbignZm9vLmJhci5leGFtcGxlLmNvbScpXG4gKiAvLyBbJ2V4YW1wbGUuY29tJywgJ2Jhci5leGFtcGxlLmNvbScsICdmb28uYmFyLmV4YW1wbGUuY29tJ11cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBkb21haW4gLSB0aGUgZG9tYWluIHRvIGdlbmVyYXRlIHBlcm11dGF0aW9ucyBmb3JcbiAqIEBwYXJhbSBhbGxvd1NwZWNpYWxVc2VEb21haW4gLSBmbGFnIHRvIGNvbnRyb2wgaWYge0BsaW5rIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzYxLmh0bWwgfCBTcGVjaWFsIFVzZSBEb21haW5zfSBzdWNoIGFzIGBsb2NhbGhvc3RgIHNob3VsZCBiZSBhbGxvd2VkXG4gKi9cbmZ1bmN0aW9uIHBlcm11dGVEb21haW4oZG9tYWluLCBhbGxvd1NwZWNpYWxVc2VEb21haW4pIHtcbiAgICBjb25zdCBwdWJTdWYgPSAoMCwgZ2V0UHVibGljU3VmZml4XzEuZ2V0UHVibGljU3VmZml4KShkb21haW4sIHtcbiAgICAgICAgYWxsb3dTcGVjaWFsVXNlRG9tYWluOiBhbGxvd1NwZWNpYWxVc2VEb21haW4sXG4gICAgfSk7XG4gICAgaWYgKCFwdWJTdWYpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHB1YlN1ZiA9PSBkb21haW4pIHtcbiAgICAgICAgcmV0dXJuIFtkb21haW5dO1xuICAgIH1cbiAgICAvLyBOdWtlIHRyYWlsaW5nIGRvdFxuICAgIGlmIChkb21haW4uc2xpY2UoLTEpID09ICcuJykge1xuICAgICAgICBkb21haW4gPSBkb21haW4uc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSBkb21haW4uc2xpY2UoMCwgLShwdWJTdWYubGVuZ3RoICsgMSkpOyAvLyBcIi5leGFtcGxlLmNvbVwiXG4gICAgY29uc3QgcGFydHMgPSBwcmVmaXguc3BsaXQoJy4nKS5yZXZlcnNlKCk7XG4gICAgbGV0IGN1ciA9IHB1YlN1ZjtcbiAgICBjb25zdCBwZXJtdXRhdGlvbnMgPSBbY3VyXTtcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBjdXIgPSBgJHtwYXJ0fS4ke2N1cn1gO1xuICAgICAgICBwZXJtdXRhdGlvbnMucHVzaChjdXIpO1xuICAgIH1cbiAgICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/permuteDomain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/store.js":
/*!*************************************************!*\
  !*** ./node_modules/tough-cookie/dist/store.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n// disabling this lint on this whole file because Store should be abstract\n// but we have implementations in the wild that may not implement all features\n/* eslint-disable @typescript-eslint/no-unused-vars */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Store = void 0;\n/**\n * Base class for {@link CookieJar} stores.\n *\n * The storage model for each {@link CookieJar} instance can be replaced with a custom implementation. The default is\n * {@link MemoryCookieStore}.\n *\n * @remarks\n * - Stores should inherit from the base Store class, which is available as a top-level export.\n *\n * - Stores are asynchronous by default, but if {@link Store.synchronous} is set to true, then the `*Sync` methods\n *     of the containing {@link CookieJar} can be used.\n *\n * @public\n */\nclass Store {\n    constructor() {\n        this.synchronous = false;\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    findCookie(_domain, _path, _key, _callback) {\n        throw new Error('findCookie is not implemented');\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback) {\n        throw new Error('findCookies is not implemented');\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    putCookie(_cookie, _callback) {\n        throw new Error('putCookie is not implemented');\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    updateCookie(_oldCookie, _newCookie, _callback) {\n        // recommended default implementation:\n        // return this.putCookie(newCookie, cb);\n        throw new Error('updateCookie is not implemented');\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeCookie(_domain, _path, _key, _callback) {\n        throw new Error('removeCookie is not implemented');\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeCookies(_domain, _path, _callback) {\n        throw new Error('removeCookies is not implemented');\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    removeAllCookies(_callback) {\n        throw new Error('removeAllCookies is not implemented');\n    }\n    /**\n     * @internal No doc because this is an overload that supports the implementation\n     */\n    getAllCookies(_callback) {\n        throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');\n    }\n}\nexports.Store = Store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9zdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2I7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRCxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUUsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3Qvc3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBkaXNhYmxpbmcgdGhpcyBsaW50IG9uIHRoaXMgd2hvbGUgZmlsZSBiZWNhdXNlIFN0b3JlIHNob3VsZCBiZSBhYnN0cmFjdFxuLy8gYnV0IHdlIGhhdmUgaW1wbGVtZW50YXRpb25zIGluIHRoZSB3aWxkIHRoYXQgbWF5IG5vdCBpbXBsZW1lbnQgYWxsIGZlYXR1cmVzXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcmUgPSB2b2lkIDA7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHtAbGluayBDb29raWVKYXJ9IHN0b3Jlcy5cbiAqXG4gKiBUaGUgc3RvcmFnZSBtb2RlbCBmb3IgZWFjaCB7QGxpbmsgQ29va2llSmFyfSBpbnN0YW5jZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi4gVGhlIGRlZmF1bHQgaXNcbiAqIHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0uXG4gKlxuICogQHJlbWFya3NcbiAqIC0gU3RvcmVzIHNob3VsZCBpbmhlcml0IGZyb20gdGhlIGJhc2UgU3RvcmUgY2xhc3MsIHdoaWNoIGlzIGF2YWlsYWJsZSBhcyBhIHRvcC1sZXZlbCBleHBvcnQuXG4gKlxuICogLSBTdG9yZXMgYXJlIGFzeW5jaHJvbm91cyBieSBkZWZhdWx0LCBidXQgaWYge0BsaW5rIFN0b3JlLnN5bmNocm9ub3VzfSBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgYCpTeW5jYCBtZXRob2RzXG4gKiAgICAgb2YgdGhlIGNvbnRhaW5pbmcge0BsaW5rIENvb2tpZUphcn0gY2FuIGJlIHVzZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmaW5kQ29va2llKF9kb21haW4sIF9wYXRoLCBfa2V5LCBfY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaW5kQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZpbmRDb29raWVzKF9kb21haW4sIF9wYXRoLCBfYWxsb3dTcGVjaWFsVXNlRG9tYWluID0gZmFsc2UsIF9jYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmRDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIHB1dENvb2tpZShfY29va2llLCBfY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdXRDb29raWUgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgdXBkYXRlQ29va2llKF9vbGRDb29raWUsIF9uZXdDb29raWUsIF9jYWxsYmFjaykge1xuICAgICAgICAvLyByZWNvbW1lbmRlZCBkZWZhdWx0IGltcGxlbWVudGF0aW9uOlxuICAgICAgICAvLyByZXR1cm4gdGhpcy5wdXRDb29raWUobmV3Q29va2llLCBjYik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXBkYXRlQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIHJlbW92ZUNvb2tpZShfZG9tYWluLCBfcGF0aCwgX2tleSwgX2NhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIHJlbW92ZUNvb2tpZXMoX2RvbWFpbiwgX3BhdGgsIF9jYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUNvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlQWxsQ29va2llcyhfY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVBbGxDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGdldEFsbENvb2tpZXMoX2NhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0QWxsQ29va2llcyBpcyBub3QgaW1wbGVtZW50ZWQgKHRoZXJlZm9yZSBqYXIgY2Fubm90IGJlIHNlcmlhbGl6ZWQpJyk7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yZSA9IFN0b3JlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/store.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/tough-cookie/dist/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.safeToString = exports.objectToString = void 0;\nexports.createPromiseCallback = createPromiseCallback;\nexports.inOperator = inOperator;\n/** Wrapped `Object.prototype.toString`, so that you don't need to remember to use `.call()`. */\nconst objectToString = (obj) => Object.prototype.toString.call(obj);\nexports.objectToString = objectToString;\n/**\n * Converts an array to string, safely handling symbols, null prototype objects, and recursive arrays.\n */\nconst safeArrayToString = (arr, seenArrays) => {\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString#description\n    if (typeof arr.join !== 'function')\n        return (0, exports.objectToString)(arr);\n    seenArrays.add(arr);\n    const mapped = arr.map((val) => val === null || val === undefined || seenArrays.has(val)\n        ? ''\n        : safeToStringImpl(val, seenArrays));\n    return mapped.join();\n};\nconst safeToStringImpl = (val, seenArrays = new WeakSet()) => {\n    // Using .toString() fails for null/undefined and implicit conversion (val + \"\") fails for symbols\n    // and objects with null prototype\n    if (typeof val !== 'object' || val === null) {\n        return String(val);\n    }\n    else if (typeof val.toString === 'function') {\n        return Array.isArray(val)\n            ? // Arrays have a weird custom toString that we need to replicate\n                safeArrayToString(val, seenArrays)\n            : // eslint-disable-next-line @typescript-eslint/no-base-to-string\n                String(val);\n    }\n    else {\n        // This case should just be objects with null prototype, so we can just use Object#toString\n        return (0, exports.objectToString)(val);\n    }\n};\n/** Safely converts any value to string, using the value's own `toString` when available. */\nconst safeToString = (val) => safeToStringImpl(val);\nexports.safeToString = safeToString;\n/** Converts a callback into a utility object where either a callback or a promise can be used. */\nfunction createPromiseCallback(cb) {\n    let callback;\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n    if (typeof cb === 'function') {\n        callback = (err, result) => {\n            try {\n                if (err)\n                    cb(err);\n                // If `err` is null, we know `result` must be `T`\n                // The assertion isn't *strictly* correct, as `T` could be nullish, but, ehh, good enough...\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                else\n                    cb(null, result);\n            }\n            catch (e) {\n                reject(e instanceof Error ? e : new Error());\n            }\n        };\n    }\n    else {\n        callback = (err, result) => {\n            try {\n                // If `err` is null, we know `result` must be `T`\n                // The assertion isn't *strictly* correct, as `T` could be nullish, but, ehh, good enough...\n                if (err)\n                    reject(err);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                else\n                    resolve(result);\n            }\n            catch (e) {\n                reject(e instanceof Error ? e : new Error());\n            }\n        };\n    }\n    return {\n        promise,\n        callback,\n        resolve: (value) => {\n            callback(null, value);\n            return promise;\n        },\n        reject: (error) => {\n            callback(error);\n            return promise;\n        },\n    };\n}\nfunction inOperator(k, o) {\n    return k in o;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxzQkFBc0I7QUFDN0MsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNhZmVUb1N0cmluZyA9IGV4cG9ydHMub2JqZWN0VG9TdHJpbmcgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZVByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjaztcbmV4cG9ydHMuaW5PcGVyYXRvciA9IGluT3BlcmF0b3I7XG4vKiogV3JhcHBlZCBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AsIHNvIHRoYXQgeW91IGRvbid0IG5lZWQgdG8gcmVtZW1iZXIgdG8gdXNlIGAuY2FsbCgpYC4gKi9cbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5leHBvcnRzLm9iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IHRvIHN0cmluZywgc2FmZWx5IGhhbmRsaW5nIHN5bWJvbHMsIG51bGwgcHJvdG90eXBlIG9iamVjdHMsIGFuZCByZWN1cnNpdmUgYXJyYXlzLlxuICovXG5jb25zdCBzYWZlQXJyYXlUb1N0cmluZyA9IChhcnIsIHNlZW5BcnJheXMpID0+IHtcbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvdG9TdHJpbmcjZGVzY3JpcHRpb25cbiAgICBpZiAodHlwZW9mIGFyci5qb2luICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMub2JqZWN0VG9TdHJpbmcpKGFycik7XG4gICAgc2VlbkFycmF5cy5hZGQoYXJyKTtcbiAgICBjb25zdCBtYXBwZWQgPSBhcnIubWFwKCh2YWwpID0+IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCB8fCBzZWVuQXJyYXlzLmhhcyh2YWwpXG4gICAgICAgID8gJydcbiAgICAgICAgOiBzYWZlVG9TdHJpbmdJbXBsKHZhbCwgc2VlbkFycmF5cykpO1xuICAgIHJldHVybiBtYXBwZWQuam9pbigpO1xufTtcbmNvbnN0IHNhZmVUb1N0cmluZ0ltcGwgPSAodmFsLCBzZWVuQXJyYXlzID0gbmV3IFdlYWtTZXQoKSkgPT4ge1xuICAgIC8vIFVzaW5nIC50b1N0cmluZygpIGZhaWxzIGZvciBudWxsL3VuZGVmaW5lZCBhbmQgaW1wbGljaXQgY29udmVyc2lvbiAodmFsICsgXCJcIikgZmFpbHMgZm9yIHN5bWJvbHNcbiAgICAvLyBhbmQgb2JqZWN0cyB3aXRoIG51bGwgcHJvdG90eXBlXG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKVxuICAgICAgICAgICAgPyAvLyBBcnJheXMgaGF2ZSBhIHdlaXJkIGN1c3RvbSB0b1N0cmluZyB0aGF0IHdlIG5lZWQgdG8gcmVwbGljYXRlXG4gICAgICAgICAgICAgICAgc2FmZUFycmF5VG9TdHJpbmcodmFsLCBzZWVuQXJyYXlzKVxuICAgICAgICAgICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgICAgICAgICAgICAgU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIGp1c3QgYmUgb2JqZWN0cyB3aXRoIG51bGwgcHJvdG90eXBlLCBzbyB3ZSBjYW4ganVzdCB1c2UgT2JqZWN0I3RvU3RyaW5nXG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5vYmplY3RUb1N0cmluZykodmFsKTtcbiAgICB9XG59O1xuLyoqIFNhZmVseSBjb252ZXJ0cyBhbnkgdmFsdWUgdG8gc3RyaW5nLCB1c2luZyB0aGUgdmFsdWUncyBvd24gYHRvU3RyaW5nYCB3aGVuIGF2YWlsYWJsZS4gKi9cbmNvbnN0IHNhZmVUb1N0cmluZyA9ICh2YWwpID0+IHNhZmVUb1N0cmluZ0ltcGwodmFsKTtcbmV4cG9ydHMuc2FmZVRvU3RyaW5nID0gc2FmZVRvU3RyaW5nO1xuLyoqIENvbnZlcnRzIGEgY2FsbGJhY2sgaW50byBhIHV0aWxpdHkgb2JqZWN0IHdoZXJlIGVpdGhlciBhIGNhbGxiYWNrIG9yIGEgcHJvbWlzZSBjYW4gYmUgdXNlZC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYikge1xuICAgIGxldCBjYWxsYmFjaztcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgICAgICByZWplY3QgPSBfcmVqZWN0O1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBgZXJyYCBpcyBudWxsLCB3ZSBrbm93IGByZXN1bHRgIG11c3QgYmUgYFRgXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFzc2VydGlvbiBpc24ndCAqc3RyaWN0bHkqIGNvcnJlY3QsIGFzIGBUYCBjb3VsZCBiZSBudWxsaXNoLCBidXQsIGVoaCwgZ29vZCBlbm91Z2guLi5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBgZXJyYCBpcyBudWxsLCB3ZSBrbm93IGByZXN1bHRgIG11c3QgYmUgYFRgXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFzc2VydGlvbiBpc24ndCAqc3RyaWN0bHkqIGNvcnJlY3QsIGFzIGBUYCBjb3VsZCBiZSBudWxsaXNoLCBidXQsIGVoaCwgZ29vZCBlbm91Z2guLi5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSBpbnN0YW5jZW9mIEVycm9yID8gZSA6IG5ldyBFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIHJlc29sdmU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5PcGVyYXRvcihrLCBvKSB7XG4gICAgcmV0dXJuIGsgaW4gbztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/validators.js":
/*!******************************************************!*\
  !*** ./node_modules/tough-cookie/dist/validators.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/* ************************************************************************************\nExtracted from check-types.js\nhttps://gitlab.com/philbooth/check-types.js\n\nMIT License\n\nCopyright (c) 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 Phil Booth\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n************************************************************************************ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParameterError = void 0;\nexports.isNonEmptyString = isNonEmptyString;\nexports.isDate = isDate;\nexports.isEmptyString = isEmptyString;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isInteger = isInteger;\nexports.validate = validate;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/utils.js\");\n/* Validation functions copied from check-types package - https://www.npmjs.com/package/check-types */\n/** Determines whether the argument is a non-empty string. */\nfunction isNonEmptyString(data) {\n    return isString(data) && data !== '';\n}\n/** Determines whether the argument is a *valid* Date. */\nfunction isDate(data) {\n    return data instanceof Date && isInteger(data.getTime());\n}\n/** Determines whether the argument is the empty string. */\nfunction isEmptyString(data) {\n    return data === '' || (data instanceof String && data.toString() === '');\n}\n/** Determines whether the argument is a string. */\nfunction isString(data) {\n    return typeof data === 'string' || data instanceof String;\n}\n/** Determines whether the string representation of the argument is \"[object Object]\". */\nfunction isObject(data) {\n    return (0, utils_1.objectToString)(data) === '[object Object]';\n}\n/** Determines whether the argument is an integer. */\nfunction isInteger(data) {\n    return typeof data === 'number' && data % 1 === 0;\n}\n/* -- End validation functions -- */\n/**\n * When the first argument is false, an error is created with the given message. If a callback is\n * provided, the error is passed to the callback, otherwise the error is thrown.\n */\nfunction validate(bool, cbOrMessage, message) {\n    if (bool)\n        return; // Validation passes\n    const cb = typeof cbOrMessage === 'function' ? cbOrMessage : undefined;\n    let options = typeof cbOrMessage === 'function' ? message : cbOrMessage;\n    // The default message prior to v5 was '[object Object]' due to a bug, and the message is kept\n    // for backwards compatibility.\n    if (!isObject(options))\n        options = '[object Object]';\n    const err = new ParameterError((0, utils_1.safeToString)(options));\n    if (cb)\n        cb(err);\n    else\n        throw err;\n}\n/**\n * Represents a validation error.\n * @public\n */\nclass ParameterError extends Error {\n}\nexports.ParameterError = ParameterError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC92YWxpZGF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvdmFsaWRhdG9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuRXh0cmFjdGVkIGZyb20gY2hlY2stdHlwZXMuanNcbmh0dHBzOi8vZ2l0bGFiLmNvbS9waGlsYm9vdGgvY2hlY2stdHlwZXMuanNcblxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDEyLCAyMDEzLCAyMDE0LCAyMDE1LCAyMDE2LCAyMDE3LCAyMDE4LCAyMDE5IFBoaWwgQm9vdGhcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyYW1ldGVyRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmlzTm9uRW1wdHlTdHJpbmcgPSBpc05vbkVtcHR5U3RyaW5nO1xuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLmlzRW1wdHlTdHJpbmcgPSBpc0VtcHR5U3RyaW5nO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKiBWYWxpZGF0aW9uIGZ1bmN0aW9ucyBjb3BpZWQgZnJvbSBjaGVjay10eXBlcyBwYWNrYWdlIC0gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2hlY2stdHlwZXMgKi9cbi8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGEgbm9uLWVtcHR5IHN0cmluZy4gKi9cbmZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoZGF0YSkge1xuICAgIHJldHVybiBpc1N0cmluZyhkYXRhKSAmJiBkYXRhICE9PSAnJztcbn1cbi8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGEgKnZhbGlkKiBEYXRlLiAqL1xuZnVuY3Rpb24gaXNEYXRlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIERhdGUgJiYgaXNJbnRlZ2VyKGRhdGEuZ2V0VGltZSgpKTtcbn1cbi8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIHRoZSBlbXB0eSBzdHJpbmcuICovXG5mdW5jdGlvbiBpc0VtcHR5U3RyaW5nKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gJycgfHwgKGRhdGEgaW5zdGFuY2VvZiBTdHJpbmcgJiYgZGF0YS50b1N0cmluZygpID09PSAnJyk7XG59XG4vKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZy4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGRhdGEgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG4vKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFyZ3VtZW50IGlzIFwiW29iamVjdCBPYmplY3RdXCIuICovXG5mdW5jdGlvbiBpc09iamVjdChkYXRhKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLm9iamVjdFRvU3RyaW5nKShkYXRhKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG4vKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhbiBpbnRlZ2VyLiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgJSAxID09PSAwO1xufVxuLyogLS0gRW5kIHZhbGlkYXRpb24gZnVuY3Rpb25zIC0tICovXG4vKipcbiAqIFdoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGZhbHNlLCBhbiBlcnJvciBpcyBjcmVhdGVkIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuIElmIGEgY2FsbGJhY2sgaXNcbiAqIHByb3ZpZGVkLCB0aGUgZXJyb3IgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgb3RoZXJ3aXNlIHRoZSBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKGJvb2wsIGNiT3JNZXNzYWdlLCBtZXNzYWdlKSB7XG4gICAgaWYgKGJvb2wpXG4gICAgICAgIHJldHVybjsgLy8gVmFsaWRhdGlvbiBwYXNzZXNcbiAgICBjb25zdCBjYiA9IHR5cGVvZiBjYk9yTWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IGNiT3JNZXNzYWdlIDogdW5kZWZpbmVkO1xuICAgIGxldCBvcHRpb25zID0gdHlwZW9mIGNiT3JNZXNzYWdlID09PSAnZnVuY3Rpb24nID8gbWVzc2FnZSA6IGNiT3JNZXNzYWdlO1xuICAgIC8vIFRoZSBkZWZhdWx0IG1lc3NhZ2UgcHJpb3IgdG8gdjUgd2FzICdbb2JqZWN0IE9iamVjdF0nIGR1ZSB0byBhIGJ1ZywgYW5kIHRoZSBtZXNzYWdlIGlzIGtlcHRcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgaWYgKCFpc09iamVjdChvcHRpb25zKSlcbiAgICAgICAgb3B0aW9ucyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIGNvbnN0IGVyciA9IG5ldyBQYXJhbWV0ZXJFcnJvcigoMCwgdXRpbHNfMS5zYWZlVG9TdHJpbmcpKG9wdGlvbnMpKTtcbiAgICBpZiAoY2IpXG4gICAgICAgIGNiKGVycik7XG4gICAgZWxzZVxuICAgICAgICB0aHJvdyBlcnI7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSB2YWxpZGF0aW9uIGVycm9yLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBQYXJhbWV0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuUGFyYW1ldGVyRXJyb3IgPSBQYXJhbWV0ZXJFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/validators.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/dist/version.js":
/*!***************************************************!*\
  !*** ./node_modules/tough-cookie/dist/version.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\n/**\n * The version of `tough-cookie`\n * @public\n */\nexports.version = '5.1.0';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbi8qKlxuICogVGhlIHZlcnNpb24gb2YgYHRvdWdoLWNvb2tpZWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy52ZXJzaW9uID0gJzUuMS4wJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/dist/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ts-mixer/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-mixer/dist/esm/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mixin: () => (/* binding */ Mixin),\n/* harmony export */   decorate: () => (/* binding */ decorate),\n/* harmony export */   hasMixin: () => (/* binding */ hasMixin),\n/* harmony export */   mix: () => (/* binding */ mix),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)\n        delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null)\n        return currentChain;\n    return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n    if (objs.length === 0)\n        return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map(obj => protoChain(obj));\n    while (protoChains.every(protoChain => protoChain.length > 0)) {\n        const protos = protoChains.map(protoChain => protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every(proto => proto === potentialCommonProto))\n            commonProto = potentialCommonProto;\n        else\n            break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients) {\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for (let i = protos.length - 1; i >= 0; i--) {\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n    const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while (protosAreLeftToSearch) {\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for (let i = ingredients.length - 1; i >= 0; i--) {\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n    getPrototypeOf() {\n        return prototype;\n    },\n    setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n        if (ingredientWithProp === undefined)\n            throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n        ingredientWithProp[prop] = val;\n        return true;\n    },\n    deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n        return ingredients\n            .map(Object.getOwnPropertyNames)\n            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    },\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);\n\nconst settings = {\n    initFunction: null,\n    staticsStrategy: 'copy',\n    prototypeStrategy: 'copy',\n    decoratorInheritance: 'deep',\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = (clazz) => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n    if (instance instanceof mixin)\n        return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while (frontier.size > 0) {\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin))\n            return true;\n        frontier.forEach((item) => visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach((item) => {\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype)\n                .map((proto) => proto.constructor)\n                .filter((item) => item !== null);\n            if (itemConstituents)\n                itemConstituents.forEach((constituent) => {\n                    if (!visited.has(constituent) && !frontier.has(constituent))\n                        newFrontier.add(constituent);\n                });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n    var _a, _b;\n    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n    const mergedObject = {};\n    for (let key of allKeys)\n        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n    var _a, _b, _c, _d;\n    return ({\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),\n    });\n};\nconst mergeDecorators = (d1, d2) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),\n    });\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([...classes]);\n    while (frontier.size > 0) {\n        for (let clazz of frontier) {\n            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n            for (let newClass of newClasses)\n                frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n    const decoratorsForClassChain = findAllConstituentClasses(...classes)\n        .map(clazz => decorators.get(clazz))\n        .filter(decorators => !!decorators);\n    if (decoratorsForClassChain.length == 0)\n        return {};\n    if (decoratorsForClassChain.length == 1)\n        return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0)\n        return {};\n    if (classDecorators.length === 1)\n        return classDecorators[0];\n    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz) => {\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator) => ((clazz) => {\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n        classDecorators = [];\n        decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n});\nconst decorateMember = (decorator) => ((object, key, ...otherArgs) => {\n    var _a, _b, _c;\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n    decoratorsForTargetType[decoratorType] = decoratorsForType;\n    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n    decoratorsForType[key] = decoratorsForKey;\n    // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    return decorator(object, key, ...otherArgs);\n});\nconst decorate = (decorator) => ((...args) => {\n    if (args.length === 1)\n        return decorateClass(decorator)(args[0]);\n    return decorateMember(decorator)(...args);\n});\n\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map(constructor => constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes\n            .map(proto => proto[initFunctionName])\n            .filter(func => typeof func === 'function');\n        const combinedInitFunction = function (...args) {\n            for (let initFunction of initFunctions)\n                initFunction.apply(this, args);\n        };\n        const extraProto = { [initFunctionName]: combinedInitFunction };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)\n            // @ts-ignore: potentially abstract class\n            copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')\n            this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === 'copy'\n        ? hardMixProtos(prototypes, MixedClass)\n        : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'\n        ? hardMixProtos(constructors, null, ['prototype'])\n        : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== 'none') {\n        const classDecorators = settings.decoratorInheritance === 'deep'\n            ? deepDecoratorSearch(...constructors)\n            : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {\n            const result = decorator(DecoratedMixedClass);\n            if (result) {\n                DecoratedMixedClass = result;\n            }\n        }\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators)\n        for (let key in propDecorators)\n            for (let decorator of propDecorators[key])\n                decorator(target, key);\n    if (methodDecorators)\n        for (let key in methodDecorators)\n            for (let decorator of methodDecorators[key])\n                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n        value: decoratedClass.name,\n        writable: false,\n    });\n    return mixedClass;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cy1taXhlci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2RkFBNkY7QUFDN0YsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGFBQWE7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUlBQXlJLGdHQUFnRztBQUN6TyxxSUFBcUksOEZBQThGO0FBQ25PLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJLDhGQUE4RjtBQUMzTyxpSkFBaUosZ0dBQWdHO0FBQ2pQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3S0FBd0s7QUFDeEssMEtBQTBLO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRW9EIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3RzLW1peGVyL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IHdvcmtzIGxpa2UgYE9iamVjdC5hcHBseWAsIGJ1dCBjb3BpZXMgZ2V0dGVycyBhbmQgc2V0dGVycyBwcm9wZXJseSBhcyB3ZWxsLiAgQWRkaXRpb25hbGx5IGdpdmVzXG4gKiB0aGUgb3B0aW9uIHRvIGV4Y2x1ZGUgcHJvcGVydGllcyBieSBuYW1lLlxuICovXG5jb25zdCBjb3B5UHJvcHMgPSAoZGVzdCwgc3JjLCBleGNsdWRlID0gW10pID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNyYyk7XG4gICAgZm9yIChsZXQgcHJvcCBvZiBleGNsdWRlKVxuICAgICAgICBkZWxldGUgcHJvcHNbcHJvcF07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVzdCwgcHJvcHMpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBjaGFpbiBvZiBwcm90b3R5cGVzIHVwIHVudGlsIE9iamVjdC5wcm90b3R5cGUgZ2l2ZW4gYSBzdGFydGluZyBvYmplY3QuICBUaGUgb3JkZXIgb2YgcHJvdG90eXBlcyB3aWxsXG4gKiBiZSBjbG9zZXN0IHRvIGZhcnRoZXN0IGluIHRoZSBjaGFpbi5cbiAqL1xuY29uc3QgcHJvdG9DaGFpbiA9IChvYmosIGN1cnJlbnRDaGFpbiA9IFtvYmpdKSA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgICAgIHJldHVybiBjdXJyZW50Q2hhaW47XG4gICAgcmV0dXJuIHByb3RvQ2hhaW4ocHJvdG8sIFsuLi5jdXJyZW50Q2hhaW4sIHByb3RvXSk7XG59O1xuLyoqXG4gKiBJZGVudGlmaWVzIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGNvbW1vbiB0byBhbGwgdGhlIGdpdmVuIG9iamVjdHMgaW4gdGhlaXIgcHJvdG90eXBlIGNoYWlucy4gIEZvciBtb3N0IHVucmVsYXRlZFxuICogb2JqZWN0cywgdGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuXG4gKi9cbmNvbnN0IG5lYXJlc3RDb21tb25Qcm90byA9ICguLi5vYmpzKSA9PiB7XG4gICAgaWYgKG9ianMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBjb21tb25Qcm90byA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm90b0NoYWlucyA9IG9ianMubWFwKG9iaiA9PiBwcm90b0NoYWluKG9iaikpO1xuICAgIHdoaWxlIChwcm90b0NoYWlucy5ldmVyeShwcm90b0NoYWluID0+IHByb3RvQ2hhaW4ubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgY29uc3QgcHJvdG9zID0gcHJvdG9DaGFpbnMubWFwKHByb3RvQ2hhaW4gPT4gcHJvdG9DaGFpbi5wb3AoKSk7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbENvbW1vblByb3RvID0gcHJvdG9zWzBdO1xuICAgICAgICBpZiAocHJvdG9zLmV2ZXJ5KHByb3RvID0+IHByb3RvID09PSBwb3RlbnRpYWxDb21tb25Qcm90bykpXG4gICAgICAgICAgICBjb21tb25Qcm90byA9IHBvdGVudGlhbENvbW1vblByb3RvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vblByb3RvO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwcm90b3R5cGUgb2JqZWN0IHRoYXQgaXMgYSBtaXh0dXJlIG9mIHRoZSBnaXZlbiBwcm90b3R5cGVzLiAgVGhlIG1peGluZyBpcyBhY2hpZXZlZCBieSBmaXJzdFxuICogaWRlbnRpZnlpbmcgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGFuZCB1c2luZyBpdCBhcyB0aGUgcHJvdG90eXBlIGZvciBhIG5ldyBvYmplY3QuICBUaGVuIGFsbCBwcm9wZXJ0aWVzL21ldGhvZHNcbiAqIGRvd25zdHJlYW0gb2YgdGhpcyBwcm90b3R5cGUgKE9OTFkgZG93bnN0cmVhbSkgYXJlIGNvcGllZCBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuICpcbiAqIFRoZSByZXN1bHRpbmcgcHJvdG90eXBlIGlzIG1vcmUgcGVyZm9ybWFudCB0aGFuIHNvZnRNaXhQcm90b3MoLi4uKSwgYXMgd2VsbCBhcyBFUzUgY29tcGF0aWJsZS4gIEhvd2V2ZXIsIGl0J3Mgbm90IGFzXG4gKiBmbGV4aWJsZSBhcyB1cGRhdGVzIHRvIHRoZSBzb3VyY2UgcHJvdG90eXBlcyBhcmVuJ3QgY2FwdHVyZWQgYnkgdGhlIG1peGVkIHJlc3VsdC4gIFNlZSBzb2Z0TWl4UHJvdG9zIGZvciB3aHkgeW91IG1heVxuICogd2FudCB0byB1c2UgdGhhdCBpbnN0ZWFkLlxuICovXG5jb25zdCBoYXJkTWl4UHJvdG9zID0gKGluZ3JlZGllbnRzLCBjb25zdHJ1Y3RvciwgZXhjbHVkZSA9IFtdKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGJhc2UgPSAoX2EgPSBuZWFyZXN0Q29tbW9uUHJvdG8oLi4uaW5ncmVkaWVudHMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBPYmplY3QucHJvdG90eXBlO1xuICAgIGNvbnN0IG1peGVkUHJvdG8gPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIC8vIEtlZXBzIHRyYWNrIG9mIHByb3RvdHlwZXMgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRvIGF2b2lkIGNvcHlpbmcgdGhlIHNhbWUgcHJvcGVydGllcyBtdWx0aXBsZSB0aW1lcy4gIFdlIGluaXQgdGhlXG4gICAgLy8gbGlzdCB3aXRoIHRoZSBwcm90byBjaGFpbiBiZWxvdyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGFueSBvZiB0aG9zZSBtZXRob2RzIG1peGVkIGluXG4gICAgLy8gd2hlbiB0aGV5IHdpbGwgYWxyZWFkeSBiZSBhY2Nlc3NpYmxlIHZpYSBwcm90b3R5cGUgYWNjZXNzLlxuICAgIGNvbnN0IHZpc2l0ZWRQcm90b3MgPSBwcm90b0NoYWluKGJhc2UpO1xuICAgIGZvciAobGV0IHByb3RvdHlwZSBvZiBpbmdyZWRpZW50cykge1xuICAgICAgICBsZXQgcHJvdG9zID0gcHJvdG9DaGFpbihwcm90b3R5cGUpO1xuICAgICAgICAvLyBBcHBseSB0aGUgcHJvdG90eXBlIGNoYWluIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCBvbGQgbWV0aG9kcyBkb24ndCBvdmVycmlkZSBuZXdlciBvbmVzLlxuICAgICAgICBmb3IgKGxldCBpID0gcHJvdG9zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbmV3UHJvdG8gPSBwcm90b3NbaV07XG4gICAgICAgICAgICBpZiAodmlzaXRlZFByb3Rvcy5pbmRleE9mKG5ld1Byb3RvKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb3B5UHJvcHMobWl4ZWRQcm90bywgbmV3UHJvdG8sIFsnY29uc3RydWN0b3InLCAuLi5leGNsdWRlXSk7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFByb3Rvcy5wdXNoKG5ld1Byb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtaXhlZFByb3RvLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG1peGVkUHJvdG87XG59O1xuY29uc3QgdW5pcXVlID0gKGFycikgPT4gYXJyLmZpbHRlcigoZSwgaSkgPT4gYXJyLmluZGV4T2YoZSkgPT0gaSk7XG5cbi8qKlxuICogRmluZHMgdGhlIGluZ3JlZGllbnQgd2l0aCB0aGUgZ2l2ZW4gcHJvcCwgc2VhcmNoaW5nIGluIHJldmVyc2Ugb3JkZXIgYW5kIGJyZWFkdGgtZmlyc3QgaWYgc2VhcmNoaW5nIGluZ3JlZGllbnRcbiAqIHByb3RvdHlwZXMgaXMgcmVxdWlyZWQuXG4gKi9cbmNvbnN0IGdldEluZ3JlZGllbnRXaXRoUHJvcCA9IChwcm9wLCBpbmdyZWRpZW50cykgPT4ge1xuICAgIGNvbnN0IHByb3RvQ2hhaW5zID0gaW5ncmVkaWVudHMubWFwKGluZ3JlZGllbnQgPT4gcHJvdG9DaGFpbihpbmdyZWRpZW50KSk7XG4gICAgLy8gc2luY2Ugd2Ugc2VhcmNoIGJyZWFkdGgtZmlyc3QsIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBvdXIgZGVwdGggaW4gdGhlIHByb3RvdHlwZSBjaGFpbnNcbiAgICBsZXQgcHJvdG9EZXB0aCA9IDA7XG4gICAgLy8gbm90IGFsbCBwcm90b3R5cGUgY2hhaW5zIGFyZSB0aGUgc2FtZSBkZXB0aCwgc28gdGhpcyByZW1haW5zIHRydWUgYXMgbG9uZyBhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGluZ3JlZGllbnRzJ1xuICAgIC8vIHByb3RvdHlwZSBjaGFpbnMgaGFzIGFuIG9iamVjdCBhdCB0aGlzIGRlcHRoXG4gICAgbGV0IHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IHRydWU7XG4gICAgd2hpbGUgKHByb3Rvc0FyZUxlZnRUb1NlYXJjaCkge1xuICAgICAgICAvLyB3aXRoIHRoZSBzdGFydCBvZiBlYWNoIGhvcml6b250YWwgc2xpY2UsIHdlIGFzc3VtZSB0aGlzIGlzIHRoZSBvbmUgdGhhdCdzIGRlZXBlciB0aGFuIGFueSBvZiB0aGUgcHJvdG8gY2hhaW5zXG4gICAgICAgIHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IGZhbHNlO1xuICAgICAgICAvLyBzY2FuIHRocm91Z2ggdGhlIGluZ3JlZGllbnRzIHJpZ2h0IHRvIGxlZnRcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZ3JlZGllbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hUYXJnZXQgPSBwcm90b0NoYWluc1tpXVtwcm90b0RlcHRoXTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hUYXJnZXQgIT09IHVuZGVmaW5lZCAmJiBzZWFyY2hUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIHNvbWV0aGluZywgdGhpcyBpcyBwcm9vZiB0aGF0IHRoaXMgaG9yaXpvbnRhbCBzbGljZSBwb3RlbnRpYWxseSBtb3JlIG9iamVjdHMgdG8gc2VhcmNoXG4gICAgICAgICAgICAgICAgcHJvdG9zQXJlTGVmdFRvU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBldXJla2EsIHdlIGZvdW5kIGl0XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VhcmNoVGFyZ2V0LCBwcm9wKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvQ2hhaW5zW2ldWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm90b0RlcHRoKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLyoqXG4gKiBcIk1peGVzXCIgaW5ncmVkaWVudHMgYnkgd3JhcHBpbmcgdGhlbSBpbiBhIFByb3h5LiAgVGhlIG9wdGlvbmFsIHByb3RvdHlwZSBhcmd1bWVudCBhbGxvd3MgdGhlIG1peGVkIG9iamVjdCB0byBzaXRcbiAqIGRvd25zdHJlYW0gb2YgYW4gZXhpc3RpbmcgcHJvdG90eXBlIGNoYWluLiAgTm90ZSB0aGF0IFwicHJvcGVydGllc1wiIGNhbm5vdCBiZSBhZGRlZCwgZGVsZXRlZCwgb3IgbW9kaWZpZWQuXG4gKi9cbmNvbnN0IHByb3h5TWl4ID0gKGluZ3JlZGllbnRzLCBwcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlKSA9PiBuZXcgUHJveHkoe30sIHtcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZTtcbiAgICB9LFxuICAgIHNldFByb3RvdHlwZU9mKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHNldCBwcm90b3R5cGUgb2YgUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXywgcHJvcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpIHx8IHt9LCBwcm9wKTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWZpbmUgbmV3IHByb3BlcnRpZXMgb24gUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBoYXMoXywgcHJvcCkge1xuICAgICAgICByZXR1cm4gZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKSAhPT0gdW5kZWZpbmVkIHx8IHByb3RvdHlwZVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZ2V0KF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIChnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpIHx8IHByb3RvdHlwZSlbcHJvcF07XG4gICAgfSxcbiAgICBzZXQoXywgcHJvcCwgdmFsKSB7XG4gICAgICAgIGNvbnN0IGluZ3JlZGllbnRXaXRoUHJvcCA9IGdldEluZ3JlZGllbnRXaXRoUHJvcChwcm9wLCBpbmdyZWRpZW50cyk7XG4gICAgICAgIGlmIChpbmdyZWRpZW50V2l0aFByb3AgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBuZXcgcHJvcGVydGllcyBvbiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICAgICAgaW5ncmVkaWVudFdpdGhQcm9wW3Byb3BdID0gdmFsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWxldGUgcHJvcGVydGllcyBvbiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICAgIHJldHVybiBpbmdyZWRpZW50c1xuICAgICAgICAgICAgLm1hcChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcylcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IGN1cnIuY29uY2F0KHByZXYuZmlsdGVyKGtleSA9PiBjdXJyLmluZGV4T2Yoa2V5KSA8IDApKSk7XG4gICAgfSxcbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHByb3h5LXByb3RvdHlwZSBvYmplY3QgdGhhdCBpcyBhIFwic29mdFwiIG1peHR1cmUgb2YgdGhlIGdpdmVuIHByb3RvdHlwZXMuICBUaGUgbWl4aW5nIGlzIGFjaGlldmVkIGJ5XG4gKiBwcm94eWluZyBhbGwgcHJvcGVydHkgYWNjZXNzIHRvIHRoZSBpbmdyZWRpZW50cy4gIFRoaXMgaXMgbm90IEVTNSBjb21wYXRpYmxlIGFuZCBsZXNzIHBlcmZvcm1hbnQuICBIb3dldmVyLCBhbnlcbiAqIGNoYW5nZXMgbWFkZSB0byB0aGUgc291cmNlIHByb3RvdHlwZXMgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlIHByb3h5LXByb3RvdHlwZSwgd2hpY2ggbWF5IGJlIGRlc2lyYWJsZS5cbiAqL1xuY29uc3Qgc29mdE1peFByb3RvcyA9IChpbmdyZWRpZW50cywgY29uc3RydWN0b3IpID0+IHByb3h5TWl4KFsuLi5pbmdyZWRpZW50cywgeyBjb25zdHJ1Y3RvciB9XSk7XG5cbmNvbnN0IHNldHRpbmdzID0ge1xuICAgIGluaXRGdW5jdGlvbjogbnVsbCxcbiAgICBzdGF0aWNzU3RyYXRlZ3k6ICdjb3B5JyxcbiAgICBwcm90b3R5cGVTdHJhdGVneTogJ2NvcHknLFxuICAgIGRlY29yYXRvckluaGVyaXRhbmNlOiAnZGVlcCcsXG59O1xuXG4vLyBLZWVwcyB0cmFjayBvZiBjb25zdGl0dWVudCBjbGFzc2VzIGZvciBldmVyeSBtaXhpbiBjbGFzcyBjcmVhdGVkIGJ5IHRzLW1peGVyLlxuY29uc3QgbWl4aW5zID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldE1peGluc0ZvckNsYXNzID0gKGNsYXp6KSA9PiBtaXhpbnMuZ2V0KGNsYXp6KTtcbmNvbnN0IHJlZ2lzdGVyTWl4aW5zID0gKG1peGVkQ2xhc3MsIGNvbnN0aXR1ZW50cykgPT4gbWl4aW5zLnNldChtaXhlZENsYXNzLCBjb25zdGl0dWVudHMpO1xuY29uc3QgaGFzTWl4aW4gPSAoaW5zdGFuY2UsIG1peGluKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgbWl4aW4pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZnJvbnRpZXIgPSBuZXcgU2V0KCk7XG4gICAgZnJvbnRpZXIuYWRkKGNvbnN0cnVjdG9yKTtcbiAgICB3aGlsZSAoZnJvbnRpZXIuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyb250aWVyIGhhcyB0aGUgbWl4aW4gd2UncmUgbG9va2luZyBmb3IuICBpZiBub3QsIHdlIGNhbiBzYXkgd2UgdmlzaXRlZCBldmVyeSBpdGVtIGluIHRoZSBmcm9udGllclxuICAgICAgICBpZiAoZnJvbnRpZXIuaGFzKG1peGluKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmcm9udGllci5mb3JFYWNoKChpdGVtKSA9PiB2aXNpdGVkLmFkZChpdGVtKSk7XG4gICAgICAgIC8vIGJ1aWxkIGEgbmV3IGZyb250aWVyIGJhc2VkIG9uIHRoZSBhc3NvY2lhdGVkIG1peGluIGNsYXNzZXMgYW5kIHByb3RvdHlwZSBjaGFpbnMgb2YgZWFjaCBmcm9udGllciBpdGVtXG4gICAgICAgIGNvbnN0IG5ld0Zyb250aWVyID0gbmV3IFNldCgpO1xuICAgICAgICBmcm9udGllci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBpdGVtQ29uc3RpdHVlbnRzID0gKF9hID0gbWl4aW5zLmdldChpdGVtKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvdG9DaGFpbihpdGVtLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICAubWFwKChwcm90bykgPT4gcHJvdG8uY29uc3RydWN0b3IpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoaXRlbUNvbnN0aXR1ZW50cylcbiAgICAgICAgICAgICAgICBpdGVtQ29uc3RpdHVlbnRzLmZvckVhY2goKGNvbnN0aXR1ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoY29uc3RpdHVlbnQpICYmICFmcm9udGllci5oYXMoY29uc3RpdHVlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RnJvbnRpZXIuYWRkKGNvbnN0aXR1ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdlIGhhdmUgYSBuZXcgZnJvbnRpZXIsIG5vdyBzZWFyY2ggYWdhaW5cbiAgICAgICAgZnJvbnRpZXIgPSBuZXdGcm9udGllcjtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ2V0IGhlcmUsIHdlIGNvdWxkbid0IGZpbmQgdGhlIG1peGluIGFueXdoZXJlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb3IgYXNzb2NpYXRlZCBtaXhpbiBjbGFzc2VzXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzID0gKG8xLCBvMikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYWxsS2V5cyA9IHVuaXF1ZShbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobzEpLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvMildKTtcbiAgICBjb25zdCBtZXJnZWRPYmplY3QgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYWxsS2V5cylcbiAgICAgICAgbWVyZ2VkT2JqZWN0W2tleV0gPSB1bmlxdWUoWy4uLigoX2EgPSBvMSA9PT0gbnVsbCB8fCBvMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbzFba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLCAuLi4oKF9iID0gbzIgPT09IG51bGwgfHwgbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8yW2tleV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKV0pO1xuICAgIHJldHVybiBtZXJnZWRPYmplY3Q7XG59O1xuY29uc3QgbWVyZ2VQcm9wZXJ0eUFuZE1ldGhvZERlY29yYXRvcnMgPSAoZDEsIGQyKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiAoe1xuICAgICAgICBwcm9wZXJ0eTogbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzKChfYSA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5wcm9wZXJ0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIChfYiA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5wcm9wZXJ0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLFxuICAgICAgICBtZXRob2Q6IG1lcmdlT2JqZWN0c09mRGVjb3JhdG9ycygoX2MgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEubWV0aG9kKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSwgKF9kID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLm1ldGhvZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30pLFxuICAgIH0pO1xufTtcbmNvbnN0IG1lcmdlRGVjb3JhdG9ycyA9IChkMSwgZDIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICByZXR1cm4gKHtcbiAgICAgICAgY2xhc3M6IHVuaXF1ZShbLi4uKF9hID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLmNsYXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgLi4uKF9iID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLmNsYXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXV0pLFxuICAgICAgICBzdGF0aWM6IG1lcmdlUHJvcGVydHlBbmRNZXRob2REZWNvcmF0b3JzKChfYyA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5zdGF0aWMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCAoX2QgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuc3RhdGljKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSksXG4gICAgICAgIGluc3RhbmNlOiBtZXJnZVByb3BlcnR5QW5kTWV0aG9kRGVjb3JhdG9ycygoX2UgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEuaW5zdGFuY2UpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHt9LCAoX2YgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuaW5zdGFuY2UpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHt9KSxcbiAgICB9KTtcbn07XG5jb25zdCBkZWNvcmF0b3JzID0gbmV3IE1hcCgpO1xuY29uc3QgZmluZEFsbENvbnN0aXR1ZW50Q2xhc3NlcyA9ICguLi5jbGFzc2VzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZnJvbnRpZXIgPSBuZXcgU2V0KFsuLi5jbGFzc2VzXSk7XG4gICAgd2hpbGUgKGZyb250aWVyLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGNsYXp6IG9mIGZyb250aWVyKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90b0NoYWluQ2xhc3NlcyA9IHByb3RvQ2hhaW4oY2xhenoucHJvdG90eXBlKS5tYXAocHJvdG8gPT4gcHJvdG8uY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgbWl4aW5DbGFzc2VzID0gKF9hID0gZ2V0TWl4aW5zRm9yQ2xhc3MoY2xhenopKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbGx5TmV3Q2xhc3NlcyA9IFsuLi5wcm90b0NoYWluQ2xhc3NlcywgLi4ubWl4aW5DbGFzc2VzXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBwb3RlbnRpYWxseU5ld0NsYXNzZXMuZmlsdGVyKGMgPT4gIWFsbENsYXNzZXMuaGFzKGMpKTtcbiAgICAgICAgICAgIGZvciAobGV0IG5ld0NsYXNzIG9mIG5ld0NsYXNzZXMpXG4gICAgICAgICAgICAgICAgZnJvbnRpZXIuYWRkKG5ld0NsYXNzKTtcbiAgICAgICAgICAgIGFsbENsYXNzZXMuYWRkKGNsYXp6KTtcbiAgICAgICAgICAgIGZyb250aWVyLmRlbGV0ZShjbGF6eik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5hbGxDbGFzc2VzXTtcbn07XG5jb25zdCBkZWVwRGVjb3JhdG9yU2VhcmNoID0gKC4uLmNsYXNzZXMpID0+IHtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbiA9IGZpbmRBbGxDb25zdGl0dWVudENsYXNzZXMoLi4uY2xhc3NlcylcbiAgICAgICAgLm1hcChjbGF6eiA9PiBkZWNvcmF0b3JzLmdldChjbGF6eikpXG4gICAgICAgIC5maWx0ZXIoZGVjb3JhdG9ycyA9PiAhIWRlY29yYXRvcnMpO1xuICAgIGlmIChkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGRlY29yYXRvcnNGb3JDbGFzc0NoYWluWzBdO1xuICAgIHJldHVybiBkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5yZWR1Y2UoKGQxLCBkMikgPT4gbWVyZ2VEZWNvcmF0b3JzKGQxLCBkMikpO1xufTtcbmNvbnN0IGRpcmVjdERlY29yYXRvclNlYXJjaCA9ICguLi5jbGFzc2VzKSA9PiB7XG4gICAgY29uc3QgY2xhc3NEZWNvcmF0b3JzID0gY2xhc3Nlcy5tYXAoY2xhenogPT4gZ2V0RGVjb3JhdG9yc0ZvckNsYXNzKGNsYXp6KSk7XG4gICAgaWYgKGNsYXNzRGVjb3JhdG9ycy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoY2xhc3NEZWNvcmF0b3JzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGNsYXNzRGVjb3JhdG9yc1swXTtcbiAgICByZXR1cm4gY2xhc3NEZWNvcmF0b3JzLnJlZHVjZSgoZDEsIGQyKSA9PiBtZXJnZURlY29yYXRvcnMoZDEsIGQyKSk7XG59O1xuY29uc3QgZ2V0RGVjb3JhdG9yc0ZvckNsYXNzID0gKGNsYXp6KSA9PiB7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JDbGFzcyA9IGRlY29yYXRvcnMuZ2V0KGNsYXp6KTtcbiAgICBpZiAoIWRlY29yYXRvcnNGb3JDbGFzcykge1xuICAgICAgICBkZWNvcmF0b3JzRm9yQ2xhc3MgPSB7fTtcbiAgICAgICAgZGVjb3JhdG9ycy5zZXQoY2xhenosIGRlY29yYXRvcnNGb3JDbGFzcyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0b3JzRm9yQ2xhc3M7XG59O1xuY29uc3QgZGVjb3JhdGVDbGFzcyA9IChkZWNvcmF0b3IpID0+ICgoY2xhenopID0+IHtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3MgPSBnZXREZWNvcmF0b3JzRm9yQ2xhc3MoY2xhenopO1xuICAgIGxldCBjbGFzc0RlY29yYXRvcnMgPSBkZWNvcmF0b3JzRm9yQ2xhc3MuY2xhc3M7XG4gICAgaWYgKCFjbGFzc0RlY29yYXRvcnMpIHtcbiAgICAgICAgY2xhc3NEZWNvcmF0b3JzID0gW107XG4gICAgICAgIGRlY29yYXRvcnNGb3JDbGFzcy5jbGFzcyA9IGNsYXNzRGVjb3JhdG9ycztcbiAgICB9XG4gICAgY2xhc3NEZWNvcmF0b3JzLnB1c2goZGVjb3JhdG9yKTtcbiAgICByZXR1cm4gZGVjb3JhdG9yKGNsYXp6KTtcbn0pO1xuY29uc3QgZGVjb3JhdGVNZW1iZXIgPSAoZGVjb3JhdG9yKSA9PiAoKG9iamVjdCwga2V5LCAuLi5vdGhlckFyZ3MpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBkZWNvcmF0b3JUYXJnZXRUeXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJyA/ICdzdGF0aWMnIDogJ2luc3RhbmNlJztcbiAgICBjb25zdCBkZWNvcmF0b3JUeXBlID0gdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nID8gJ21ldGhvZCcgOiAncHJvcGVydHknO1xuICAgIGNvbnN0IGNsYXp6ID0gZGVjb3JhdG9yVGFyZ2V0VHlwZSA9PT0gJ3N0YXRpYycgPyBvYmplY3QgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgY29uc3QgZGVjb3JhdG9yc0ZvckNsYXNzID0gZ2V0RGVjb3JhdG9yc0ZvckNsYXNzKGNsYXp6KTtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSA9IChfYSA9IGRlY29yYXRvcnNGb3JDbGFzcyA9PT0gbnVsbCB8fCBkZWNvcmF0b3JzRm9yQ2xhc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JDbGFzc1tkZWNvcmF0b3JUYXJnZXRUeXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgZGVjb3JhdG9yc0ZvckNsYXNzW2RlY29yYXRvclRhcmdldFR5cGVdID0gZGVjb3JhdG9yc0ZvclRhcmdldFR5cGU7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JUeXBlID0gKF9iID0gZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUgPT09IG51bGwgfHwgZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlW2RlY29yYXRvclR5cGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZVtkZWNvcmF0b3JUeXBlXSA9IGRlY29yYXRvcnNGb3JUeXBlO1xuICAgIGxldCBkZWNvcmF0b3JzRm9yS2V5ID0gKF9jID0gZGVjb3JhdG9yc0ZvclR5cGUgPT09IG51bGwgfHwgZGVjb3JhdG9yc0ZvclR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JUeXBlW2tleV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgIGRlY29yYXRvcnNGb3JUeXBlW2tleV0gPSBkZWNvcmF0b3JzRm9yS2V5O1xuICAgIC8vIEB0cy1pZ25vcmU6IGFycmF5IGlzIHR5cGUgYEFbXSB8IEJbXWAgYW5kIGl0ZW0gaXMgdHlwZSBgQSB8IEJgLCBzbyB0ZWNobmljYWxseSBhIHR5cGUgZXJyb3IsIGJ1dCBpdCdzIGZpbmVcbiAgICBkZWNvcmF0b3JzRm9yS2V5LnB1c2goZGVjb3JhdG9yKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGRlY29yYXRvcihvYmplY3QsIGtleSwgLi4ub3RoZXJBcmdzKTtcbn0pO1xuY29uc3QgZGVjb3JhdGUgPSAoZGVjb3JhdG9yKSA9PiAoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBkZWNvcmF0ZUNsYXNzKGRlY29yYXRvcikoYXJnc1swXSk7XG4gICAgcmV0dXJuIGRlY29yYXRlTWVtYmVyKGRlY29yYXRvcikoLi4uYXJncyk7XG59KTtcblxuZnVuY3Rpb24gTWl4aW4oLi4uY29uc3RydWN0b3JzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgcHJvdG90eXBlcyA9IGNvbnN0cnVjdG9ycy5tYXAoY29uc3RydWN0b3IgPT4gY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAvLyBIZXJlIHdlIGdhdGhlciB1cCB0aGUgaW5pdCBmdW5jdGlvbnMgb2YgdGhlIGluZ3JlZGllbnQgcHJvdG90eXBlcywgY29tYmluZSB0aGVtIGludG8gb25lIGluaXQgZnVuY3Rpb24sIGFuZFxuICAgIC8vIGF0dGFjaCBpdCB0byB0aGUgbWl4ZWQgY2xhc3MgcHJvdG90eXBlLiAgVGhlIHJlYXNvbiB3ZSBkbyB0aGlzIGlzIGJlY2F1c2Ugd2Ugd2FudCB0aGUgaW5pdCBmdW5jdGlvbnMgdG8gbWl4XG4gICAgLy8gc2ltaWxhcmx5IHRvIGNvbnN0cnVjdG9ycyAtLSBub3QgbWV0aG9kcywgd2hpY2ggc2ltcGx5IG92ZXJyaWRlIGVhY2ggb3RoZXIuXG4gICAgY29uc3QgaW5pdEZ1bmN0aW9uTmFtZSA9IHNldHRpbmdzLmluaXRGdW5jdGlvbjtcbiAgICBpZiAoaW5pdEZ1bmN0aW9uTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpbml0RnVuY3Rpb25zID0gcHJvdG90eXBlc1xuICAgICAgICAgICAgLm1hcChwcm90byA9PiBwcm90b1tpbml0RnVuY3Rpb25OYW1lXSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuYyA9PiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkSW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGluaXRGdW5jdGlvbiBvZiBpbml0RnVuY3Rpb25zKVxuICAgICAgICAgICAgICAgIGluaXRGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXh0cmFQcm90byA9IHsgW2luaXRGdW5jdGlvbk5hbWVdOiBjb21iaW5lZEluaXRGdW5jdGlvbiB9O1xuICAgICAgICBwcm90b3R5cGVzLnB1c2goZXh0cmFQcm90byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1peGVkQ2xhc3MoLi4uYXJncykge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnN0cnVjdG9yIG9mIGNvbnN0cnVjdG9ycylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IHBvdGVudGlhbGx5IGFic3RyYWN0IGNsYXNzXG4gICAgICAgICAgICBjb3B5UHJvcHModGhpcywgbmV3IGNvbnN0cnVjdG9yKC4uLmFyZ3MpKTtcbiAgICAgICAgaWYgKGluaXRGdW5jdGlvbk5hbWUgIT09IG51bGwgJiYgdHlwZW9mIHRoaXNbaW5pdEZ1bmN0aW9uTmFtZV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aGlzW2luaXRGdW5jdGlvbk5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBNaXhlZENsYXNzLnByb3RvdHlwZSA9IHNldHRpbmdzLnByb3RvdHlwZVN0cmF0ZWd5ID09PSAnY29weSdcbiAgICAgICAgPyBoYXJkTWl4UHJvdG9zKHByb3RvdHlwZXMsIE1peGVkQ2xhc3MpXG4gICAgICAgIDogc29mdE1peFByb3Rvcyhwcm90b3R5cGVzLCBNaXhlZENsYXNzKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoTWl4ZWRDbGFzcywgc2V0dGluZ3Muc3RhdGljc1N0cmF0ZWd5ID09PSAnY29weSdcbiAgICAgICAgPyBoYXJkTWl4UHJvdG9zKGNvbnN0cnVjdG9ycywgbnVsbCwgWydwcm90b3R5cGUnXSlcbiAgICAgICAgOiBwcm94eU1peChjb25zdHJ1Y3RvcnMsIEZ1bmN0aW9uLnByb3RvdHlwZSkpO1xuICAgIGxldCBEZWNvcmF0ZWRNaXhlZENsYXNzID0gTWl4ZWRDbGFzcztcbiAgICBpZiAoc2V0dGluZ3MuZGVjb3JhdG9ySW5oZXJpdGFuY2UgIT09ICdub25lJykge1xuICAgICAgICBjb25zdCBjbGFzc0RlY29yYXRvcnMgPSBzZXR0aW5ncy5kZWNvcmF0b3JJbmhlcml0YW5jZSA9PT0gJ2RlZXAnXG4gICAgICAgICAgICA/IGRlZXBEZWNvcmF0b3JTZWFyY2goLi4uY29uc3RydWN0b3JzKVxuICAgICAgICAgICAgOiBkaXJlY3REZWNvcmF0b3JTZWFyY2goLi4uY29uc3RydWN0b3JzKTtcbiAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIChfYSA9IGNsYXNzRGVjb3JhdG9ycyA9PT0gbnVsbCB8fCBjbGFzc0RlY29yYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsYXNzRGVjb3JhdG9ycy5jbGFzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29yYXRvcihEZWNvcmF0ZWRNaXhlZENsYXNzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBEZWNvcmF0ZWRNaXhlZENsYXNzID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMoKF9iID0gY2xhc3NEZWNvcmF0b3JzID09PSBudWxsIHx8IGNsYXNzRGVjb3JhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NEZWNvcmF0b3JzLnN0YXRpYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sIERlY29yYXRlZE1peGVkQ2xhc3MpO1xuICAgICAgICBhcHBseVByb3BBbmRNZXRob2REZWNvcmF0b3JzKChfYyA9IGNsYXNzRGVjb3JhdG9ycyA9PT0gbnVsbCB8fCBjbGFzc0RlY29yYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsYXNzRGVjb3JhdG9ycy5pbnN0YW5jZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIERlY29yYXRlZE1peGVkQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJNaXhpbnMoRGVjb3JhdGVkTWl4ZWRDbGFzcywgY29uc3RydWN0b3JzKTtcbiAgICByZXR1cm4gRGVjb3JhdGVkTWl4ZWRDbGFzcztcbn1cbmNvbnN0IGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMgPSAocHJvcEFuZE1ldGhvZERlY29yYXRvcnMsIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHByb3BEZWNvcmF0b3JzID0gcHJvcEFuZE1ldGhvZERlY29yYXRvcnMucHJvcGVydHk7XG4gICAgY29uc3QgbWV0aG9kRGVjb3JhdG9ycyA9IHByb3BBbmRNZXRob2REZWNvcmF0b3JzLm1ldGhvZDtcbiAgICBpZiAocHJvcERlY29yYXRvcnMpXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBwcm9wRGVjb3JhdG9ycylcbiAgICAgICAgICAgIGZvciAobGV0IGRlY29yYXRvciBvZiBwcm9wRGVjb3JhdG9yc1trZXldKVxuICAgICAgICAgICAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSk7XG4gICAgaWYgKG1ldGhvZERlY29yYXRvcnMpXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBtZXRob2REZWNvcmF0b3JzKVxuICAgICAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIG1ldGhvZERlY29yYXRvcnNba2V5XSlcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpKTtcbn07XG4vKipcbiAqIEEgZGVjb3JhdG9yIHZlcnNpb24gb2YgdGhlIGBNaXhpbmAgZnVuY3Rpb24uICBZb3UnbGwgd2FudCB0byB1c2UgdGhpcyBpbnN0ZWFkIG9mIGBNaXhpbmAgZm9yIG1peGluZyBnZW5lcmljIGNsYXNzZXMuXG4gKi9cbmNvbnN0IG1peCA9ICguLi5pbmdyZWRpZW50cykgPT4gZGVjb3JhdGVkQ2xhc3MgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBtaXhlZENsYXNzID0gTWl4aW4oLi4uaW5ncmVkaWVudHMuY29uY2F0KFtkZWNvcmF0ZWRDbGFzc10pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWl4ZWRDbGFzcywgJ25hbWUnLCB7XG4gICAgICAgIHZhbHVlOiBkZWNvcmF0ZWRDbGFzcy5uYW1lLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1peGVkQ2xhc3M7XG59O1xuXG5leHBvcnQgeyBNaXhpbiwgZGVjb3JhdGUsIGhhc01peGluLCBtaXgsIHNldHRpbmdzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ts-mixer/dist/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/url-join/lib/url-join.js":
/*!***********************************************!*\
  !*** ./node_modules/url-join/lib/url-join.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (name, context, definition) {\n  if ( true && module.exports) module.exports = definition();\n  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  else {}\n})('urljoin', this, function () {\n\n  function normalize (strArray) {\n    var resultArray = [];\n    if (strArray.length === 0) { return ''; }\n\n    if (typeof strArray[0] !== 'string') {\n      throw new TypeError('Url must be a string. Received ' + strArray[0]);\n    }\n\n    // If the first part is a plain protocol, we combine it with the next part.\n    if (strArray[0].match(/^[^/:]+:\\/*$/) && strArray.length > 1) {\n      var first = strArray.shift();\n      strArray[0] = first + strArray[0];\n    }\n\n    // There must be two or three slashes in the file protocol, two slashes in anything else.\n    if (strArray[0].match(/^file:\\/\\/\\//)) {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1:///');\n    } else {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1://');\n    }\n\n    for (var i = 0; i < strArray.length; i++) {\n      var component = strArray[i];\n\n      if (typeof component !== 'string') {\n        throw new TypeError('Url must be a string. Received ' + component);\n      }\n\n      if (component === '') { continue; }\n\n      if (i > 0) {\n        // Removing the starting slashes for each component but the first.\n        component = component.replace(/^[\\/]+/, '');\n      }\n      if (i < strArray.length - 1) {\n        // Removing the ending slashes for each component but the last.\n        component = component.replace(/[\\/]+$/, '');\n      } else {\n        // For the last component we will combine multiple slashes to a single one.\n        component = component.replace(/[\\/]+$/, '/');\n      }\n\n      resultArray.push(component);\n\n    }\n\n    var str = resultArray.join('/');\n    // Each input component is now separated by a single slash except the possible first plain protocol part.\n\n    // remove trailing slash before parameters or hash\n    str = str.replace(/\\/(\\?|&|#[^!])/g, '$1');\n\n    // replace ? in parameters with &\n    var parts = str.split('?');\n    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');\n\n    return str;\n  }\n\n  return function () {\n    var input;\n\n    if (typeof arguments[0] === 'object') {\n      input = arguments[0];\n    } else {\n      input = [].slice.call(arguments);\n    }\n\n    return normalize(input);\n  };\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91cmwtam9pbi9saWIvdXJsLWpvaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNLEtBQTZCO0FBQ25DLFdBQVcsSUFBMEMsRUFBRSxvQ0FBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDekUsT0FBTyxFQUE2QjtBQUNwQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdXJsLWpvaW4vbGliL3VybC1qb2luLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShkZWZpbml0aW9uKTtcbiAgZWxzZSBjb250ZXh0W25hbWVdID0gZGVmaW5pdGlvbigpO1xufSkoJ3VybGpvaW4nLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplIChzdHJBcnJheSkge1xuICAgIHZhciByZXN1bHRBcnJheSA9IFtdO1xuICAgIGlmIChzdHJBcnJheS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG5cbiAgICBpZiAodHlwZW9mIHN0ckFycmF5WzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVXJsIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBzdHJBcnJheVswXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGZpcnN0IHBhcnQgaXMgYSBwbGFpbiBwcm90b2NvbCwgd2UgY29tYmluZSBpdCB3aXRoIHRoZSBuZXh0IHBhcnQuXG4gICAgaWYgKHN0ckFycmF5WzBdLm1hdGNoKC9eW14vOl0rOlxcLyokLykgJiYgc3RyQXJyYXkubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGZpcnN0ID0gc3RyQXJyYXkuc2hpZnQoKTtcbiAgICAgIHN0ckFycmF5WzBdID0gZmlyc3QgKyBzdHJBcnJheVswXTtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSBtdXN0IGJlIHR3byBvciB0aHJlZSBzbGFzaGVzIGluIHRoZSBmaWxlIHByb3RvY29sLCB0d28gc2xhc2hlcyBpbiBhbnl0aGluZyBlbHNlLlxuICAgIGlmIChzdHJBcnJheVswXS5tYXRjaCgvXmZpbGU6XFwvXFwvXFwvLykpIHtcbiAgICAgIHN0ckFycmF5WzBdID0gc3RyQXJyYXlbMF0ucmVwbGFjZSgvXihbXi86XSspOlxcLyovLCAnJDE6Ly8vJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ckFycmF5WzBdID0gc3RyQXJyYXlbMF0ucmVwbGFjZSgvXihbXi86XSspOlxcLyovLCAnJDE6Ly8nKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gc3RyQXJyYXlbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVcmwgbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIGNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQgPT09ICcnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAvLyBSZW1vdmluZyB0aGUgc3RhcnRpbmcgc2xhc2hlcyBmb3IgZWFjaCBjb21wb25lbnQgYnV0IHRoZSBmaXJzdC5cbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoL15bXFwvXSsvLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IHN0ckFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gUmVtb3ZpbmcgdGhlIGVuZGluZyBzbGFzaGVzIGZvciBlYWNoIGNvbXBvbmVudCBidXQgdGhlIGxhc3QuXG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudC5yZXBsYWNlKC9bXFwvXSskLywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIHRoZSBsYXN0IGNvbXBvbmVudCB3ZSB3aWxsIGNvbWJpbmUgbXVsdGlwbGUgc2xhc2hlcyB0byBhIHNpbmdsZSBvbmUuXG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudC5yZXBsYWNlKC9bXFwvXSskLywgJy8nKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0QXJyYXkucHVzaChjb21wb25lbnQpO1xuXG4gICAgfVxuXG4gICAgdmFyIHN0ciA9IHJlc3VsdEFycmF5LmpvaW4oJy8nKTtcbiAgICAvLyBFYWNoIGlucHV0IGNvbXBvbmVudCBpcyBub3cgc2VwYXJhdGVkIGJ5IGEgc2luZ2xlIHNsYXNoIGV4Y2VwdCB0aGUgcG9zc2libGUgZmlyc3QgcGxhaW4gcHJvdG9jb2wgcGFydC5cblxuICAgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaCBiZWZvcmUgcGFyYW1ldGVycyBvciBoYXNoXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcLyhcXD98JnwjW14hXSkvZywgJyQxJyk7XG5cbiAgICAvLyByZXBsYWNlID8gaW4gcGFyYW1ldGVycyB3aXRoICZcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJz8nKTtcbiAgICBzdHIgPSBwYXJ0cy5zaGlmdCgpICsgKHBhcnRzLmxlbmd0aCA+IDAgPyAnPyc6ICcnKSArIHBhcnRzLmpvaW4oJyYnKTtcblxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnB1dDtcblxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5wdXQgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemUoaW5wdXQpO1xuICB9O1xuXG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/url-join/lib/url-join.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"7931afa39cf6\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvc3JjL2FwcC9nbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjc5MzFhZmEzOWNmNlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Providers.jsx":
/*!**************************************!*\
  !*** ./src/components/Providers.jsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Providers: () => (/* binding */ Providers)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _starknet_react_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @starknet-react/chains */ \"(app-pages-browser)/./node_modules/@starknet-react/chains/dist/index.js\");\n/* harmony import */ var _starknet_react_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @starknet-react/core */ \"(app-pages-browser)/./node_modules/@starknet-react/core/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ Providers auto */ \nvar _s = $RefreshSig$();\n/* eslint-disable react/prop-types */ \n\nfunction Providers(param) {\n    let { children } = param;\n    _s();\n    const { connectors } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_2__.useInjectedConnectors)({\n        recommended: [\n            (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_2__.argent)(),\n            (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_2__.braavos)()\n        ],\n        includeRecommended: \"onlyIfNoConnectors\",\n        order: \"random\"\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_starknet_react_core__WEBPACK_IMPORTED_MODULE_2__.StarknetConfig, {\n        chains: [\n            _starknet_react_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia\n        ],\n        provider: (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_2__.jsonRpcProvider)({\n            rpc: ()=>({\n                    nodeUrl: \"https://starknet-sepolia.g.alchemy.com/starknet/version/rpc/v0_7/qlN-xyqi66nfFyKbY9Hnanh7a3MTFvhK\"\n                })\n        }),\n        connectors: connectors,\n        explorer: _starknet_react_core__WEBPACK_IMPORTED_MODULE_2__.voyager,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/wilfrid-k/projects/onlydust/chainevents-frontend/src/components/Providers.jsx\",\n        lineNumber: 21,\n        columnNumber: 5\n    }, this);\n}\n_s(Providers, \"QIZFWVyP7rhWJtKTvwXbbiIUgHo=\", false, function() {\n    return [\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_2__.useInjectedConnectors\n    ];\n});\n_c = Providers;\nvar _c;\n$RefreshReg$(_c, \"Providers\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1Byb3ZpZGVycy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUEsbUNBQW1DLEdBQ2M7QUFRbkI7QUFFdkIsU0FBU08sVUFBVSxLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7O0lBQ3hCLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUdMLDJFQUFxQkEsQ0FBQztRQUMzQ00sYUFBYTtZQUFDUiw0REFBTUE7WUFBSUMsNkRBQU9BO1NBQUc7UUFDbENRLG9CQUFvQjtRQUNwQkMsT0FBTztJQUNUO0lBQ0EscUJBQ0UsOERBQUNYLGdFQUFjQTtRQUNiWSxRQUFRO1lBQUNiLDJEQUFPQTtTQUFDO1FBQ2pCYyxVQUFVVCxxRUFBZUEsQ0FBQztZQUN4QlUsS0FBSyxJQUFPO29CQUFFQyxTQUFTQyxtR0FBK0I7Z0JBQUM7UUFDekQ7UUFDQVIsWUFBWUE7UUFDWlcsVUFBVWQseURBQU9BO2tCQUVoQkU7Ozs7OztBQUdQO0dBbEJnQkQ7O1FBQ1NILHVFQUFxQkE7OztLQUQ5QkciLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9zcmMvY29tcG9uZW50cy9Qcm92aWRlcnMuanN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG5pbXBvcnQgeyBzZXBvbGlhIH0gZnJvbSBcIkBzdGFya25ldC1yZWFjdC9jaGFpbnNcIjtcbmltcG9ydCB7XG4gIFN0YXJrbmV0Q29uZmlnLFxuICBhcmdlbnQsXG4gIGJyYWF2b3MsXG4gIHVzZUluamVjdGVkQ29ubmVjdG9ycyxcbiAganNvblJwY1Byb3ZpZGVyLFxuICB2b3lhZ2VyLFxufSBmcm9tIFwiQHN0YXJrbmV0LXJlYWN0L2NvcmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVycyh7IGNoaWxkcmVuIH0pIHtcbiAgY29uc3QgeyBjb25uZWN0b3JzIH0gPSB1c2VJbmplY3RlZENvbm5lY3RvcnMoe1xuICAgIHJlY29tbWVuZGVkOiBbYXJnZW50KCksIGJyYWF2b3MoKV0sXG4gICAgaW5jbHVkZVJlY29tbWVuZGVkOiBcIm9ubHlJZk5vQ29ubmVjdG9yc1wiLFxuICAgIG9yZGVyOiBcInJhbmRvbVwiLFxuICB9KTtcbiAgcmV0dXJuIChcbiAgICA8U3RhcmtuZXRDb25maWdcbiAgICAgIGNoYWlucz17W3NlcG9saWFdfVxuICAgICAgcHJvdmlkZXI9e2pzb25ScGNQcm92aWRlcih7XG4gICAgICAgIHJwYzogKCkgPT4gKHsgbm9kZVVybDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUlBDX1VSTCB9KSxcbiAgICAgIH0pfVxuICAgICAgY29ubmVjdG9ycz17Y29ubmVjdG9yc31cbiAgICAgIGV4cGxvcmVyPXt2b3lhZ2VyfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1N0YXJrbmV0Q29uZmlnPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInNlcG9saWEiLCJTdGFya25ldENvbmZpZyIsImFyZ2VudCIsImJyYWF2b3MiLCJ1c2VJbmplY3RlZENvbm5lY3RvcnMiLCJqc29uUnBjUHJvdmlkZXIiLCJ2b3lhZ2VyIiwiUHJvdmlkZXJzIiwiY2hpbGRyZW4iLCJjb25uZWN0b3JzIiwicmVjb21tZW5kZWQiLCJpbmNsdWRlUmVjb21tZW5kZWQiLCJvcmRlciIsImNoYWlucyIsInByb3ZpZGVyIiwicnBjIiwibm9kZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19SUENfVVJMIiwiZXhwbG9yZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Providers.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.jsx\",\"import\":\"Geist\",\"arguments\":[{\"variable\":\"--font-geist-sans\",\"subsets\":[\"latin\"]}],\"variableName\":\"geistSans\"}":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"src/app/layout.jsx","import":"Geist","arguments":[{"variable":"--font-geist-sans","subsets":["latin"]}],"variableName":"geistSans"} ***!
  \***********************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Geist', 'Geist Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_4d318d\",\"variable\":\"__variable_4d318d\"};\n    if(true) {\n      // 1738344085882\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjL2FwcC9sYXlvdXQuanN4XCIsXCJpbXBvcnRcIjpcIkdlaXN0XCIsXCJhcmd1bWVudHNcIjpbe1widmFyaWFibGVcIjpcIi0tZm9udC1nZWlzdC1zYW5zXCIsXCJzdWJzZXRzXCI6W1wibGF0aW5cIl19XSxcInZhcmlhYmxlTmFtZVwiOlwiZ2Vpc3RTYW5zXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsOERBQThEO0FBQ3pGLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUE0SSxjQUFjLHNEQUFzRDtBQUM5TyxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJzcmMvYXBwL2xheW91dC5qc3hcIixcImltcG9ydFwiOlwiR2Vpc3RcIixcImFyZ3VtZW50c1wiOlt7XCJ2YXJpYWJsZVwiOlwiLS1mb250LWdlaXN0LXNhbnNcIixcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJnZWlzdFNhbnNcIn0iXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ0dlaXN0JywgJ0dlaXN0IEZhbGxiYWNrJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzRkMzE4ZFwiLFwidmFyaWFibGVcIjpcIl9fdmFyaWFibGVfNGQzMThkXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MzgzNDQwODU4ODJcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.jsx\",\"import\":\"Geist\",\"arguments\":[{\"variable\":\"--font-geist-sans\",\"subsets\":[\"latin\"]}],\"variableName\":\"geistSans\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.jsx\",\"import\":\"Geist_Mono\",\"arguments\":[{\"variable\":\"--font-geist-mono\",\"subsets\":[\"latin\"]}],\"variableName\":\"geistMono\"}":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"src/app/layout.jsx","import":"Geist_Mono","arguments":[{"variable":"--font-geist-mono","subsets":["latin"]}],"variableName":"geistMono"} ***!
  \****************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Geist Mono', 'Geist Mono Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_ea5f4b\",\"variable\":\"__variable_ea5f4b\"};\n    if(true) {\n      // 1738344085884\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjL2FwcC9sYXlvdXQuanN4XCIsXCJpbXBvcnRcIjpcIkdlaXN0X01vbm9cIixcImFyZ3VtZW50c1wiOlt7XCJ2YXJpYWJsZVwiOlwiLS1mb250LWdlaXN0LW1vbm9cIixcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJnZWlzdE1vbm9cIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyx3RUFBd0U7QUFDbkcsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQTRJLGNBQWMsc0RBQXNEO0FBQzlPLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcInBhdGhcIjpcInNyYy9hcHAvbGF5b3V0LmpzeFwiLFwiaW1wb3J0XCI6XCJHZWlzdF9Nb25vXCIsXCJhcmd1bWVudHNcIjpbe1widmFyaWFibGVcIjpcIi0tZm9udC1nZWlzdC1tb25vXCIsXCJzdWJzZXRzXCI6W1wibGF0aW5cIl19XSxcInZhcmlhYmxlTmFtZVwiOlwiZ2Vpc3RNb25vXCJ9Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidHZWlzdCBNb25vJywgJ0dlaXN0IE1vbm8gRmFsbGJhY2snXCIsXCJmb250U3R5bGVcIjpcIm5vcm1hbFwifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfZWE1ZjRiXCIsXCJ2YXJpYWJsZVwiOlwiX192YXJpYWJsZV9lYTVmNGJcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTczODM0NDA4NTg4NFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.jsx\",\"import\":\"Geist_Mono\",\"arguments\":[{\"variable\":\"--font-geist-mono\",\"subsets\":[\"latin\"]}],\"variableName\":\"geistMono\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDUDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyx3REFBSSxZQUFZLGdFQUFXO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ087QUFDUCw2QkFBNkIscUVBQVcsR0FBRywrQkFBK0I7QUFDMUUsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNzRDtBQUNWO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWE7QUFDakIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0Y7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQyxJQUFJLGlEQUFNO0FBQ1Y7QUFDQSwyQ0FBMkMsc0RBQVc7QUFDdEQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixnREFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsR0FBRztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFieXRlcywgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFudW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cywgZ290ICR7aX0gaW4gYXJyYXlgKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUoc2NhbGFycykpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLHNEQUFzRDtBQUN0RCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHlEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzREFBc0Q7QUFDN0Q7QUFDQSx5REFBeUQsTUFBTTtBQUMvRCxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxXQUFXO0FBQzFGLDhDQUE4QztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFlLGVBQWUsMERBQWU7QUFDL0U7QUFDQTtBQUNBLDBEQUEwRCxNQUFNLFFBQVEsYUFBYTtBQUNyRiwwQkFBMEIsMERBQWUsVUFBVSwwREFBZTtBQUNsRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU8sNEJBQTRCLFFBQVE7QUFDcEcsdUJBQXVCLDBEQUFlLFNBQVMsMERBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPLDRCQUE0QixJQUFJO0FBQzNFLHVCQUF1QiwwREFBZSxRQUFRLDBEQUFlO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWUsc0JBQXNCLDBEQUFlO0FBQ3RFO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/poseidon.js":
/*!*************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/poseidon.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poseidon: () => (/* binding */ poseidon),\n/* harmony export */   splitConstants: () => (/* binding */ splitConstants),\n/* harmony export */   validateOpts: () => (/* binding */ validateOpts)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Poseidon Hash: https://eprint.iacr.org/2019/458.pdf, https://www.poseidon-hash.info\n\nfunction validateOpts(opts) {\n    const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;\n    const { roundsFull, roundsPartial, sboxPower, t } = opts;\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(Fp);\n    for (const i of ['t', 'roundsFull', 'roundsPartial']) {\n        if (typeof opts[i] !== 'number' || !Number.isSafeInteger(opts[i]))\n            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);\n    }\n    // MDS is TxT matrix\n    if (!Array.isArray(mds) || mds.length !== t)\n        throw new Error('Poseidon: wrong MDS matrix');\n    const _mds = mds.map((mdsRow) => {\n        if (!Array.isArray(mdsRow) || mdsRow.length !== t)\n            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);\n        return mdsRow.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon MDS matrix value=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (rev !== undefined && typeof rev !== 'boolean')\n        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);\n    if (roundsFull % 2 !== 0)\n        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);\n    const rounds = roundsFull + roundsPartial;\n    if (!Array.isArray(rc) || rc.length !== rounds)\n        throw new Error('Poseidon: wrong round constants');\n    const roundConstants = rc.map((rc) => {\n        if (!Array.isArray(rc) || rc.length !== t)\n            throw new Error(`Poseidon wrong round constants: ${rc}`);\n        return rc.map((i) => {\n            if (typeof i !== 'bigint' || !Fp.isValid(i))\n                throw new Error(`Poseidon wrong round constant=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (!sboxPower || ![3, 5, 7].includes(sboxPower))\n        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);\n    const _sboxPower = BigInt(sboxPower);\n    let sboxFn = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow)(Fp, n, _sboxPower);\n    // Unwrapped sbox power for common cases (195->142μs)\n    if (sboxPower === 3)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);\n    else if (sboxPower === 5)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);\n    return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });\n}\nfunction splitConstants(rc, t) {\n    if (typeof t !== 'number')\n        throw new Error('poseidonSplitConstants: wrong t');\n    if (!Array.isArray(rc) || rc.length % t)\n        throw new Error('poseidonSplitConstants: wrong rc');\n    const res = [];\n    let tmp = [];\n    for (let i = 0; i < rc.length; i++) {\n        tmp.push(rc[i]);\n        if (tmp.length === t) {\n            res.push(tmp);\n            tmp = [];\n        }\n    }\n    return res;\n}\nfunction poseidon(opts) {\n    const _opts = validateOpts(opts);\n    const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;\n    const halfRoundsFull = _opts.roundsFull / 2;\n    const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;\n    const poseidonRound = (values, isFull, idx) => {\n        values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));\n        if (isFull)\n            values = values.map((i) => sboxFn(i));\n        else\n            values[partialIdx] = sboxFn(values[partialIdx]);\n        // Matrix multiplication\n        values = mds.map((i) => i.reduce((acc, i, j) => Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));\n        return values;\n    };\n    const poseidonHash = function poseidonHash(values) {\n        if (!Array.isArray(values) || values.length !== t)\n            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);\n        values = values.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);\n            return Fp.create(i);\n        });\n        let round = 0;\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        // Apply r_p partial rounds.\n        for (let i = 0; i < roundsPartial; i++)\n            values = poseidonRound(values, false, round++);\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        if (round !== rounds)\n            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);\n        return values;\n    };\n    // For verification in tests\n    poseidonHash.roundConstants = roundConstants;\n    return poseidonHash;\n}\n//# sourceMappingURL=poseidon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9wb3NlaWRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNvRDtBQUM3QztBQUNQLFlBQVkseURBQXlEO0FBQ3JFLFlBQVksMENBQTBDO0FBQ3RELElBQUksMERBQWE7QUFDakI7QUFDQTtBQUNBLHVEQUF1RCxFQUFFLEdBQUcsU0FBUyxHQUFHLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHdFQUF3RSxJQUFJO0FBQzVFO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxHQUFHO0FBQ2xFO0FBQ0E7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBLHdCQUF3QixrREFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLDREQUE0RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLEVBQUU7QUFDL0Y7QUFDQTtBQUNBLHlEQUF5RCxHQUFHLEdBQUcsU0FBUztBQUN4RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsNEVBQTRFLE1BQU0sVUFBVSxPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3Bvc2VpZG9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFBvc2VpZG9uIEhhc2g6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTkvNDU4LnBkZiwgaHR0cHM6Ly93d3cucG9zZWlkb24taGFzaC5pbmZvXG5pbXBvcnQgeyBGcFBvdywgdmFsaWRhdGVGaWVsZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPcHRzKG9wdHMpIHtcbiAgICBjb25zdCB7IEZwLCBtZHMsIHJldmVyc2VQYXJ0aWFsUG93SWR4OiByZXYsIHJvdW5kQ29uc3RhbnRzOiByYyB9ID0gb3B0cztcbiAgICBjb25zdCB7IHJvdW5kc0Z1bGwsIHJvdW5kc1BhcnRpYWwsIHNib3hQb3dlciwgdCB9ID0gb3B0cztcbiAgICB2YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgWyd0JywgJ3JvdW5kc0Z1bGwnLCAncm91bmRzUGFydGlhbCddKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0c1tpXSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHNbaV0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogaW52YWxpZCBwYXJhbSAke2l9PSR7b3B0c1tpXX0gKCR7dHlwZW9mIG9wdHNbaV19KWApO1xuICAgIH1cbiAgICAvLyBNRFMgaXMgVHhUIG1hdHJpeFxuICAgIGlmICghQXJyYXkuaXNBcnJheShtZHMpIHx8IG1kcy5sZW5ndGggIT09IHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zZWlkb246IHdyb25nIE1EUyBtYXRyaXgnKTtcbiAgICBjb25zdCBfbWRzID0gbWRzLm1hcCgobWRzUm93KSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZHNSb3cpIHx8IG1kc1Jvdy5sZW5ndGggIT09IHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIE1EUyBtYXRyaXggcm93OiAke21kc1Jvd31gKTtcbiAgICAgICAgcmV0dXJuIG1kc1Jvdy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiBNRFMgbWF0cml4IHZhbHVlPSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXYgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmV2ICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IGludmFsaWQgcGFyYW0gcmV2ZXJzZVBhcnRpYWxQb3dJZHg9JHtyZXZ9YCk7XG4gICAgaWYgKHJvdW5kc0Z1bGwgJSAyICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHJvdW5kc0Z1bGwgaXMgbm90IGV2ZW46ICR7cm91bmRzRnVsbH1gKTtcbiAgICBjb25zdCByb3VuZHMgPSByb3VuZHNGdWxsICsgcm91bmRzUGFydGlhbDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmMpIHx8IHJjLmxlbmd0aCAhPT0gcm91bmRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2VpZG9uOiB3cm9uZyByb3VuZCBjb25zdGFudHMnKTtcbiAgICBjb25zdCByb3VuZENvbnN0YW50cyA9IHJjLm1hcCgocmMpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJjKSB8fCByYy5sZW5ndGggIT09IHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHJvdW5kIGNvbnN0YW50czogJHtyY31gKTtcbiAgICAgICAgcmV0dXJuIHJjLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JyB8fCAhRnAuaXNWYWxpZChpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHJvdW5kIGNvbnN0YW50PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghc2JveFBvd2VyIHx8ICFbMywgNSwgN10uaW5jbHVkZXMoc2JveFBvd2VyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiB3cm9uZyBzYm94UG93ZXI9JHtzYm94UG93ZXJ9YCk7XG4gICAgY29uc3QgX3Nib3hQb3dlciA9IEJpZ0ludChzYm94UG93ZXIpO1xuICAgIGxldCBzYm94Rm4gPSAobikgPT4gRnBQb3coRnAsIG4sIF9zYm94UG93ZXIpO1xuICAgIC8vIFVud3JhcHBlZCBzYm94IHBvd2VyIGZvciBjb21tb24gY2FzZXMgKDE5NS0+MTQyzrxzKVxuICAgIGlmIChzYm94UG93ZXIgPT09IDMpXG4gICAgICAgIHNib3hGbiA9IChuKSA9PiBGcC5tdWwoRnAuc3FyTihuKSwgbik7XG4gICAgZWxzZSBpZiAoc2JveFBvd2VyID09PSA1KVxuICAgICAgICBzYm94Rm4gPSAobikgPT4gRnAubXVsKEZwLnNxck4oRnAuc3FyTihuKSksIG4pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cywgcm91bmRzLCBzYm94Rm4sIHJvdW5kQ29uc3RhbnRzLCBtZHM6IF9tZHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRDb25zdGFudHMocmMsIHQpIHtcbiAgICBpZiAodHlwZW9mIHQgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2VpZG9uU3BsaXRDb25zdGFudHM6IHdyb25nIHQnKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmMpIHx8IHJjLmxlbmd0aCAlIHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zZWlkb25TcGxpdENvbnN0YW50czogd3JvbmcgcmMnKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBsZXQgdG1wID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0bXAucHVzaChyY1tpXSk7XG4gICAgICAgIGlmICh0bXAubGVuZ3RoID09PSB0KSB7XG4gICAgICAgICAgICByZXMucHVzaCh0bXApO1xuICAgICAgICAgICAgdG1wID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbihvcHRzKSB7XG4gICAgY29uc3QgX29wdHMgPSB2YWxpZGF0ZU9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCwgbWRzLCByb3VuZENvbnN0YW50cywgcm91bmRzLCByb3VuZHNQYXJ0aWFsLCBzYm94Rm4sIHQgfSA9IF9vcHRzO1xuICAgIGNvbnN0IGhhbGZSb3VuZHNGdWxsID0gX29wdHMucm91bmRzRnVsbCAvIDI7XG4gICAgY29uc3QgcGFydGlhbElkeCA9IF9vcHRzLnJldmVyc2VQYXJ0aWFsUG93SWR4ID8gdCAtIDEgOiAwO1xuICAgIGNvbnN0IHBvc2VpZG9uUm91bmQgPSAodmFsdWVzLCBpc0Z1bGwsIGlkeCkgPT4ge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKChpLCBqKSA9PiBGcC5hZGQoaSwgcm91bmRDb25zdGFudHNbaWR4XVtqXSkpO1xuICAgICAgICBpZiAoaXNGdWxsKVxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSkgPT4gc2JveEZuKGkpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsdWVzW3BhcnRpYWxJZHhdID0gc2JveEZuKHZhbHVlc1twYXJ0aWFsSWR4XSk7XG4gICAgICAgIC8vIE1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgICAgICB2YWx1ZXMgPSBtZHMubWFwKChpKSA9PiBpLnJlZHVjZSgoYWNjLCBpLCBqKSA9PiBGcC5hZGQoYWNjLCBGcC5tdWxOKGksIHZhbHVlc1tqXSkpLCBGcC5aRVJPKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBjb25zdCBwb3NlaWRvbkhhc2ggPSBmdW5jdGlvbiBwb3NlaWRvbkhhc2godmFsdWVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGggIT09IHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiB3cm9uZyB2YWx1ZXMgKGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMgd2l0aCBsZW5ndGggJHt0fSlgKTtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiB3cm9uZyB2YWx1ZT0ke2l9ICgke3R5cGVvZiBpfSlgKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcm91bmQgPSAwO1xuICAgICAgICAvLyBBcHBseSByX2YvMiBmdWxsIHJvdW5kcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmUm91bmRzRnVsbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIHRydWUsIHJvdW5kKyspO1xuICAgICAgICAvLyBBcHBseSByX3AgcGFydGlhbCByb3VuZHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzUGFydGlhbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIGZhbHNlLCByb3VuZCsrKTtcbiAgICAgICAgLy8gQXBwbHkgcl9mLzIgZnVsbCByb3VuZHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFsZlJvdW5kc0Z1bGw7IGkrKylcbiAgICAgICAgICAgIHZhbHVlcyA9IHBvc2VpZG9uUm91bmQodmFsdWVzLCB0cnVlLCByb3VuZCsrKTtcbiAgICAgICAgaWYgKHJvdW5kICE9PSByb3VuZHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiB3cm9uZyBudW1iZXIgb2Ygcm91bmRzOiBsYXN0IHJvdW5kPSR7cm91bmR9LCB0b3RhbD0ke3JvdW5kc31gKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIC8vIEZvciB2ZXJpZmljYXRpb24gaW4gdGVzdHNcbiAgICBwb3NlaWRvbkhhc2gucm91bmRDb25zdGFudHMgPSByb3VuZENvbnN0YW50cztcbiAgICByZXR1cm4gcG9zZWlkb25IYXNoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9zZWlkb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/poseidon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDTztBQUNQO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDaUQ7QUFDYjtBQUNIO0FBQ1E7QUFDekM7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsUUFBUSx3Q0FBd0MsRUFBRSxzQ0FBRTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsUUFBUSw2Q0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLEtBQUssU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQWM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFvRTtBQUNwRjtBQUNBLGdCQUFnQiw4Q0FBVTtBQUMxQixzQkFBc0IsaURBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWtCLENBQUMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLDRCQUE0QixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQSxrQkFBa0IsNENBQU8sVUFBVTtBQUNuQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QywwREFBMEQ7QUFDMUQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLG9CQUFvQix5QkFBeUI7QUFDN0MsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0Msc0JBQXNCLGlCQUFpQjtBQUN2QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBYTtBQUM5QixJQUFJLHFEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDTztBQUNQO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsZUFBZSw0Q0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSwrQ0FBVTtBQUN6QjtBQUNBLFlBQVksMkZBQTJGO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQWtCO0FBQzVDO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsbURBQW1ELEtBQUssd0JBQXdCLGVBQWUsc0JBQXNCLGlCQUFpQjtBQUN0STtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsbUNBQW1DLGlEQUFhLENBQUMsc0RBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0RBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxZQUFZLHNEQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxvQ0FBb0Msc0RBQVcsdUJBQXVCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckMsa0VBQWtFO0FBQ2xFO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBYTtBQUNoQztBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQW9CO0FBQy9DLG1CQUFtQix1REFBa0I7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWtCLFNBQVM7QUFDbkQsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSx1QkFBdUIsOENBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0EsZUFBZSxzREFBa0I7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGNBQWMsbUNBQW1DLFFBQVE7QUFDekQ7QUFDQSx5QkFBeUI7QUFDekIsa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDBCQUEwQixzREFBVyxzQkFBc0I7QUFDM0Q7QUFDQSxxQkFBcUIsa0RBQWMsZUFBZTtBQUNsRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx5REFBeUQ7QUFDekQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLCtCQUErQjtBQUMvQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLG1DQUFtQztBQUNqRTtBQUNBLHFCQUFxQixxREFBaUI7QUFDdEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVztBQUM3QixvQkFBb0Isc0RBQVc7QUFDL0I7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhDQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0Esa0JBQWtCO0FBQ2xCLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLDRDQUE0QztBQUM1QztBQUNBLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0Isd0NBQXdDO0FBQ3hDLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QztBQUNBLHlCQUF5QixTQUFTO0FBQ2xDLCtCQUErQjtBQUMvQixzQ0FBc0M7QUFDdEMseUNBQXlDO0FBQ3pDLDZDQUE2QztBQUM3QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMsMENBQTBDO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx1Q0FBdUM7QUFDdkM7QUFDQSxpQ0FBaUM7QUFDakMsc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMsa0NBQWtDO0FBQ2xDLHVDQUF1QztBQUN2QywrQ0FBK0Msa0JBQWtCO0FBQ2pFLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0MscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxzREFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtRUFBbUU7QUFDbkUsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdCQUFnQixpQkFBaUIsdUJBQXVCO0FBQ3hELDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsc0NBQXNDO0FBQ3RDLHdDQUF3QztBQUN4QyxnREFBZ0Q7QUFDaEQsdUNBQXVDO0FBQ3ZDLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgeyB2YWxpZGF0ZUJhc2ljLCB3TkFGIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZykpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUN3QztBQUNqQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBSyxxQ0FBcUMsZUFBZTtBQUM3RCxrQkFBa0IsNkRBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBTTtBQUMzQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDREQUFNLENBQUMsK0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlO0FBQ3ZDLG9CQUFvQix5REFBRztBQUN2QixvQkFBb0IseURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQVc7QUFDL0QsY0FBYywrREFBVztBQUN6QixZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsY0FBYywrREFBVywwQkFBMEI7QUFDbkQsMkJBQTJCLG1FQUFlLGlDQUFpQztBQUMzRSx3REFBd0Q7QUFDeEQsb0JBQW9CLG1FQUFlLFNBQVM7QUFDNUM7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSx1QkFBdUIsMkJBQTJCO0FBQzlELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFXO0FBQzNCLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLCtEQUFXO0FBQzNCO0FBQ0EseUJBQXlCLG1FQUFlLFFBQVEsd0JBQXdCO0FBQ3hFLGtCQUFrQixtRUFBZSx1QkFBdUIsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWUsd0JBQXdCLDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsc0NBQXNDLHNFQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLHdFQUFZO0FBQy9DLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVDdXJ2ZSB9IGZyb20gJy4vX3Nob3J0d191dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgRmllbGQsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KDcpLCAvLyBTZWVtIHRvIGJlIHJpZ2lkOiBiaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzVcbiAgICBGcCwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLDBEQUEwRCxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLGlFQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBub3QgJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYm9vbGVhbiBleHBlY3RlZCwgbm90ICR7Yn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGguYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmV4cG9ydCBjb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuZXhwb3J0IGNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELHFDQUFxQywyQ0FBRztBQUN4QywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELGlDQUFpQywyQ0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1ELCBDaGksIE1haiB9IGZyb20gJy4vX21kLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZTpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDQztBQUMvQyxZQUFZLFVBQVU7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNUO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCBieXRlU3dhcCA9ICh3b3JkKSA9PiAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4vLyBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm1cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBpc0xFID8gKG4pID0+IG4gOiAobikgPT4gYnl0ZVN3YXAobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput)\n/* harmony export */ });\n/**\n * Internal assertion helpers.\n * @module\n */\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29EO0FBQ3BEIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBhc3NlcnRpb24gaGVscGVycy5cbiAqIEBtb2R1bGVcbiAqL1xuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5mdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogSXMgbnVtYmVyIGFuIFVpbnQ4QXJyYXk/IENvcGllZCBmcm9tIHV0aWxzIGZvciBwZXJmLiAqL1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5mdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZnVuY3Rpb24gYWhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBhbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBhbnVtYmVyKGguYmxvY2tMZW4pO1xufVxuLyoqIEFzc2VydHMgYSBoYXNoIGluc3RhbmNlIGhhcyBub3QgYmVlbiBkZXN0cm95ZWQgLyBmaW5pc2hlZCAqL1xuZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICcgKyBtaW4pO1xuICAgIH1cbn1cbmV4cG9ydCB7IGFudW1iZXIsIGFieXRlcywgYWhhc2gsIGFleGlzdHMsIGFvdXRwdXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIGhlbHBlcnMgZm9yIHU2NC4gQmlnVWludDY0QXJyYXkgaXMgdG9vIHNsb3cgYXMgcGVyIDIwMjUsIHNvIHdlIGltcGxlbWVudCBpdCB1c2luZyBVaW50MzJBcnJheS5cbiAqIEB0b2RvIHJlLWNoZWNrIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDIyMTI1ODhcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\n\n\n\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\n/** Keccak sponge function. */\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.aexists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.aexists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.aoutput)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/** SHA3-256 hash function. Different from keccak-256. */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\n/** SHA3-384 hash function. */\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\n/** SHA3-512 hash function. */\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\n/** keccak-224 hash function. */\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/** keccak-256 hash function. Different from SHA3-256. */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\n/** keccak-384 hash function. */\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\n/** keccak-512 hash function. */\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\n/** SHAKE256 XOF with 256-bit security. */\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUU7QUFDQztBQUM4QztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhDQUFLO0FBQ3hEO0FBQ0EscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0QscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0Q7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDJDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUc7QUFDMUI7QUFDQTtBQUNBLGFBQWEsMkNBQUk7QUFDakIsWUFBWSxxREFBVTtBQUN0QjtBQUNBLGFBQWEsMkNBQUk7QUFDakIsWUFBWSxxREFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQU87QUFDZixnQkFBZ0Isa0JBQWtCO0FBQ2xDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTztBQUNmLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMERBQWU7QUFDNUQ7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUCxrREFBa0QscUVBQTBCLFdBQVc7QUFDdkY7QUFDTztBQUNQO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0hBMyAoa2VjY2FrKSBoYXNoIGZ1bmN0aW9uLCBiYXNlZCBvbiBhIG5ldyBcIlNwb25nZSBmdW5jdGlvblwiIGRlc2lnbi5cbiAqIERpZmZlcmVudCBmcm9tIG9sZGVyIGhhc2hlcywgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuICpcbiAqIENoZWNrIG91dCBbRklQUy0yMDJdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4yMDIucGRmKSxcbiAqIFtXZWJzaXRlXShodHRwczovL2tlY2Nhay50ZWFtL2tlY2Nhay5odG1sKSxcbiAqIFt0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBTSEEtMyBhbmQgS2VjY2FrXShodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTU3Mjcvd2hhdC1hcmUtdGhlLWtleS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXRoZS1kcmFmdC1zaGEtMy1zdGFuZGFyZC1hbmQtdGhlLWtlY2Nhay1zdWIpLlxuICpcbiAqIENoZWNrIG91dCBgc2hhMy1hZGRvbnNgIG1vZHVsZSBmb3IgY1NIQUtFLCBrMTIsIGFuZCBvdGhlcnMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYW51bWJlciwgYW91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHNwbGl0IH0gZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IGJ5dGVTd2FwMzIsIEhhc2gsIGlzTEUsIHRvQnl0ZXMsIHUzMiwgd3JhcENvbnN0cnVjdG9yLCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cywgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFNIQTNfUEkgPSBbXTtcbmNvbnN0IFNIQTNfUk9UTCA9IFtdO1xuY29uc3QgX1NIQTNfSU9UQSA9IFtdO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vKiogYGtlY2Nha2YxNjAwYCBpbnRlcm5hbCBmdW5jdGlvbiwgYWRkaXRpb25hbGx5IGFsbG93cyB0byBhZGp1c3Qgcm91bmQgY291bnQuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuLyoqIEtlY2NhayBzcG9uZ2UgZnVuY3Rpb24uICovXG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBhbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgLy8gMCA8IGJsb2NrTGVuIDwgMjAwXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICBieXRlU3dhcDMyKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBhYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIGFudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuLyoqIFNIQTMtMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XG4vKiogU0hBMy0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20ga2VjY2FrLTI1Ni4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbi8qKiBTSEEzLTM4NCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xuLyoqIFNIQTMtNTEyIGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbi8qKiBrZWNjYWstMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCk7XG4vKioga2VjY2FrLTM4NCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG4vKioga2VjY2FrLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG4vKiogU0hBS0UxMjggWE9GIHdpdGggMTI4LWJpdCBzZWN1cml0eS4gKi9cbmV4cG9ydCBjb25zdCBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xuLyoqIFNIQUtFMjU2IFhPRiB3aXRoIDI1Ni1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n// Cast array to view\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nconst byteSwapIfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Wraps hash function, creating an interface on top of it */\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUNSO0FBQ3RDLFlBQVksVUFBVTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGtEQUFNO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmltcG9ydCB7IGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLy8gVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gKCgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKSk7XG59XG4vKiogQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtICovXG5leHBvcnQgY29uc3QgYnl0ZVN3YXBJZkJFID0gaXNMRVxuICAgID8gKG4pID0+IG5cbiAgICA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8qKiBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnQgSlMgc3RyaW5nIHRvIGJ5dGUgYXJyYXkuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2Ygc3RyKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKiogRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2UgKi9cbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHt9LnRvU3RyaW5nLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIFdyYXBzIGhhc2ggZnVuY3Rpb24sIGNyZWF0aW5nIGFuIGludGVyZmFjZSBvbiB0b3Agb2YgaXQgKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32nopad = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32hexnopad = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (words instanceof Uint8Array)\n            words = Array.from(words);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\nconst bech32 = /* @__PURE__ */ genBech32('bech32');\nconst bech32m = /* @__PURE__ */ genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBLHdEQUF3RCxPQUFPLGNBQWMsU0FBUztBQUN0RjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw4REFBOEQsTUFBTSxLQUFLLElBQUksWUFBWSxzQkFBc0I7QUFDL0c7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEdBQUcsT0FBTyxLQUFLO0FBQy9FO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSyxPQUFPLEtBQUs7QUFDbEY7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLGdCQUFnQixNQUFNO0FBQzlFO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxHQUFHLDRCQUE0QixFQUFFLElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFdBQVc7QUFDcEY7QUFDQSx3REFBd0QsWUFBWSxHQUFHLElBQUksa0JBQWtCLE1BQU07QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLGNBQWMsSUFBSTtBQUN6RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdFQUFnRSxVQUFVLGNBQWMsU0FBUztBQUNqRztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkI7QUFDM0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllc1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gKGEpID0+IGE7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5lbmNvZGUpLnJlZHVjZVJpZ2h0KHdyYXAsIGlkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5kZWNvZGUpLnJlZHVjZSh3cmFwLCBpZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2tcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKkBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgICBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCBjb252ZXJ0UmFkaXgsIGNvbnZlcnRSYWRpeDIsIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcsXG59O1xuLy8gUkZDIDQ2NDggYWthIFJGQyAzNTQ4XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4cnAgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyB4bXIgdmVyIGlzIGRvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4vLyBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuLy8gRGF0YSBsZW4gKGluZGV4KSAtPiBlbmNvZGVkIGJsb2NrIGxlblxuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuLy8gbGVnYWN5IGV4cG9ydCwgYmFkIG5hbWVcbmV4cG9ydCBjb25zdCBiYXNlNThjaGVjayA9IGNyZWF0ZUJhc2U1OGNoZWNrO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICh3b3JkcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICB3b3JkcyA9IEFycmF5LmZyb20od29yZHMpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHByZWZpeCBsZW5ndGggJHtwcmVmaXgubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IGxvd2VyZWQubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGxvd2VyZWQuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbG93ZXJlZC5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShkYXRhKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghZGF0YS5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlRnJvbUJ5dGVzKHByZWZpeCwgYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZShwcmVmaXgsIHRvV29yZHMoYnl0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlLFxuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZUZyb21CeXRlcyxcbiAgICAgICAgZGVjb2RlVG9CeXRlcyxcbiAgICAgICAgZGVjb2RlVW5zYWZlLFxuICAgICAgICBmcm9tV29yZHMsXG4gICAgICAgIGZyb21Xb3Jkc1Vuc2FmZSxcbiAgICAgICAgdG9Xb3JkcyxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IGJlY2gzMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnQgY29uc3QgdXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG5leHBvcnQgY29uc3QgaGV4ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9ICdJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yJztcbmV4cG9ydCBjb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBzdHIgPSBieXRlc1RvU3RyaW5nOyAvLyBhcyBpbiBweXRob24sIGJ1dCBmb3IgYnl0ZXMgb25seVxuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG5leHBvcnQgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/lib/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@scure/starknet/lib/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Fp251: () => (/* binding */ Fp251),\n/* harmony export */   MAX_VALUE: () => (/* binding */ MAX_VALUE),\n/* harmony export */   ProjectivePoint: () => (/* binding */ ProjectivePoint),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   _poseidonMDS: () => (/* binding */ _poseidonMDS),\n/* harmony export */   _starkCurve: () => (/* binding */ _starkCurve),\n/* harmony export */   computeHashOnElements: () => (/* binding */ computeHashOnElements),\n/* harmony export */   ethSigToPrivate: () => (/* binding */ ethSigToPrivate),\n/* harmony export */   getAccountPath: () => (/* binding */ getAccountPath),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   getStarkKey: () => (/* binding */ getStarkKey),\n/* harmony export */   grindKey: () => (/* binding */ grindKey),\n/* harmony export */   keccak: () => (/* binding */ keccak),\n/* harmony export */   pedersen: () => (/* binding */ pedersen),\n/* harmony export */   poseidonBasic: () => (/* binding */ poseidonBasic),\n/* harmony export */   poseidonCreate: () => (/* binding */ poseidonCreate),\n/* harmony export */   poseidonHash: () => (/* binding */ poseidonHash),\n/* harmony export */   poseidonHashFunc: () => (/* binding */ poseidonHashFunc),\n/* harmony export */   poseidonHashMany: () => (/* binding */ poseidonHashMany),\n/* harmony export */   poseidonHashSingle: () => (/* binding */ poseidonHashSingle),\n/* harmony export */   poseidonSmall: () => (/* binding */ poseidonSmall),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/_shortw_utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js\");\n\n\n\n\n\n\n\n\nconst CURVE_ORDER = BigInt('3618502788666131213697322783095070105526743751716087489154079457884512865583');\nconst MAX_VALUE = BigInt('0x800000000000000000000000000000000000000000000000000000000000000');\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while (bytes[0] === 0)\n        bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === 'string') {\n        hex = strip0x(hex);\n        if (hex.length & 1)\n            hex = '0' + hex;\n    }\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(hex);\n}\nconst curve = (0,_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.weierstrass)({\n    a: BigInt(1),\n    b: BigInt('3141592653589793238462643383279502884197169399375105820974944592307816406665'),\n    Fp: (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt('0x800000000000011000000000000000000000000000000000000000000000001')),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt('874739451078007766457464989774322083649278607533249481151382481072868806602'),\n    Gy: BigInt('152666792071518830868575557812948353041420400780739481342941381225525861407'),\n    h: BigInt(1),\n    lowS: false,\n    ...(0,_noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__.getHash)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256),\n    bits2int,\n    bits2int_modN: (bytes) => {\n        const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63)\n            bytes = hex0xToBytes(hex + '0');\n        return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(bits2int(bytes), CURVE_ORDER);\n    },\n});\nconst _starkCurve = curve;\nfunction ensureBytes(hex) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.ensureBytes('', typeof hex === 'string' ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(ensureBytes(privKey)).padStart(64, '0');\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n    const { r, s } = signature;\n    if (r < 0n || r >= MAX_VALUE)\n        throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n    const w = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert)(s, CURVE_ORDER);\n    if (w < 0n || w >= MAX_VALUE)\n        throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    if (num >= MAX_VALUE)\n        throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n    return bytes;\n}\nfunction sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nfunction verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        }\n        catch (derError) {\n            if (!(derError instanceof _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.DER.Err))\n                throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\n\nfunction extractX(bytes) {\n    const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, '');\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, '');\n}\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(sha256mask, CURVE_ORDER);\n    for (let i = 0;; i++) {\n        const key = sha256Num(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes(_seed, _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(BigInt(i))));\n        if (key < limit)\n            return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(key, CURVE_ORDER).toString(16);\n        if (i === 100000)\n            throw new Error('grindKey is broken: tried 100k vals');\n    }\n}\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130)\n        throw new Error('Wrong ethereum signature');\n    return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n) => Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n),\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for (let i = 0; i < 248; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for (let i = 0; i < 4; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === 'bigint') {\n        value = arg;\n    }\n    else if (typeof arg === 'number') {\n        if (!Number.isSafeInteger(arg))\n            throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    }\n    else {\n        value = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER))\n        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for (let j = 0; j < 252; j++) {\n        const pt = constants[j];\n        if (pt.equals(point))\n            throw new Error('Same point');\n        if ((x & 1n) !== 0n)\n            point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nconst computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));\nconst MASK_250 = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bitMask(250);\nconst keccak = (data) => _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__.keccak_256)(data)) & MASK_250;\nconst sha256Num = (data) => _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(data));\nconst Fp251 = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt('3618502788666131213697322783095070105623107215331596699973092056135872020481'));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for (let i = 0; i < m; i++) {\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([...x_values, ...y_values]).size !== 2 * m)\n        throw new Error('X and Y values are not distinct');\n    return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [\n    [3, 1, 1],\n    [1, -1, 1],\n    [1, 1, -2],\n].map((i) => i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))\n        throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for (let i = 0; i < rounds; i++) {\n        const row = [];\n        for (let j = 0; j < m; j++)\n            row.push(poseidonRoundConstant(opts.Fp, 'Hades', m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0,_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants,\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt))\n        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, 'HadesMDS', m, mdsAttempt));\n}\nconst poseidonSmall = poseidonBasic({ Fp: Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);\nfunction poseidonHash(x, y, fn = poseidonSmall) {\n    return fn([x, y, 2n])[0];\n}\nfunction poseidonHashFunc(x, y, fn = poseidonSmall) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(poseidonHash(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(x), _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(y), fn));\n}\nfunction poseidonHashSingle(x, fn = poseidonSmall) {\n    return fn([x, 0n, 1n])[0];\n}\nfunction poseidonHashMany(values, fn = poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values))\n        throw new Error('bigint array expected in values');\n    const padded = Array.from(values);\n    padded.push(1n);\n    while (padded.length % rate !== 0)\n        padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for (let i = 0; i < padded.length; i += rate) {\n        for (let j = 0; j < rate; j++)\n            state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0Y7QUFDSTtBQUNpQztBQUN4QjtBQUNXO0FBQ3BCO0FBQ0k7QUFDdEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ0EsY0FBYywrRUFBVztBQUN6QjtBQUNBO0FBQ0EsUUFBUSxxRUFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sbUVBQU8sQ0FBQyx3REFBTTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CLHlFQUFpQjtBQUNyQztBQUNBO0FBQ0EsZUFBZSxtRUFBRztBQUNsQixLQUFLO0FBQ0wsQ0FBQztBQUNNO0FBQ1A7QUFDQSxXQUFXLHFFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxxREFBcUQsVUFBVTtBQUMvRCxjQUFjLHNFQUFNO0FBQ3BCO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlFQUFpQjtBQUNqQztBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUVBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJDQUEyQztBQUNDO0FBQ3BEO0FBQ0EsZ0JBQWdCLG9FQUFZO0FBQzVCO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwrQkFBK0IsbUVBQUc7QUFDbEMscUJBQXFCO0FBQ3JCLDhCQUE4QixxRUFBYSxRQUFRLDRFQUFvQjtBQUN2RTtBQUNBLG1CQUFtQixtRUFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IscUVBQWE7QUFDN0Isc0JBQXNCLFNBQVMsSUFBSSxlQUFlLElBQUksV0FBVyxJQUFJLGtCQUFrQixJQUFJLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5RUFBaUI7QUFDakM7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsaUVBQVM7QUFDbkIseUJBQXlCLHlFQUFpQixDQUFDLDhEQUFVO0FBQzVELDRCQUE0Qix5RUFBaUIsQ0FBQyw0REFBTTtBQUM3QyxjQUFjLHFFQUFLO0FBQzFCO0FBQ0EsNkJBQTZCLDREQUFNLENBQUMsZ0VBQVcsSUFBSSxLQUFLLEVBQUUsSUFBSTtBQUM5RDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsbURBQW1ELEtBQUs7QUFDeEQsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksNkVBQWE7QUFDakI7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5RUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDTyxzQ0FBc0MsbUVBQW1FO0FBQ3pHO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyw0RUFBb0IsY0FBYyx5RUFBaUIsS0FBSyx5RUFBaUI7QUFDcEY7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbGliL2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCB2YWxpZGF0ZUZpZWxkLCBpbnZlcnQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuaW1wb3J0IHsgcG9zZWlkb24gfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzLCBERVIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzJztcbmltcG9ydCAqIGFzIHUgZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgeyBnZXRIYXNoIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzJztcbmNvbnN0IENVUlZFX09SREVSID0gQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NTI2NzQzNzUxNzE2MDg3NDg5MTU0MDc5NDU3ODg0NTEyODY1NTgzJyk7XG5leHBvcnQgY29uc3QgTUFYX1ZBTFVFID0gQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuY29uc3QgbkJpdExlbmd0aCA9IDI1MjtcbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgd2hpbGUgKGJ5dGVzWzBdID09PSAwKVxuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIG5CaXRMZW5ndGg7XG4gICAgY29uc3QgbnVtID0gdS5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbn1cbmZ1bmN0aW9uIGhleDB4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gc3RyaXAweChoZXgpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgfVxuICAgIHJldHVybiB1LmhleFRvQnl0ZXMoaGV4KTtcbn1cbmNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3Moe1xuICAgIGE6IEJpZ0ludCgxKSxcbiAgICBiOiBCaWdJbnQoJzMxNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDY2NjUnKSxcbiAgICBGcDogRmllbGQoQmlnSW50KCcweDgwMDAwMDAwMDAwMDAxMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScpKSxcbiAgICBuOiBDVVJWRV9PUkRFUixcbiAgICBuQml0TGVuZ3RoLFxuICAgIEd4OiBCaWdJbnQoJzg3NDczOTQ1MTA3ODAwNzc2NjQ1NzQ2NDk4OTc3NDMyMjA4MzY0OTI3ODYwNzUzMzI0OTQ4MTE1MTM4MjQ4MTA3Mjg2ODgwNjYwMicpLFxuICAgIEd5OiBCaWdJbnQoJzE1MjY2Njc5MjA3MTUxODgzMDg2ODU3NTU1NzgxMjk0ODM1MzA0MTQyMDQwMDc4MDczOTQ4MTM0Mjk0MTM4MTIyNTUyNTg2MTQwNycpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZSxcbiAgICAuLi5nZXRIYXNoKHNoYTI1NiksXG4gICAgYml0czJpbnQsXG4gICAgYml0czJpbnRfbW9kTjogKGJ5dGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA2MylcbiAgICAgICAgICAgIGJ5dGVzID0gaGV4MHhUb0J5dGVzKGhleCArICcwJyk7XG4gICAgICAgIHJldHVybiBtb2QoYml0czJpbnQoYnl0ZXMpLCBDVVJWRV9PUkRFUik7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGNvbnN0IF9zdGFya0N1cnZlID0gY3VydmU7XG5mdW5jdGlvbiBlbnN1cmVCeXRlcyhoZXgpIHtcbiAgICByZXR1cm4gdS5lbnN1cmVCeXRlcygnJywgdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoZXgweFRvQnl0ZXMoaGV4KSA6IGhleCk7XG59XG5mdW5jdGlvbiBub3JtUHJpdktleShwcml2S2V5KSB7XG4gICAgcmV0dXJuIHUuYnl0ZXNUb0hleChlbnN1cmVCeXRlcyhwcml2S2V5KSkucGFkU3RhcnQoNjQsICcwJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShub3JtUHJpdktleShwcml2S2V5KSwgaXNDb21wcmVzc2VkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdktleUEsIHB1YktleUIpIHtcbiAgICByZXR1cm4gY3VydmUuZ2V0U2hhcmVkU2VjcmV0KG5vcm1Qcml2S2V5KHByaXZLZXlBKSwgcHViS2V5Qik7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZ25hdHVyZTtcbiAgICBpZiAociA8IDBuIHx8IHIgPj0gTUFYX1ZBTFVFKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25hdHVyZS5yIHNob3VsZCBiZSBbMSwgJHtNQVhfVkFMVUV9KWApO1xuICAgIGNvbnN0IHcgPSBpbnZlcnQocywgQ1VSVkVfT1JERVIpO1xuICAgIGlmICh3IDwgMG4gfHwgdyA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52KFNpZ25hdHVyZS5zKSBzaG91bGQgYmUgWzEsICR7TUFYX1ZBTFVFfSlgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWVzc2FnZShtc2dIYXNoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhtc2dIYXNoKTtcbiAgICBjb25zdCBudW0gPSB1LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgaWYgKG51bSA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbXNnSGFzaCBzaG91bGQgYmUgWzAsICR7TUFYX1ZBTFVFfSlgKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzKSB7XG4gICAgY29uc3Qgc2lnID0gY3VydmUuc2lnbihjaGVja01lc3NhZ2UobXNnSGFzaCksIG5vcm1Qcml2S2V5KHByaXZLZXkpLCBvcHRzKTtcbiAgICBjaGVja1NpZ25hdHVyZShzaWcpO1xuICAgIHJldHVybiBzaWc7XG59XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHViS2V5KSB7XG4gICAgaWYgKCEoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKHNpZ25hdHVyZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbURFUihieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1NpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIHJldHVybiBjdXJ2ZS52ZXJpZnkoc2lnbmF0dXJlLCBjaGVja01lc3NhZ2UobXNnSGFzaCksIGVuc3VyZUJ5dGVzKHB1YktleSkpO1xufVxuY29uc3QgeyBDVVJWRSwgUHJvamVjdGl2ZVBvaW50LCBTaWduYXR1cmUsIHV0aWxzIH0gPSBjdXJ2ZTtcbmV4cG9ydCB7IENVUlZFLCBQcm9qZWN0aXZlUG9pbnQsIFNpZ25hdHVyZSwgdXRpbHMgfTtcbmZ1bmN0aW9uIGV4dHJhY3RYKGJ5dGVzKSB7XG4gICAgY29uc3QgaGV4ID0gdS5ieXRlc1RvSGV4KGJ5dGVzLnN1YmFycmF5KDEpKTtcbiAgICBjb25zdCBzdHJpcHBlZCA9IGhleC5yZXBsYWNlKC9eMCsvZ20sICcnKTtcbiAgICByZXR1cm4gYDB4JHtzdHJpcHBlZH1gO1xufVxuZnVuY3Rpb24gc3RyaXAweChoZXgpIHtcbiAgICByZXR1cm4gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ3JpbmRLZXkoc2VlZCkge1xuICAgIGNvbnN0IF9zZWVkID0gZW5zdXJlQnl0ZXMoc2VlZCk7XG4gICAgY29uc3Qgc2hhMjU2bWFzayA9IDJuICoqIDI1Nm47XG4gICAgY29uc3QgbGltaXQgPSBzaGEyNTZtYXNrIC0gbW9kKHNoYTI1Nm1hc2ssIENVUlZFX09SREVSKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzaGEyNTZOdW0odS5jb25jYXRCeXRlcyhfc2VlZCwgdS5udW1iZXJUb1ZhckJ5dGVzQkUoQmlnSW50KGkpKSkpO1xuICAgICAgICBpZiAoa2V5IDwgbGltaXQpXG4gICAgICAgICAgICByZXR1cm4gbW9kKGtleSwgQ1VSVkVfT1JERVIpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGkgPT09IDEwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ3JpbmRLZXkgaXMgYnJva2VuOiB0cmllZCAxMDBrIHZhbHMnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcmtLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHRyYWN0WChnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgdHJ1ZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV0aFNpZ1RvUHJpdmF0ZShzaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzdHJpcDB4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBldGhlcmV1bSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gZ3JpbmRLZXkoc2lnbmF0dXJlLnN1YnN0cmluZygwLCA2NCkpO1xufVxuY29uc3QgTUFTS18zMSA9IDJuICoqIDMxbiAtIDFuO1xuY29uc3QgaW50MzEgPSAobikgPT4gTnVtYmVyKG4gJiBNQVNLXzMxKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50UGF0aChsYXllciwgYXBwbGljYXRpb24sIGV0aGVyZXVtQWRkcmVzcywgaW5kZXgpIHtcbiAgICBjb25zdCBsYXllck51bSA9IGludDMxKHNoYTI1Nk51bShsYXllcikpO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uTnVtID0gaW50MzEoc2hhMjU2TnVtKGFwcGxpY2F0aW9uKSk7XG4gICAgY29uc3QgZXRoID0gdS5oZXhUb051bWJlcihzdHJpcDB4KGV0aGVyZXVtQWRkcmVzcykpO1xuICAgIHJldHVybiBgbS8yNjQ1Jy8ke2xheWVyTnVtfScvJHthcHBsaWNhdGlvbk51bX0nLyR7aW50MzEoZXRoKX0nLyR7aW50MzEoZXRoID4+IDMxbil9Jy8ke2luZGV4fWA7XG59XG5jb25zdCBQRURFUlNFTl9QT0lOVFMgPSBbXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0biwgMTcxMzkzMTMyOTU0MDY2MDM3NzAyMzQwNjEwOTE5OTQxMDQxNDgxMDcwNTg2NzI2MDgwMjA3ODE4NzA4MjM0NTUyOTIwNzY5NDk4Nm4sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDk5Njc4MTIwNTgzMzAwODc3NDUxNDUwMDA4MjM3Njc4MzI0OTEwMjM5NjAyMzY2MzQ1NDgxMzQ0NzQyMzE0Nzk3NzM5NzIzMjc2M24sIDE2Njg1MDM2NzY3ODYzNzc3MjU4MDU0ODkzNDQ3NzEwMjM5MjEwNzkxMjY1NTIwMTkxNjAxNTY5MjA2MzQ2MTkyNTU5NzA0ODU3ODFuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMjUxNTYzMjc0NDg5NzUwNTM1MTE3ODg2NDI2NTMzMjIyNDM1Mjk0MDQ2NDI4MzQ3MzI5MjAzNjI3MDIxMjQ5MTY5NjE2MTg0MTg0biwgMTc5ODcxNjAwNzU2MjcyODkwNTI5NTQ4MDY3OTc4OTUyNjMyMjE3NTg2ODMyODA2MjQyMDIzNzQxOTE0MzU5MzAyMTY3NDk5Mjk3M24sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIxMzg0MTQ2OTUxOTQxNTExNjA5NDMzMDU3MjcwMzY1NzU5NTkxOTUzMDkyMTg2MTE3MzgxOTMyNjExNzkzMTA1MTE4NTQ4MDc0NDduLCAxMTM0MTAyNzY3MzAwNjQ0ODYyNTUxMDIwOTM4NDY1NDAxMzM3ODQ4NjUyODY5MjkwNTI0MjY5MzE0NzQxMDYzOTYxMzUwNzIxNTZuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMzc5OTYyNzQ5NTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2biwgNzc2NDk2NDUzNjMzMjk4MTc1NDgzOTg1Mzk4NjQ4NzU4NTg2NTI1OTMzODEyNTM2NjUzMDg5NDAxOTA1MjkyMDYzNzA4ODE2NDIybiwgMW4pLFxuXTtcbmZ1bmN0aW9uIHBlZGVyc2VuUHJlY29tcHV0ZShwMSwgcDIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IHAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ4OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICBwID0gcDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuY29uc3QgUEVERVJTRU5fUE9JTlRTMSA9IHBlZGVyc2VuUHJlY29tcHV0ZShQRURFUlNFTl9QT0lOVFNbMV0sIFBFREVSU0VOX1BPSU5UU1syXSk7XG5jb25zdCBQRURFUlNFTl9QT0lOVFMyID0gcGVkZXJzZW5QcmVjb21wdXRlKFBFREVSU0VOX1BPSU5UU1szXSwgUEVERVJTRU5fUE9JTlRTWzRdKTtcbmZ1bmN0aW9uIHBlZGVyc2VuQXJnKGFyZykge1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYXJnKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZWRlcnNlbkFyZzogJHthcmd9YCk7XG4gICAgICAgIHZhbHVlID0gQmlnSW50KGFyZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHUuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKGFyZykpO1xuICAgIH1cbiAgICBpZiAoISgwbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8IGN1cnZlLkNVUlZFLkZwLk9SREVSKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQZWRlcnNlbkFyZyBzaG91bGQgYmUgMCA8PSB2YWx1ZSA8IENVUlZFLlA6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGVkZXJzZW5TaW5nbGUocG9pbnQsIHZhbHVlLCBjb25zdGFudHMpIHtcbiAgICBsZXQgeCA9IHBlZGVyc2VuQXJnKHZhbHVlKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1MjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHB0ID0gY29uc3RhbnRzW2pdO1xuICAgICAgICBpZiAocHQuZXF1YWxzKHBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2FtZSBwb2ludCcpO1xuICAgICAgICBpZiAoKHggJiAxbikgIT09IDBuKVxuICAgICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQocHQpO1xuICAgICAgICB4ID4+PSAxbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBlZGVyc2VuKHgsIHkpIHtcbiAgICBsZXQgcG9pbnQgPSBQRURFUlNFTl9QT0lOVFNbMF07XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeCwgUEVERVJTRU5fUE9JTlRTMSk7XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeSwgUEVERVJTRU5fUE9JTlRTMik7XG4gICAgcmV0dXJuIGV4dHJhY3RYKHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkpO1xufVxuZXhwb3J0IGNvbnN0IGNvbXB1dGVIYXNoT25FbGVtZW50cyA9IChkYXRhLCBmbiA9IHBlZGVyc2VuKSA9PiBbMCwgLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gZm4oeCwgeSkpO1xuY29uc3QgTUFTS18yNTAgPSB1LmJpdE1hc2soMjUwKTtcbmV4cG9ydCBjb25zdCBrZWNjYWsgPSAoZGF0YSkgPT4gdS5ieXRlc1RvTnVtYmVyQkUoa2VjY2FrXzI1NihkYXRhKSkgJiBNQVNLXzI1MDtcbmNvbnN0IHNoYTI1Nk51bSA9IChkYXRhKSA9PiB1LmJ5dGVzVG9OdW1iZXJCRShzaGEyNTYoZGF0YSkpO1xuZXhwb3J0IGNvbnN0IEZwMjUxID0gRmllbGQoQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NjIzMTA3MjE1MzMxNTk2Njk5OTczMDkyMDU2MTM1ODcyMDIwNDgxJykpO1xuZnVuY3Rpb24gcG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBuYW1lLCBpZHgpIHtcbiAgICBjb25zdCB2YWwgPSBGcC5mcm9tQnl0ZXMoc2hhMjU2KHV0ZjhUb0J5dGVzKGAke25hbWV9JHtpZHh9YCkpKTtcbiAgICByZXR1cm4gRnAuY3JlYXRlKHZhbCk7XG59XG5leHBvcnQgZnVuY3Rpb24gX3Bvc2VpZG9uTURTKEZwLCBuYW1lLCBtLCBhdHRlbXB0ID0gMCkge1xuICAgIGNvbnN0IHhfdmFsdWVzID0gW107XG4gICAgY29uc3QgeV92YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICB4X3ZhbHVlcy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChGcCwgYCR7bmFtZX14YCwgYXR0ZW1wdCAqIG0gKyBpKSk7XG4gICAgICAgIHlfdmFsdWVzLnB1c2gocG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBgJHtuYW1lfXlgLCBhdHRlbXB0ICogbSArIGkpKTtcbiAgICB9XG4gICAgaWYgKG5ldyBTZXQoWy4uLnhfdmFsdWVzLCAuLi55X3ZhbHVlc10pLnNpemUgIT09IDIgKiBtKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ggYW5kIFkgdmFsdWVzIGFyZSBub3QgZGlzdGluY3QnKTtcbiAgICByZXR1cm4geF92YWx1ZXMubWFwKCh4KSA9PiB5X3ZhbHVlcy5tYXAoKHkpID0+IEZwLmludihGcC5zdWIoeCwgeSkpKSk7XG59XG5jb25zdCBNRFNfU01BTEwgPSBbXG4gICAgWzMsIDEsIDFdLFxuICAgIFsxLCAtMSwgMV0sXG4gICAgWzEsIDEsIC0yXSxcbl0ubWFwKChpKSA9PiBpLm1hcChCaWdJbnQpKTtcbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkJhc2ljKG9wdHMsIG1kcykge1xuICAgIHZhbGlkYXRlRmllbGQob3B0cy5GcCk7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzLnJhdGUpIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzLmNhcGFjaXR5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NlaWRvbiBvcHRzOiAke29wdHN9YCk7XG4gICAgY29uc3QgbSA9IG9wdHMucmF0ZSArIG9wdHMuY2FwYWNpdHk7XG4gICAgY29uc3Qgcm91bmRzID0gb3B0cy5yb3VuZHNGdWxsICsgb3B0cy5yb3VuZHNQYXJ0aWFsO1xuICAgIGNvbnN0IHJvdW5kQ29uc3RhbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspXG4gICAgICAgICAgICByb3cucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQob3B0cy5GcCwgJ0hhZGVzJywgbSAqIGkgKyBqKSk7XG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLnB1c2gocm93KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gcG9zZWlkb24oe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB0OiBtLFxuICAgICAgICBzYm94UG93ZXI6IDMsXG4gICAgICAgIHJldmVyc2VQYXJ0aWFsUG93SWR4OiB0cnVlLFxuICAgICAgICBtZHMsXG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLFxuICAgIH0pO1xuICAgIHJlcy5tID0gbTtcbiAgICByZXMucmF0ZSA9IG9wdHMucmF0ZTtcbiAgICByZXMuY2FwYWNpdHkgPSBvcHRzLmNhcGFjaXR5O1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25DcmVhdGUob3B0cywgbWRzQXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG1kc0F0dGVtcHQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIG1kc0F0dGVtcHQ9JHttZHNBdHRlbXB0fWApO1xuICAgIHJldHVybiBwb3NlaWRvbkJhc2ljKG9wdHMsIF9wb3NlaWRvbk1EUyhvcHRzLkZwLCAnSGFkZXNNRFMnLCBtLCBtZHNBdHRlbXB0KSk7XG59XG5leHBvcnQgY29uc3QgcG9zZWlkb25TbWFsbCA9IHBvc2VpZG9uQmFzaWMoeyBGcDogRnAyNTEsIHJhdGU6IDIsIGNhcGFjaXR5OiAxLCByb3VuZHNGdWxsOiA4LCByb3VuZHNQYXJ0aWFsOiA4MyB9LCBNRFNfU01BTEwpO1xuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaCh4LCB5LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gZm4oW3gsIHksIDJuXSlbMF07XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25IYXNoRnVuYyh4LCB5LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gdS5udW1iZXJUb1ZhckJ5dGVzQkUocG9zZWlkb25IYXNoKHUuYnl0ZXNUb051bWJlckJFKHgpLCB1LmJ5dGVzVG9OdW1iZXJCRSh5KSwgZm4pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hTaW5nbGUoeCwgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCAwbiwgMW5dKVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hNYW55KHZhbHVlcywgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgY29uc3QgeyBtLCByYXRlIH0gPSBmbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgYXJyYXkgZXhwZWN0ZWQgaW4gdmFsdWVzJyk7XG4gICAgY29uc3QgcGFkZGVkID0gQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICAgIHBhZGRlZC5wdXNoKDFuKTtcbiAgICB3aGlsZSAocGFkZGVkLmxlbmd0aCAlIHJhdGUgIT09IDApXG4gICAgICAgIHBhZGRlZC5wdXNoKDBuKTtcbiAgICBsZXQgc3RhdGUgPSBuZXcgQXJyYXkobSkuZmlsbCgwbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWQubGVuZ3RoOyBpICs9IHJhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYXRlOyBqKyspXG4gICAgICAgICAgICBzdGF0ZVtqXSArPSBwYWRkZWRbaSArIGpdO1xuICAgICAgICBzdGF0ZSA9IGZuKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlWzBdO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUMwQztBQUNxQjtBQUNQO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFJLFlBQVksZ0VBQVc7QUFDM0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixxRUFBVyxHQUFHLCtCQUErQjtBQUMxRSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3NEO0FBQ1Y7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYTtBQUNqQixJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUVBQXFFLFFBQVEsTUFBTSxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRDtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsc0RBQXNEO0FBQ3RELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcseURBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNEQUFzRDtBQUM3RDtBQUNBLHlEQUF5RCxNQUFNO0FBQy9ELFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFdBQVc7QUFDMUYsOENBQThDO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMERBQWUsZUFBZSwwREFBZTtBQUMvRTtBQUNBO0FBQ0EsMERBQTBELE1BQU0sUUFBUSxhQUFhO0FBQ3JGLDBCQUEwQiwwREFBZSxVQUFVLDBEQUFlO0FBQ2xFLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxzREFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTyw0QkFBNEIsUUFBUTtBQUNwRyx1QkFBdUIsMERBQWUsU0FBUywwREFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU8sNEJBQTRCLElBQUk7QUFDM0UsdUJBQXVCLDBEQUFlLFFBQVEsMERBQWU7QUFDN0Q7QUFDQTtBQUNBLGtCQUFrQiwwREFBZSxzQkFBc0IsMERBQWU7QUFDdEU7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poseidon: () => (/* binding */ poseidon),\n/* harmony export */   splitConstants: () => (/* binding */ splitConstants),\n/* harmony export */   validateOpts: () => (/* binding */ validateOpts)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Poseidon Hash: https://eprint.iacr.org/2019/458.pdf, https://www.poseidon-hash.info\n\nfunction validateOpts(opts) {\n    const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;\n    const { roundsFull, roundsPartial, sboxPower, t } = opts;\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(Fp);\n    for (const i of ['t', 'roundsFull', 'roundsPartial']) {\n        if (typeof opts[i] !== 'number' || !Number.isSafeInteger(opts[i]))\n            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);\n    }\n    // MDS is TxT matrix\n    if (!Array.isArray(mds) || mds.length !== t)\n        throw new Error('Poseidon: wrong MDS matrix');\n    const _mds = mds.map((mdsRow) => {\n        if (!Array.isArray(mdsRow) || mdsRow.length !== t)\n            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);\n        return mdsRow.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon MDS matrix value=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (rev !== undefined && typeof rev !== 'boolean')\n        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);\n    if (roundsFull % 2 !== 0)\n        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);\n    const rounds = roundsFull + roundsPartial;\n    if (!Array.isArray(rc) || rc.length !== rounds)\n        throw new Error('Poseidon: wrong round constants');\n    const roundConstants = rc.map((rc) => {\n        if (!Array.isArray(rc) || rc.length !== t)\n            throw new Error(`Poseidon wrong round constants: ${rc}`);\n        return rc.map((i) => {\n            if (typeof i !== 'bigint' || !Fp.isValid(i))\n                throw new Error(`Poseidon wrong round constant=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (!sboxPower || ![3, 5, 7].includes(sboxPower))\n        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);\n    const _sboxPower = BigInt(sboxPower);\n    let sboxFn = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow)(Fp, n, _sboxPower);\n    // Unwrapped sbox power for common cases (195->142μs)\n    if (sboxPower === 3)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);\n    else if (sboxPower === 5)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);\n    return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });\n}\nfunction splitConstants(rc, t) {\n    if (typeof t !== 'number')\n        throw new Error('poseidonSplitConstants: wrong t');\n    if (!Array.isArray(rc) || rc.length % t)\n        throw new Error('poseidonSplitConstants: wrong rc');\n    const res = [];\n    let tmp = [];\n    for (let i = 0; i < rc.length; i++) {\n        tmp.push(rc[i]);\n        if (tmp.length === t) {\n            res.push(tmp);\n            tmp = [];\n        }\n    }\n    return res;\n}\nfunction poseidon(opts) {\n    const _opts = validateOpts(opts);\n    const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;\n    const halfRoundsFull = _opts.roundsFull / 2;\n    const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;\n    const poseidonRound = (values, isFull, idx) => {\n        values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));\n        if (isFull)\n            values = values.map((i) => sboxFn(i));\n        else\n            values[partialIdx] = sboxFn(values[partialIdx]);\n        // Matrix multiplication\n        values = mds.map((i) => i.reduce((acc, i, j) => Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));\n        return values;\n    };\n    const poseidonHash = function poseidonHash(values) {\n        if (!Array.isArray(values) || values.length !== t)\n            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);\n        values = values.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);\n            return Fp.create(i);\n        });\n        let round = 0;\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        // Apply r_p partial rounds.\n        for (let i = 0; i < roundsPartial; i++)\n            values = poseidonRound(values, false, round++);\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        if (round !== rounds)\n            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);\n        return values;\n    };\n    // For verification in tests\n    poseidonHash.roundConstants = roundConstants;\n    return poseidonHash;\n}\n//# sourceMappingURL=poseidon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3Bvc2VpZG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29EO0FBQzdDO0FBQ1AsWUFBWSx5REFBeUQ7QUFDckUsWUFBWSwwQ0FBMEM7QUFDdEQsSUFBSSwwREFBYTtBQUNqQjtBQUNBO0FBQ0EsdURBQXVELEVBQUUsR0FBRyxTQUFTLEdBQUcsZUFBZTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0EsNkRBQTZELEVBQUU7QUFDL0Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esd0VBQXdFLElBQUk7QUFDNUU7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEdBQUc7QUFDbEU7QUFDQTtBQUNBLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0Esd0JBQXdCLGtEQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQW9EO0FBQy9FO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksNERBQTREO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsRUFBRTtBQUMvRjtBQUNBO0FBQ0EseURBQXlELEdBQUcsR0FBRyxTQUFTO0FBQ3hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSw0RUFBNEUsTUFBTSxVQUFVLE9BQU87QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9wb3NlaWRvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBQb3NlaWRvbiBIYXNoOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5LzQ1OC5wZGYsIGh0dHBzOi8vd3d3LnBvc2VpZG9uLWhhc2guaW5mb1xuaW1wb3J0IHsgRnBQb3csIHZhbGlkYXRlRmllbGQgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhvcHRzKSB7XG4gICAgY29uc3QgeyBGcCwgbWRzLCByZXZlcnNlUGFydGlhbFBvd0lkeDogcmV2LCByb3VuZENvbnN0YW50czogcmMgfSA9IG9wdHM7XG4gICAgY29uc3QgeyByb3VuZHNGdWxsLCByb3VuZHNQYXJ0aWFsLCBzYm94UG93ZXIsIHQgfSA9IG9wdHM7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgZm9yIChjb25zdCBpIG9mIFsndCcsICdyb3VuZHNGdWxsJywgJ3JvdW5kc1BhcnRpYWwnXSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHNbaV0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzW2ldKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IGludmFsaWQgcGFyYW0gJHtpfT0ke29wdHNbaV19ICgke3R5cGVvZiBvcHRzW2ldfSlgKTtcbiAgICB9XG4gICAgLy8gTURTIGlzIFR4VCBtYXRyaXhcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWRzKSB8fCBtZHMubGVuZ3RoICE9PSB0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2VpZG9uOiB3cm9uZyBNRFMgbWF0cml4Jyk7XG4gICAgY29uc3QgX21kcyA9IG1kcy5tYXAoKG1kc1JvdykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWRzUm93KSB8fCBtZHNSb3cubGVuZ3RoICE9PSB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiBNRFMgbWF0cml4IHJvdzogJHttZHNSb3d9YCk7XG4gICAgICAgIHJldHVybiBtZHNSb3cubWFwKChpKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gTURTIG1hdHJpeCB2YWx1ZT0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gRnAuY3JlYXRlKGkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmV2ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJldiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiBpbnZhbGlkIHBhcmFtIHJldmVyc2VQYXJ0aWFsUG93SWR4PSR7cmV2fWApO1xuICAgIGlmIChyb3VuZHNGdWxsICUgMiAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiByb3VuZHNGdWxsIGlzIG5vdCBldmVuOiAke3JvdW5kc0Z1bGx9YCk7XG4gICAgY29uc3Qgcm91bmRzID0gcm91bmRzRnVsbCArIHJvdW5kc1BhcnRpYWw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJjKSB8fCByYy5sZW5ndGggIT09IHJvdW5kcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NlaWRvbjogd3Jvbmcgcm91bmQgY29uc3RhbnRzJyk7XG4gICAgY29uc3Qgcm91bmRDb25zdGFudHMgPSByYy5tYXAoKHJjKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYykgfHwgcmMubGVuZ3RoICE9PSB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiB3cm9uZyByb3VuZCBjb25zdGFudHM6ICR7cmN9YCk7XG4gICAgICAgIHJldHVybiByYy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcgfHwgIUZwLmlzVmFsaWQoaSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiB3cm9uZyByb3VuZCBjb25zdGFudD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gRnAuY3JlYXRlKGkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIXNib3hQb3dlciB8fCAhWzMsIDUsIDddLmluY2x1ZGVzKHNib3hQb3dlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gd3Jvbmcgc2JveFBvd2VyPSR7c2JveFBvd2VyfWApO1xuICAgIGNvbnN0IF9zYm94UG93ZXIgPSBCaWdJbnQoc2JveFBvd2VyKTtcbiAgICBsZXQgc2JveEZuID0gKG4pID0+IEZwUG93KEZwLCBuLCBfc2JveFBvd2VyKTtcbiAgICAvLyBVbndyYXBwZWQgc2JveCBwb3dlciBmb3IgY29tbW9uIGNhc2VzICgxOTUtPjE0Ms68cylcbiAgICBpZiAoc2JveFBvd2VyID09PSAzKVxuICAgICAgICBzYm94Rm4gPSAobikgPT4gRnAubXVsKEZwLnNxck4obiksIG4pO1xuICAgIGVsc2UgaWYgKHNib3hQb3dlciA9PT0gNSlcbiAgICAgICAgc2JveEZuID0gKG4pID0+IEZwLm11bChGcC5zcXJOKEZwLnNxck4obikpLCBuKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMsIHJvdW5kcywgc2JveEZuLCByb3VuZENvbnN0YW50cywgbWRzOiBfbWRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0Q29uc3RhbnRzKHJjLCB0KSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NlaWRvblNwbGl0Q29uc3RhbnRzOiB3cm9uZyB0Jyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJjKSB8fCByYy5sZW5ndGggJSB0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2VpZG9uU3BsaXRDb25zdGFudHM6IHdyb25nIHJjJyk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IHRtcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG1wLnB1c2gocmNbaV0pO1xuICAgICAgICBpZiAodG1wLmxlbmd0aCA9PT0gdCkge1xuICAgICAgICAgICAgcmVzLnB1c2godG1wKTtcbiAgICAgICAgICAgIHRtcCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb24ob3B0cykge1xuICAgIGNvbnN0IF9vcHRzID0gdmFsaWRhdGVPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAsIG1kcywgcm91bmRDb25zdGFudHMsIHJvdW5kcywgcm91bmRzUGFydGlhbCwgc2JveEZuLCB0IH0gPSBfb3B0cztcbiAgICBjb25zdCBoYWxmUm91bmRzRnVsbCA9IF9vcHRzLnJvdW5kc0Z1bGwgLyAyO1xuICAgIGNvbnN0IHBhcnRpYWxJZHggPSBfb3B0cy5yZXZlcnNlUGFydGlhbFBvd0lkeCA/IHQgLSAxIDogMDtcbiAgICBjb25zdCBwb3NlaWRvblJvdW5kID0gKHZhbHVlcywgaXNGdWxsLCBpZHgpID0+IHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSwgaikgPT4gRnAuYWRkKGksIHJvdW5kQ29uc3RhbnRzW2lkeF1bal0pKTtcbiAgICAgICAgaWYgKGlzRnVsbClcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKGkpID0+IHNib3hGbihpKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbHVlc1twYXJ0aWFsSWR4XSA9IHNib3hGbih2YWx1ZXNbcGFydGlhbElkeF0pO1xuICAgICAgICAvLyBNYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICAgICAgdmFsdWVzID0gbWRzLm1hcCgoaSkgPT4gaS5yZWR1Y2UoKGFjYywgaSwgaikgPT4gRnAuYWRkKGFjYywgRnAubXVsTihpLCB2YWx1ZXNbal0pKSwgRnAuWkVSTykpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgY29uc3QgcG9zZWlkb25IYXNoID0gZnVuY3Rpb24gcG9zZWlkb25IYXNoKHZhbHVlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoICE9PSB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgdmFsdWVzIChleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzIHdpdGggbGVuZ3RoICR7dH0pYCk7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgdmFsdWU9JHtpfSAoJHt0eXBlb2YgaX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gRnAuY3JlYXRlKGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJvdW5kID0gMDtcbiAgICAgICAgLy8gQXBwbHkgcl9mLzIgZnVsbCByb3VuZHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFsZlJvdW5kc0Z1bGw7IGkrKylcbiAgICAgICAgICAgIHZhbHVlcyA9IHBvc2VpZG9uUm91bmQodmFsdWVzLCB0cnVlLCByb3VuZCsrKTtcbiAgICAgICAgLy8gQXBwbHkgcl9wIHBhcnRpYWwgcm91bmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kc1BhcnRpYWw7IGkrKylcbiAgICAgICAgICAgIHZhbHVlcyA9IHBvc2VpZG9uUm91bmQodmFsdWVzLCBmYWxzZSwgcm91bmQrKyk7XG4gICAgICAgIC8vIEFwcGx5IHJfZi8yIGZ1bGwgcm91bmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbGZSb3VuZHNGdWxsOyBpKyspXG4gICAgICAgICAgICB2YWx1ZXMgPSBwb3NlaWRvblJvdW5kKHZhbHVlcywgdHJ1ZSwgcm91bmQrKyk7XG4gICAgICAgIGlmIChyb3VuZCAhPT0gcm91bmRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgbnVtYmVyIG9mIHJvdW5kczogbGFzdCByb3VuZD0ke3JvdW5kfSwgdG90YWw9JHtyb3VuZHN9YCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICAvLyBGb3IgdmVyaWZpY2F0aW9uIGluIHRlc3RzXG4gICAgcG9zZWlkb25IYXNoLnJvdW5kQ29uc3RhbnRzID0gcm91bmRDb25zdGFudHM7XG4gICAgcmV0dXJuIHBvc2VpZG9uSGFzaDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvc2VpZG9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    let res = new Uint8Array(sum);\n    let pad = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25ELDhEQUE4RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsV0FBVyxjQUFjLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0J5dGVzKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGlmICghaXNCeXRlcyhhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGxldCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGxldCBwYWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(data))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNvQztBQUNIO0FBQ1E7QUFDUTtBQUNqRDtBQUNBLGlCQUFpQix3REFBYTtBQUM5QixJQUFJLHFEQUFpQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QyxFQUFFLHNDQUFFO0FBQzdDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxhQUFhLDhDQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxHQUFHLEVBQUUsRUFBRTtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxLQUFLLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFjO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBb0U7QUFDcEY7QUFDQSxnQkFBZ0IsOENBQVU7QUFDMUIsc0JBQXNCLGlEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFrQixDQUFDLHNEQUFXO0FBQ3BEO0FBQ0E7QUFDQSxtREFBbUQsYUFBYSw0QkFBNEIsV0FBVztBQUN2RztBQUNBO0FBQ0Esa0JBQWtCLDRDQUFPLFVBQVU7QUFDbkMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNEQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0MsMERBQTBEO0FBQzFELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IseUJBQXlCO0FBQzdDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DLHNCQUFzQixpQkFBaUI7QUFDdkMsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ087QUFDUDtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLGVBQWUsNENBQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsK0NBQVU7QUFDekI7QUFDQSxZQUFZLDJGQUEyRjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFrQjtBQUM1QztBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyx3QkFBd0IsZUFBZSxzQkFBc0IsaUJBQWlCO0FBQ3RJO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxtQ0FBbUMsaURBQWEsQ0FBQyxzREFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzREFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPLFlBQVksc0RBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLG9DQUFvQyxzREFBVyx1QkFBdUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQyxrRUFBa0U7QUFDbEU7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFhO0FBQ2hDO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBb0I7QUFDL0MsbUJBQW1CLHVEQUFrQjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBa0IsU0FBUztBQUNuRCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQSxlQUFlLHNEQUFrQjtBQUNqQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEMsY0FBYyxtQ0FBbUMsUUFBUTtBQUN6RDtBQUNBLHlCQUF5QjtBQUN6QixrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQSxzQkFBc0Isc0RBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsMEJBQTBCLHNEQUFXLHNCQUFzQjtBQUMzRDtBQUNBLHFCQUFxQixrREFBYyxlQUFlO0FBQ2xELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLHlEQUF5RDtBQUN6RCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWMsbUNBQW1DO0FBQ2pFO0FBQ0EscUJBQXFCLHFEQUFpQjtBQUN0QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLG9CQUFvQixzREFBVztBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsOENBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QiwwQ0FBMEM7QUFDMUMsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQSxrQkFBa0I7QUFDbEIsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsNENBQTRDO0FBQzVDO0FBQ0Esc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQix3Q0FBd0M7QUFDeEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEMsK0JBQStCO0FBQy9CLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHVDQUF1QztBQUN2QztBQUNBLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxrQ0FBa0M7QUFDbEMsdUNBQXVDO0FBQ3ZDLCtDQUErQyxrQkFBa0I7QUFDakUseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQyxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHNEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1FQUFtRTtBQUNuRSxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDeEQsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRCx1Q0FBdUM7QUFDdkMsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuaW1wb3J0ICogYXMgbW9kIGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIXV0LmlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYXNzZXJ0R0UgaGVyZVxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbW9kLmdldE1pbkhhc2hMZW5ndGgoQ1VSVkUubik7XG4gICAgICAgICAgICByZXR1cm4gbW9kLm1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBwcmVjb21wdXRlIHRhYmxlIGZvciBhbiBhcmJpdHJhcnkgRUMgcG9pbnQuIE1ha2VzIHBvaW50IFwiY2FjaGVkXCIuXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxuICAgICAgICAgKiBAcmV0dXJucyBjYWNoZWQgcG9pbnRcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcbiAgICAgICAgICogZmFzdC5tdWx0aXBseShwcml2S2V5KTsgLy8gbXVjaCBmYXN0ZXIgRUNESCBub3dcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpOyAvLyAzIGlzIGFyYml0cmFyeSwganVzdCBuZWVkIGFueSBudW1iZXIgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIFB1YmxpYyBrZXksIGZ1bGwgd2hlbiBpc0NvbXByZXNzZWQ9ZmFsc2U7IHNob3J0IHdoZW4gaXNDb21wcmVzc2VkPXRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICBjb25zdCBhcnIgPSB1dC5pc0J5dGVzKGl0ZW0pO1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCB1dC5pc0J5dGVzKHNnKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQixpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuLy8gY29waWVkIGZyb20gdXRpbHNcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgZnJvbUJpZywgc3BsaXQsIHRvQmlnLCBzaHJTSCwgc2hyU0wsIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCwgcm90cjMySCwgcm90cjMyTCwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLCBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNyRDtBQUMzQztBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsb0JBQW9CLGtEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCLFFBQVEsaURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2lCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ0s7QUFDNEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4Q0FBSztBQUN4RDtBQUNBLHFDQUFxQywrQ0FBTSxZQUFZLCtDQUFNO0FBQzdELHFDQUFxQywrQ0FBTSxZQUFZLCtDQUFNO0FBQzdEO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLGtCQUFrQjtBQUNsQyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGlEQUFLO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFlO0FBQ3JEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1Asa0RBQWtELHFFQUEwQixXQUFXO0FBQ2hGO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG4vLyBPdGhlciBsaWJyYXJpZXMgd291bGQgc2lsZW50bHkgY29ycnVwdCB0aGUgZGF0YSBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yLFxuLy8gd2hlbiB0aGV5IGRvbid0IHN1cHBvcnQgaXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBpZiAoIWlzQnl0ZXMoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Permission: () => (/* binding */ Permission)\n/* harmony export */ });\nconst Permission = {\n    ACCOUNTS: 'accounts',\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtaW8vdHlwZXMtanMvZGlzdC9lc20vd2FsbGV0LWFwaS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdGFya25ldC1pby90eXBlcy1qcy9kaXN0L2VzbS93YWxsZXQtYXBpL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgUGVybWlzc2lvbiA9IHtcbiAgICBBQ0NPVU5UUzogJ2FjY291bnRzJyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@starknet-react/chains/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@starknet-react/chains/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devnet: () => (/* binding */ devnet),\n/* harmony export */   getSlotChain: () => (/* binding */ getSlotChain),\n/* harmony export */   mainnet: () => (/* binding */ mainnet),\n/* harmony export */   sepolia: () => (/* binding */ sepolia)\n/* harmony export */ });\n// src/devnet.ts\nvar devnet = {\n  id: BigInt(\"0x534e5f5345504f4c4941\"),\n  network: \"devnet\",\n  name: \"Starknet Devnet\",\n  nativeCurrency: {\n    address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  testnet: true,\n  rpcUrls: {\n    default: {\n      http: []\n    },\n    public: {\n      http: [\"http://localhost:5050/rpc\"]\n    }\n  }\n};\n\n// src/starknet.ts\nvar mainnet = {\n  id: BigInt(\"0x534e5f4d41494e\"),\n  network: \"mainnet\",\n  name: \"Starknet\",\n  nativeCurrency: {\n    address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  rpcUrls: {\n    alchemy: {\n      http: [\"https://starknet-mainnet.g.alchemy.com/v2\"]\n    },\n    blast: {\n      http: [\"https://starknet-mainnet.blastapi.io\"]\n    },\n    infura: {\n      http: [\"https://starknet-mainnet.infura.io/v3\"]\n    },\n    lava: {\n      http: [\"https://g.w.lavanet.xyz:443/gateway/strk/rpc-http\"]\n    },\n    nethermind: {\n      http: [\"https://rpc.nethermind.io/mainnet-juno\"]\n    },\n    reddio: {\n      http: [\"https://starknet-mainnet.reddio.com\"]\n    },\n    cartridge: {\n      http: [\"https://api.cartridge.gg/x/starknet/mainnet\"]\n    },\n    default: {\n      http: []\n    },\n    public: {\n      http: [\n        \"https://starknet-mainnet.public.blastapi.io/rpc/v0_7\",\n        \"https://rpc.starknet.lava.build\",\n        \"https://free-rpc.nethermind.io/mainnet-juno/v0_7\"\n      ]\n    }\n  },\n  explorers: {\n    starkCompass: [\"https://www.starkcompass.com\"],\n    starkscan: [\"https://starkscan.co\"],\n    viewblock: [\"https://viewblock.io/starknet\"],\n    voyager: [\"https://voyager.online\"]\n  }\n};\nvar sepolia = {\n  id: BigInt(\"0x534e5f5345504f4c4941\"),\n  network: \"sepolia\",\n  name: \"Starknet Sepolia Testnet\",\n  nativeCurrency: {\n    address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  testnet: true,\n  rpcUrls: {\n    blast: {\n      http: [\"https://starknet-sepolia.blastapi.io\"]\n    },\n    infura: {\n      http: [\"https://starknet-sepolia.infura.io/v3\"]\n    },\n    nethermind: {\n      http: [\"https://rpc.nethermind.io/sepolia-juno\"]\n    },\n    reddio: {\n      http: [\"https://starknet-sepolia.reddio.com\"]\n    },\n    cartridge: {\n      http: [\"https://api.cartridge.gg/x/starknet/sepolia\"]\n    },\n    default: {\n      http: []\n    },\n    public: {\n      http: [\n        \"https://starknet-sepolia.public.blastapi.io\",\n        \"https://free-rpc.nethermind.io/sepolia-juno\"\n      ]\n    }\n  },\n  explorers: {\n    starkscan: [\"https://sepolia.starkscan.co\"],\n    voyager: [\"https://sepolia.voyager.online\"]\n  }\n};\n\n// src/slot.ts\nfunction getSlotChain(projectId) {\n  return {\n    id: BigInt(projectId),\n    network: `slot-${projectId}`,\n    name: `${projectId}`,\n    nativeCurrency: {\n      address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18\n    },\n    testnet: true,\n    rpcUrls: {\n      default: {\n        http: []\n      },\n      public: {\n        http: [`https://api.cartridge.gg/x/${projectId}/katana`]\n      }\n    }\n  };\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtcmVhY3QvY2hhaW5zL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0IsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN0YXJrbmV0LXJlYWN0L2NoYWlucy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kZXZuZXQudHNcbnZhciBkZXZuZXQgPSB7XG4gIGlkOiBCaWdJbnQoXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIpLFxuICBuZXR3b3JrOiBcImRldm5ldFwiLFxuICBuYW1lOiBcIlN0YXJrbmV0IERldm5ldFwiLFxuICBuYXRpdmVDdXJyZW5jeToge1xuICAgIGFkZHJlc3M6IFwiMHgwNDlkMzY1NzBkNGU0NmY0OGU5OTY3NGJkM2ZjYzg0NjQ0ZGRkNmI5NmY3Yzc0MWIxNTYyYjgyZjllMDA0ZGM3XCIsXG4gICAgbmFtZTogXCJFdGhlclwiLFxuICAgIHN5bWJvbDogXCJFVEhcIixcbiAgICBkZWNpbWFsczogMThcbiAgfSxcbiAgdGVzdG5ldDogdHJ1ZSxcbiAgcnBjVXJsczoge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGh0dHA6IFtdXG4gICAgfSxcbiAgICBwdWJsaWM6IHtcbiAgICAgIGh0dHA6IFtcImh0dHA6Ly9sb2NhbGhvc3Q6NTA1MC9ycGNcIl1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9zdGFya25ldC50c1xudmFyIG1haW5uZXQgPSB7XG4gIGlkOiBCaWdJbnQoXCIweDUzNGU1ZjRkNDE0OTRlXCIpLFxuICBuZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgbmFtZTogXCJTdGFya25ldFwiLFxuICBuYXRpdmVDdXJyZW5jeToge1xuICAgIGFkZHJlc3M6IFwiMHgwNDlkMzY1NzBkNGU0NmY0OGU5OTY3NGJkM2ZjYzg0NjQ0ZGRkNmI5NmY3Yzc0MWIxNTYyYjgyZjllMDA0ZGM3XCIsXG4gICAgbmFtZTogXCJFdGhlclwiLFxuICAgIHN5bWJvbDogXCJFVEhcIixcbiAgICBkZWNpbWFsczogMThcbiAgfSxcbiAgcnBjVXJsczoge1xuICAgIGFsY2hlbXk6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyXCJdXG4gICAgfSxcbiAgICBibGFzdDoge1xuICAgICAgaHR0cDogW1wiaHR0cHM6Ly9zdGFya25ldC1tYWlubmV0LmJsYXN0YXBpLmlvXCJdXG4gICAgfSxcbiAgICBpbmZ1cmE6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5pbmZ1cmEuaW8vdjNcIl1cbiAgICB9LFxuICAgIGxhdmE6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vZy53LmxhdmFuZXQueHl6OjQ0My9nYXRld2F5L3N0cmsvcnBjLWh0dHBcIl1cbiAgICB9LFxuICAgIG5ldGhlcm1pbmQ6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vcnBjLm5ldGhlcm1pbmQuaW8vbWFpbm5ldC1qdW5vXCJdXG4gICAgfSxcbiAgICByZWRkaW86IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5yZWRkaW8uY29tXCJdXG4gICAgfSxcbiAgICBjYXJ0cmlkZ2U6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vYXBpLmNhcnRyaWRnZS5nZy94L3N0YXJrbmV0L21haW5uZXRcIl1cbiAgICB9LFxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGh0dHA6IFtdXG4gICAgfSxcbiAgICBwdWJsaWM6IHtcbiAgICAgIGh0dHA6IFtcbiAgICAgICAgXCJodHRwczovL3N0YXJrbmV0LW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy92MF83XCIsXG4gICAgICAgIFwiaHR0cHM6Ly9ycGMuc3RhcmtuZXQubGF2YS5idWlsZFwiLFxuICAgICAgICBcImh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9tYWlubmV0LWp1bm8vdjBfN1wiXG4gICAgICBdXG4gICAgfVxuICB9LFxuICBleHBsb3JlcnM6IHtcbiAgICBzdGFya0NvbXBhc3M6IFtcImh0dHBzOi8vd3d3LnN0YXJrY29tcGFzcy5jb21cIl0sXG4gICAgc3RhcmtzY2FuOiBbXCJodHRwczovL3N0YXJrc2Nhbi5jb1wiXSxcbiAgICB2aWV3YmxvY2s6IFtcImh0dHBzOi8vdmlld2Jsb2NrLmlvL3N0YXJrbmV0XCJdLFxuICAgIHZveWFnZXI6IFtcImh0dHBzOi8vdm95YWdlci5vbmxpbmVcIl1cbiAgfVxufTtcbnZhciBzZXBvbGlhID0ge1xuICBpZDogQmlnSW50KFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiKSxcbiAgbmV0d29yazogXCJzZXBvbGlhXCIsXG4gIG5hbWU6IFwiU3RhcmtuZXQgU2Vwb2xpYSBUZXN0bmV0XCIsXG4gIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgYWRkcmVzczogXCIweDA0OWQzNjU3MGQ0ZTQ2ZjQ4ZTk5Njc0YmQzZmNjODQ2NDRkZGQ2Yjk2ZjdjNzQxYjE1NjJiODJmOWUwMDRkYzdcIixcbiAgICBuYW1lOiBcIkV0aGVyXCIsXG4gICAgc3ltYm9sOiBcIkVUSFwiLFxuICAgIGRlY2ltYWxzOiAxOFxuICB9LFxuICB0ZXN0bmV0OiB0cnVlLFxuICBycGNVcmxzOiB7XG4gICAgYmxhc3Q6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vc3RhcmtuZXQtc2Vwb2xpYS5ibGFzdGFwaS5pb1wiXVxuICAgIH0sXG4gICAgaW5mdXJhOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3N0YXJrbmV0LXNlcG9saWEuaW5mdXJhLmlvL3YzXCJdXG4gICAgfSxcbiAgICBuZXRoZXJtaW5kOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3JwYy5uZXRoZXJtaW5kLmlvL3NlcG9saWEtanVub1wiXVxuICAgIH0sXG4gICAgcmVkZGlvOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3N0YXJrbmV0LXNlcG9saWEucmVkZGlvLmNvbVwiXVxuICAgIH0sXG4gICAgY2FydHJpZGdlOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL2FwaS5jYXJ0cmlkZ2UuZ2cveC9zdGFya25ldC9zZXBvbGlhXCJdXG4gICAgfSxcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXVxuICAgIH0sXG4gICAgcHVibGljOiB7XG4gICAgICBodHRwOiBbXG4gICAgICAgIFwiaHR0cHM6Ly9zdGFya25ldC1zZXBvbGlhLnB1YmxpYy5ibGFzdGFwaS5pb1wiLFxuICAgICAgICBcImh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9zZXBvbGlhLWp1bm9cIlxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgZXhwbG9yZXJzOiB7XG4gICAgc3RhcmtzY2FuOiBbXCJodHRwczovL3NlcG9saWEuc3RhcmtzY2FuLmNvXCJdLFxuICAgIHZveWFnZXI6IFtcImh0dHBzOi8vc2Vwb2xpYS52b3lhZ2VyLm9ubGluZVwiXVxuICB9XG59O1xuXG4vLyBzcmMvc2xvdC50c1xuZnVuY3Rpb24gZ2V0U2xvdENoYWluKHByb2plY3RJZCkge1xuICByZXR1cm4ge1xuICAgIGlkOiBCaWdJbnQocHJvamVjdElkKSxcbiAgICBuZXR3b3JrOiBgc2xvdC0ke3Byb2plY3RJZH1gLFxuICAgIG5hbWU6IGAke3Byb2plY3RJZH1gLFxuICAgIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgICBhZGRyZXNzOiBcIjB4MDQ5ZDM2NTcwZDRlNDZmNDhlOTk2NzRiZDNmY2M4NDY0NGRkZDZiOTZmN2M3NDFiMTU2MmI4MmY5ZTAwNGRjN1wiLFxuICAgICAgbmFtZTogXCJFdGhlclwiLFxuICAgICAgc3ltYm9sOiBcIkVUSFwiLFxuICAgICAgZGVjaW1hbHM6IDE4XG4gICAgfSxcbiAgICB0ZXN0bmV0OiB0cnVlLFxuICAgIHJwY1VybHM6IHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaHR0cDogW11cbiAgICAgIH0sXG4gICAgICBwdWJsaWM6IHtcbiAgICAgICAgaHR0cDogW2BodHRwczovL2FwaS5jYXJ0cmlkZ2UuZ2cveC8ke3Byb2plY3RJZH0va2F0YW5hYF1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBkZXZuZXQsXG4gIGdldFNsb3RDaGFpbixcbiAgbWFpbm5ldCxcbiAgc2Vwb2xpYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@starknet-react/chains/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@starknet-react/core/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@starknet-react/core/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Connector: () => (/* binding */ Connector),\n/* harmony export */   ConnectorAlreadyConnectedError: () => (/* binding */ ConnectorAlreadyConnectedError),\n/* harmony export */   ConnectorNotConnectedError: () => (/* binding */ ConnectorNotConnectedError),\n/* harmony export */   ConnectorNotFoundError: () => (/* binding */ ConnectorNotFoundError),\n/* harmony export */   InjectedConnector: () => (/* binding */ InjectedConnector),\n/* harmony export */   LegacyInjectedConnector: () => (/* binding */ LegacyInjectedConnector),\n/* harmony export */   MockConnector: () => (/* binding */ MockConnector),\n/* harmony export */   OverrideAccount: () => (/* binding */ AccountProvider),\n/* harmony export */   StarknetConfig: () => (/* binding */ StarknetConfig),\n/* harmony export */   StarkscanExplorer: () => (/* binding */ StarkscanExplorer),\n/* harmony export */   UnsupportedAccountInterfaceError: () => (/* binding */ UnsupportedAccountInterfaceError),\n/* harmony export */   UserNotConnectedError: () => (/* binding */ UserNotConnectedError),\n/* harmony export */   UserRejectedRequestError: () => (/* binding */ UserRejectedRequestError),\n/* harmony export */   ViewblockExplorer: () => (/* binding */ ViewblockExplorer),\n/* harmony export */   VoyagerExplorer: () => (/* binding */ VoyagerExplorer),\n/* harmony export */   alchemyProvider: () => (/* binding */ alchemyProvider),\n/* harmony export */   argent: () => (/* binding */ argent),\n/* harmony export */   blastProvider: () => (/* binding */ blastProvider),\n/* harmony export */   braavos: () => (/* binding */ braavos),\n/* harmony export */   cartridgeProvider: () => (/* binding */ cartridgeProvider),\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   infuraProvider: () => (/* binding */ infuraProvider),\n/* harmony export */   injected: () => (/* binding */ injected),\n/* harmony export */   jsonRpcProvider: () => (/* binding */ jsonRpcProvider),\n/* harmony export */   lavaProvider: () => (/* binding */ lavaProvider),\n/* harmony export */   legacyInjected: () => (/* binding */ legacyInjected),\n/* harmony export */   nethermindProvider: () => (/* binding */ nethermindProvider),\n/* harmony export */   publicProvider: () => (/* binding */ publicProvider),\n/* harmony export */   reddioProvider: () => (/* binding */ reddioProvider),\n/* harmony export */   slotProvider: () => (/* binding */ slotProvider),\n/* harmony export */   starknetChainId: () => (/* binding */ starknetChainId),\n/* harmony export */   starkscan: () => (/* binding */ starkscan),\n/* harmony export */   useAccount: () => (/* binding */ useAccount),\n/* harmony export */   useAddChain: () => (/* binding */ useAddChain),\n/* harmony export */   useBalance: () => (/* binding */ useBalance),\n/* harmony export */   useBlock: () => (/* binding */ useBlock),\n/* harmony export */   useBlockNumber: () => (/* binding */ useBlockNumber),\n/* harmony export */   useCall: () => (/* binding */ useCall),\n/* harmony export */   useConnect: () => (/* binding */ useConnect),\n/* harmony export */   useContract: () => (/* binding */ useContract),\n/* harmony export */   useContractFactory: () => (/* binding */ useContractFactory),\n/* harmony export */   useDeclareContract: () => (/* binding */ useDeclareContract),\n/* harmony export */   useDeployAccount: () => (/* binding */ useDeployAccount),\n/* harmony export */   useDisconnect: () => (/* binding */ useDisconnect),\n/* harmony export */   useEstimateFees: () => (/* binding */ useEstimateFees),\n/* harmony export */   useEvents: () => (/* binding */ useEvents),\n/* harmony export */   useExplorer: () => (/* binding */ useExplorer),\n/* harmony export */   useInjectedConnectors: () => (/* binding */ useInjectedConnectors),\n/* harmony export */   useInvalidateOnBlock: () => (/* binding */ useInvalidateOnBlock),\n/* harmony export */   useNetwork: () => (/* binding */ useNetwork),\n/* harmony export */   useNonceForAddress: () => (/* binding */ useNonceForAddress),\n/* harmony export */   useProvider: () => (/* binding */ useProvider),\n/* harmony export */   useReadContract: () => (/* binding */ useReadContract),\n/* harmony export */   useSendTransaction: () => (/* binding */ useSendTransaction),\n/* harmony export */   useSignTypedData: () => (/* binding */ useSignTypedData),\n/* harmony export */   useStarkAddress: () => (/* binding */ useStarkAddress),\n/* harmony export */   useStarkName: () => (/* binding */ useStarkName),\n/* harmony export */   useStarkProfile: () => (/* binding */ useStarkProfile),\n/* harmony export */   useSwitchChain: () => (/* binding */ useSwitchChain),\n/* harmony export */   useTransactionReceipt: () => (/* binding */ useTransactionReceipt),\n/* harmony export */   useUniversalDeployerContract: () => (/* binding */ useUniversalDeployerContract),\n/* harmony export */   useWalletRequest: () => (/* binding */ useWalletRequest),\n/* harmony export */   useWatchAsset: () => (/* binding */ useWatchAsset),\n/* harmony export */   viewblock: () => (/* binding */ viewblock),\n/* harmony export */   voyager: () => (/* binding */ voyager)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @starknet-io/types-js */ \"(app-pages-browser)/./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"(app-pages-browser)/./node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @starknet-react/chains */ \"(app-pages-browser)/./node_modules/@starknet-react/chains/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useMutation.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/connectors/base.ts\n\nvar Connector = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n};\n\n// src/connectors/injected.ts\n\n\n\n// src/errors.ts\nvar ConnectorAlreadyConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"ConnectorAlreadyConnectedError\");\n    __publicField(this, \"message\", \"Connector already connected\");\n  }\n};\nvar ConnectorNotConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"ConnectorNotConnectedError\");\n    __publicField(this, \"message\", \"Connector not connected\");\n  }\n};\nvar ConnectorNotFoundError = class extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"ConnectorNotFoundError\");\n    __publicField(this, \"message\", \"Connector not found\");\n  }\n};\nvar UserRejectedRequestError = class extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"UserRejectedRequestError\");\n    __publicField(this, \"message\", \"User rejected request\");\n  }\n};\nvar UserNotConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"UserNotConnectedError\");\n    __publicField(this, \"message\", \"User not connected\");\n  }\n};\nvar UnsupportedAccountInterfaceError = class extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"UnsupportedAccountInterfaceError\");\n    __publicField(this, \"message\", \"Unsupported account interface. starknet-react v1 only supports the starknet.js v5 account interface\");\n  }\n};\n\n// src/connectors/injected.ts\nvar WALLET_NOT_FOUND_ICON_LIGHT = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+\";\nvar WALLET_NOT_FOUND_ICON_DARK = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==\";\nvar walletIcons = {\n  argentX: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2NS4xOTUwOCA1Ny43MzU2MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjUuMTk1MDggNTcuNzM1NjI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkY4NzVCO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTQwLjk4NTkyLDBIMjQuMjA4ODhjLTAuNTYsMC0xLjAxMDAxLDAuNDUxMDItMS4wMjE5NywxLjAxMjAyCgljLTAuMzM4OTksMTUuNzU1LTguNTgyMDMsMzAuNzA4OTgtMjIuNzcwMDIsNDEuMzAwOTljLTAuNDUwMDEsMC4zMzcwMS0wLjU1Mjk4LDAuOTY3OTktMC4yMjQsMS40MjNsOS44MTU5OCwxMy41NzMKCWMwLjMzNDA1LDAuNDYyMDEsMC45ODUwNSwwLjU2NTk4LDEuNDQyOTksMC4yMjY5OWM4Ljg3MTAzLTYuNTc5MDEsMTYuMDA3MDItMTQuNTE3LDIxLjE0NjA2LTIzLjMxNQoJYzUuMTM4LDguNzk4LDEyLjI3Mzk5LDE2LjczNTk5LDIxLjE0NiwyMy4zMTVjMC40NTY5NywwLjMzODk5LDEuMTA3OTcsMC4yMzUwMiwxLjQ0MTk2LTAuMjI2OTlsOS44MTYwNC0xMy41NzMKCWMwLjMyODk4LTAuNDU1MDIsMC4yMjY5OS0xLjA4Ni0wLjIyNC0xLjQyM0M1MC41ODk4NiwzMS43MjEwMSw0Mi4zNDY4OCwxNi43NjcwMyw0Mi4wMDc4OSwxLjAxMjAyCglDNDEuOTk1ODcsMC40NTEwMiw0MS41NDY4OSwwLDQwLjk4NTkyLDAiLz4KPC9zdmc+Cg==\",\n  braavos: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=\"\n};\nvar InjectedConnector = class extends Connector {\n  constructor({ options }) {\n    super();\n    __publicField(this, \"_wallet\");\n    __publicField(this, \"_options\");\n    this._options = options;\n  }\n  get id() {\n    return this._options.id;\n  }\n  get name() {\n    this.ensureWallet();\n    return this._options.name ?? this._wallet?.name ?? this._options.id;\n  }\n  get icon() {\n    this.ensureWallet();\n    const deafultIcon = {\n      dark: walletIcons[this.id] || WALLET_NOT_FOUND_ICON_DARK,\n      light: walletIcons[this.id] || WALLET_NOT_FOUND_ICON_LIGHT\n    };\n    return this._options.icon || this._wallet?.icon || deafultIcon;\n  }\n  available() {\n    this.ensureWallet();\n    return this._wallet !== void 0;\n  }\n  async chainId() {\n    this.ensureWallet();\n    const locked = await this.isLocked();\n    if (!this._wallet || locked) {\n      throw new ConnectorNotConnectedError();\n    }\n    try {\n      return this.requestChainId();\n    } catch {\n      throw new ConnectorNotFoundError();\n    }\n  }\n  async ready() {\n    this.ensureWallet();\n    if (!this._wallet) return false;\n    const permissions = await this.request({\n      type: \"wallet_getPermissions\"\n    });\n    return permissions?.includes(_starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__.Permission.ACCOUNTS);\n  }\n  async account(provider) {\n    this.ensureWallet();\n    const locked = await this.isLocked();\n    if (locked || !this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n    return new starknet__WEBPACK_IMPORTED_MODULE_1__.WalletAccount(provider, this._wallet);\n  }\n  async connect(_args = {}) {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n    let accounts;\n    try {\n      accounts = await this.request({\n        type: \"wallet_requestAccounts\"\n      });\n    } catch {\n      throw new UserRejectedRequestError();\n    }\n    if (!accounts) {\n      throw new UserRejectedRequestError();\n    }\n    this._wallet.on(\"accountsChanged\", async (accounts2) => {\n      await this.onAccountsChanged(accounts2);\n    });\n    this._wallet.on(\"networkChanged\", (chainId2, accounts2) => {\n      this.onNetworkChanged(chainId2, accounts2);\n    });\n    await this.onAccountsChanged(accounts);\n    const [account] = accounts;\n    const chainId = await this.requestChainId();\n    this.emit(\"connect\", { account, chainId });\n    return {\n      account,\n      chainId\n    };\n  }\n  async disconnect() {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n    this.emit(\"disconnect\");\n  }\n  async request(call) {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n    try {\n      return await this._wallet.request(call);\n    } catch {\n      throw new UserRejectedRequestError();\n    }\n  }\n  async isLocked() {\n    const accounts = await this.request({\n      type: \"wallet_requestAccounts\",\n      params: { silent_mode: true }\n    });\n    return accounts.length === 0;\n  }\n  async requestChainId() {\n    const chainIdHex = await this.request({ type: \"wallet_requestChainId\" });\n    return BigInt(chainIdHex);\n  }\n  ensureWallet() {\n    const global_object = globalThis;\n    const wallet = global_object?.[`starknet_${this._options.id}`];\n    if (wallet) {\n      this._wallet = wallet;\n    }\n  }\n  async onAccountsChanged(accounts) {\n    if (!accounts) {\n      this.emit(\"disconnect\");\n    } else {\n      const [account] = accounts;\n      if (account) {\n        const chainId = await this.requestChainId();\n        this.emit(\"change\", { account, chainId });\n      } else {\n        this.emit(\"disconnect\");\n      }\n    }\n  }\n  onNetworkChanged(chainIdHex, accounts) {\n    if (chainIdHex) {\n      const chainId = BigInt(chainIdHex);\n      const [account] = accounts || [];\n      this.emit(\"change\", { chainId, account });\n    } else {\n      this.emit(\"change\", {});\n    }\n  }\n};\n\n// src/connectors/legacy.ts\n\n\nvar WALLET_NOT_FOUND_ICON_LIGHT2 = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+\";\nvar WALLET_NOT_FOUND_ICON_DARK2 = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==\";\nvar walletIcons2 = {\n  argentX: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2NS4xOTUwOCA1Ny43MzU2MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjUuMTk1MDggNTcuNzM1NjI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkY4NzVCO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTQwLjk4NTkyLDBIMjQuMjA4ODhjLTAuNTYsMC0xLjAxMDAxLDAuNDUxMDItMS4wMjE5NywxLjAxMjAyCgljLTAuMzM4OTksMTUuNzU1LTguNTgyMDMsMzAuNzA4OTgtMjIuNzcwMDIsNDEuMzAwOTljLTAuNDUwMDEsMC4zMzcwMS0wLjU1Mjk4LDAuOTY3OTktMC4yMjQsMS40MjNsOS44MTU5OCwxMy41NzMKCWMwLjMzNDA1LDAuNDYyMDEsMC45ODUwNSwwLjU2NTk4LDEuNDQyOTksMC4yMjY5OWM4Ljg3MTAzLTYuNTc5MDEsMTYuMDA3MDItMTQuNTE3LDIxLjE0NjA2LTIzLjMxNQoJYzUuMTM4LDguNzk4LDEyLjI3Mzk5LDE2LjczNTk5LDIxLjE0NiwyMy4zMTVjMC40NTY5NywwLjMzODk5LDEuMTA3OTcsMC4yMzUwMiwxLjQ0MTk2LTAuMjI2OTlsOS44MTYwNC0xMy41NzMKCWMwLjMyODk4LTAuNDU1MDIsMC4yMjY5OS0xLjA4Ni0wLjIyNC0xLjQyM0M1MC41ODk4NiwzMS43MjEwMSw0Mi4zNDY4OCwxNi43NjcwMyw0Mi4wMDc4OSwxLjAxMjAyCglDNDEuOTk1ODcsMC40NTEwMiw0MS41NDY4OSwwLDQwLjk4NTkyLDAiLz4KPC9zdmc+Cg==\",\n  braavos: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=\"\n};\nvar LegacyInjectedConnector = class extends Connector {\n  constructor({ options }) {\n    super();\n    __publicField(this, \"_wallet\");\n    __publicField(this, \"_options\");\n    this._options = options;\n  }\n  get id() {\n    return this._options.id;\n  }\n  get name() {\n    return this._options.name ?? this._wallet?.name ?? this._options.id;\n  }\n  get icon() {\n    const defaultIcon = {\n      dark: walletIcons2[this.id] || WALLET_NOT_FOUND_ICON_DARK2,\n      light: walletIcons2[this.id] || WALLET_NOT_FOUND_ICON_LIGHT2\n    };\n    return this._options.icon || this._wallet?.icon || defaultIcon;\n  }\n  available() {\n    this.ensureWallet();\n    return this._wallet !== void 0;\n  }\n  async chainId() {\n    this.ensureWallet();\n    if (!this._wallet || !this._wallet.provider) {\n      throw new ConnectorNotConnectedError();\n    }\n    const chainIdHex = await this._wallet.provider.getChainId();\n    const chainId = BigInt(chainIdHex);\n    return chainId;\n  }\n  async ready() {\n    this.ensureWallet();\n    if (!this._wallet) return false;\n    return await this._wallet.isPreauthorized();\n  }\n  async connect(_args = {}) {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n    let accounts;\n    try {\n      accounts = await this._wallet.enable({ starknetVersion: \"v5\" });\n    } catch {\n      throw new UserRejectedRequestError();\n    }\n    if (!this._wallet.isConnected || !this._wallet.account || !accounts) {\n      throw new UserRejectedRequestError();\n    }\n    this._wallet.on(\n      \"accountsChanged\",\n      async (accounts2) => {\n        if (!accounts2) return;\n        await this.onAccountsChanged(accounts2);\n      }\n    );\n    this._wallet.on(\"networkChanged\", (network) => {\n      this.onNetworkChanged(network);\n    });\n    await this.onAccountsChanged(accounts);\n    const account = this._wallet.account.address;\n    const chainId = await this.chainId();\n    this.emit(\"connect\", { account, chainId });\n    return {\n      account,\n      chainId\n    };\n  }\n  async disconnect() {\n    this.ensureWallet();\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n    if (!this._wallet?.isConnected) {\n      throw new UserNotConnectedError();\n    }\n    this.emit(\"disconnect\");\n  }\n  async account() {\n    this.ensureWallet();\n    if (!this._wallet || !this._wallet.account) {\n      throw new ConnectorNotConnectedError();\n    }\n    return this._wallet.account;\n  }\n  async request(call) {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n    try {\n      switch (call.type) {\n        case \"wallet_getPermissions\": {\n          if (this._wallet) {\n            return [_starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__.Permission.ACCOUNTS];\n          }\n          return [];\n        }\n        case \"wallet_requestAccounts\": {\n          if (this._wallet.account) {\n            return [this._wallet.account.address];\n          }\n          return [];\n        }\n        case \"wallet_requestChainId\": {\n          if (this._wallet.chainId) {\n            return this._wallet.chainId;\n          }\n          return null;\n        }\n        case \"wallet_addInvokeTransaction\": {\n          if (!this._wallet) {\n            throw new Error(\"Send transaction failed\");\n          }\n          const calls = (call.params.calls ?? []).map(\n            // @ts-ignore\n            ({ calldata, contract_address, entry_point }) => ({\n              calldata,\n              contractAddress: contract_address,\n              entrypoint: entry_point\n            })\n          );\n          return await this._wallet.account?.execute(calls);\n        }\n        default: {\n          throw new Error(`Wallet API method ${call.type} is not supported.`);\n        }\n      }\n    } catch {\n      throw new UserRejectedRequestError();\n    }\n  }\n  ensureWallet() {\n    const installed = getAvailableWallets(globalThis);\n    const wallet = installed.filter((w) => w.id === this._options.id)[0];\n    if (wallet) {\n      this._wallet = wallet;\n    }\n  }\n  async onAccountsChanged(accounts) {\n    let account;\n    if (typeof accounts === \"string\") {\n      account = accounts;\n    } else {\n      account = accounts[0];\n    }\n    if (account) {\n      const chainId = await this.chainId();\n      this.emit(\"change\", { account, chainId });\n    } else {\n      this.emit(\"disconnect\");\n    }\n  }\n  onNetworkChanged(network) {\n    switch (network) {\n      // Argent\n      case \"SN_MAIN\":\n        this.emit(\"change\", { chainId: _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.mainnet.id });\n        break;\n      case \"SN_SEPOLIA\":\n        this.emit(\"change\", { chainId: _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.sepolia.id });\n        break;\n      // Braavos\n      case \"mainnet-alpha\":\n        this.emit(\"change\", { chainId: _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.mainnet.id });\n        break;\n      case \"sepolia-alpha\":\n        this.emit(\"change\", { chainId: _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.sepolia.id });\n        break;\n      default:\n        this.emit(\"change\", {});\n        break;\n    }\n  }\n};\nfunction getAvailableWallets(obj) {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet;\n        }\n      }\n      return wallets;\n    }, {})\n  );\n}\nfunction isWalletObject(wallet) {\n  try {\n    return wallet && [\n      // wallet's must have methods/members, see IStarknetWindowObject\n      \"request\",\n      \"isConnected\",\n      \"provider\",\n      \"enable\",\n      \"isPreauthorized\",\n      \"on\",\n      \"off\",\n      \"version\",\n      \"id\",\n      \"name\",\n      \"icon\"\n    ].every((key) => key in wallet);\n  } catch (err) {\n  }\n  return false;\n}\n\n// src/connectors/discovery.ts\n\n\n// src/connectors/helpers.ts\nfunction argent() {\n  return new InjectedConnector({\n    options: {\n      id: \"argentX\",\n      name: \"Argent X\"\n    }\n  });\n}\nfunction braavos() {\n  return new InjectedConnector({\n    options: {\n      id: \"braavos\",\n      name: \"Braavos\"\n    }\n  });\n}\nfunction injected({ id }) {\n  return new InjectedConnector({\n    options: {\n      id\n    }\n  });\n}\nfunction legacyInjected({\n  id\n}) {\n  return new LegacyInjectedConnector({\n    options: {\n      id\n    }\n  });\n}\n\n// src/connectors/discovery.ts\nfunction useInjectedConnectors({\n  recommended,\n  includeRecommended = \"always\",\n  order = \"alphabetical\",\n  shimLegacyConnectors = []\n}) {\n  const [injectedConnectors, setInjectedConnectors] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)([]);\n  const refreshConnectors = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    const wallets = scanObjectForWallets(window);\n    const connectors2 = wallets.map((wallet) => {\n      if (shimLegacyConnectors.includes(wallet.id)) {\n        return legacyInjected({ id: wallet.id });\n      }\n      return injected({ id: wallet.id });\n    });\n    setInjectedConnectors(connectors2);\n  }, [shimLegacyConnectors.includes]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    refreshConnectors();\n  }, [refreshConnectors]);\n  const connectors = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    return mergeConnectors(injectedConnectors, recommended ?? [], {\n      includeRecommended,\n      order\n    });\n  }, [injectedConnectors, recommended, includeRecommended, order]);\n  return { connectors };\n}\nfunction mergeConnectors(injected2, recommended, {\n  includeRecommended,\n  order\n}) {\n  const injectedIds = new Set(injected2.map((connector) => connector.id));\n  const allConnectors = [...injected2];\n  const shouldAddRecommended = includeRecommended === \"always\" || includeRecommended === \"onlyIfNoConnectors\" && injected2.length === 0;\n  if (shouldAddRecommended) {\n    allConnectors.push(\n      ...recommended.filter((connector) => !injectedIds.has(connector.id))\n    );\n  }\n  if (order === \"random\") {\n    return shuffle(allConnectors);\n  }\n  return allConnectors.sort((a, b) => a.id.localeCompare(b.id));\n}\nfunction shuffle(arr) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\nfunction scanObjectForWallets(obj) {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n        if (isWalletObject2(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet;\n        }\n      }\n      return wallets;\n    }, {})\n  );\n}\nfunction isWalletObject2(wallet) {\n  try {\n    return wallet && [\n      // wallet's must have methods/members, see IStarknetWindowObject\n      \"request\",\n      \"isConnected\",\n      \"provider\",\n      \"enable\",\n      \"isPreauthorized\",\n      \"on\",\n      \"off\",\n      \"version\",\n      \"id\",\n      \"name\",\n      \"icon\"\n    ].every((key) => key in wallet);\n  } catch (err) {\n  }\n  return false;\n}\n\n// src/connectors/mock.ts\n\n\nvar MockConnector = class extends Connector {\n  constructor({\n    accounts,\n    options\n  }) {\n    super();\n    __publicField(this, \"_accounts\");\n    __publicField(this, \"_accountIndex\", 0);\n    __publicField(this, \"_connected\", false);\n    __publicField(this, \"_chainId\", _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.devnet.id);\n    __publicField(this, \"options\");\n    if (accounts.mainnet.length === 0 || accounts.sepolia.length === 0) {\n      throw new Error(\"MockConnector: accounts must not be empty\");\n    }\n    this._accounts = accounts;\n    this.options = options;\n  }\n  switchChain(chainId) {\n    this._chainId = chainId;\n    this._accountIndex = 0;\n    let account;\n    if (this.options.unifiedSwitchAccountAndChain) {\n      account = this._account.address;\n    }\n    this.emit(\"change\", { chainId, account });\n    if (this.options.emitChangeAccountOnChainSwitch ?? true) {\n      this.switchAccount(this._accountIndex);\n    }\n  }\n  switchAccount(accountIndex) {\n    this._accountIndex = accountIndex;\n    this.emit(\"change\", { account: this._account.address });\n  }\n  get id() {\n    return this.options.id;\n  }\n  get name() {\n    return this.options.name;\n  }\n  get icon() {\n    return this.options.icon ?? \"\";\n  }\n  available() {\n    return this.options.available ?? true;\n  }\n  async chainId() {\n    const chainIdHex = await this.request({ type: \"wallet_requestChainId\" });\n    const chainId = BigInt(chainIdHex);\n    return chainId;\n  }\n  async ready() {\n    const permissions = await this.request({\n      type: \"wallet_getPermissions\"\n    });\n    if (!permissions?.includes(_starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__.Permission.ACCOUNTS)) {\n      return false;\n    }\n    return true;\n  }\n  async connect() {\n    if (this.options.failConnect) {\n      throw new UserRejectedRequestError();\n    }\n    this._connected = true;\n    const accounts = await this.request({\n      type: \"wallet_requestAccounts\",\n      params: { silent_mode: true }\n    });\n    const chainId = await this.chainId();\n    const [account] = accounts;\n    return { account, chainId };\n  }\n  async disconnect() {\n    this._connected = false;\n    this.emit(\"disconnect\");\n  }\n  async request(call) {\n    const { type, params } = call;\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n    if (this.options.rejectRequest) {\n      throw new UserRejectedRequestError();\n    }\n    switch (type) {\n      case \"wallet_requestChainId\":\n        return this._chainId.toString();\n      case \"wallet_getPermissions\":\n        if (this._connected) return [_starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__.Permission.ACCOUNTS];\n        return [];\n      case \"wallet_requestAccounts\":\n        return [this._account.address];\n      case \"wallet_addStarknetChain\":\n        return true;\n      case \"wallet_watchAsset\":\n        return true;\n      case \"wallet_switchStarknetChain\": {\n        if (!params) throw new Error(\"Params are missing\");\n        const { chainId } = params;\n        this.switchChain(BigInt(chainId));\n        return true;\n      }\n      case \"wallet_addDeclareTransaction\": {\n        if (!params) throw new Error(\"Params are missing\");\n        const { compiled_class_hash, contract_class, class_hash } = params;\n        return await this._account.declare({\n          compiledClassHash: compiled_class_hash,\n          contract: {\n            ...contract_class,\n            abi: JSON.parse(contract_class.abi)\n          },\n          classHash: class_hash\n        });\n      }\n      case \"wallet_addInvokeTransaction\": {\n        if (!params) throw new Error(\"Params are missing\");\n        const { calls } = params;\n        return await this._account.execute(transformCalls(calls));\n      }\n      case \"wallet_signTypedData\": {\n        if (!params) throw new Error(\"Params are missing\");\n        const { domain, message, primaryType, types } = params;\n        return await this._account.signMessage({\n          domain,\n          message,\n          primaryType,\n          types\n        });\n      }\n      default:\n        throw new Error(\"Unknown request type\");\n    }\n  }\n  async account(provider) {\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n    if (!this._connected) {\n      throw new ConnectorNotConnectedError();\n    }\n    return this._account;\n  }\n  get _account() {\n    let account;\n    if (this._chainId === _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.mainnet.id) {\n      account = this._accounts.mainnet[this._accountIndex];\n    } else {\n      account = this._accounts.sepolia[this._accountIndex];\n    }\n    if (!account) {\n      throw new ConnectorNotConnectedError();\n    }\n    return account;\n  }\n};\nfunction transformCalls(calls) {\n  return calls.map(\n    (call) => ({\n      contractAddress: call.contract_address,\n      entrypoint: call.entry_point,\n      calldata: call.calldata\n    })\n  );\n}\n\n// src/context/starknet.tsx\n\n\n\n\n\n// src/context/account.tsx\n\n\nvar AccountContext = react__WEBPACK_IMPORTED_MODULE_4__.createContext({\n  account: void 0,\n  address: void 0\n});\nfunction useStarknetAccount() {\n  const { account, address } = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(AccountContext);\n  return { account, address };\n}\nfunction AccountProvider({\n  address,\n  account,\n  children\n}) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(AccountContext.Provider, { value: { account, address }, children });\n}\n\n// src/context/starknet.tsx\n\nvar defaultQueryClient = new _tanstack_react_query__WEBPACK_IMPORTED_MODULE_6__.QueryClient();\nvar StarknetContext = (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)(void 0);\nfunction useStarknet() {\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(StarknetContext);\n  if (!state) {\n    throw new Error(\n      \"useStarknet must be used within a StarknetProvider or StarknetConfig\"\n    );\n  }\n  return state;\n}\nfunction useStarknetManager({\n  chains,\n  provider,\n  explorer,\n  connectors = [],\n  autoConnect = false,\n  defaultChainId\n}) {\n  const defaultChain = defaultChainId ? chains.find((c) => c.id === defaultChainId) ?? chains[0] : chains[0];\n  if (defaultChain === void 0) {\n    throw new Error(\"Must provide at least one chain.\");\n  }\n  const seen = /* @__PURE__ */ new Set();\n  for (const chain of chains) {\n    if (seen.has(chain.id)) {\n      throw new Error(`Duplicated chain id found: ${chain.id}`);\n    }\n    seen.add(chain.id);\n  }\n  const { chain: _, provider: defaultProvider } = providerForChain(\n    defaultChain,\n    provider\n  );\n  const connectorRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)();\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)({\n    currentChain: defaultChain,\n    currentProvider: defaultProvider,\n    connectors\n  });\n  const updateChainAndProvider = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(\n    ({ chainId }) => {\n      if (!chainId) return;\n      for (const chain of chains) {\n        if (chain.id === chainId) {\n          const { chain: newChain, provider: newProvider } = providerForChain(\n            chain,\n            provider\n          );\n          setState((state2) => ({\n            ...state2,\n            currentChain: newChain,\n            currentProvider: newProvider\n          }));\n          return;\n        }\n      }\n    },\n    [chains, provider]\n  );\n  const handleConnectorChange = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(\n    async ({ chainId, account: address }) => {\n      if (chainId) {\n        updateChainAndProvider({ chainId });\n      }\n      if (address && connectorRef.current) {\n        setState((state2) => ({\n          ...state2,\n          currentAddress: address\n        }));\n      }\n    },\n    [updateChainAndProvider]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (!connectorRef.current) {\n      setState((state2) => ({\n        ...state2,\n        currentChain: defaultChain,\n        currentProvider: providerForChain(defaultChain, provider).provider\n      }));\n    }\n  }, [defaultChain, provider]);\n  const connect = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(\n    async ({ connector }) => {\n      if (!connector) {\n        throw new Error(\"Must provide a connector.\");\n      }\n      const needsListenerSetup = connectorRef.current?.id !== connector.id;\n      if (needsListenerSetup) {\n        connectorRef.current?.off(\"change\", handleConnectorChange);\n        connectorRef.current?.off(\"disconnect\", disconnect);\n      }\n      try {\n        const { chainId, account: address } = await connector.connect({\n          chainIdHint: defaultChain.id\n        });\n        if (address !== state.currentAddress) {\n          connectorRef.current = connector;\n          setState((state2) => ({\n            ...state2,\n            currentAddress: address\n          }));\n        }\n        if (autoConnect) {\n          localStorage.setItem(\"lastUsedConnector\", connector.id);\n        }\n        if (needsListenerSetup) {\n          connector.on(\"change\", handleConnectorChange);\n          connector.on(\"disconnect\", disconnect);\n        }\n        updateChainAndProvider({ chainId });\n      } catch (err) {\n        setState((state2) => ({\n          ...state2,\n          error: new ConnectorNotFoundError()\n        }));\n        throw err;\n      }\n    },\n    [\n      autoConnect,\n      state.currentAddress,\n      defaultChain.id,\n      handleConnectorChange,\n      updateChainAndProvider\n    ]\n  );\n  const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(async () => {\n    setState((state2) => ({\n      ...state2,\n      currentAddress: void 0,\n      currentProvider: defaultProvider,\n      currentChain: defaultChain\n    }));\n    if (autoConnect) {\n      localStorage.removeItem(\"lastUsedConnector\");\n    }\n    if (!connectorRef.current) return;\n    connectorRef.current.off(\"change\", handleConnectorChange);\n    connectorRef.current.off(\"disconnect\", disconnect);\n    try {\n      await connectorRef.current.disconnect();\n    } catch {\n    }\n    connectorRef.current = void 0;\n  }, [autoConnect, handleConnectorChange, defaultProvider, defaultChain]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    async function tryAutoConnect(connectors2) {\n      const lastConnectedConnectorId = localStorage.getItem(\"lastUsedConnector\");\n      if (lastConnectedConnectorId === null) {\n        return;\n      }\n      const lastConnectedConnector = connectors2.find(\n        (connector) => connector.id === lastConnectedConnectorId\n      );\n      if (lastConnectedConnector === void 0) {\n        return;\n      }\n      try {\n        if (!await lastConnectedConnector.ready()) {\n          return;\n        }\n        connect({ connector: lastConnectedConnector });\n      } catch {\n      }\n    }\n    if (autoConnect && !connectorRef.current) {\n      tryAutoConnect(connectors);\n    }\n  }, []);\n  return {\n    address: state.currentAddress,\n    provider: state.currentProvider,\n    chain: state.currentChain,\n    connector: connectorRef.current,\n    explorer,\n    connect,\n    disconnect,\n    connectors,\n    chains\n  };\n}\nfunction StarknetProvider({\n  chains,\n  provider,\n  connectors,\n  explorer,\n  autoConnect,\n  queryClient,\n  defaultChainId,\n  children\n}) {\n  const { account, address, ...state } = useStarknetManager({\n    chains,\n    provider,\n    explorer,\n    connectors,\n    autoConnect,\n    defaultChainId\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__.QueryClientProvider, { client: queryClient ?? defaultQueryClient, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(StarknetContext.Provider, { value: state, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(AccountProvider, { address, account, children }) }) });\n}\nfunction providerForChain(chain, factory) {\n  const provider = factory(chain);\n  if (provider) {\n    return { chain, provider };\n  }\n  throw new Error(`No provider found for chain ${chain.name}`);\n}\nfunction starknetChainId(chainId) {\n  switch (chainId) {\n    case _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.mainnet.id:\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.StarknetChainId.SN_MAIN;\n    case _starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.sepolia.id:\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.StarknetChainId.SN_SEPOLIA;\n    default:\n      return void 0;\n  }\n}\n\n// src/context/index.tsx\n\nfunction StarknetConfig({ children, ...config }) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(StarknetProvider, { ...config, children });\n}\n\n// src/explorers/starkscan.ts\nvar StarkscanExplorer = class {\n  constructor(chain) {\n    __publicField(this, \"name\", \"Starkscan\");\n    __publicField(this, \"link\");\n    this.link = chain.explorers?.[\"starkscan\"]?.toString() ?? \"\";\n  }\n  block(hashOrNumber) {\n    return `${this.link}/block/${hashOrNumber.hash ?? hashOrNumber.number}`;\n  }\n  transaction(hash3) {\n    return `${this.link}/tx/${hash3}`;\n  }\n  contract(address) {\n    return `${this.link}/contract/${address}`;\n  }\n  class(hash3) {\n    return `${this.link}/class/${hash3}`;\n  }\n};\nvar starkscan = (chain) => {\n  return new StarkscanExplorer(chain);\n};\n\n// src/explorers/viewblock.ts\nvar ViewblockExplorer = class {\n  constructor(chain) {\n    __publicField(this, \"name\", \"Viewblock\");\n    __publicField(this, \"link\");\n    this.link = chain.explorers?.[\"viewblock\"]?.toString() ?? \"\";\n  }\n  block(hashOrNumber) {\n    if (hashOrNumber.hash && hashOrNumber.number === void 0) {\n      throw new Error(\n        \"The viewblock explorer doesnt support hashes for blocks. Please provide a hash.\"\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.number}`;\n  }\n  transaction(hash3) {\n    return `${this.link}/tx/${hash3}`;\n  }\n  contract(address) {\n    return `${this.link}/contract/${address}`;\n  }\n  class(hash3) {\n    return `${this.link}/class/${hash3}`;\n  }\n};\nvar viewblock = (chain) => {\n  return new ViewblockExplorer(chain);\n};\n\n// src/explorers/voyager.ts\nvar VoyagerExplorer = class {\n  constructor(chain) {\n    __publicField(this, \"name\", \"Voyager\");\n    __publicField(this, \"link\");\n    this.link = chain.explorers?.[\"voyager\"]?.toString() ?? \"\";\n  }\n  block(hashOrNumber) {\n    if (hashOrNumber.number !== void 0 && hashOrNumber.hash === void 0) {\n      throw new Error(\n        \"The voyager explorer doesn't support numbers for blocks. Please provide a hash.\"\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.hash}`;\n  }\n  transaction(hash3) {\n    return `${this.link}/tx/${hash3}`;\n  }\n  contract(address) {\n    return `${this.link}/contract/${address}`;\n  }\n  class(hash3) {\n    return `${this.link}/class/${hash3}`;\n  }\n};\nvar voyager = (chain) => {\n  return new VoyagerExplorer(chain);\n};\n\n// src/hooks/use-account.ts\n\n\n// src/utils.ts\n\nfunction getAddress(address) {\n  return (0,starknet__WEBPACK_IMPORTED_MODULE_1__.validateAndParseAddress)(address);\n}\n\n// src/hooks/use-provider.ts\nfunction useProvider() {\n  const { provider } = useStarknet();\n  return { provider };\n}\n\n// src/hooks/use-account.ts\nfunction useAccount() {\n  const { connector, chain } = useStarknet();\n  const { provider } = useProvider();\n  const { address: connectedAddress } = useStarknetAccount();\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)({\n    status: \"disconnected\"\n  });\n  const refreshState = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(async () => {\n    if (connector && provider && connectedAddress) {\n      setState({\n        status: \"connected\",\n        connector,\n        chainId: chain.id,\n        account: void 0,\n        address: getAddress(connectedAddress),\n        isConnected: true,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: false\n      });\n      connector.account(provider).then(\n        (connectedAccount) => setState((state2) => ({ ...state2, account: connectedAccount }))\n      );\n    } else {\n      return setState({\n        status: \"disconnected\",\n        connector: void 0,\n        chainId: void 0,\n        account: void 0,\n        address: void 0,\n        isConnected: false,\n        isConnecting: false,\n        isDisconnected: true,\n        isReconnecting: false\n      });\n    }\n  }, [provider, connector, chain.id, connectedAddress]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    refreshState();\n  }, [refreshState]);\n  return state;\n}\n\n// src/hooks/use-wallet-request.ts\n\n\n// src/query.ts\n\nfunction useQuery(args) {\n  const base = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useQuery)({ ...args, structuralSharing: false });\n  return {\n    data: base.data,\n    error: base.error,\n    status: base.status,\n    isSuccess: base.isSuccess,\n    isError: base.isError,\n    isPending: base.isPending,\n    fetchStatus: base.fetchStatus,\n    isFetching: base.isFetching,\n    isLoading: base.isLoading,\n    refetch: base.refetch\n  };\n}\nfunction useMutation(args) {\n  const base = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_9__.useMutation)(args);\n  return {\n    data: base.data,\n    error: base.error,\n    reset: base.reset,\n    isError: base.isError,\n    isIdle: base.isIdle,\n    isPending: base.isPending,\n    isSuccess: base.isSuccess,\n    isPaused: base.isPaused,\n    mutate: base.mutate,\n    mutateAsync: base.mutateAsync,\n    status: base.status,\n    variables: base.variables\n  };\n}\nfunction useInfiniteQuery(args) {\n  const base = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_10__.useInfiniteQuery)({ ...args, structuralSharing: false });\n  return {\n    data: base.data,\n    error: base.error,\n    status: base.status,\n    isSuccess: base.isSuccess,\n    isError: base.isError,\n    isPending: base.isPending,\n    fetchStatus: base.fetchStatus,\n    isFetching: base.isFetching,\n    isLoading: base.isLoading,\n    refetch: base.refetch,\n    fetchNextPage: base.fetchNextPage,\n    fetchPreviousPage: base.fetchPreviousPage,\n    hasNextPage: base.hasNextPage,\n    hasPreviousPage: base.hasPreviousPage,\n    isFetchingNextPage: base.isFetchingNextPage,\n    isFetchingPreviousPage: base.isFetchingPreviousPage\n  };\n}\n\n// src/hooks/use-wallet-request.ts\nfunction useWalletRequest(props) {\n  const { connector } = useStarknet();\n  const { type, params, ...rest } = props;\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ type, params }),\n    mutationFn: mutationFn({ connector }),\n    ...rest\n  });\n  const request = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(\n    (args) => mutate(args ?? { type, params }),\n    [mutate, type, params]\n  );\n  const requestAsync = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(\n    (args) => mutateAsync(args ?? { type, params }),\n    [mutateAsync, type, params]\n  );\n  return {\n    request,\n    requestAsync,\n    ...result\n  };\n}\nfunction mutationKey({\n  type,\n  params\n}) {\n  return [{ entity: \"walletRequest\", type, params }];\n}\nfunction mutationFn({\n  connector\n}) {\n  return async ({ type, params }) => {\n    if (!connector) throw new Error(\"No connector connected\");\n    if (!type) throw new Error(\"Type is required\");\n    return await connector.request({ type, params });\n  };\n}\n\n// src/hooks/use-add-chain.ts\nfunction useAddChain(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addStarknetChain\",\n    params,\n    ...rest\n  });\n  const addChain = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_addStarknetChain\"\n      } : void 0\n    );\n  };\n  const addChainAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_addStarknetChain\"\n      } : void 0\n    );\n  };\n  return {\n    addChain,\n    addChainAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-balance.ts\n\n\n\n\n// src/hooks/use-contract.ts\n\n\nfunction useContract({\n  abi: abi2,\n  address,\n  provider: providedProvider\n}) {\n  const { provider: currentProvider } = useStarknet();\n  const contract = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    const provider = providedProvider ? providedProvider : currentProvider;\n    if (abi2 && address && provider) {\n      return new starknet__WEBPACK_IMPORTED_MODULE_1__.Contract(abi2, address, provider).typedv2(\n        abi2\n      );\n    }\n    return void 0;\n  }, [abi2, address, providedProvider, currentProvider]);\n  return { contract };\n}\n\n// src/hooks/use-invalidate-on-block.ts\n\n\n\n// src/hooks/use-block-number.ts\n\nfunction useBlockNumber({\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n} = {}) {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey({ blockIdentifier }) {\n  return [{ entity: \"blockNumber\", blockIdentifier }];\n}\nfunction queryFn({\n  provider,\n  blockIdentifier\n}) {\n  return async () => {\n    const block = await provider.getBlock(blockIdentifier);\n    if (block.status !== \"PENDING\") {\n      return block.block_number;\n    }\n    return void 0;\n  };\n}\n\n// src/hooks/use-invalidate-on-block.ts\nfunction useInvalidateOnBlock({\n  enabled = true,\n  queryKey: queryKey12\n}) {\n  const queryClient = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__.useQueryClient)();\n  const [prevBlockNumber, setPrevBlockNumber] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)();\n  const { data: blockNumber } = useBlockNumber({\n    enabled\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (!prevBlockNumber) {\n      return setPrevBlockNumber(blockNumber);\n    }\n    if (blockNumber !== prevBlockNumber) {\n      queryClient.invalidateQueries({ queryKey: queryKey12 }, { cancelRefetch: false });\n      return setPrevBlockNumber(blockNumber);\n    }\n  }, [blockNumber, prevBlockNumber, queryKey12, queryClient]);\n}\n\n// src/hooks/use-network.ts\nfunction useNetwork() {\n  const { chain, chains } = useStarknet();\n  return { chain, chains };\n}\n\n// src/hooks/use-balance.ts\nvar DEFAULT_FETCH_INTERVAL = 5e3;\nfunction useBalance({\n  token: token_,\n  address,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n}) {\n  const { chain } = useNetwork();\n  const token = token_ ?? chain.nativeCurrency.address;\n  const { contract } = useContract({\n    abi: balanceABIFragment,\n    address: token\n  });\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(\n    () => queryKey2({ chain, token, address, blockIdentifier }),\n    [chain, token, address, blockIdentifier]\n  );\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(\n    () => Boolean(enabled_ && contract && address),\n    [enabled_, contract, address]\n  );\n  const refetchInterval = refetchInterval_ ?? (blockIdentifier === starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.PENDING && watch ? DEFAULT_FETCH_INTERVAL : void 0);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    enabled,\n    refetchInterval,\n    queryKey: queryKey_,\n    queryFn: queryFn2({ chain, contract, token, address, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey2({\n  chain,\n  token,\n  address,\n  blockIdentifier\n}) {\n  return [\n    {\n      entity: \"balance\",\n      chainId: chain?.name,\n      token,\n      address,\n      blockIdentifier\n    }\n  ];\n}\nfunction queryFn2({\n  chain,\n  token,\n  address,\n  contract,\n  blockIdentifier\n}) {\n  return async () => {\n    if (!address) throw new Error(\"address is required\");\n    if (!contract) throw new Error(\"contract is required\");\n    const options = {\n      blockIdentifier\n    };\n    const isNativeCurrency = token === chain.nativeCurrency.address;\n    let symbol = chain.nativeCurrency.symbol;\n    if (!isNativeCurrency) {\n      const symbol_ = await contract.symbol(options);\n      symbol = starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.decodeShortString(starknet__WEBPACK_IMPORTED_MODULE_1__.num.toHex(symbol_));\n    }\n    let decimals = chain.nativeCurrency.decimals;\n    if (!isNativeCurrency) {\n      const decimals_ = await contract.decimals(options);\n      decimals = Number(decimals_);\n    }\n    const balanceOf = await contract.balanceOf(address, options);\n    const formatted = (0,viem__WEBPACK_IMPORTED_MODULE_11__.formatUnits)(balanceOf, decimals);\n    return {\n      value: balanceOf,\n      decimals,\n      symbol,\n      formatted\n    };\n  };\n}\nvar balanceABIFragment = [\n  {\n    name: \"core::integer::u256\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"low\",\n        type: \"core::integer::u128\"\n      },\n      {\n        name: \"high\",\n        type: \"core::integer::u128\"\n      }\n    ]\n  },\n  {\n    name: \"balanceOf\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"account\",\n        type: \"core::starknet::contract_address::ContractAddress\"\n      }\n    ],\n    outputs: [\n      {\n        type: \"core::integer::u256\"\n      }\n    ],\n    state_mutability: \"view\"\n  },\n  {\n    name: \"symbol\",\n    type: \"function\",\n    inputs: [],\n    outputs: [\n      {\n        type: \"core::felt252\"\n      }\n    ],\n    state_mutability: \"view\"\n  },\n  {\n    name: \"decimals\",\n    type: \"function\",\n    inputs: [],\n    outputs: [\n      {\n        type: \"core::integer::u8\"\n      }\n    ],\n    state_mutability: \"view\"\n  }\n];\n\n// src/hooks/use-block.ts\n\nfunction useBlock({\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n} = {}) {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey3({ blockIdentifier }),\n    queryFn: queryFn3({ provider, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey3({ blockIdentifier }) {\n  return [{ entity: \"block\", blockIdentifier }];\n}\nfunction queryFn3({\n  provider,\n  blockIdentifier\n}) {\n  return async () => await provider.getBlock(blockIdentifier);\n}\n\n// src/hooks/use-call.ts\n\n\nvar DEFAULT_FETCH_INTERVAL2 = 5e3;\nfunction useCall({\n  abi: abi2,\n  address,\n  functionName,\n  args,\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  parseArgs,\n  parseResult,\n  ...props\n}) {\n  const { chain } = useNetwork();\n  const { contract } = useContract({ abi: abi2, address });\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(\n    () => queryKey4({\n      chain,\n      contract,\n      functionName,\n      args,\n      blockIdentifier\n    }),\n    [chain, contract, functionName, args, blockIdentifier]\n  );\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(\n    () => Boolean(enabled_ && contract && functionName && args),\n    [enabled_, contract, functionName, args]\n  );\n  const refetchInterval = refetchInterval_ ?? (blockIdentifier === starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.PENDING && watch ? DEFAULT_FETCH_INTERVAL2 : void 0);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn4({\n      contract,\n      functionName,\n      args,\n      blockIdentifier,\n      parseArgs,\n      parseResult\n    }),\n    refetchInterval,\n    enabled,\n    ...props\n  });\n}\nfunction queryKey4({\n  chain,\n  contract,\n  functionName,\n  args,\n  blockIdentifier\n}) {\n  return [\n    {\n      entity: \"readContract\",\n      chainId: chain?.name,\n      contract: contract?.address,\n      functionName,\n      args: JSON.stringify(\n        args,\n        (_, v) => typeof v === \"bigint\" ? v.toString(10) : v\n      ),\n      blockIdentifier\n    }\n  ];\n}\nfunction queryFn4({\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n  parseArgs = true,\n  parseResult = true\n}) {\n  return async () => {\n    if (!contract) throw new Error(\"contract is required\");\n    if (contract.functions[functionName] === void 0) {\n      throw new Error(`function ${functionName} not found in contract`);\n    }\n    return contract.call(functionName, args, {\n      parseRequest: parseArgs,\n      parseResponse: parseResult,\n      blockIdentifier\n    });\n  };\n}\n\n// src/hooks/use-connect.ts\n\nfunction useConnect(props = {}) {\n  const { connector, connectors, connect: connect_, chain } = useStarknet();\n  const { mutate, mutateAsync, variables, ...result } = useMutation({\n    mutationKey: [{ entity: \"connect\", chainId: chain.name }],\n    mutationFn: connect_,\n    ...props\n  });\n  const connect = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(\n    (args) => mutate(args ?? { connector }),\n    [mutate, connector]\n  );\n  const connectAsync = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(\n    (args) => mutateAsync(args ?? { connector }),\n    [mutateAsync, connector]\n  );\n  return {\n    connector,\n    connectors,\n    pendingConnector: variables?.connector,\n    connect,\n    connectAsync,\n    variables,\n    ...result\n  };\n}\n\n// src/hooks/use-contract-factory.ts\n\n\nfunction useContractFactory({\n  compiledContract,\n  classHash,\n  abi: abi2\n}) {\n  const { account } = useAccount();\n  const contractFactory = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    if (compiledContract && account && classHash) {\n      return new starknet__WEBPACK_IMPORTED_MODULE_1__.ContractFactory({\n        compiledContract,\n        classHash,\n        account,\n        abi: abi2\n      });\n    }\n    return void 0;\n  }, [compiledContract, classHash, account, abi2]);\n  return { contractFactory };\n}\n\n// src/hooks/use-declare-contract.ts\nfunction useDeclareContract(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addDeclareTransaction\",\n    params,\n    ...rest\n  });\n  const declare = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_addDeclareTransaction\"\n      } : void 0\n    );\n  };\n  const declareAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_addDeclareTransaction\"\n      } : void 0\n    );\n  };\n  return {\n    declare,\n    declareAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-deploy-account.ts\nfunction useDeployAccount({\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n  ...props\n}) {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey2({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options\n    }),\n    mutationFn: mutationFn2({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options\n    }),\n    ...props\n  });\n  return {\n    deployAccount: mutate,\n    deployAccountAsync: mutateAsync,\n    ...result\n  };\n}\nfunction mutationKey2(props) {\n  return [{ entity: \"deployAccount\", ...props }];\n}\nfunction mutationFn2({\n  account,\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options\n}) {\n  return async () => {\n    if (!account) throw new Error(\"account is required\");\n    if (!classHash) throw new Error(\"classHash is required\");\n    return await account.deployAccount(\n      { classHash, constructorCalldata, addressSalt, contractAddress },\n      options\n    );\n  };\n}\n\n// src/hooks/use-disconnect.ts\nfunction useDisconnect(props = {}) {\n  const { disconnect, chain } = useStarknet();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: [{ entity: \"disconnect\", chainId: chain.name }],\n    mutationFn: disconnect,\n    ...props\n  });\n  return {\n    disconnect: mutate,\n    disconnectAsync: mutateAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-estimate-fees.ts\n\nfunction useEstimateFees({\n  calls,\n  options,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { account } = useAccount();\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(\n    () => queryKey5({ calls, options }),\n    [calls, options]\n  );\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => Boolean(enabled_ && calls), [enabled_, calls]);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn5({\n      account,\n      calls,\n      options\n    }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey5({ calls, options }) {\n  return [\n    {\n      entity: \"estimateInvokeFee\",\n      calls,\n      options\n    }\n  ];\n}\nfunction queryFn5({\n  account,\n  calls,\n  options\n}) {\n  return async () => {\n    if (!account) throw new Error(\"account is required\");\n    if (!calls || calls.length === 0) throw new Error(\"calls are required\");\n    return account?.estimateInvokeFee(calls, options);\n  };\n}\n\n// src/hooks/use-explorer.ts\nfunction useExplorer() {\n  const { explorer, chain } = useStarknet();\n  if (!explorer)\n    throw Error(\"Explorer is undefined. Try adding it to StarknetConfig.\");\n  const explorerInstance = explorer(chain);\n  if (!explorerInstance) throw Error(\"Explorer Instance is undefined\");\n  return explorerInstance;\n}\n\n// src/hooks/use-nonce-for-address.ts\n\nfunction useNonceForAddress({\n  address,\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n}) {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey6({ address, blockIdentifier }),\n    queryFn: queryFn6({ address, provider, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey6({\n  address,\n  blockIdentifier\n}) {\n  return [{ entity: \"nonce\", blockIdentifier, address }];\n}\nfunction queryFn6({\n  provider,\n  blockIdentifier,\n  address\n}) {\n  return async () => {\n    const nonce = await provider.getNonceForAddress(address, blockIdentifier);\n    return nonce;\n  };\n}\n\n// src/hooks/use-read-contract.ts\nfunction useReadContract(props) {\n  return useCall(props);\n}\n\n// src/hooks/use-send-transaction.ts\nfunction useSendTransaction(props) {\n  const { calls, ...rest } = props;\n  const params = calls ? { calls: transformCalls2(calls) } : void 0;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addInvokeTransaction\",\n    params,\n    ...rest\n  });\n  const send = (args) => {\n    return request(\n      args ? {\n        params: { calls: transformCalls2(args) },\n        type: \"wallet_addInvokeTransaction\"\n      } : void 0\n    );\n  };\n  const sendAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: { calls: transformCalls2(args) },\n        type: \"wallet_addInvokeTransaction\"\n      } : void 0\n    );\n  };\n  return {\n    send,\n    sendAsync,\n    ...result\n  };\n}\nfunction transformCalls2(calls) {\n  return calls.map(\n    (call) => ({\n      contract_address: call.contractAddress,\n      entry_point: call.entrypoint,\n      calldata: call.calldata\n    })\n  );\n}\n\n// src/hooks/use-sign.ts\nfunction useSignTypedData(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_signTypedData\",\n    params,\n    ...rest\n  });\n  const signTypedData = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_signTypedData\"\n      } : void 0\n    );\n  };\n  const signTypedDataAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_signTypedData\"\n      } : void 0\n    );\n  };\n  return {\n    signTypedData,\n    signTypedDataAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-stark-address.ts\n\n\nfunction useStarkAddress({\n  name,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => Boolean(enabled_ && name), [enabled_, name]);\n  return useQuery({\n    queryKey: queryKey7({ name, contract, network: chain.network }),\n    queryFn: queryFn7({ name, contract, provider, network: chain.network }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey7({\n  name,\n  contract,\n  network\n}) {\n  return [{ entity: \"addressFromStarkName\", name, contract, network }];\n}\nfunction queryFn7({\n  name,\n  contract,\n  provider,\n  network\n}) {\n  return async () => {\n    if (!name) throw new Error(\"name is required\");\n    const namingContract = contract ?? StarknetIdNamingContract[network];\n    const p = new starknet__WEBPACK_IMPORTED_MODULE_1__.Provider(provider);\n    const encodedDomain = encodeDomain(name);\n    const result = await p.callContract({\n      contractAddress: namingContract,\n      entrypoint: \"domain_to_address\",\n      calldata: starknet__WEBPACK_IMPORTED_MODULE_1__.CallData.compile({ domain: encodedDomain, hint: [] })\n    });\n    if (BigInt(result[0]) === BigInt(0)) throw new Error(\"Address not found\");\n    return result[0];\n  };\n}\nvar StarknetIdNamingContract = {\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\"\n};\nvar encodeDomain = (domain) => {\n  if (!domain) return [\"0\"];\n  const encoded = [];\n  for (const subdomain of domain.replace(\".stark\", \"\").split(\".\"))\n    encoded.push(starknet__WEBPACK_IMPORTED_MODULE_1__.starknetId.useEncoded(subdomain).toString(10));\n  return encoded;\n};\n\n// src/hooks/use-stark-name.ts\n\n\nfunction useStarkName({\n  address,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(\n    () => Boolean(enabled_ && address),\n    [enabled_, address]\n  );\n  return useQuery({\n    queryKey: queryKey8({ address, contract, network: chain.network }),\n    queryFn: queryFn8({ address, contract, provider, network: chain.network }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey8({\n  address,\n  contract,\n  network\n}) {\n  return [{ entity: \"starkName\", address, contract, network }];\n}\nfunction queryFn8({\n  address,\n  contract,\n  provider,\n  network\n}) {\n  return async () => {\n    if (!address) throw new Error(\"address is required\");\n    const namingContract = contract ?? StarknetIdNamingContract2[network];\n    const p = new starknet__WEBPACK_IMPORTED_MODULE_1__.Provider(provider);\n    return await p.getStarkName(address, namingContract);\n  };\n}\nvar StarknetIdNamingContract2 = {\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\"\n};\n\n// src/hooks/use-stark-profile.ts\n\n\nfunction useStarkProfile({\n  address,\n  useDefaultPfp = true,\n  namingContract,\n  identityContract,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  if (!StarknetIdcontracts[chain.network])\n    throw new Error(\"Network not supported\");\n  const { contract: multicallContract } = useContract({\n    abi: multicallABI,\n    address: StarknetIdcontracts[chain.network][\"multicall\"]\n  });\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(\n    () => Boolean(enabled_ && address),\n    [enabled_, address]\n  );\n  const { refetchInterval, ...rest } = props;\n  return useQuery({\n    queryKey: queryKey9({\n      address,\n      namingContract,\n      identityContract,\n      network: chain.network,\n      useDefaultPfp\n    }),\n    queryFn: queryFn9({\n      address,\n      useDefaultPfp,\n      namingContract,\n      network: chain.network,\n      identityContract,\n      multicallContract\n    }),\n    enabled,\n    refetchInterval,\n    ...rest\n  });\n}\nfunction queryKey9({\n  address,\n  namingContract,\n  identityContract,\n  network,\n  useDefaultPfp\n}) {\n  return [\n    {\n      entity: \"starkprofile\",\n      address,\n      namingContract,\n      identityContract,\n      network,\n      useDefaultPfp\n    }\n  ];\n}\nfunction queryFn9({\n  address,\n  useDefaultPfp,\n  namingContract,\n  identityContract,\n  network,\n  multicallContract\n}) {\n  return async () => {\n    if (!address) throw new Error(\"address is required\");\n    if (!multicallContract) throw new Error(\"multicallContract is required\");\n    if (!network) throw new Error(\"network is required\");\n    const contracts = StarknetIdcontracts[network];\n    const identity = identityContract ?? contracts[\"identity\"];\n    const naming = namingContract ?? contracts[\"naming\"];\n    const data = await multicallContract.call(\"aggregate\", [\n      [\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"address_to_domain\")),\n          calldata: [hardcoded(address), hardcoded(0)]\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"domain_to_id\")),\n          calldata: [arrayReference(0, 0)]\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.encodeShortString(\"twitter\")),\n            hardcoded(contracts[\"verifier\"]),\n            hardcoded(\"0\")\n          ]\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.encodeShortString(\"github\")),\n            hardcoded(contracts[\"verifier\"]),\n            hardcoded(\"0\")\n          ]\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.encodeShortString(\"discord\")),\n            hardcoded(contracts[\"verifier\"]),\n            hardcoded(\"0\")\n          ]\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.encodeShortString(\"proof_of_personhood\")),\n            hardcoded(contracts[\"verifier_pop\"]),\n            hardcoded(\"0\")\n          ]\n        },\n        // PFP\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.encodeShortString(\"nft_pp_contract\")),\n            hardcoded(contracts[\"verifier_pfp\"]),\n            hardcoded(\"0\")\n          ]\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(\n            starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"get_extended_verifier_data\")\n          ),\n          calldata: [\n            reference(1, 0),\n            hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.encodeShortString(\"nft_pp_id\")),\n            hardcoded(\"2\"),\n            hardcoded(contracts[\"verifier_pfp\"]),\n            hardcoded(\"0\")\n          ]\n        },\n        {\n          execution: notEqual(6, 0, 0),\n          to: reference(6, 0),\n          selector: hardcoded(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.getSelectorFromName(\"tokenURI\")),\n          calldata: [reference(7, 1), reference(7, 2)]\n        }\n      ]\n    ]);\n    if (Array.isArray(data)) {\n      const name = data[0][0] !== BigInt(0) ? starknet__WEBPACK_IMPORTED_MODULE_1__.starknetId.useDecoded(data[0].slice(1).map((val) => BigInt(val))) : void 0;\n      const twitter = data[2][0] !== BigInt(0) ? data[2][0].toString() : void 0;\n      const github = data[3][0] !== BigInt(0) ? data[3][0].toString() : void 0;\n      const discord = data[4][0] !== BigInt(0) ? data[4][0].toString() : void 0;\n      const proofOfPersonhood = data[5][0] === BigInt(1);\n      const profile = data.length === 9 ? data[8].slice(1).map((val) => starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.decodeShortString(val.toString())).join(\"\") : void 0;\n      const profilePicture = profile ? profile.includes(\"base64\") ? parseBase64Image(profile) : await fetchImageUrl(profile) : useDefaultPfp ? `https://starknet.id/api/identicons/${data[1][0].toString()}` : void 0;\n      const res = {\n        name,\n        twitter,\n        github,\n        discord,\n        proofOfPersonhood,\n        profilePicture,\n        profile\n      };\n      return res;\n    }\n    throw new Error(\"Error while fetching data\");\n  };\n}\nvar hardcoded = (arg) => {\n  return new starknet__WEBPACK_IMPORTED_MODULE_1__.CairoCustomEnum({\n    Hardcoded: arg\n  });\n};\nvar reference = (call, pos) => {\n  return new starknet__WEBPACK_IMPORTED_MODULE_1__.CairoCustomEnum({\n    Reference: starknet__WEBPACK_IMPORTED_MODULE_1__.cairo.tuple(call, pos)\n  });\n};\nvar arrayReference = (call, pos) => {\n  return new starknet__WEBPACK_IMPORTED_MODULE_1__.CairoCustomEnum({\n    ArrayReference: starknet__WEBPACK_IMPORTED_MODULE_1__.cairo.tuple(call, pos)\n  });\n};\nvar staticExecution = () => {\n  return new starknet__WEBPACK_IMPORTED_MODULE_1__.CairoCustomEnum({\n    Static: {}\n  });\n};\nvar notEqual = (call, pos, value) => {\n  return new starknet__WEBPACK_IMPORTED_MODULE_1__.CairoCustomEnum({\n    IfNotEqual: starknet__WEBPACK_IMPORTED_MODULE_1__.cairo.tuple(call, pos, value)\n  });\n};\nvar parseBase64Image = (metadata) => {\n  return JSON.parse(atob(metadata.split(\",\")[1].slice(0, -1))).image;\n};\nvar parseImageUrl = (url) => {\n  return url.startsWith(\"ipfs://\") ? url.replace(\"ipfs://\", \"https://ipfs.io/ipfs/\") : url;\n};\nvar fetchImageUrl = async (url) => {\n  try {\n    const response = await fetch(parseImageUrl(url));\n    if (!response.ok) {\n      throw new Error(\"Network response was not ok\");\n    }\n    const data = await response.json();\n    if (data.image) {\n      return parseImageUrl(data.image);\n    }\n    return void 0;\n  } catch (error) {\n    console.error(\"There was a problem fetching the image URL:\", error);\n    return void 0;\n  }\n};\nvar StarknetIdcontracts = {\n  sepolia: {\n    naming: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n    identity: \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\",\n    verifier: \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\",\n    verifier_pop: \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\",\n    verifier_pfp: \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\",\n    multicall: \"0x07a9013697371ce40d0306b4c810c6a4db9bfda119dd9ae1e8701c8e288d734b\"\n  },\n  mainnet: {\n    naming: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n    identity: \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\",\n    verifier: \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\",\n    verifier_pop: \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\",\n    verifier_pfp: \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\",\n    multicall: \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\"\n  }\n};\nvar multicallABI = [\n  {\n    name: \"ComposableMulticallImpl\",\n    type: \"impl\",\n    interface_name: \"composable_multicall::IComposableMulticall\"\n  },\n  {\n    name: \"composable_multicall::Execution\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Static\",\n        type: \"()\"\n      },\n      {\n        name: \"IfEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\"\n      },\n      {\n        name: \"IfNotEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::DynamicFelt\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Hardcoded\",\n        type: \"core::felt252\"\n      },\n      {\n        name: \"Reference\",\n        type: \"(core::integer::u32, core::integer::u32)\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::DynamicCalldata\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Hardcoded\",\n        type: \"core::felt252\"\n      },\n      {\n        name: \"Reference\",\n        type: \"(core::integer::u32, core::integer::u32)\"\n      },\n      {\n        name: \"ArrayReference\",\n        type: \"(core::integer::u32, core::integer::u32)\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::DynamicCall\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"execution\",\n        type: \"composable_multicall::Execution\"\n      },\n      {\n        name: \"to\",\n        type: \"composable_multicall::DynamicFelt\"\n      },\n      {\n        name: \"selector\",\n        type: \"composable_multicall::DynamicFelt\"\n      },\n      {\n        name: \"calldata\",\n        type: \"core::array::Array::<composable_multicall::DynamicCalldata>\"\n      }\n    ]\n  },\n  {\n    name: \"core::array::Span::<core::felt252>\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"snapshot\",\n        type: \"@core::array::Array::<core::felt252>\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::IComposableMulticall\",\n    type: \"interface\",\n    items: [\n      {\n        name: \"aggregate\",\n        type: \"function\",\n        inputs: [\n          {\n            name: \"calls\",\n            type: \"core::array::Array::<composable_multicall::DynamicCall>\"\n          }\n        ],\n        outputs: [\n          {\n            type: \"core::array::Array::<core::array::Span::<core::felt252>>\"\n          }\n        ],\n        state_mutability: \"view\"\n      }\n    ]\n  },\n  {\n    kind: \"enum\",\n    name: \"composable_multicall::contract::ComposableMulticall::Event\",\n    type: \"event\",\n    variants: []\n  }\n];\n\n// src/hooks/use-switch-chain.ts\nfunction useSwitchChain(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_switchStarknetChain\",\n    params,\n    ...rest\n  });\n  const switchChain = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_switchStarknetChain\"\n      } : void 0\n    );\n  };\n  const switchChainAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_switchStarknetChain\"\n      } : void 0\n    );\n  };\n  return {\n    switchChain,\n    switchChainAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-transaction-receipt.ts\n\nfunction useTransactionReceipt({\n  hash: hash3,\n  watch,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider, chain } = useStarknet();\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => queryKey10({ chain, hash: hash3 }), [chain, hash3]);\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => Boolean(enabled_ && hash3), [enabled_, hash3]);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn10({ provider, hash: hash3 }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey10({ chain, hash: hash3 }) {\n  return [\n    { entity: \"transactionReceipt\", chainId: chain?.name, hash: hash3 }\n  ];\n}\nfunction queryFn10({\n  provider,\n  hash: hash3\n}) {\n  return async () => {\n    if (!hash3) throw new Error(\"hash is required\");\n    return await provider.getTransactionReceipt(hash3);\n  };\n}\n\n// src/hooks/use-watch-asset.ts\nfunction useWatchAsset(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_watchAsset\",\n    params,\n    ...rest\n  });\n  const watchAsset = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_watchAsset\"\n      } : void 0\n    );\n  };\n  const watchAssetAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_watchAsset\"\n      } : void 0\n    );\n  };\n  return {\n    watchAsset,\n    watchAssetAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-universal-deployer-contract.tsx\nfunction useUniversalDeployerContract(props) {\n  const { address, provider } = props || {};\n  return {\n    udc: useContract({\n      abi,\n      address: address ?? \"0x04a64cd09a853868621d94cae9952b106f2c36a3f81260f85de6696c6b050221\",\n      provider\n    }).contract\n  };\n}\nvar abi = [\n  {\n    name: \"UniversalDeployerImpl\",\n    type: \"impl\",\n    interface_name: \"openzeppelin::utils::universal_deployer::interface::IUniversalDeployer\"\n  },\n  {\n    name: \"core::bool\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"False\",\n        type: \"()\"\n      },\n      {\n        name: \"True\",\n        type: \"()\"\n      }\n    ]\n  },\n  {\n    name: \"core::array::Span::<core::felt252>\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"snapshot\",\n        type: \"@core::array::Array::<core::felt252>\"\n      }\n    ]\n  },\n  {\n    name: \"openzeppelin::utils::universal_deployer::interface::IUniversalDeployer\",\n    type: \"interface\",\n    items: [\n      {\n        name: \"deploy_contract\",\n        type: \"function\",\n        inputs: [\n          {\n            name: \"class_hash\",\n            type: \"core::starknet::class_hash::ClassHash\"\n          },\n          {\n            name: \"salt\",\n            type: \"core::felt252\"\n          },\n          {\n            name: \"from_zero\",\n            type: \"core::bool\"\n          },\n          {\n            name: \"calldata\",\n            type: \"core::array::Span::<core::felt252>\"\n          }\n        ],\n        outputs: [\n          {\n            type: \"core::starknet::contract_address::ContractAddress\"\n          }\n        ],\n        state_mutability: \"external\"\n      }\n    ]\n  },\n  {\n    kind: \"struct\",\n    name: \"openzeppelin::presets::universal_deployer::UniversalDeployer::ContractDeployed\",\n    type: \"event\",\n    members: [\n      {\n        kind: \"data\",\n        name: \"address\",\n        type: \"core::starknet::contract_address::ContractAddress\"\n      },\n      {\n        kind: \"data\",\n        name: \"deployer\",\n        type: \"core::starknet::contract_address::ContractAddress\"\n      },\n      {\n        kind: \"data\",\n        name: \"from_zero\",\n        type: \"core::bool\"\n      },\n      {\n        kind: \"data\",\n        name: \"class_hash\",\n        type: \"core::starknet::class_hash::ClassHash\"\n      },\n      {\n        kind: \"data\",\n        name: \"calldata\",\n        type: \"core::array::Span::<core::felt252>\"\n      },\n      {\n        kind: \"data\",\n        name: \"salt\",\n        type: \"core::felt252\"\n      }\n    ]\n  },\n  {\n    kind: \"enum\",\n    name: \"openzeppelin::presets::universal_deployer::UniversalDeployer::Event\",\n    type: \"event\",\n    variants: [\n      {\n        kind: \"nested\",\n        name: \"ContractDeployed\",\n        type: \"openzeppelin::presets::universal_deployer::UniversalDeployer::ContractDeployed\"\n      }\n    ]\n  }\n];\n\n// src/hooks/use-events.ts\n\nvar DEFAULT_PAGE_SIZE = 5;\nfunction useEvents({\n  address,\n  eventName,\n  fromBlock: fromBlock_,\n  toBlock: toBlock_,\n  pageSize\n}) {\n  const { provider } = useProvider();\n  const rpcProvider = provider;\n  const keyFilter = eventName ? [starknet__WEBPACK_IMPORTED_MODULE_1__.num.toHex(starknet__WEBPACK_IMPORTED_MODULE_1__.hash.starknetKeccak(eventName))] : [];\n  const keys = [keyFilter];\n  const fromBlock = fromBlock_ ? blockIdentifierToBlockId(fromBlock_) : void 0;\n  const toBlock = toBlock_ ? blockIdentifierToBlockId(toBlock_) : void 0;\n  const chunkSize = pageSize ? pageSize : DEFAULT_PAGE_SIZE;\n  const fetchEvents = async ({\n    pageParam\n  }) => {\n    const res = await rpcProvider.getEvents({\n      from_block: fromBlock,\n      to_block: toBlock,\n      address,\n      keys,\n      chunk_size: chunkSize,\n      continuation_token: pageParam === \"0\" ? void 0 : pageParam\n    });\n    return res;\n  };\n  return useInfiniteQuery({\n    // TODO: useMemo ?\n    queryKey: queryKey11({\n      address,\n      eventName,\n      fromBlock: fromBlock_,\n      toBlock: toBlock_,\n      pageSize\n    }),\n    queryFn: fetchEvents,\n    initialPageParam: \"0\",\n    getNextPageParam: (lastPage, pages) => lastPage.continuation_token\n  });\n}\nfunction queryKey11({\n  address,\n  eventName,\n  fromBlock,\n  toBlock,\n  pageSize\n}) {\n  return [\n    {\n      entity: \"events\",\n      address,\n      eventName,\n      fromBlock,\n      toBlock,\n      pageSize\n    }\n  ];\n}\nfunction blockIdentifierToBlockId(blockIdentifier) {\n  if (blockIdentifier === null) {\n    return starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.PENDING;\n  }\n  if (typeof blockIdentifier === \"number\") {\n    return { block_number: blockIdentifier };\n  }\n  if (typeof blockIdentifier === \"string\") {\n    if (blockIdentifier === \"latest\" || blockIdentifier === \"pending\") {\n      return blockIdentifier;\n    }\n    return { block_hash: blockIdentifier };\n  }\n  throw new Error(\n    `Unsupported BlockIdentifier type: ${typeof blockIdentifier}`\n  );\n}\n\n// src/providers/jsonrpc.ts\n\nfunction jsonRpcProvider({\n  rpc\n}) {\n  return (chain) => {\n    const config = rpc(chain);\n    if (!config) return null;\n    const chainId = starknetChainId(chain.id);\n    const provider = new starknet__WEBPACK_IMPORTED_MODULE_1__.RpcProvider({ ...config, chainId });\n    return provider;\n  };\n}\n\n// src/providers/public.ts\nfunction publicProvider() {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const rpcs = chain.rpcUrls.public.http;\n      const nodeUrl = rpcs[Math.floor(Math.random() * rpcs.length)];\n      if (!nodeUrl) return null;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/alchemy.ts\nfunction alchemyProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"alchemy\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/blast.ts\nfunction blastProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"blast\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/cartridge.ts\nfunction cartridgeProvider() {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const nodeUrl = chain.rpcUrls[\"cartridge\"]?.http[0];\n      if (!nodeUrl) return null;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/infura.ts\nfunction infuraProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"infura\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/lava.ts\nfunction lavaProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"lava\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/nethermind.ts\nfunction nethermindProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"nethermind\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/?apikey=${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/reddio.ts\nfunction reddioProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"reddio\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/slot.ts\n\nfunction slotProvider({ projectId }) {\n  return jsonRpcProvider({\n    rpc: () => {\n      const chain = (0,_starknet_react_chains__WEBPACK_IMPORTED_MODULE_3__.getSlotChain)(projectId);\n      const nodeUrl = chain.rpcUrls.public.http[0];\n      return { nodeUrl };\n    }\n  });\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtcmVhY3QvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJOztBQUVBO0FBQ3lDO0FBQ3pDLDhCQUE4QixxREFBWTtBQUMxQzs7QUFFQTtBQUcrQjtBQUdiOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQ7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLDZEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBYTtBQUM1QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QyxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUcrQjtBQUMyQjtBQUMxRCx1REFBdUQ7QUFDdkQsc0RBQXNEO0FBQ3REO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlDQUF5QztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTLDJEQUFPLEtBQUs7QUFDbkQ7QUFDQTtBQUNBLDhCQUE4QixTQUFTLDJEQUFPLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVMsMkRBQU8sS0FBSztBQUNuRDtBQUNBO0FBQ0EsOEJBQThCLFNBQVMsMkRBQU8sS0FBSztBQUNuRDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ2tFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0RBQXNELCtDQUFRO0FBQzlELDRCQUE0QixrREFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLDhDQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBRytCO0FBQ3NDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQkFBK0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQiw2REFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2REFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFrRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFRO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUlnQztBQUN5QztBQVExRDtBQUdHOztBQUVsQjtBQUMwQztBQUNGO0FBQ3hDLHFCQUFxQixnREFBbUI7QUFDeEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVUsbUJBQW1CLEVBQUUsaURBQVU7QUFDekMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLHNEQUFHLDRCQUE0QixTQUFTLGtCQUFrQixZQUFZO0FBQy9GOztBQUVBO0FBQ2dEO0FBQ2hELDZCQUE2Qiw4REFBVztBQUN4QyxzQkFBc0Isb0RBQWE7QUFDbkM7QUFDQSxnQkFBZ0IsaURBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBTTtBQUM3Qiw0QkFBNEIsK0NBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlDQUFpQyxrREFBWTtBQUM3QyxPQUFPLFNBQVM7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQyxrREFBWTtBQUM1QyxhQUFhLDJCQUEyQjtBQUN4QztBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILGtCQUFrQixrREFBWTtBQUM5QixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QixzREFBSSxDQUFDLHNFQUFtQixJQUFJLHFFQUFxRSxzREFBSSw2QkFBNkIsd0NBQXdDLHNEQUFJLG9CQUFvQiw0QkFBNEIsR0FBRyxHQUFHO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUywyREFBUTtBQUNqQixhQUFhLCtDQUFTO0FBQ3RCLFNBQVMsMkRBQVE7QUFDakIsYUFBYSwrQ0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRDtBQUNoRCwwQkFBMEIscUJBQXFCO0FBQy9DLHlCQUF5QixzREFBSSxxQkFBcUIscUJBQXFCO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVUsU0FBUyx5Q0FBeUM7QUFDMUU7QUFDQTtBQUNBLGNBQWMsVUFBVSxNQUFNLE1BQU07QUFDcEM7QUFDQTtBQUNBLGNBQWMsVUFBVSxZQUFZLFFBQVE7QUFDNUM7QUFDQTtBQUNBLGNBQWMsVUFBVSxTQUFTLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxTQUFTLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0EsY0FBYyxVQUFVLE1BQU0sTUFBTTtBQUNwQztBQUNBO0FBQ0EsY0FBYyxVQUFVLFlBQVksUUFBUTtBQUM1QztBQUNBO0FBQ0EsY0FBYyxVQUFVLFNBQVMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLFNBQVMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQSxjQUFjLFVBQVUsTUFBTSxNQUFNO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjLFVBQVUsWUFBWSxRQUFRO0FBQzVDO0FBQ0E7QUFDQSxjQUFjLFVBQVUsU0FBUyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDb0c7O0FBRXBHO0FBQ21EO0FBQ25EO0FBQ0EsU0FBUyxpRUFBdUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCLFVBQVUsV0FBVztBQUNyQixVQUFVLDRCQUE0QjtBQUN0Qyw0QkFBNEIsK0NBQVM7QUFDckM7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLGtEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzREFBc0Qsc0NBQXNDO0FBQzVGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ29EOztBQUVwRDtBQUsrQjtBQUMvQjtBQUNBLGVBQWUsK0RBQVMsR0FBRyxtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0VBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdFQUFpQixHQUFHLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsd0JBQXdCO0FBQ2xDLFVBQVUsaUNBQWlDO0FBQzNDLCtCQUErQixjQUFjO0FBQzdDLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0EsR0FBRztBQUNILGtCQUFrQixrREFBWTtBQUM5QiwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0EsdUJBQXVCLGtEQUFZO0FBQ25DLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzRDO0FBSzFCO0FBQ2lCOztBQUVuQztBQUM0QztBQUcxQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLDRCQUE0QjtBQUN0QyxtQkFBbUIsOENBQVE7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7O0FBRUE7QUFDdUQ7QUFDZ0I7O0FBRXZFO0FBQ29DO0FBQ3BDO0FBQ0Esb0JBQW9CLDhDQUFRO0FBQzVCO0FBQ0EsRUFBRSxJQUFJO0FBQ04sVUFBVSxXQUFXO0FBQ3JCO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQyx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQixxRUFBYztBQUNwQyxnREFBZ0QsK0NBQVM7QUFDekQsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQixJQUFJLHNCQUFzQjtBQUN0RjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBUztBQUM3QjtBQUNBLENBQUM7QUFDRCxVQUFVLFFBQVE7QUFDbEI7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQkFBb0IsOENBQVE7QUFDNUIsc0JBQXNCLHdDQUF3QztBQUM5RDtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw4Q0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQWtEO0FBQzFFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVcsbUJBQW1CLHlDQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdrQjtBQUNsQjtBQUNBLG9CQUFvQiw4Q0FBUztBQUM3QjtBQUNBLEVBQUUsSUFBSTtBQUNOLFVBQVUsV0FBVztBQUNyQjtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0Msd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEMsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUM0QztBQUcxQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsUUFBUTtBQUNsQixVQUFVLFdBQVcsZ0JBQWdCLG9CQUFvQjtBQUN6RCxvQkFBb0IsOENBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsOENBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDhDQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDb0Q7QUFDcEQsOEJBQThCO0FBQzlCLFVBQVUsa0RBQWtEO0FBQzVELFVBQVUsNENBQTRDO0FBQ3RELG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0Isa0RBQVk7QUFDOUIsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBLHVCQUF1QixrREFBWTtBQUNuQyxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEM7QUFDRDtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLFVBQVU7QUFDcEIsMEJBQTBCLDhDQUFRO0FBQ2xDO0FBQ0EsaUJBQWlCLHFEQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQThEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsaUNBQWlDO0FBQzNDLG9CQUFvQiwyQ0FBMkM7QUFDL0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsVUFBVTtBQUNwQixvQkFBb0IsOENBQVE7QUFDNUIsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLDhDQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR2tCO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0IsOENBQVM7QUFDN0I7QUFDQSxDQUFDO0FBQ0QsVUFBVSxXQUFXO0FBQ3JCO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRCx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0IsMkJBQTJCLGdDQUFnQztBQUMzRCxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEM7QUFLMUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLFdBQVc7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLGtCQUFrQiw4Q0FBUTtBQUMxQjtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEUsd0JBQXdCLGtEQUFrRDtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWSx5REFBeUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBUSxXQUFXLGlDQUFpQztBQUNwRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFVO0FBQzNCO0FBQ0E7O0FBRUE7QUFDNEM7QUFDSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsV0FBVztBQUNyQixVQUFVLFFBQVE7QUFDbEIsa0JBQWtCLDhDQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUEyQztBQUNyRSx3QkFBd0IscURBQXFEO0FBQzdFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzRDO0FBTzFCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsV0FBVztBQUNyQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLDhDQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBDQUFJO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBSTtBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQUk7QUFDbEM7QUFDQTtBQUNBLHNCQUFzQixpREFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBDQUFJO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0IsaURBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBSTtBQUNsQztBQUNBO0FBQ0Esc0JBQXNCLGlEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQUk7QUFDbEM7QUFDQTtBQUNBLHNCQUFzQixpREFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQUk7QUFDbEM7QUFDQTtBQUNBLHNCQUFzQixpREFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnREFBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpREFBWTtBQUNwRixxTEFBcUwsc0JBQXNCO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQWU7QUFDNUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEscURBQWU7QUFDNUIsZUFBZSwyQ0FBSztBQUNwQixHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEscURBQWU7QUFDNUIsb0JBQW9CLDJDQUFLO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxxREFBZTtBQUM1QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxxREFBZTtBQUM1QixnQkFBZ0IsMkNBQUs7QUFDckIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxrQkFBa0I7QUFDNUIsb0JBQW9CLDhDQUFTLG9CQUFvQixvQkFBb0I7QUFDckUsa0JBQWtCLDhDQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFLa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxXQUFXO0FBQ3JCO0FBQ0EsaUNBQWlDLHlDQUFJLE9BQU8sMENBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQVM7QUFDcEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDdUM7QUFDdkM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBVyxHQUFHLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLEdBQUcsT0FBTztBQUMvQyxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLEdBQUcsT0FBTztBQUMvQyxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLE9BQU87QUFDL0MsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLE9BQU87QUFDL0MsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxXQUFXLE9BQU87QUFDdkQsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLE9BQU87QUFDL0MsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ3NEO0FBQ3RELHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQVk7QUFDaEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7QUFtRUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtcmVhY3QvY29yZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5cbi8vIHNyYy9jb25uZWN0b3JzL2Jhc2UudHNcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbnZhciBDb25uZWN0b3IgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG59O1xuXG4vLyBzcmMvY29ubmVjdG9ycy9pbmplY3RlZC50c1xuaW1wb3J0IHtcbiAgUGVybWlzc2lvblxufSBmcm9tIFwiQHN0YXJrbmV0LWlvL3R5cGVzLWpzXCI7XG5pbXBvcnQge1xuICBXYWxsZXRBY2NvdW50XG59IGZyb20gXCJzdGFya25ldFwiO1xuXG4vLyBzcmMvZXJyb3JzLnRzXG52YXIgQ29ubmVjdG9yQWxyZWFkeUNvbm5lY3RlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJDb25uZWN0b3JBbHJlYWR5Q29ubmVjdGVkRXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1lc3NhZ2VcIiwgXCJDb25uZWN0b3IgYWxyZWFkeSBjb25uZWN0ZWRcIik7XG4gIH1cbn07XG52YXIgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkNvbm5lY3Rvck5vdENvbm5lY3RlZEVycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXNzYWdlXCIsIFwiQ29ubmVjdG9yIG5vdCBjb25uZWN0ZWRcIik7XG4gIH1cbn07XG52YXIgQ29ubmVjdG9yTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiQ29ubmVjdG9yTm90Rm91bmRFcnJvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWVzc2FnZVwiLCBcIkNvbm5lY3RvciBub3QgZm91bmRcIik7XG4gIH1cbn07XG52YXIgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1lc3NhZ2VcIiwgXCJVc2VyIHJlamVjdGVkIHJlcXVlc3RcIik7XG4gIH1cbn07XG52YXIgVXNlck5vdENvbm5lY3RlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJVc2VyTm90Q29ubmVjdGVkRXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1lc3NhZ2VcIiwgXCJVc2VyIG5vdCBjb25uZWN0ZWRcIik7XG4gIH1cbn07XG52YXIgVW5zdXBwb3J0ZWRBY2NvdW50SW50ZXJmYWNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIlVuc3VwcG9ydGVkQWNjb3VudEludGVyZmFjZUVycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXNzYWdlXCIsIFwiVW5zdXBwb3J0ZWQgYWNjb3VudCBpbnRlcmZhY2UuIHN0YXJrbmV0LXJlYWN0IHYxIG9ubHkgc3VwcG9ydHMgdGhlIHN0YXJrbmV0LmpzIHY1IGFjY291bnQgaW50ZXJmYWNlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY29ubmVjdG9ycy9pbmplY3RlZC50c1xudmFyIFdBTExFVF9OT1RfRk9VTkRfSUNPTl9MSUdIVCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdacGJHdzlJbTV2Ym1VaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdjM1J5YjJ0bExYZHBaSFJvUFNJeExqVWlJSE4wY205clpUMGlZbXhoWTJzaVBnb2dJRHh3WVhSb0lITjBjbTlyWlMxc2FXNWxZMkZ3UFNKeWIzVnVaQ0lnYzNSeWIydGxMV3hwYm1WcWIybHVQU0p5YjNWdVpDSWdaRDBpVFRrdU9EYzVJRGN1TlRFNVl6RXVNVGN4TFRFdU1ESTFJRE11TURjeExURXVNREkxSURRdU1qUXlJREFnTVM0eE56SWdNUzR3TWpVZ01TNHhOeklnTWk0Mk9EY2dNQ0F6TGpjeE1pMHVNakF6TGpFM09TMHVORE11TXpJMkxTNDJOeTQwTkRJdExqYzBOUzR6TmpFdE1TNDBOUzQ1T1RrdE1TNDBOU0F4TGpneU4zWXVOelZOTWpFZ01USmhPU0E1SURBZ01URXRNVGdnTUNBNUlEa2dNQ0F3TVRFNElEQjZiUzA1SURVdU1qVm9MakF3T0hZdU1EQTRTREV5ZGkwdU1EQTRlaUlnTHo0S1BDOXpkbWMrXCI7XG52YXIgV0FMTEVUX05PVF9GT1VORF9JQ09OX0RBUksgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHWnBiR3c5SW01dmJtVWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnYzNSeWIydGxMWGRwWkhSb1BTSXhMalVpSUhOMGNtOXJaVDBpZDJocGRHVWlQZ29nSUR4d1lYUm9JSE4wY205clpTMXNhVzVsWTJGd1BTSnliM1Z1WkNJZ2MzUnliMnRsTFd4cGJtVnFiMmx1UFNKeWIzVnVaQ0lnWkQwaVRUa3VPRGM1SURjdU5URTVZekV1TVRjeExURXVNREkxSURNdU1EY3hMVEV1TURJMUlEUXVNalF5SURBZ01TNHhOeklnTVM0d01qVWdNUzR4TnpJZ01pNDJPRGNnTUNBekxqY3hNaTB1TWpBekxqRTNPUzB1TkRNdU16STJMUzQyTnk0ME5ESXRMamMwTlM0ek5qRXRNUzQwTlM0NU9Ua3RNUzQwTlNBeExqZ3lOM1l1TnpWTk1qRWdNVEpoT1NBNUlEQWdNVEV0TVRnZ01DQTVJRGtnTUNBd01URTRJREI2YlMwNUlEVXVNalZvTGpBd09IWXVNREE0U0RFeWRpMHVNREE0ZWlJZ0x6NEtQQzl6ZG1jK0NnPT1cIjtcbnZhciB3YWxsZXRJY29ucyA9IHtcbiAgYXJnZW50WDogXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NEtQQ0V0TFNCSFpXNWxjbUYwYjNJNklFRmtiMkpsSUVsc2JIVnpkSEpoZEc5eUlESTBMakF1TVN3Z1UxWkhJRVY0Y0c5eWRDQlFiSFZuTFVsdUlDNGdVMVpISUZabGNuTnBiMjQ2SURZdU1EQWdRblZwYkdRZ01Da2dJQzB0UGdvOGMzWm5JSFpsY25OcGIyNDlJakV1TVNJZ2FXUTlJa3hoZVdWeVh6RWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWdvSklIWnBaWGRDYjNnOUlqQWdNQ0EyTlM0eE9UVXdPQ0ExTnk0M016VTJNaUlnYzNSNWJHVTlJbVZ1WVdKc1pTMWlZV05yWjNKdmRXNWtPbTVsZHlBd0lEQWdOalV1TVRrMU1EZ2dOVGN1TnpNMU5qSTdJaUI0Yld3NmMzQmhZMlU5SW5CeVpYTmxjblpsSWo0S1BITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajRLQ1M1emREQjdabWxzYkRvalJrWTROelZDTzMwS1BDOXpkSGxzWlQ0S1BIQmhkR2dnWTJ4aGMzTTlJbk4wTUNJZ1pEMGlUVFF3TGprNE5Ua3lMREJJTWpRdU1qQTRPRGhqTFRBdU5UWXNNQzB4TGpBeE1EQXhMREF1TkRVeE1ESXRNUzR3TWpFNU55d3hMakF4TWpBeUNnbGpMVEF1TXpNNE9Ua3NNVFV1TnpVMUxUZ3VOVGd5TURNc016QXVOekE0T1RndE1qSXVOemN3TURJc05ERXVNekF3T1RsakxUQXVORFV3TURFc01DNHpNemN3TVMwd0xqVTFNams0TERBdU9UWTNPVGt0TUM0eU1qUXNNUzQwTWpOc09TNDRNVFU1T0N3eE15NDFOek1LQ1dNd0xqTXpOREExTERBdU5EWXlNREVzTUM0NU9EVXdOU3d3TGpVMk5UazRMREV1TkRReU9Ua3NNQzR5TWpZNU9XTTRMamczTVRBekxUWXVOVGM1TURFc01UWXVNREEzTURJdE1UUXVOVEUzTERJeExqRTBOakEyTFRJekxqTXhOUW9KWXpVdU1UTTRMRGd1TnprNExERXlMakkzTXprNUxERTJMamN6TlRrNUxESXhMakUwTml3eU15NHpNVFZqTUM0ME5UWTVOeXd3TGpNek9EazVMREV1TVRBM09UY3NNQzR5TXpVd01pd3hMalEwTVRrMkxUQXVNakkyT1Rsc09TNDRNVFl3TkMweE15NDFOek1LQ1dNd0xqTXlPRGs0TFRBdU5EVTFNRElzTUM0eU1qWTVPUzB4TGpBNE5pMHdMakl5TkMweExqUXlNME0xTUM0MU9EazROaXd6TVM0M01qRXdNU3cwTWk0ek5EWTRPQ3d4Tmk0M05qY3dNeXcwTWk0d01EYzRPU3d4TGpBeE1qQXlDZ2xETkRFdU9UazFPRGNzTUM0ME5URXdNaXcwTVM0MU5EWTRPU3d3TERRd0xqazROVGt5TERBaUx6NEtQQzl6ZG1jK0NnPT1cIixcbiAgYnJhYXZvczogXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEF3SWlCb1pXbG5hSFE5SWpVd01DSWdkbWxsZDBKdmVEMGlNQ0F3SURVd01DQTFNREFpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK0NqeHdZWFJvSUdROUlrMHpNak11TkRRZ05ERXVNemc0TmtNek1qUXVNVGs0SURReUxqWTNNamdnTXpJekxqRTVOU0EwTkM0eU5qQXpJRE15TVM0M01EUWdORFF1TWpZd00wTXlPVEV1TlRFZ05EUXVNall3TXlBeU5qWXVPVFkxSURZNExqRTJOVFlnTWpZMkxqTTRPU0E1Tnk0NE56RkRNalUyTGpBMUlEazFMamswTURjZ01qUTFMak16TnlBNU5TNDNPVFUySURJek5DNDNOVFFnT1RjdU5UYzROME15TXpRdU1ESXpJRFk0TGpBd09TQXlNRGt1TlRRZ05EUXVNall3TXlBeE56a3VORFExSURRMExqSTJNRE5ETVRjM0xqazFNeUEwTkM0eU5qQXpJREUzTmk0NU5Ea2dOREl1TmpjeE5pQXhOemN1TnpBM0lEUXhMak00TmpWRE1Ua3lMak15TXlBeE5pNDJNek1nTWpFNUxqUTRNeUF3SURJMU1DNDFOek1nTUVNeU9ERXVOalkwSURBZ016QTRMamd5TkNBeE5pNDJNek01SURNeU15NDBOQ0EwTVM0ek9EZzJXaUlnWm1sc2JEMGlkWEpzS0NOd1lXbHVkREJmYkdsdVpXRnlYekl6TWpSZk5qRTROamtwSWk4K0NqeHdZWFJvSUdROUlrMDBNVGd1TnpVMklESXlOaTQ0T1RSRE5ESTJMak0zSURJeU9TNHlJRFF6TXk0MU9ERWdNakl5TGpVeE55QTBNekV1TURNMklESXhOQzQ1TnpsRE5EQTBMalV3TnlBeE16WXVOREF4SURNeE5pNDFNelVnTVRBMExqTTFPQ0F5TlRBdU1UVTVJREV3TkM0ek5UaERNVGd6TGpZM05DQXhNRFF1TXpVNElEa3pMamN6T1RFZ01UTTNMalF4T0NBMk9TNHpNRFV4SURJeE5TNHpNekZETmpZdU9UVTNOQ0F5TWpJdU9ERTRJRGMwTGpFME5qVWdNakk1TGpJM05TQTRNUzQyTkRjNUlESXlOaTQ1TnpkTU1qUTBMakkxSURFM055NHhOVEZETWpRM0xqVTJPU0F4TnpZdU1UTTBJREkxTVM0eE1UWWdNVGMyTGpFeU9DQXlOVFF1TkRNNUlERTNOeTR4TXpWTU5ERTRMamMxTmlBeU1qWXVPRGswV2lJZ1ptbHNiRDBpZFhKc0tDTndZV2x1ZERGZmJHbHVaV0Z5WHpJek1qUmZOakU0TmprcElpOCtDanh3WVhSb0lHUTlJazAyT1M0M01UWTFJREl6T1M0ME1qWk1NalEwTGpNM0lERTROaTQwTlRaRE1qUTNMalkyT1NBeE9EVXVORFUySURJMU1TNHhPVEVnTVRnMUxqUTFNeUF5TlRRdU5Ea3lJREU0Tmk0ME5EaE1ORE13TGpJek1pQXlNemt1TkRVeVF6UTBOQzQzTmlBeU5ETXVPRE16SURRMU5DNDNNREVnTWpVM0xqSXhOaUEwTlRRdU56QXhJREkzTWk0ek9WWTBNekF1TkRneFF6UTFOQzR3TWpnZ05EWTVMakEzSURReE9TNHpOaklnTlRBd0lETTRNQzQzT0RZZ05UQXdTRE14Tmk0M01USkRNekV3TGpNM09TQTFNREFnTXpBMUxqSTFJRFE1TkM0NE56Y2dNekExTGpJMUlEUTRPQzQxTkROV05ETXpMakV4TlVNek1EVXVNalVnTkRFeExqSTRPU0F6TVRndU1UWTNJRE01TVM0MU16VWdNek00TGpFMU5TQXpPREl1TnpreVF6TTJOQzQ1TkRrZ016Y3hMakEzTVNBek9UWXVOalEySURNMU5TNHlNVGdnTkRBeUxqWXdPQ0F6TWpNdU5EQTJRelF3TkM0MU16SWdNekV6TGpFek9DQXpPVGN1T0RNM0lETXdNeTR5TXpRZ016ZzNMalU1TlNBek1ERXVNVGs0UXpNMk1TNDJPVGtnTWprMkxqQTFNU0F6TXpJdU9UZzVJREk1T0M0d016a2dNekE0TGpjeE1TQXpNRGd1T0RrNFF6STRNUzR4TlNBek1qRXVNakkxSURJM015NDVOQ0F6TkRFdU56TXhJREkzTVM0eU56RWdNelk1TGpJM1RESTJPQzR3TXpZZ016azRMamt6T0VNeU5qY3VNRFEzSURRd09DNHdNRFVnTWpVNExqVTBOaUEwTVRRdU9UVXlJREkwT1M0ME1qa2dOREUwTGprMU1rTXlNemt1T1RrNElEUXhOQzQ1TlRJZ01qTXlMamt5TmlBME1EY3VOelk1SURJek1TNDVNRE1nTXprNExqTTRPRXd5TWpndU56STRJRE0yT1M0eU4wTXlNall1TkRReUlETTBOUzQyT0RFZ01qSXlMakk1T0NBek1qSXVOelkzSURFNU55NDVNVElnTXpFeExqZzJRekUzTUM0d09UVWdNams1TGpReE9TQXhOREl1TVRReElESTVOUzR5T0RjZ01URXlMalF3TkNBek1ERXVNVGs0UXpFd01pNHhOaklnTXpBekxqSXpOQ0E1TlM0ME5qY2dNekV6TGpFek9DQTVOeTR6T1RFeklETXlNeTQwTURaRE1UQXpMalF3TlNBek5UVXVORGsxSURFek5DNDROVFFnTXpjd0xqazROU0F4TmpFdU9EUTBJRE00TWk0M09USkRNVGd4TGpnek15QXpPVEV1TlRNMUlERTVOQzQzTlNBME1URXVNamc1SURFNU5DNDNOU0EwTXpNdU1URTFWalE0T0M0MU16TkRNVGswTGpjMUlEUTVOQzQ0TmpjZ01UZzVMall5TWlBMU1EQWdNVGd6TGpJNE9TQTFNREJJTVRFNUxqSXhORU00TUM0Mk16YzBJRFV3TUNBME5TNDVOekUySURRMk9TNHdOeUEwTlM0eU9UYzVJRFF6TUM0ME9ERldNamN5TGpNME9VTTBOUzR5T1RjNUlESTFOeTR4T1RRZ05UVXVNakUwTWlBeU5ETXVPREkwSURZNUxqY3hOalVnTWpNNUxqUXlObG9pSUdacGJHdzlJblZ5YkNnamNHRnBiblF5WDJ4cGJtVmhjbDh5TXpJMFh6WXhPRFk1S1NJdlBnbzhaR1ZtY3o0S1BHeHBibVZoY2tkeVlXUnBaVzUwSUdsa1BTSndZV2x1ZERCZmJHbHVaV0Z5WHpJek1qUmZOakU0TmpraUlIZ3hQU0l5TkRVdU9UZzJJaUI1TVQwaUxUSTNJaUI0TWowaU5ESTFMalE1TmlJZ2VUSTlJalV3TWk0ek56WWlJR2R5WVdScFpXNTBWVzVwZEhNOUluVnpaWEpUY0dGalpVOXVWWE5sSWo0S1BITjBiM0FnYzNSdmNDMWpiMnh2Y2owaUkwWTFSRFExUlNJdlBnbzhjM1J2Y0NCdlptWnpaWFE5SWpFaUlITjBiM0F0WTI5c2IzSTlJaU5HUmprMk1EQWlMejRLUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDRLUEd4cGJtVmhja2R5WVdScFpXNTBJR2xrUFNKd1lXbHVkREZmYkdsdVpXRnlYekl6TWpSZk5qRTROamtpSUhneFBTSXlORFV1T1RnMklpQjVNVDBpTFRJM0lpQjRNajBpTkRJMUxqUTVOaUlnZVRJOUlqVXdNaTR6TnpZaUlHZHlZV1JwWlc1MFZXNXBkSE05SW5WelpYSlRjR0ZqWlU5dVZYTmxJajRLUEhOMGIzQWdjM1J2Y0MxamIyeHZjajBpSTBZMVJEUTFSU0l2UGdvOGMzUnZjQ0J2Wm1aelpYUTlJakVpSUhOMGIzQXRZMjlzYjNJOUlpTkdSamsyTURBaUx6NEtQQzlzYVc1bFlYSkhjbUZrYVdWdWRENEtQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0p3WVdsdWRESmZiR2x1WldGeVh6SXpNalJmTmpFNE5qa2lJSGd4UFNJeU5EVXVPVGcySWlCNU1UMGlMVEkzSWlCNE1qMGlOREkxTGpRNU5pSWdlVEk5SWpVd01pNHpOellpSUdkeVlXUnBaVzUwVlc1cGRITTlJblZ6WlhKVGNHRmpaVTl1VlhObElqNEtQSE4wYjNBZ2MzUnZjQzFqYjJ4dmNqMGlJMFkxUkRRMVJTSXZQZ284YzNSdmNDQnZabVp6WlhROUlqRWlJSE4wYjNBdFkyOXNiM0k5SWlOR1JqazJNREFpTHo0S1BDOXNhVzVsWVhKSGNtRmthV1Z1ZEQ0S1BDOWtaV1p6UGdvOEwzTjJaejQ9XCJcbn07XG52YXIgSW5qZWN0ZWRDb25uZWN0b3IgPSBjbGFzcyBleHRlbmRzIENvbm5lY3RvciB7XG4gIGNvbnN0cnVjdG9yKHsgb3B0aW9ucyB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3dhbGxldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX29wdGlvbnNcIik7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmlkO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHRoaXMuZW5zdXJlV2FsbGV0KCk7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMubmFtZSA/PyB0aGlzLl93YWxsZXQ/Lm5hbWUgPz8gdGhpcy5fb3B0aW9ucy5pZDtcbiAgfVxuICBnZXQgaWNvbigpIHtcbiAgICB0aGlzLmVuc3VyZVdhbGxldCgpO1xuICAgIGNvbnN0IGRlYWZ1bHRJY29uID0ge1xuICAgICAgZGFyazogd2FsbGV0SWNvbnNbdGhpcy5pZF0gfHwgV0FMTEVUX05PVF9GT1VORF9JQ09OX0RBUkssXG4gICAgICBsaWdodDogd2FsbGV0SWNvbnNbdGhpcy5pZF0gfHwgV0FMTEVUX05PVF9GT1VORF9JQ09OX0xJR0hUXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5pY29uIHx8IHRoaXMuX3dhbGxldD8uaWNvbiB8fCBkZWFmdWx0SWNvbjtcbiAgfVxuICBhdmFpbGFibGUoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0ICE9PSB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgY2hhaW5JZCgpIHtcbiAgICB0aGlzLmVuc3VyZVdhbGxldCgpO1xuICAgIGNvbnN0IGxvY2tlZCA9IGF3YWl0IHRoaXMuaXNMb2NrZWQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldCB8fCBsb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdENoYWluSWQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RGb3VuZEVycm9yKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlYWR5KCkge1xuICAgIHRoaXMuZW5zdXJlV2FsbGV0KCk7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICB0eXBlOiBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHBlcm1pc3Npb25zPy5pbmNsdWRlcyhQZXJtaXNzaW9uLkFDQ09VTlRTKTtcbiAgfVxuICBhc3luYyBhY2NvdW50KHByb3ZpZGVyKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBjb25zdCBsb2NrZWQgPSBhd2FpdCB0aGlzLmlzTG9ja2VkKCk7XG4gICAgaWYgKGxvY2tlZCB8fCAhdGhpcy5fd2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXYWxsZXRBY2NvdW50KHByb3ZpZGVyLCB0aGlzLl93YWxsZXQpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoX2FyZ3MgPSB7fSkge1xuICAgIHRoaXMuZW5zdXJlV2FsbGV0KCk7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RGb3VuZEVycm9yKCk7XG4gICAgfVxuICAgIGxldCBhY2NvdW50cztcbiAgICB0cnkge1xuICAgICAgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0QWNjb3VudHNcIlxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKCk7XG4gICAgfVxuICAgIGlmICghYWNjb3VudHMpIHtcbiAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG4gICAgdGhpcy5fd2FsbGV0Lm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsIGFzeW5jIChhY2NvdW50czIpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMub25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMyKTtcbiAgICB9KTtcbiAgICB0aGlzLl93YWxsZXQub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCAoY2hhaW5JZDIsIGFjY291bnRzMikgPT4ge1xuICAgICAgdGhpcy5vbk5ldHdvcmtDaGFuZ2VkKGNoYWluSWQyLCBhY2NvdW50czIpO1xuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMub25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpO1xuICAgIGNvbnN0IFthY2NvdW50XSA9IGFjY291bnRzO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLnJlcXVlc3RDaGFpbklkKCk7XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7IGFjY291bnQsIGNoYWluSWQgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnQsXG4gICAgICBjaGFpbklkXG4gICAgfTtcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuZW5zdXJlV2FsbGV0KCk7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RGb3VuZEVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChjYWxsKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fd2FsbGV0LnJlcXVlc3QoY2FsbCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGlzTG9ja2VkKCkge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIHR5cGU6IFwid2FsbGV0X3JlcXVlc3RBY2NvdW50c1wiLFxuICAgICAgcGFyYW1zOiB7IHNpbGVudF9tb2RlOiB0cnVlIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWNjb3VudHMubGVuZ3RoID09PSAwO1xuICB9XG4gIGFzeW5jIHJlcXVlc3RDaGFpbklkKCkge1xuICAgIGNvbnN0IGNoYWluSWRIZXggPSBhd2FpdCB0aGlzLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9yZXF1ZXN0Q2hhaW5JZFwiIH0pO1xuICAgIHJldHVybiBCaWdJbnQoY2hhaW5JZEhleCk7XG4gIH1cbiAgZW5zdXJlV2FsbGV0KCkge1xuICAgIGNvbnN0IGdsb2JhbF9vYmplY3QgPSBnbG9iYWxUaGlzO1xuICAgIGNvbnN0IHdhbGxldCA9IGdsb2JhbF9vYmplY3Q/Lltgc3RhcmtuZXRfJHt0aGlzLl9vcHRpb25zLmlkfWBdO1xuICAgIGlmICh3YWxsZXQpIHtcbiAgICAgIHRoaXMuX3dhbGxldCA9IHdhbGxldDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgb25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICBpZiAoIWFjY291bnRzKSB7XG4gICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbYWNjb3VudF0gPSBhY2NvdW50cztcbiAgICAgIGlmIChhY2NvdW50KSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLnJlcXVlc3RDaGFpbklkKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7IGFjY291bnQsIGNoYWluSWQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbk5ldHdvcmtDaGFuZ2VkKGNoYWluSWRIZXgsIGFjY291bnRzKSB7XG4gICAgaWYgKGNoYWluSWRIZXgpIHtcbiAgICAgIGNvbnN0IGNoYWluSWQgPSBCaWdJbnQoY2hhaW5JZEhleCk7XG4gICAgICBjb25zdCBbYWNjb3VudF0gPSBhY2NvdW50cyB8fCBbXTtcbiAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7IGNoYWluSWQsIGFjY291bnQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7fSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY29ubmVjdG9ycy9sZWdhY3kudHNcbmltcG9ydCB7XG4gIFBlcm1pc3Npb24gYXMgUGVybWlzc2lvbjJcbn0gZnJvbSBcIkBzdGFya25ldC1pby90eXBlcy1qc1wiO1xuaW1wb3J0IHsgbWFpbm5ldCwgc2Vwb2xpYSB9IGZyb20gXCJAc3RhcmtuZXQtcmVhY3QvY2hhaW5zXCI7XG52YXIgV0FMTEVUX05PVF9GT1VORF9JQ09OX0xJR0hUMiA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdacGJHdzlJbTV2Ym1VaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdjM1J5YjJ0bExYZHBaSFJvUFNJeExqVWlJSE4wY205clpUMGlZbXhoWTJzaVBnb2dJRHh3WVhSb0lITjBjbTlyWlMxc2FXNWxZMkZ3UFNKeWIzVnVaQ0lnYzNSeWIydGxMV3hwYm1WcWIybHVQU0p5YjNWdVpDSWdaRDBpVFRrdU9EYzVJRGN1TlRFNVl6RXVNVGN4TFRFdU1ESTFJRE11TURjeExURXVNREkxSURRdU1qUXlJREFnTVM0eE56SWdNUzR3TWpVZ01TNHhOeklnTWk0Mk9EY2dNQ0F6TGpjeE1pMHVNakF6TGpFM09TMHVORE11TXpJMkxTNDJOeTQwTkRJdExqYzBOUzR6TmpFdE1TNDBOUzQ1T1RrdE1TNDBOU0F4TGpneU4zWXVOelZOTWpFZ01USmhPU0E1SURBZ01URXRNVGdnTUNBNUlEa2dNQ0F3TVRFNElEQjZiUzA1SURVdU1qVm9MakF3T0hZdU1EQTRTREV5ZGkwdU1EQTRlaUlnTHo0S1BDOXpkbWMrXCI7XG52YXIgV0FMTEVUX05PVF9GT1VORF9JQ09OX0RBUksyID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR1pwYkd3OUltNXZibVVpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2MzUnliMnRsTFhkcFpIUm9QU0l4TGpVaUlITjBjbTlyWlQwaWQyaHBkR1VpUGdvZ0lEeHdZWFJvSUhOMGNtOXJaUzFzYVc1bFkyRndQU0p5YjNWdVpDSWdjM1J5YjJ0bExXeHBibVZxYjJsdVBTSnliM1Z1WkNJZ1pEMGlUVGt1T0RjNUlEY3VOVEU1WXpFdU1UY3hMVEV1TURJMUlETXVNRGN4TFRFdU1ESTFJRFF1TWpReUlEQWdNUzR4TnpJZ01TNHdNalVnTVM0eE56SWdNaTQyT0RjZ01DQXpMamN4TWkwdU1qQXpMakUzT1MwdU5ETXVNekkyTFM0Mk55NDBOREl0TGpjME5TNHpOakV0TVM0ME5TNDVPVGt0TVM0ME5TQXhMamd5TjNZdU56Vk5NakVnTVRKaE9TQTVJREFnTVRFdE1UZ2dNQ0E1SURrZ01DQXdNVEU0SURCNmJTMDVJRFV1TWpWb0xqQXdPSFl1TURBNFNERXlkaTB1TURBNGVpSWdMejRLUEM5emRtYytDZz09XCI7XG52YXIgd2FsbGV0SWNvbnMyID0ge1xuICBhcmdlbnRYOiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0S1BDRXRMU0JIWlc1bGNtRjBiM0k2SUVGa2IySmxJRWxzYkhWemRISmhkRzl5SURJMExqQXVNU3dnVTFaSElFVjRjRzl5ZENCUWJIVm5MVWx1SUM0Z1UxWkhJRlpsY25OcGIyNDZJRFl1TURBZ1FuVnBiR1FnTUNrZ0lDMHRQZ284YzNabklIWmxjbk5wYjI0OUlqRXVNU0lnYVdROUlreGhlV1Z5WHpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpSUhnOUlqQndlQ0lnZVQwaU1IQjRJZ29KSUhacFpYZENiM2c5SWpBZ01DQTJOUzR4T1RVd09DQTFOeTQzTXpVMk1pSWdjM1I1YkdVOUltVnVZV0pzWlMxaVlXTnJaM0p2ZFc1a09tNWxkeUF3SURBZ05qVXVNVGsxTURnZ05UY3VOek0xTmpJN0lpQjRiV3c2YzNCaFkyVTlJbkJ5WlhObGNuWmxJajRLUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNEtDUzV6ZERCN1ptbHNiRG9qUmtZNE56VkNPMzBLUEM5emRIbHNaVDRLUEhCaGRHZ2dZMnhoYzNNOUluTjBNQ0lnWkQwaVRUUXdMams0TlRreUxEQklNalF1TWpBNE9EaGpMVEF1TlRZc01DMHhMakF4TURBeExEQXVORFV4TURJdE1TNHdNakU1Tnl3eExqQXhNakF5Q2dsakxUQXVNek00T1Rrc01UVXVOelUxTFRndU5UZ3lNRE1zTXpBdU56QTRPVGd0TWpJdU56Y3dNRElzTkRFdU16QXdPVGxqTFRBdU5EVXdNREVzTUM0ek16Y3dNUzB3TGpVMU1qazRMREF1T1RZM09Ua3RNQzR5TWpRc01TNDBNak5zT1M0NE1UVTVPQ3d4TXk0MU56TUtDV013TGpNek5EQTFMREF1TkRZeU1ERXNNQzQ1T0RVd05Td3dMalUyTlRrNExERXVORFF5T1Rrc01DNHlNalk1T1dNNExqZzNNVEF6TFRZdU5UYzVNREVzTVRZdU1EQTNNREl0TVRRdU5URTNMREl4TGpFME5qQTJMVEl6TGpNeE5Rb0pZelV1TVRNNExEZ3VOems0TERFeUxqSTNNems1TERFMkxqY3pOVGs1TERJeExqRTBOaXd5TXk0ek1UVmpNQzQwTlRZNU55d3dMak16T0RrNUxERXVNVEEzT1Rjc01DNHlNelV3TWl3eExqUTBNVGsyTFRBdU1qSTJPVGxzT1M0NE1UWXdOQzB4TXk0MU56TUtDV013TGpNeU9EazRMVEF1TkRVMU1ESXNNQzR5TWpZNU9TMHhMakE0Tmkwd0xqSXlOQzB4TGpReU0wTTFNQzQxT0RrNE5pd3pNUzQzTWpFd01TdzBNaTR6TkRZNE9Dd3hOaTQzTmpjd015dzBNaTR3TURjNE9Td3hMakF4TWpBeUNnbEROREV1T1RrMU9EY3NNQzQwTlRFd01pdzBNUzQxTkRZNE9Td3dMRFF3TGprNE5Ua3lMREFpTHo0S1BDOXpkbWMrQ2c9PVwiLFxuICBicmFhdm9zOiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5UQXdJaUJvWldsbmFIUTlJalV3TUNJZ2RtbGxkMEp2ZUQwaU1DQXdJRFV3TUNBMU1EQWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrQ2p4d1lYUm9JR1E5SWswek1qTXVORFFnTkRFdU16ZzROa016TWpRdU1UazRJRFF5TGpZM01qZ2dNekl6TGpFNU5TQTBOQzR5TmpBeklETXlNUzQzTURRZ05EUXVNall3TTBNeU9URXVOVEVnTkRRdU1qWXdNeUF5TmpZdU9UWTFJRFk0TGpFMk5UWWdNalkyTGpNNE9TQTVOeTQ0TnpGRE1qVTJMakExSURrMUxqazBNRGNnTWpRMUxqTXpOeUE1TlM0M09UVTJJREl6TkM0M05UUWdPVGN1TlRjNE4wTXlNelF1TURJeklEWTRMakF3T1NBeU1Ea3VOVFFnTkRRdU1qWXdNeUF4TnprdU5EUTFJRFEwTGpJMk1ETkRNVGMzTGprMU15QTBOQzR5TmpBeklERTNOaTQ1TkRrZ05ESXVOamN4TmlBeE56Y3VOekEzSURReExqTTROalZETVRreUxqTXlNeUF4Tmk0Mk16TWdNakU1TGpRNE15QXdJREkxTUM0MU56TWdNRU15T0RFdU5qWTBJREFnTXpBNExqZ3lOQ0F4Tmk0Mk16TTVJRE15TXk0ME5DQTBNUzR6T0RnMldpSWdabWxzYkQwaWRYSnNLQ053WVdsdWREQmZiR2x1WldGeVh6SXpNalJmTmpFNE5qa3BJaTgrQ2p4d1lYUm9JR1E5SWswME1UZ3VOelUySURJeU5pNDRPVFJETkRJMkxqTTNJREl5T1M0eUlEUXpNeTQxT0RFZ01qSXlMalV4TnlBME16RXVNRE0ySURJeE5DNDVOemxETkRBMExqVXdOeUF4TXpZdU5EQXhJRE14Tmk0MU16VWdNVEEwTGpNMU9DQXlOVEF1TVRVNUlERXdOQzR6TlRoRE1UZ3pMalkzTkNBeE1EUXVNelU0SURrekxqY3pPVEVnTVRNM0xqUXhPQ0EyT1M0ek1EVXhJREl4TlM0ek16RkROall1T1RVM05DQXlNakl1T0RFNElEYzBMakUwTmpVZ01qSTVMakkzTlNBNE1TNDJORGM1SURJeU5pNDVOemRNTWpRMExqSTFJREUzTnk0eE5URkRNalEzTGpVMk9TQXhOell1TVRNMElESTFNUzR4TVRZZ01UYzJMakV5T0NBeU5UUXVORE01SURFM055NHhNelZNTkRFNExqYzFOaUF5TWpZdU9EazBXaUlnWm1sc2JEMGlkWEpzS0NOd1lXbHVkREZmYkdsdVpXRnlYekl6TWpSZk5qRTROamtwSWk4K0NqeHdZWFJvSUdROUlrMDJPUzQzTVRZMUlESXpPUzQwTWpaTU1qUTBMak0zSURFNE5pNDBOVFpETWpRM0xqWTJPU0F4T0RVdU5EVTJJREkxTVM0eE9URWdNVGcxTGpRMU15QXlOVFF1TkRreUlERTROaTQwTkRoTU5ETXdMakl6TWlBeU16a3VORFV5UXpRME5DNDNOaUF5TkRNdU9ETXpJRFExTkM0M01ERWdNalUzTGpJeE5pQTBOVFF1TnpBeElESTNNaTR6T1ZZME16QXVORGd4UXpRMU5DNHdNamdnTkRZNUxqQTNJRFF4T1M0ek5qSWdOVEF3SURNNE1DNDNPRFlnTlRBd1NETXhOaTQzTVRKRE16RXdMak0zT1NBMU1EQWdNekExTGpJMUlEUTVOQzQ0TnpjZ016QTFMakkxSURRNE9DNDFORE5XTkRNekxqRXhOVU16TURVdU1qVWdOREV4TGpJNE9TQXpNVGd1TVRZM0lETTVNUzQxTXpVZ016TTRMakUxTlNBek9ESXVOemt5UXpNMk5DNDVORGtnTXpjeExqQTNNU0F6T1RZdU5qUTJJRE0xTlM0eU1UZ2dOREF5TGpZd09DQXpNak11TkRBMlF6UXdOQzQxTXpJZ016RXpMakV6T0NBek9UY3VPRE0zSURNd015NHlNelFnTXpnM0xqVTVOU0F6TURFdU1UazRRek0yTVM0Mk9Ua2dNamsyTGpBMU1TQXpNekl1T1RnNUlESTVPQzR3TXprZ016QTRMamN4TVNBek1EZ3VPRGs0UXpJNE1TNHhOU0F6TWpFdU1qSTFJREkzTXk0NU5DQXpOREV1TnpNeElESTNNUzR5TnpFZ016WTVMakkzVERJMk9DNHdNellnTXprNExqa3pPRU15TmpjdU1EUTNJRFF3T0M0d01EVWdNalU0TGpVME5pQTBNVFF1T1RVeUlESTBPUzQwTWprZ05ERTBMamsxTWtNeU16a3VPVGs0SURReE5DNDVOVElnTWpNeUxqa3lOaUEwTURjdU56WTVJREl6TVM0NU1ETWdNems0TGpNNE9Fd3lNamd1TnpJNElETTJPUzR5TjBNeU1qWXVORFF5SURNME5TNDJPREVnTWpJeUxqSTVPQ0F6TWpJdU56WTNJREU1Tnk0NU1USWdNekV4TGpnMlF6RTNNQzR3T1RVZ01qazVMalF4T1NBeE5ESXVNVFF4SURJNU5TNHlPRGNnTVRFeUxqUXdOQ0F6TURFdU1UazRRekV3TWk0eE5qSWdNekF6TGpJek5DQTVOUzQwTmpjZ016RXpMakV6T0NBNU55NHpPVEV6SURNeU15NDBNRFpETVRBekxqUXdOU0F6TlRVdU5EazFJREV6TkM0NE5UUWdNemN3TGprNE5TQXhOakV1T0RRMElETTRNaTQzT1RKRE1UZ3hMamd6TXlBek9URXVOVE0xSURFNU5DNDNOU0EwTVRFdU1qZzVJREU1TkM0M05TQTBNek11TVRFMVZqUTRPQzQxTXpORE1UazBMamMxSURRNU5DNDROamNnTVRnNUxqWXlNaUExTURBZ01UZ3pMakk0T1NBMU1EQklNVEU1TGpJeE5FTTRNQzQyTXpjMElEVXdNQ0EwTlM0NU56RTJJRFEyT1M0d055QTBOUzR5T1RjNUlEUXpNQzQwT0RGV01qY3lMak0wT1VNME5TNHlPVGM1SURJMU55NHhPVFFnTlRVdU1qRTBNaUF5TkRNdU9ESTBJRFk1TGpjeE5qVWdNak01TGpReU5sb2lJR1pwYkd3OUluVnliQ2dqY0dGcGJuUXlYMnhwYm1WaGNsOHlNekkwWHpZeE9EWTVLU0l2UGdvOFpHVm1jejRLUEd4cGJtVmhja2R5WVdScFpXNTBJR2xrUFNKd1lXbHVkREJmYkdsdVpXRnlYekl6TWpSZk5qRTROamtpSUhneFBTSXlORFV1T1RnMklpQjVNVDBpTFRJM0lpQjRNajBpTkRJMUxqUTVOaUlnZVRJOUlqVXdNaTR6TnpZaUlHZHlZV1JwWlc1MFZXNXBkSE05SW5WelpYSlRjR0ZqWlU5dVZYTmxJajRLUEhOMGIzQWdjM1J2Y0MxamIyeHZjajBpSTBZMVJEUTFSU0l2UGdvOGMzUnZjQ0J2Wm1aelpYUTlJakVpSUhOMGIzQXRZMjlzYjNJOUlpTkdSamsyTURBaUx6NEtQQzlzYVc1bFlYSkhjbUZrYVdWdWRENEtQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0p3WVdsdWRERmZiR2x1WldGeVh6SXpNalJmTmpFNE5qa2lJSGd4UFNJeU5EVXVPVGcySWlCNU1UMGlMVEkzSWlCNE1qMGlOREkxTGpRNU5pSWdlVEk5SWpVd01pNHpOellpSUdkeVlXUnBaVzUwVlc1cGRITTlJblZ6WlhKVGNHRmpaVTl1VlhObElqNEtQSE4wYjNBZ2MzUnZjQzFqYjJ4dmNqMGlJMFkxUkRRMVJTSXZQZ284YzNSdmNDQnZabVp6WlhROUlqRWlJSE4wYjNBdFkyOXNiM0k5SWlOR1JqazJNREFpTHo0S1BDOXNhVzVsWVhKSGNtRmthV1Z1ZEQ0S1BHeHBibVZoY2tkeVlXUnBaVzUwSUdsa1BTSndZV2x1ZERKZmJHbHVaV0Z5WHpJek1qUmZOakU0TmpraUlIZ3hQU0l5TkRVdU9UZzJJaUI1TVQwaUxUSTNJaUI0TWowaU5ESTFMalE1TmlJZ2VUSTlJalV3TWk0ek56WWlJR2R5WVdScFpXNTBWVzVwZEhNOUluVnpaWEpUY0dGalpVOXVWWE5sSWo0S1BITjBiM0FnYzNSdmNDMWpiMnh2Y2owaUkwWTFSRFExUlNJdlBnbzhjM1J2Y0NCdlptWnpaWFE5SWpFaUlITjBiM0F0WTI5c2IzSTlJaU5HUmprMk1EQWlMejRLUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDRLUEM5a1pXWnpQZ284TDNOMlp6ND1cIlxufTtcbnZhciBMZWdhY3lJbmplY3RlZENvbm5lY3RvciA9IGNsYXNzIGV4dGVuZHMgQ29ubmVjdG9yIHtcbiAgY29uc3RydWN0b3IoeyBvcHRpb25zIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfd2FsbGV0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfb3B0aW9uc1wiKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuaWQ7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMubmFtZSA/PyB0aGlzLl93YWxsZXQ/Lm5hbWUgPz8gdGhpcy5fb3B0aW9ucy5pZDtcbiAgfVxuICBnZXQgaWNvbigpIHtcbiAgICBjb25zdCBkZWZhdWx0SWNvbiA9IHtcbiAgICAgIGRhcms6IHdhbGxldEljb25zMlt0aGlzLmlkXSB8fCBXQUxMRVRfTk9UX0ZPVU5EX0lDT05fREFSSzIsXG4gICAgICBsaWdodDogd2FsbGV0SWNvbnMyW3RoaXMuaWRdIHx8IFdBTExFVF9OT1RfRk9VTkRfSUNPTl9MSUdIVDJcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmljb24gfHwgdGhpcy5fd2FsbGV0Py5pY29uIHx8IGRlZmF1bHRJY29uO1xuICB9XG4gIGF2YWlsYWJsZSgpIHtcbiAgICB0aGlzLmVuc3VyZVdhbGxldCgpO1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQgIT09IHZvaWQgMDtcbiAgfVxuICBhc3luYyBjaGFpbklkKCkge1xuICAgIHRoaXMuZW5zdXJlV2FsbGV0KCk7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQgfHwgIXRoaXMuX3dhbGxldC5wcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluSWRIZXggPSBhd2FpdCB0aGlzLl93YWxsZXQucHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBCaWdJbnQoY2hhaW5JZEhleCk7XG4gICAgcmV0dXJuIGNoYWluSWQ7XG4gIH1cbiAgYXN5bmMgcmVhZHkoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl93YWxsZXQuaXNQcmVhdXRob3JpemVkKCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChfYXJncyA9IHt9KSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgbGV0IGFjY291bnRzO1xuICAgIHRyeSB7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuX3dhbGxldC5lbmFibGUoeyBzdGFya25ldFZlcnNpb246IFwidjVcIiB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl93YWxsZXQuaXNDb25uZWN0ZWQgfHwgIXRoaXMuX3dhbGxldC5hY2NvdW50IHx8ICFhY2NvdW50cykge1xuICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLl93YWxsZXQub24oXG4gICAgICBcImFjY291bnRzQ2hhbmdlZFwiLFxuICAgICAgYXN5bmMgKGFjY291bnRzMikgPT4ge1xuICAgICAgICBpZiAoIWFjY291bnRzMikgcmV0dXJuO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzMik7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLl93YWxsZXQub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCAobmV0d29yaykgPT4ge1xuICAgICAgdGhpcy5vbk5ldHdvcmtDaGFuZ2VkKG5ldHdvcmspO1xuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMub25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpO1xuICAgIGNvbnN0IGFjY291bnQgPSB0aGlzLl93YWxsZXQuYWNjb3VudC5hZGRyZXNzO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmNoYWluSWQoKTtcbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHsgYWNjb3VudCwgY2hhaW5JZCB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudCxcbiAgICAgIGNoYWluSWRcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuYXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RGb3VuZEVycm9yKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fd2FsbGV0Py5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IFVzZXJOb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIGFjY291bnQoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldCB8fCAhdGhpcy5fd2FsbGV0LmFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmFjY291bnQ7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChjYWxsKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNhbGwudHlwZSkge1xuICAgICAgICBjYXNlIFwid2FsbGV0X2dldFBlcm1pc3Npb25zXCI6IHtcbiAgICAgICAgICBpZiAodGhpcy5fd2FsbGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gW1Blcm1pc3Npb24yLkFDQ09VTlRTXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCI6IHtcbiAgICAgICAgICBpZiAodGhpcy5fd2FsbGV0LmFjY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5fd2FsbGV0LmFjY291bnQuYWRkcmVzc107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwid2FsbGV0X3JlcXVlc3RDaGFpbklkXCI6IHtcbiAgICAgICAgICBpZiAodGhpcy5fd2FsbGV0LmNoYWluSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93YWxsZXQuY2hhaW5JZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIndhbGxldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiOiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl93YWxsZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgdHJhbnNhY3Rpb24gZmFpbGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjYWxscyA9IChjYWxsLnBhcmFtcy5jYWxscyA/PyBbXSkubWFwKFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgKHsgY2FsbGRhdGEsIGNvbnRyYWN0X2FkZHJlc3MsIGVudHJ5X3BvaW50IH0pID0+ICh7XG4gICAgICAgICAgICAgIGNhbGxkYXRhLFxuICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICAgICAgICAgIGVudHJ5cG9pbnQ6IGVudHJ5X3BvaW50XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhbGxldC5hY2NvdW50Py5leGVjdXRlKGNhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYWxsZXQgQVBJIG1ldGhvZCAke2NhbGwudHlwZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcigpO1xuICAgIH1cbiAgfVxuICBlbnN1cmVXYWxsZXQoKSB7XG4gICAgY29uc3QgaW5zdGFsbGVkID0gZ2V0QXZhaWxhYmxlV2FsbGV0cyhnbG9iYWxUaGlzKTtcbiAgICBjb25zdCB3YWxsZXQgPSBpbnN0YWxsZWQuZmlsdGVyKCh3KSA9PiB3LmlkID09PSB0aGlzLl9vcHRpb25zLmlkKVswXTtcbiAgICBpZiAod2FsbGV0KSB7XG4gICAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gICAgfVxuICB9XG4gIGFzeW5jIG9uQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzKSB7XG4gICAgbGV0IGFjY291bnQ7XG4gICAgaWYgKHR5cGVvZiBhY2NvdW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYWNjb3VudCA9IGFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NvdW50ID0gYWNjb3VudHNbMF07XG4gICAgfVxuICAgIGlmIChhY2NvdW50KSB7XG4gICAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5jaGFpbklkKCk7XG4gICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgeyBhY2NvdW50LCBjaGFpbklkIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICAgIH1cbiAgfVxuICBvbk5ldHdvcmtDaGFuZ2VkKG5ldHdvcmspIHtcbiAgICBzd2l0Y2ggKG5ldHdvcmspIHtcbiAgICAgIC8vIEFyZ2VudFxuICAgICAgY2FzZSBcIlNOX01BSU5cIjpcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHsgY2hhaW5JZDogbWFpbm5ldC5pZCB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiU05fU0VQT0xJQVwiOlxuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgeyBjaGFpbklkOiBzZXBvbGlhLmlkIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIEJyYWF2b3NcbiAgICAgIGNhc2UgXCJtYWlubmV0LWFscGhhXCI6XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7IGNoYWluSWQ6IG1haW5uZXQuaWQgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlcG9saWEtYWxwaGFcIjpcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHsgY2hhaW5JZDogc2Vwb2xpYS5pZCB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwge30pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRBdmFpbGFibGVXYWxsZXRzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLnJlZHVjZSgod2FsbGV0cywga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJzdGFya25ldFwiKSkge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKGlzV2FsbGV0T2JqZWN0KHdhbGxldCkgJiYgIXdhbGxldHNbd2FsbGV0LmlkXSkge1xuICAgICAgICAgIHdhbGxldHNbd2FsbGV0LmlkXSA9IHdhbGxldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgfSwge30pXG4gICk7XG59XG5mdW5jdGlvbiBpc1dhbGxldE9iamVjdCh3YWxsZXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2FsbGV0ICYmIFtcbiAgICAgIC8vIHdhbGxldCdzIG11c3QgaGF2ZSBtZXRob2RzL21lbWJlcnMsIHNlZSBJU3RhcmtuZXRXaW5kb3dPYmplY3RcbiAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgXCJpc0Nvbm5lY3RlZFwiLFxuICAgICAgXCJwcm92aWRlclwiLFxuICAgICAgXCJlbmFibGVcIixcbiAgICAgIFwiaXNQcmVhdXRob3JpemVkXCIsXG4gICAgICBcIm9uXCIsXG4gICAgICBcIm9mZlwiLFxuICAgICAgXCJ2ZXJzaW9uXCIsXG4gICAgICBcImlkXCIsXG4gICAgICBcIm5hbWVcIixcbiAgICAgIFwiaWNvblwiXG4gICAgXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gd2FsbGV0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvY29ubmVjdG9ycy9kaXNjb3ZlcnkudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb25uZWN0b3JzL2hlbHBlcnMudHNcbmZ1bmN0aW9uIGFyZ2VudCgpIHtcbiAgcmV0dXJuIG5ldyBJbmplY3RlZENvbm5lY3Rvcih7XG4gICAgb3B0aW9uczoge1xuICAgICAgaWQ6IFwiYXJnZW50WFwiLFxuICAgICAgbmFtZTogXCJBcmdlbnQgWFwiXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJyYWF2b3MoKSB7XG4gIHJldHVybiBuZXcgSW5qZWN0ZWRDb25uZWN0b3Ioe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGlkOiBcImJyYWF2b3NcIixcbiAgICAgIG5hbWU6IFwiQnJhYXZvc1wiXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluamVjdGVkKHsgaWQgfSkge1xuICByZXR1cm4gbmV3IEluamVjdGVkQ29ubmVjdG9yKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBpZFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsZWdhY3lJbmplY3RlZCh7XG4gIGlkXG59KSB7XG4gIHJldHVybiBuZXcgTGVnYWN5SW5qZWN0ZWRDb25uZWN0b3Ioe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGlkXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2Nvbm5lY3RvcnMvZGlzY292ZXJ5LnRzXG5mdW5jdGlvbiB1c2VJbmplY3RlZENvbm5lY3RvcnMoe1xuICByZWNvbW1lbmRlZCxcbiAgaW5jbHVkZVJlY29tbWVuZGVkID0gXCJhbHdheXNcIixcbiAgb3JkZXIgPSBcImFscGhhYmV0aWNhbFwiLFxuICBzaGltTGVnYWN5Q29ubmVjdG9ycyA9IFtdXG59KSB7XG4gIGNvbnN0IFtpbmplY3RlZENvbm5lY3RvcnMsIHNldEluamVjdGVkQ29ubmVjdG9yc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHJlZnJlc2hDb25uZWN0b3JzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHdhbGxldHMgPSBzY2FuT2JqZWN0Rm9yV2FsbGV0cyh3aW5kb3cpO1xuICAgIGNvbnN0IGNvbm5lY3RvcnMyID0gd2FsbGV0cy5tYXAoKHdhbGxldCkgPT4ge1xuICAgICAgaWYgKHNoaW1MZWdhY3lDb25uZWN0b3JzLmluY2x1ZGVzKHdhbGxldC5pZCkpIHtcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUluamVjdGVkKHsgaWQ6IHdhbGxldC5pZCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmplY3RlZCh7IGlkOiB3YWxsZXQuaWQgfSk7XG4gICAgfSk7XG4gICAgc2V0SW5qZWN0ZWRDb25uZWN0b3JzKGNvbm5lY3RvcnMyKTtcbiAgfSwgW3NoaW1MZWdhY3lDb25uZWN0b3JzLmluY2x1ZGVzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmcmVzaENvbm5lY3RvcnMoKTtcbiAgfSwgW3JlZnJlc2hDb25uZWN0b3JzXSk7XG4gIGNvbnN0IGNvbm5lY3RvcnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VDb25uZWN0b3JzKGluamVjdGVkQ29ubmVjdG9ycywgcmVjb21tZW5kZWQgPz8gW10sIHtcbiAgICAgIGluY2x1ZGVSZWNvbW1lbmRlZCxcbiAgICAgIG9yZGVyXG4gICAgfSk7XG4gIH0sIFtpbmplY3RlZENvbm5lY3RvcnMsIHJlY29tbWVuZGVkLCBpbmNsdWRlUmVjb21tZW5kZWQsIG9yZGVyXSk7XG4gIHJldHVybiB7IGNvbm5lY3RvcnMgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ29ubmVjdG9ycyhpbmplY3RlZDIsIHJlY29tbWVuZGVkLCB7XG4gIGluY2x1ZGVSZWNvbW1lbmRlZCxcbiAgb3JkZXJcbn0pIHtcbiAgY29uc3QgaW5qZWN0ZWRJZHMgPSBuZXcgU2V0KGluamVjdGVkMi5tYXAoKGNvbm5lY3RvcikgPT4gY29ubmVjdG9yLmlkKSk7XG4gIGNvbnN0IGFsbENvbm5lY3RvcnMgPSBbLi4uaW5qZWN0ZWQyXTtcbiAgY29uc3Qgc2hvdWxkQWRkUmVjb21tZW5kZWQgPSBpbmNsdWRlUmVjb21tZW5kZWQgPT09IFwiYWx3YXlzXCIgfHwgaW5jbHVkZVJlY29tbWVuZGVkID09PSBcIm9ubHlJZk5vQ29ubmVjdG9yc1wiICYmIGluamVjdGVkMi5sZW5ndGggPT09IDA7XG4gIGlmIChzaG91bGRBZGRSZWNvbW1lbmRlZCkge1xuICAgIGFsbENvbm5lY3RvcnMucHVzaChcbiAgICAgIC4uLnJlY29tbWVuZGVkLmZpbHRlcigoY29ubmVjdG9yKSA9PiAhaW5qZWN0ZWRJZHMuaGFzKGNvbm5lY3Rvci5pZCkpXG4gICAgKTtcbiAgfVxuICBpZiAob3JkZXIgPT09IFwicmFuZG9tXCIpIHtcbiAgICByZXR1cm4gc2h1ZmZsZShhbGxDb25uZWN0b3JzKTtcbiAgfVxuICByZXR1cm4gYWxsQ29ubmVjdG9ycy5zb3J0KChhLCBiKSA9PiBhLmlkLmxvY2FsZUNvbXBhcmUoYi5pZCkpO1xufVxuZnVuY3Rpb24gc2h1ZmZsZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgIFthcnJbaV0sIGFycltqXV0gPSBbYXJyW2pdLCBhcnJbaV1dO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBzY2FuT2JqZWN0Rm9yV2FsbGV0cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5yZWR1Y2UoKHdhbGxldHMsIGtleSkgPT4ge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwic3RhcmtuZXRcIikpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gb2JqW2tleV07XG4gICAgICAgIGlmIChpc1dhbGxldE9iamVjdDIod2FsbGV0KSAmJiAhd2FsbGV0c1t3YWxsZXQuaWRdKSB7XG4gICAgICAgICAgd2FsbGV0c1t3YWxsZXQuaWRdID0gd2FsbGV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd2FsbGV0cztcbiAgICB9LCB7fSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzV2FsbGV0T2JqZWN0Mih3YWxsZXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2FsbGV0ICYmIFtcbiAgICAgIC8vIHdhbGxldCdzIG11c3QgaGF2ZSBtZXRob2RzL21lbWJlcnMsIHNlZSBJU3RhcmtuZXRXaW5kb3dPYmplY3RcbiAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgXCJpc0Nvbm5lY3RlZFwiLFxuICAgICAgXCJwcm92aWRlclwiLFxuICAgICAgXCJlbmFibGVcIixcbiAgICAgIFwiaXNQcmVhdXRob3JpemVkXCIsXG4gICAgICBcIm9uXCIsXG4gICAgICBcIm9mZlwiLFxuICAgICAgXCJ2ZXJzaW9uXCIsXG4gICAgICBcImlkXCIsXG4gICAgICBcIm5hbWVcIixcbiAgICAgIFwiaWNvblwiXG4gICAgXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gd2FsbGV0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvY29ubmVjdG9ycy9tb2NrLnRzXG5pbXBvcnQge1xuICBQZXJtaXNzaW9uIGFzIFBlcm1pc3Npb24zXG59IGZyb20gXCJAc3RhcmtuZXQtaW8vdHlwZXMtanNcIjtcbmltcG9ydCB7IGRldm5ldCwgbWFpbm5ldCBhcyBtYWlubmV0MiB9IGZyb20gXCJAc3RhcmtuZXQtcmVhY3QvY2hhaW5zXCI7XG52YXIgTW9ja0Nvbm5lY3RvciA9IGNsYXNzIGV4dGVuZHMgQ29ubmVjdG9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGFjY291bnRzLFxuICAgIG9wdGlvbnNcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hY2NvdW50c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2FjY291bnRJbmRleFwiLCAwKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Nvbm5lY3RlZFwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jaGFpbklkXCIsIGRldm5ldC5pZCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgaWYgKGFjY291bnRzLm1haW5uZXQubGVuZ3RoID09PSAwIHx8IGFjY291bnRzLnNlcG9saWEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2NrQ29ubmVjdG9yOiBhY2NvdW50cyBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgdGhpcy5fYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHN3aXRjaENoYWluKGNoYWluSWQpIHtcbiAgICB0aGlzLl9jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLl9hY2NvdW50SW5kZXggPSAwO1xuICAgIGxldCBhY2NvdW50O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudW5pZmllZFN3aXRjaEFjY291bnRBbmRDaGFpbikge1xuICAgICAgYWNjb3VudCA9IHRoaXMuX2FjY291bnQuYWRkcmVzcztcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHsgY2hhaW5JZCwgYWNjb3VudCB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVtaXRDaGFuZ2VBY2NvdW50T25DaGFpblN3aXRjaCA/PyB0cnVlKSB7XG4gICAgICB0aGlzLnN3aXRjaEFjY291bnQodGhpcy5fYWNjb3VudEluZGV4KTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoQWNjb3VudChhY2NvdW50SW5kZXgpIHtcbiAgICB0aGlzLl9hY2NvdW50SW5kZXggPSBhY2NvdW50SW5kZXg7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHsgYWNjb3VudDogdGhpcy5fYWNjb3VudC5hZGRyZXNzIH0pO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlkO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubmFtZTtcbiAgfVxuICBnZXQgaWNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmljb24gPz8gXCJcIjtcbiAgfVxuICBhdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdmFpbGFibGUgPz8gdHJ1ZTtcbiAgfVxuICBhc3luYyBjaGFpbklkKCkge1xuICAgIGNvbnN0IGNoYWluSWRIZXggPSBhd2FpdCB0aGlzLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9yZXF1ZXN0Q2hhaW5JZFwiIH0pO1xuICAgIGNvbnN0IGNoYWluSWQgPSBCaWdJbnQoY2hhaW5JZEhleCk7XG4gICAgcmV0dXJuIGNoYWluSWQ7XG4gIH1cbiAgYXN5bmMgcmVhZHkoKSB7XG4gICAgY29uc3QgcGVybWlzc2lvbnMgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIlxuICAgIH0pO1xuICAgIGlmICghcGVybWlzc2lvbnM/LmluY2x1ZGVzKFBlcm1pc3Npb24zLkFDQ09VTlRTKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmFpbENvbm5lY3QpIHtcbiAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0QWNjb3VudHNcIixcbiAgICAgIHBhcmFtczogeyBzaWxlbnRfbW9kZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuY2hhaW5JZCgpO1xuICAgIGNvbnN0IFthY2NvdW50XSA9IGFjY291bnRzO1xuICAgIHJldHVybiB7IGFjY291bnQsIGNoYWluSWQgfTtcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChjYWxsKSB7XG4gICAgY29uc3QgeyB0eXBlLCBwYXJhbXMgfSA9IGNhbGw7XG4gICAgaWYgKCF0aGlzLmF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Rm91bmRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlamVjdFJlcXVlc3QpIHtcbiAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwid2FsbGV0X3JlcXVlc3RDaGFpbklkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCk7XG4gICAgICBjYXNlIFwid2FsbGV0X2dldFBlcm1pc3Npb25zXCI6XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHJldHVybiBbUGVybWlzc2lvbjMuQUNDT1VOVFNdO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICBjYXNlIFwid2FsbGV0X3JlcXVlc3RBY2NvdW50c1wiOlxuICAgICAgICByZXR1cm4gW3RoaXMuX2FjY291bnQuYWRkcmVzc107XG4gICAgICBjYXNlIFwid2FsbGV0X2FkZFN0YXJrbmV0Q2hhaW5cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwid2FsbGV0X3dhdGNoQXNzZXRcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwid2FsbGV0X3N3aXRjaFN0YXJrbmV0Q2hhaW5cIjoge1xuICAgICAgICBpZiAoIXBhcmFtcykgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1zIGFyZSBtaXNzaW5nXCIpO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zd2l0Y2hDaGFpbihCaWdJbnQoY2hhaW5JZCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ3YWxsZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCI6IHtcbiAgICAgICAgaWYgKCFwYXJhbXMpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtcyBhcmUgbWlzc2luZ1wiKTtcbiAgICAgICAgY29uc3QgeyBjb21waWxlZF9jbGFzc19oYXNoLCBjb250cmFjdF9jbGFzcywgY2xhc3NfaGFzaCB9ID0gcGFyYW1zO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNjb3VudC5kZWNsYXJlKHtcbiAgICAgICAgICBjb21waWxlZENsYXNzSGFzaDogY29tcGlsZWRfY2xhc3NfaGFzaCxcbiAgICAgICAgICBjb250cmFjdDoge1xuICAgICAgICAgICAgLi4uY29udHJhY3RfY2xhc3MsXG4gICAgICAgICAgICBhYmk6IEpTT04ucGFyc2UoY29udHJhY3RfY2xhc3MuYWJpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xhc3NIYXNoOiBjbGFzc19oYXNoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcIndhbGxldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiOiB7XG4gICAgICAgIGlmICghcGFyYW1zKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbXMgYXJlIG1pc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IHsgY2FsbHMgfSA9IHBhcmFtcztcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjY291bnQuZXhlY3V0ZSh0cmFuc2Zvcm1DYWxscyhjYWxscykpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIndhbGxldF9zaWduVHlwZWREYXRhXCI6IHtcbiAgICAgICAgaWYgKCFwYXJhbXMpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtcyBhcmUgbWlzc2luZ1wiKTtcbiAgICAgICAgY29uc3QgeyBkb21haW4sIG1lc3NhZ2UsIHByaW1hcnlUeXBlLCB0eXBlcyB9ID0gcGFyYW1zO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNjb3VudC5zaWduTWVzc2FnZSh7XG4gICAgICAgICAgZG9tYWluLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgICAgdHlwZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJlcXVlc3QgdHlwZVwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWNjb3VudChwcm92aWRlcikge1xuICAgIGlmICghdGhpcy5hdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudDtcbiAgfVxuICBnZXQgX2FjY291bnQoKSB7XG4gICAgbGV0IGFjY291bnQ7XG4gICAgaWYgKHRoaXMuX2NoYWluSWQgPT09IG1haW5uZXQyLmlkKSB7XG4gICAgICBhY2NvdW50ID0gdGhpcy5fYWNjb3VudHMubWFpbm5ldFt0aGlzLl9hY2NvdW50SW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NvdW50ID0gdGhpcy5fYWNjb3VudHMuc2Vwb2xpYVt0aGlzLl9hY2NvdW50SW5kZXhdO1xuICAgIH1cbiAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudDtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybUNhbGxzKGNhbGxzKSB7XG4gIHJldHVybiBjYWxscy5tYXAoXG4gICAgKGNhbGwpID0+ICh7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IGNhbGwuY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGVudHJ5cG9pbnQ6IGNhbGwuZW50cnlfcG9pbnQsXG4gICAgICBjYWxsZGF0YTogY2FsbC5jYWxsZGF0YVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy9jb250ZXh0L3N0YXJrbmV0LnRzeFxuaW1wb3J0IHtcbiAgbWFpbm5ldCBhcyBtYWlubmV0MyxcbiAgc2Vwb2xpYSBhcyBzZXBvbGlhMlxufSBmcm9tIFwiQHN0YXJrbmV0LXJlYWN0L2NoYWluc1wiO1xuaW1wb3J0IHsgUXVlcnlDbGllbnQsIFF1ZXJ5Q2xpZW50UHJvdmlkZXIgfSBmcm9tIFwiQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5XCI7XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIGNvbnN0YW50c1xufSBmcm9tIFwic3RhcmtuZXRcIjtcblxuLy8gc3JjL2NvbnRleHQvYWNjb3VudC50c3hcbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBY2NvdW50Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBhY2NvdW50OiB2b2lkIDAsXG4gIGFkZHJlc3M6IHZvaWQgMFxufSk7XG5mdW5jdGlvbiB1c2VTdGFya25ldEFjY291bnQoKSB7XG4gIGNvbnN0IHsgYWNjb3VudCwgYWRkcmVzcyB9ID0gdXNlQ29udGV4dChBY2NvdW50Q29udGV4dCk7XG4gIHJldHVybiB7IGFjY291bnQsIGFkZHJlc3MgfTtcbn1cbmZ1bmN0aW9uIEFjY291bnRQcm92aWRlcih7XG4gIGFkZHJlc3MsXG4gIGFjY291bnQsXG4gIGNoaWxkcmVuXG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEFjY291bnRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGFjY291bnQsIGFkZHJlc3MgfSwgY2hpbGRyZW4gfSk7XG59XG5cbi8vIHNyYy9jb250ZXh0L3N0YXJrbmV0LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBkZWZhdWx0UXVlcnlDbGllbnQgPSBuZXcgUXVlcnlDbGllbnQoKTtcbnZhciBTdGFya25ldENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiB1c2VTdGFya25ldCgpIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VDb250ZXh0MihTdGFya25ldENvbnRleHQpO1xuICBpZiAoIXN0YXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ1c2VTdGFya25ldCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgU3RhcmtuZXRQcm92aWRlciBvciBTdGFya25ldENvbmZpZ1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VTdGFya25ldE1hbmFnZXIoe1xuICBjaGFpbnMsXG4gIHByb3ZpZGVyLFxuICBleHBsb3JlcixcbiAgY29ubmVjdG9ycyA9IFtdLFxuICBhdXRvQ29ubmVjdCA9IGZhbHNlLFxuICBkZWZhdWx0Q2hhaW5JZFxufSkge1xuICBjb25zdCBkZWZhdWx0Q2hhaW4gPSBkZWZhdWx0Q2hhaW5JZCA/IGNoYWlucy5maW5kKChjKSA9PiBjLmlkID09PSBkZWZhdWx0Q2hhaW5JZCkgPz8gY2hhaW5zWzBdIDogY2hhaW5zWzBdO1xuICBpZiAoZGVmYXVsdENoYWluID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIGNoYWluLlwiKTtcbiAgfVxuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBjaGFpbiBvZiBjaGFpbnMpIHtcbiAgICBpZiAoc2Vlbi5oYXMoY2hhaW4uaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZWQgY2hhaW4gaWQgZm91bmQ6ICR7Y2hhaW4uaWR9YCk7XG4gICAgfVxuICAgIHNlZW4uYWRkKGNoYWluLmlkKTtcbiAgfVxuICBjb25zdCB7IGNoYWluOiBfLCBwcm92aWRlcjogZGVmYXVsdFByb3ZpZGVyIH0gPSBwcm92aWRlckZvckNoYWluKFxuICAgIGRlZmF1bHRDaGFpbixcbiAgICBwcm92aWRlclxuICApO1xuICBjb25zdCBjb25uZWN0b3JSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTIoe1xuICAgIGN1cnJlbnRDaGFpbjogZGVmYXVsdENoYWluLFxuICAgIGN1cnJlbnRQcm92aWRlcjogZGVmYXVsdFByb3ZpZGVyLFxuICAgIGNvbm5lY3RvcnNcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZUNoYWluQW5kUHJvdmlkZXIgPSB1c2VDYWxsYmFjazIoXG4gICAgKHsgY2hhaW5JZCB9KSA9PiB7XG4gICAgICBpZiAoIWNoYWluSWQpIHJldHVybjtcbiAgICAgIGZvciAoY29uc3QgY2hhaW4gb2YgY2hhaW5zKSB7XG4gICAgICAgIGlmIChjaGFpbi5pZCA9PT0gY2hhaW5JZCkge1xuICAgICAgICAgIGNvbnN0IHsgY2hhaW46IG5ld0NoYWluLCBwcm92aWRlcjogbmV3UHJvdmlkZXIgfSA9IHByb3ZpZGVyRm9yQ2hhaW4oXG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIHByb3ZpZGVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRTdGF0ZSgoc3RhdGUyKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUyLFxuICAgICAgICAgICAgY3VycmVudENoYWluOiBuZXdDaGFpbixcbiAgICAgICAgICAgIGN1cnJlbnRQcm92aWRlcjogbmV3UHJvdmlkZXJcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbY2hhaW5zLCBwcm92aWRlcl1cbiAgKTtcbiAgY29uc3QgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jICh7IGNoYWluSWQsIGFjY291bnQ6IGFkZHJlc3MgfSkgPT4ge1xuICAgICAgaWYgKGNoYWluSWQpIHtcbiAgICAgICAgdXBkYXRlQ2hhaW5BbmRQcm92aWRlcih7IGNoYWluSWQgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkcmVzcyAmJiBjb25uZWN0b3JSZWYuY3VycmVudCkge1xuICAgICAgICBzZXRTdGF0ZSgoc3RhdGUyKSA9PiAoe1xuICAgICAgICAgIC4uLnN0YXRlMixcbiAgICAgICAgICBjdXJyZW50QWRkcmVzczogYWRkcmVzc1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbdXBkYXRlQ2hhaW5BbmRQcm92aWRlcl1cbiAgKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKCFjb25uZWN0b3JSZWYuY3VycmVudCkge1xuICAgICAgc2V0U3RhdGUoKHN0YXRlMikgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUyLFxuICAgICAgICBjdXJyZW50Q2hhaW46IGRlZmF1bHRDaGFpbixcbiAgICAgICAgY3VycmVudFByb3ZpZGVyOiBwcm92aWRlckZvckNoYWluKGRlZmF1bHRDaGFpbiwgcHJvdmlkZXIpLnByb3ZpZGVyXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbZGVmYXVsdENoYWluLCBwcm92aWRlcl0pO1xuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jICh7IGNvbm5lY3RvciB9KSA9PiB7XG4gICAgICBpZiAoIWNvbm5lY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBjb25uZWN0b3IuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVlZHNMaXN0ZW5lclNldHVwID0gY29ubmVjdG9yUmVmLmN1cnJlbnQ/LmlkICE9PSBjb25uZWN0b3IuaWQ7XG4gICAgICBpZiAobmVlZHNMaXN0ZW5lclNldHVwKSB7XG4gICAgICAgIGNvbm5lY3RvclJlZi5jdXJyZW50Py5vZmYoXCJjaGFuZ2VcIiwgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlKTtcbiAgICAgICAgY29ubmVjdG9yUmVmLmN1cnJlbnQ/Lm9mZihcImRpc2Nvbm5lY3RcIiwgZGlzY29ubmVjdCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIGFjY291bnQ6IGFkZHJlc3MgfSA9IGF3YWl0IGNvbm5lY3Rvci5jb25uZWN0KHtcbiAgICAgICAgICBjaGFpbklkSGludDogZGVmYXVsdENoYWluLmlkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWRkcmVzcyAhPT0gc3RhdGUuY3VycmVudEFkZHJlc3MpIHtcbiAgICAgICAgICBjb25uZWN0b3JSZWYuY3VycmVudCA9IGNvbm5lY3RvcjtcbiAgICAgICAgICBzZXRTdGF0ZSgoc3RhdGUyKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUyLFxuICAgICAgICAgICAgY3VycmVudEFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dG9Db25uZWN0KSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJsYXN0VXNlZENvbm5lY3RvclwiLCBjb25uZWN0b3IuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc0xpc3RlbmVyU2V0dXApIHtcbiAgICAgICAgICBjb25uZWN0b3Iub24oXCJjaGFuZ2VcIiwgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlKTtcbiAgICAgICAgICBjb25uZWN0b3Iub24oXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNoYWluQW5kUHJvdmlkZXIoeyBjaGFpbklkIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldFN0YXRlKChzdGF0ZTIpID0+ICh7XG4gICAgICAgICAgLi4uc3RhdGUyLFxuICAgICAgICAgIGVycm9yOiBuZXcgQ29ubmVjdG9yTm90Rm91bmRFcnJvcigpXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgYXV0b0Nvbm5lY3QsXG4gICAgICBzdGF0ZS5jdXJyZW50QWRkcmVzcyxcbiAgICAgIGRlZmF1bHRDaGFpbi5pZCxcbiAgICAgIGhhbmRsZUNvbm5lY3RvckNoYW5nZSxcbiAgICAgIHVwZGF0ZUNoYWluQW5kUHJvdmlkZXJcbiAgICBdXG4gICk7XG4gIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjazIoYXN5bmMgKCkgPT4ge1xuICAgIHNldFN0YXRlKChzdGF0ZTIpID0+ICh7XG4gICAgICAuLi5zdGF0ZTIsXG4gICAgICBjdXJyZW50QWRkcmVzczogdm9pZCAwLFxuICAgICAgY3VycmVudFByb3ZpZGVyOiBkZWZhdWx0UHJvdmlkZXIsXG4gICAgICBjdXJyZW50Q2hhaW46IGRlZmF1bHRDaGFpblxuICAgIH0pKTtcbiAgICBpZiAoYXV0b0Nvbm5lY3QpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwibGFzdFVzZWRDb25uZWN0b3JcIik7XG4gICAgfVxuICAgIGlmICghY29ubmVjdG9yUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25uZWN0b3JSZWYuY3VycmVudC5vZmYoXCJjaGFuZ2VcIiwgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlKTtcbiAgICBjb25uZWN0b3JSZWYuY3VycmVudC5vZmYoXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3QpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb25uZWN0b3JSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGNvbm5lY3RvclJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICB9LCBbYXV0b0Nvbm5lY3QsIGhhbmRsZUNvbm5lY3RvckNoYW5nZSwgZGVmYXVsdFByb3ZpZGVyLCBkZWZhdWx0Q2hhaW5dKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gdHJ5QXV0b0Nvbm5lY3QoY29ubmVjdG9yczIpIHtcbiAgICAgIGNvbnN0IGxhc3RDb25uZWN0ZWRDb25uZWN0b3JJZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibGFzdFVzZWRDb25uZWN0b3JcIik7XG4gICAgICBpZiAobGFzdENvbm5lY3RlZENvbm5lY3RvcklkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RDb25uZWN0ZWRDb25uZWN0b3IgPSBjb25uZWN0b3JzMi5maW5kKFxuICAgICAgICAoY29ubmVjdG9yKSA9PiBjb25uZWN0b3IuaWQgPT09IGxhc3RDb25uZWN0ZWRDb25uZWN0b3JJZFxuICAgICAgKTtcbiAgICAgIGlmIChsYXN0Q29ubmVjdGVkQ29ubmVjdG9yID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFhd2FpdCBsYXN0Q29ubmVjdGVkQ29ubmVjdG9yLnJlYWR5KCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdCh7IGNvbm5lY3RvcjogbGFzdENvbm5lY3RlZENvbm5lY3RvciB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXV0b0Nvbm5lY3QgJiYgIWNvbm5lY3RvclJlZi5jdXJyZW50KSB7XG4gICAgICB0cnlBdXRvQ29ubmVjdChjb25uZWN0b3JzKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBhZGRyZXNzOiBzdGF0ZS5jdXJyZW50QWRkcmVzcyxcbiAgICBwcm92aWRlcjogc3RhdGUuY3VycmVudFByb3ZpZGVyLFxuICAgIGNoYWluOiBzdGF0ZS5jdXJyZW50Q2hhaW4sXG4gICAgY29ubmVjdG9yOiBjb25uZWN0b3JSZWYuY3VycmVudCxcbiAgICBleHBsb3JlcixcbiAgICBjb25uZWN0LFxuICAgIGRpc2Nvbm5lY3QsXG4gICAgY29ubmVjdG9ycyxcbiAgICBjaGFpbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIFN0YXJrbmV0UHJvdmlkZXIoe1xuICBjaGFpbnMsXG4gIHByb3ZpZGVyLFxuICBjb25uZWN0b3JzLFxuICBleHBsb3JlcixcbiAgYXV0b0Nvbm5lY3QsXG4gIHF1ZXJ5Q2xpZW50LFxuICBkZWZhdWx0Q2hhaW5JZCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgeyBhY2NvdW50LCBhZGRyZXNzLCAuLi5zdGF0ZSB9ID0gdXNlU3RhcmtuZXRNYW5hZ2VyKHtcbiAgICBjaGFpbnMsXG4gICAgcHJvdmlkZXIsXG4gICAgZXhwbG9yZXIsXG4gICAgY29ubmVjdG9ycyxcbiAgICBhdXRvQ29ubmVjdCxcbiAgICBkZWZhdWx0Q2hhaW5JZFxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFF1ZXJ5Q2xpZW50UHJvdmlkZXIsIHsgY2xpZW50OiBxdWVyeUNsaWVudCA/PyBkZWZhdWx0UXVlcnlDbGllbnQsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihTdGFya25ldENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoQWNjb3VudFByb3ZpZGVyLCB7IGFkZHJlc3MsIGFjY291bnQsIGNoaWxkcmVuIH0pIH0pIH0pO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJGb3JDaGFpbihjaGFpbiwgZmFjdG9yeSkge1xuICBjb25zdCBwcm92aWRlciA9IGZhY3RvcnkoY2hhaW4pO1xuICBpZiAocHJvdmlkZXIpIHtcbiAgICByZXR1cm4geyBjaGFpbiwgcHJvdmlkZXIgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYE5vIHByb3ZpZGVyIGZvdW5kIGZvciBjaGFpbiAke2NoYWluLm5hbWV9YCk7XG59XG5mdW5jdGlvbiBzdGFya25ldENoYWluSWQoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIG1haW5uZXQzLmlkOlxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5TdGFya25ldENoYWluSWQuU05fTUFJTjtcbiAgICBjYXNlIHNlcG9saWEyLmlkOlxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5TdGFya25ldENoYWluSWQuU05fU0VQT0xJQTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvY29udGV4dC9pbmRleC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBTdGFya25ldENvbmZpZyh7IGNoaWxkcmVuLCAuLi5jb25maWcgfSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoU3RhcmtuZXRQcm92aWRlciwgeyAuLi5jb25maWcsIGNoaWxkcmVuIH0pO1xufVxuXG4vLyBzcmMvZXhwbG9yZXJzL3N0YXJrc2Nhbi50c1xudmFyIFN0YXJrc2NhbkV4cGxvcmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFpbikge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiU3RhcmtzY2FuXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsaW5rXCIpO1xuICAgIHRoaXMubGluayA9IGNoYWluLmV4cGxvcmVycz8uW1wic3RhcmtzY2FuXCJdPy50b1N0cmluZygpID8/IFwiXCI7XG4gIH1cbiAgYmxvY2soaGFzaE9yTnVtYmVyKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vYmxvY2svJHtoYXNoT3JOdW1iZXIuaGFzaCA/PyBoYXNoT3JOdW1iZXIubnVtYmVyfWA7XG4gIH1cbiAgdHJhbnNhY3Rpb24oaGFzaDMpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS90eC8ke2hhc2gzfWA7XG4gIH1cbiAgY29udHJhY3QoYWRkcmVzcykge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2NvbnRyYWN0LyR7YWRkcmVzc31gO1xuICB9XG4gIGNsYXNzKGhhc2gzKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vY2xhc3MvJHtoYXNoM31gO1xuICB9XG59O1xudmFyIHN0YXJrc2NhbiA9IChjaGFpbikgPT4ge1xuICByZXR1cm4gbmV3IFN0YXJrc2NhbkV4cGxvcmVyKGNoYWluKTtcbn07XG5cbi8vIHNyYy9leHBsb3JlcnMvdmlld2Jsb2NrLnRzXG52YXIgVmlld2Jsb2NrRXhwbG9yZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYWluKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJWaWV3YmxvY2tcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxpbmtcIik7XG4gICAgdGhpcy5saW5rID0gY2hhaW4uZXhwbG9yZXJzPy5bXCJ2aWV3YmxvY2tcIl0/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgfVxuICBibG9jayhoYXNoT3JOdW1iZXIpIHtcbiAgICBpZiAoaGFzaE9yTnVtYmVyLmhhc2ggJiYgaGFzaE9yTnVtYmVyLm51bWJlciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIHZpZXdibG9jayBleHBsb3JlciBkb2VzbnQgc3VwcG9ydCBoYXNoZXMgZm9yIGJsb2Nrcy4gUGxlYXNlIHByb3ZpZGUgYSBoYXNoLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS9ibG9jay8ke2hhc2hPck51bWJlci5udW1iZXJ9YDtcbiAgfVxuICB0cmFuc2FjdGlvbihoYXNoMykge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L3R4LyR7aGFzaDN9YDtcbiAgfVxuICBjb250cmFjdChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vY29udHJhY3QvJHthZGRyZXNzfWA7XG4gIH1cbiAgY2xhc3MoaGFzaDMpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS9jbGFzcy8ke2hhc2gzfWA7XG4gIH1cbn07XG52YXIgdmlld2Jsb2NrID0gKGNoYWluKSA9PiB7XG4gIHJldHVybiBuZXcgVmlld2Jsb2NrRXhwbG9yZXIoY2hhaW4pO1xufTtcblxuLy8gc3JjL2V4cGxvcmVycy92b3lhZ2VyLnRzXG52YXIgVm95YWdlckV4cGxvcmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFpbikge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiVm95YWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGlua1wiKTtcbiAgICB0aGlzLmxpbmsgPSBjaGFpbi5leHBsb3JlcnM/LltcInZveWFnZXJcIl0/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgfVxuICBibG9jayhoYXNoT3JOdW1iZXIpIHtcbiAgICBpZiAoaGFzaE9yTnVtYmVyLm51bWJlciAhPT0gdm9pZCAwICYmIGhhc2hPck51bWJlci5oYXNoID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgdm95YWdlciBleHBsb3JlciBkb2Vzbid0IHN1cHBvcnQgbnVtYmVycyBmb3IgYmxvY2tzLiBQbGVhc2UgcHJvdmlkZSBhIGhhc2guXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2Jsb2NrLyR7aGFzaE9yTnVtYmVyLmhhc2h9YDtcbiAgfVxuICB0cmFuc2FjdGlvbihoYXNoMykge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L3R4LyR7aGFzaDN9YDtcbiAgfVxuICBjb250cmFjdChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vY29udHJhY3QvJHthZGRyZXNzfWA7XG4gIH1cbiAgY2xhc3MoaGFzaDMpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS9jbGFzcy8ke2hhc2gzfWA7XG4gIH1cbn07XG52YXIgdm95YWdlciA9IChjaGFpbikgPT4ge1xuICByZXR1cm4gbmV3IFZveWFnZXJFeHBsb3JlcihjaGFpbik7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLWFjY291bnQudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCB7IHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzIH0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgcmV0dXJuIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXByb3ZpZGVyLnRzXG5mdW5jdGlvbiB1c2VQcm92aWRlcigpIHtcbiAgY29uc3QgeyBwcm92aWRlciB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgcmV0dXJuIHsgcHJvdmlkZXIgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1hY2NvdW50LnRzXG5mdW5jdGlvbiB1c2VBY2NvdW50KCkge1xuICBjb25zdCB7IGNvbm5lY3RvciwgY2hhaW4gfSA9IHVzZVN0YXJrbmV0KCk7XG4gIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHVzZVByb3ZpZGVyKCk7XG4gIGNvbnN0IHsgYWRkcmVzczogY29ubmVjdGVkQWRkcmVzcyB9ID0gdXNlU3RhcmtuZXRBY2NvdW50KCk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUzKHtcbiAgICBzdGF0dXM6IFwiZGlzY29ubmVjdGVkXCJcbiAgfSk7XG4gIGNvbnN0IHJlZnJlc2hTdGF0ZSA9IHVzZUNhbGxiYWNrMyhhc3luYyAoKSA9PiB7XG4gICAgaWYgKGNvbm5lY3RvciAmJiBwcm92aWRlciAmJiBjb25uZWN0ZWRBZGRyZXNzKSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogXCJjb25uZWN0ZWRcIixcbiAgICAgICAgY29ubmVjdG9yLFxuICAgICAgICBjaGFpbklkOiBjaGFpbi5pZCxcbiAgICAgICAgYWNjb3VudDogdm9pZCAwLFxuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGNvbm5lY3RlZEFkZHJlc3MpLFxuICAgICAgICBpc0Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaXNDb25uZWN0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNEaXNjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1JlY29ubmVjdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgY29ubmVjdG9yLmFjY291bnQocHJvdmlkZXIpLnRoZW4oXG4gICAgICAgIChjb25uZWN0ZWRBY2NvdW50KSA9PiBzZXRTdGF0ZSgoc3RhdGUyKSA9PiAoeyAuLi5zdGF0ZTIsIGFjY291bnQ6IGNvbm5lY3RlZEFjY291bnQgfSkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgICAgIGNvbm5lY3Rvcjogdm9pZCAwLFxuICAgICAgICBjaGFpbklkOiB2b2lkIDAsXG4gICAgICAgIGFjY291bnQ6IHZvaWQgMCxcbiAgICAgICAgYWRkcmVzczogdm9pZCAwLFxuICAgICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICAgIGlzQ29ubmVjdGluZzogZmFsc2UsXG4gICAgICAgIGlzRGlzY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBpc1JlY29ubmVjdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3Byb3ZpZGVyLCBjb25uZWN0b3IsIGNoYWluLmlkLCBjb25uZWN0ZWRBZGRyZXNzXSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIHJlZnJlc2hTdGF0ZSgpO1xuICB9LCBbcmVmcmVzaFN0YXRlXSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS13YWxsZXQtcmVxdWVzdC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9xdWVyeS50c1xuaW1wb3J0IHtcbiAgdXNlSW5maW5pdGVRdWVyeSBhcyB1c2VJbmZpbml0ZVF1ZXJ5XyxcbiAgdXNlTXV0YXRpb24gYXMgdXNlTXV0YXRpb25fLFxuICB1c2VRdWVyeSBhcyB1c2VRdWVyeV9cbn0gZnJvbSBcIkB0YW5zdGFjay9yZWFjdC1xdWVyeVwiO1xuZnVuY3Rpb24gdXNlUXVlcnkoYXJncykge1xuICBjb25zdCBiYXNlID0gdXNlUXVlcnlfKHsgLi4uYXJncywgc3RydWN0dXJhbFNoYXJpbmc6IGZhbHNlIH0pO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IGJhc2UuZGF0YSxcbiAgICBlcnJvcjogYmFzZS5lcnJvcixcbiAgICBzdGF0dXM6IGJhc2Uuc3RhdHVzLFxuICAgIGlzU3VjY2VzczogYmFzZS5pc1N1Y2Nlc3MsXG4gICAgaXNFcnJvcjogYmFzZS5pc0Vycm9yLFxuICAgIGlzUGVuZGluZzogYmFzZS5pc1BlbmRpbmcsXG4gICAgZmV0Y2hTdGF0dXM6IGJhc2UuZmV0Y2hTdGF0dXMsXG4gICAgaXNGZXRjaGluZzogYmFzZS5pc0ZldGNoaW5nLFxuICAgIGlzTG9hZGluZzogYmFzZS5pc0xvYWRpbmcsXG4gICAgcmVmZXRjaDogYmFzZS5yZWZldGNoXG4gIH07XG59XG5mdW5jdGlvbiB1c2VNdXRhdGlvbihhcmdzKSB7XG4gIGNvbnN0IGJhc2UgPSB1c2VNdXRhdGlvbl8oYXJncyk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogYmFzZS5kYXRhLFxuICAgIGVycm9yOiBiYXNlLmVycm9yLFxuICAgIHJlc2V0OiBiYXNlLnJlc2V0LFxuICAgIGlzRXJyb3I6IGJhc2UuaXNFcnJvcixcbiAgICBpc0lkbGU6IGJhc2UuaXNJZGxlLFxuICAgIGlzUGVuZGluZzogYmFzZS5pc1BlbmRpbmcsXG4gICAgaXNTdWNjZXNzOiBiYXNlLmlzU3VjY2VzcyxcbiAgICBpc1BhdXNlZDogYmFzZS5pc1BhdXNlZCxcbiAgICBtdXRhdGU6IGJhc2UubXV0YXRlLFxuICAgIG11dGF0ZUFzeW5jOiBiYXNlLm11dGF0ZUFzeW5jLFxuICAgIHN0YXR1czogYmFzZS5zdGF0dXMsXG4gICAgdmFyaWFibGVzOiBiYXNlLnZhcmlhYmxlc1xuICB9O1xufVxuZnVuY3Rpb24gdXNlSW5maW5pdGVRdWVyeShhcmdzKSB7XG4gIGNvbnN0IGJhc2UgPSB1c2VJbmZpbml0ZVF1ZXJ5Xyh7IC4uLmFyZ3MsIHN0cnVjdHVyYWxTaGFyaW5nOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBiYXNlLmRhdGEsXG4gICAgZXJyb3I6IGJhc2UuZXJyb3IsXG4gICAgc3RhdHVzOiBiYXNlLnN0YXR1cyxcbiAgICBpc1N1Y2Nlc3M6IGJhc2UuaXNTdWNjZXNzLFxuICAgIGlzRXJyb3I6IGJhc2UuaXNFcnJvcixcbiAgICBpc1BlbmRpbmc6IGJhc2UuaXNQZW5kaW5nLFxuICAgIGZldGNoU3RhdHVzOiBiYXNlLmZldGNoU3RhdHVzLFxuICAgIGlzRmV0Y2hpbmc6IGJhc2UuaXNGZXRjaGluZyxcbiAgICBpc0xvYWRpbmc6IGJhc2UuaXNMb2FkaW5nLFxuICAgIHJlZmV0Y2g6IGJhc2UucmVmZXRjaCxcbiAgICBmZXRjaE5leHRQYWdlOiBiYXNlLmZldGNoTmV4dFBhZ2UsXG4gICAgZmV0Y2hQcmV2aW91c1BhZ2U6IGJhc2UuZmV0Y2hQcmV2aW91c1BhZ2UsXG4gICAgaGFzTmV4dFBhZ2U6IGJhc2UuaGFzTmV4dFBhZ2UsXG4gICAgaGFzUHJldmlvdXNQYWdlOiBiYXNlLmhhc1ByZXZpb3VzUGFnZSxcbiAgICBpc0ZldGNoaW5nTmV4dFBhZ2U6IGJhc2UuaXNGZXRjaGluZ05leHRQYWdlLFxuICAgIGlzRmV0Y2hpbmdQcmV2aW91c1BhZ2U6IGJhc2UuaXNGZXRjaGluZ1ByZXZpb3VzUGFnZVxuICB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXdhbGxldC1yZXF1ZXN0LnRzXG5mdW5jdGlvbiB1c2VXYWxsZXRSZXF1ZXN0KHByb3BzKSB7XG4gIGNvbnN0IHsgY29ubmVjdG9yIH0gPSB1c2VTdGFya25ldCgpO1xuICBjb25zdCB7IHR5cGUsIHBhcmFtcywgLi4ucmVzdCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbXV0YXRlLCBtdXRhdGVBc3luYywgLi4ucmVzdWx0IH0gPSB1c2VNdXRhdGlvbih7XG4gICAgbXV0YXRpb25LZXk6IG11dGF0aW9uS2V5KHsgdHlwZSwgcGFyYW1zIH0pLFxuICAgIG11dGF0aW9uRm46IG11dGF0aW9uRm4oeyBjb25uZWN0b3IgfSksXG4gICAgLi4ucmVzdFxuICB9KTtcbiAgY29uc3QgcmVxdWVzdCA9IHVzZUNhbGxiYWNrNChcbiAgICAoYXJncykgPT4gbXV0YXRlKGFyZ3MgPz8geyB0eXBlLCBwYXJhbXMgfSksXG4gICAgW211dGF0ZSwgdHlwZSwgcGFyYW1zXVxuICApO1xuICBjb25zdCByZXF1ZXN0QXN5bmMgPSB1c2VDYWxsYmFjazQoXG4gICAgKGFyZ3MpID0+IG11dGF0ZUFzeW5jKGFyZ3MgPz8geyB0eXBlLCBwYXJhbXMgfSksXG4gICAgW211dGF0ZUFzeW5jLCB0eXBlLCBwYXJhbXNdXG4gICk7XG4gIHJldHVybiB7XG4gICAgcmVxdWVzdCxcbiAgICByZXF1ZXN0QXN5bmMsXG4gICAgLi4ucmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBtdXRhdGlvbktleSh7XG4gIHR5cGUsXG4gIHBhcmFtc1xufSkge1xuICByZXR1cm4gW3sgZW50aXR5OiBcIndhbGxldFJlcXVlc3RcIiwgdHlwZSwgcGFyYW1zIH1dO1xufVxuZnVuY3Rpb24gbXV0YXRpb25Gbih7XG4gIGNvbm5lY3RvclxufSkge1xuICByZXR1cm4gYXN5bmMgKHsgdHlwZSwgcGFyYW1zIH0pID0+IHtcbiAgICBpZiAoIWNvbm5lY3RvcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29ubmVjdG9yIGNvbm5lY3RlZFwiKTtcbiAgICBpZiAoIXR5cGUpIHRocm93IG5ldyBFcnJvcihcIlR5cGUgaXMgcmVxdWlyZWRcIik7XG4gICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rvci5yZXF1ZXN0KHsgdHlwZSwgcGFyYW1zIH0pO1xuICB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWFkZC1jaGFpbi50c1xuZnVuY3Rpb24gdXNlQWRkQ2hhaW4ocHJvcHMpIHtcbiAgY29uc3QgeyBwYXJhbXMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICBjb25zdCB7IHJlcXVlc3QsIHJlcXVlc3RBc3luYywgLi4ucmVzdWx0IH0gPSB1c2VXYWxsZXRSZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGRTdGFya25ldENoYWluXCIsXG4gICAgcGFyYW1zLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IGFkZENoYWluID0gKGFyZ3MpID0+IHtcbiAgICByZXR1cm4gcmVxdWVzdChcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfYWRkU3RhcmtuZXRDaGFpblwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgYWRkQ2hhaW5Bc3luYyA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyhcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfYWRkU3RhcmtuZXRDaGFpblwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGRDaGFpbixcbiAgICBhZGRDaGFpbkFzeW5jLFxuICAgIC4uLnJlc3VsdFxuICB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWJhbGFuY2UudHNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzMgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEJsb2NrVGFnIGFzIEJsb2NrVGFnMixcbiAgbnVtLFxuICBzaG9ydFN0cmluZ1xufSBmcm9tIFwic3RhcmtuZXRcIjtcbmltcG9ydCB7IGZvcm1hdFVuaXRzIH0gZnJvbSBcInZpZW1cIjtcblxuLy8gc3JjL2hvb2tzL3VzZS1jb250cmFjdC50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQ29udHJhY3Rcbn0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VDb250cmFjdCh7XG4gIGFiaTogYWJpMixcbiAgYWRkcmVzcyxcbiAgcHJvdmlkZXI6IHByb3ZpZGVkUHJvdmlkZXJcbn0pIHtcbiAgY29uc3QgeyBwcm92aWRlcjogY3VycmVudFByb3ZpZGVyIH0gPSB1c2VTdGFya25ldCgpO1xuICBjb25zdCBjb250cmFjdCA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVkUHJvdmlkZXIgPyBwcm92aWRlZFByb3ZpZGVyIDogY3VycmVudFByb3ZpZGVyO1xuICAgIGlmIChhYmkyICYmIGFkZHJlc3MgJiYgcHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWJpMiwgYWRkcmVzcywgcHJvdmlkZXIpLnR5cGVkdjIoXG4gICAgICAgIGFiaTJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH0sIFthYmkyLCBhZGRyZXNzLCBwcm92aWRlZFByb3ZpZGVyLCBjdXJyZW50UHJvdmlkZXJdKTtcbiAgcmV0dXJuIHsgY29udHJhY3QgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1pbnZhbGlkYXRlLW9uLWJsb2NrLnRzXG5pbXBvcnQgeyB1c2VRdWVyeUNsaWVudCB9IGZyb20gXCJAdGFuc3RhY2svcmVhY3QtcXVlcnlcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2hvb2tzL3VzZS1ibG9jay1udW1iZXIudHNcbmltcG9ydCB7IEJsb2NrVGFnIH0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VCbG9ja051bWJlcih7XG4gIGJsb2NrSWRlbnRpZmllciA9IEJsb2NrVGFnLkxBVEVTVCxcbiAgLi4ucHJvcHNcbn0gPSB7fSkge1xuICBjb25zdCB7IHByb3ZpZGVyIH0gPSB1c2VTdGFya25ldCgpO1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBxdWVyeUtleSh7IGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICBxdWVyeUZuOiBxdWVyeUZuKHsgcHJvdmlkZXIsIGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5KHsgYmxvY2tJZGVudGlmaWVyIH0pIHtcbiAgcmV0dXJuIFt7IGVudGl0eTogXCJibG9ja051bWJlclwiLCBibG9ja0lkZW50aWZpZXIgfV07XG59XG5mdW5jdGlvbiBxdWVyeUZuKHtcbiAgcHJvdmlkZXIsXG4gIGJsb2NrSWRlbnRpZmllclxufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyKTtcbiAgICBpZiAoYmxvY2suc3RhdHVzICE9PSBcIlBFTkRJTkdcIikge1xuICAgICAgcmV0dXJuIGJsb2NrLmJsb2NrX251bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1pbnZhbGlkYXRlLW9uLWJsb2NrLnRzXG5mdW5jdGlvbiB1c2VJbnZhbGlkYXRlT25CbG9jayh7XG4gIGVuYWJsZWQgPSB0cnVlLFxuICBxdWVyeUtleTogcXVlcnlLZXkxMlxufSkge1xuICBjb25zdCBxdWVyeUNsaWVudCA9IHVzZVF1ZXJ5Q2xpZW50KCk7XG4gIGNvbnN0IFtwcmV2QmxvY2tOdW1iZXIsIHNldFByZXZCbG9ja051bWJlcl0gPSB1c2VTdGF0ZTQoKTtcbiAgY29uc3QgeyBkYXRhOiBibG9ja051bWJlciB9ID0gdXNlQmxvY2tOdW1iZXIoe1xuICAgIGVuYWJsZWRcbiAgfSk7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGlmICghcHJldkJsb2NrTnVtYmVyKSB7XG4gICAgICByZXR1cm4gc2V0UHJldkJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrTnVtYmVyICE9PSBwcmV2QmxvY2tOdW1iZXIpIHtcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHsgcXVlcnlLZXk6IHF1ZXJ5S2V5MTIgfSwgeyBjYW5jZWxSZWZldGNoOiBmYWxzZSB9KTtcbiAgICAgIHJldHVybiBzZXRQcmV2QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgIH1cbiAgfSwgW2Jsb2NrTnVtYmVyLCBwcmV2QmxvY2tOdW1iZXIsIHF1ZXJ5S2V5MTIsIHF1ZXJ5Q2xpZW50XSk7XG59XG5cbi8vIHNyYy9ob29rcy91c2UtbmV0d29yay50c1xuZnVuY3Rpb24gdXNlTmV0d29yaygpIHtcbiAgY29uc3QgeyBjaGFpbiwgY2hhaW5zIH0gPSB1c2VTdGFya25ldCgpO1xuICByZXR1cm4geyBjaGFpbiwgY2hhaW5zIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtYmFsYW5jZS50c1xudmFyIERFRkFVTFRfRkVUQ0hfSU5URVJWQUwgPSA1ZTM7XG5mdW5jdGlvbiB1c2VCYWxhbmNlKHtcbiAgdG9rZW46IHRva2VuXyxcbiAgYWRkcmVzcyxcbiAgcmVmZXRjaEludGVydmFsOiByZWZldGNoSW50ZXJ2YWxfLFxuICB3YXRjaCA9IGZhbHNlLFxuICBlbmFibGVkOiBlbmFibGVkXyA9IHRydWUsXG4gIGJsb2NrSWRlbnRpZmllciA9IEJsb2NrVGFnMi5MQVRFU1QsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgY2hhaW4gfSA9IHVzZU5ldHdvcmsoKTtcbiAgY29uc3QgdG9rZW4gPSB0b2tlbl8gPz8gY2hhaW4ubmF0aXZlQ3VycmVuY3kuYWRkcmVzcztcbiAgY29uc3QgeyBjb250cmFjdCB9ID0gdXNlQ29udHJhY3Qoe1xuICAgIGFiaTogYmFsYW5jZUFCSUZyYWdtZW50LFxuICAgIGFkZHJlc3M6IHRva2VuXG4gIH0pO1xuICBjb25zdCBxdWVyeUtleV8gPSB1c2VNZW1vMyhcbiAgICAoKSA9PiBxdWVyeUtleTIoeyBjaGFpbiwgdG9rZW4sIGFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICBbY2hhaW4sIHRva2VuLCBhZGRyZXNzLCBibG9ja0lkZW50aWZpZXJdXG4gICk7XG4gIGNvbnN0IGVuYWJsZWQgPSB1c2VNZW1vMyhcbiAgICAoKSA9PiBCb29sZWFuKGVuYWJsZWRfICYmIGNvbnRyYWN0ICYmIGFkZHJlc3MpLFxuICAgIFtlbmFibGVkXywgY29udHJhY3QsIGFkZHJlc3NdXG4gICk7XG4gIGNvbnN0IHJlZmV0Y2hJbnRlcnZhbCA9IHJlZmV0Y2hJbnRlcnZhbF8gPz8gKGJsb2NrSWRlbnRpZmllciA9PT0gQmxvY2tUYWcyLlBFTkRJTkcgJiYgd2F0Y2ggPyBERUZBVUxUX0ZFVENIX0lOVEVSVkFMIDogdm9pZCAwKTtcbiAgdXNlSW52YWxpZGF0ZU9uQmxvY2soe1xuICAgIGVuYWJsZWQ6IEJvb2xlYW4oZW5hYmxlZCAmJiB3YXRjaCksXG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5X1xuICB9KTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBlbmFibGVkLFxuICAgIHJlZmV0Y2hJbnRlcnZhbCxcbiAgICBxdWVyeUtleTogcXVlcnlLZXlfLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm4yKHsgY2hhaW4sIGNvbnRyYWN0LCB0b2tlbiwgYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyIH0pLFxuICAgIC4uLnByb3BzXG4gIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlLZXkyKHtcbiAgY2hhaW4sXG4gIHRva2VuLFxuICBhZGRyZXNzLFxuICBibG9ja0lkZW50aWZpZXJcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBlbnRpdHk6IFwiYmFsYW5jZVwiLFxuICAgICAgY2hhaW5JZDogY2hhaW4/Lm5hbWUsXG4gICAgICB0b2tlbixcbiAgICAgIGFkZHJlc3MsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBxdWVyeUZuMih7XG4gIGNoYWluLFxuICB0b2tlbixcbiAgYWRkcmVzcyxcbiAgY29udHJhY3QsXG4gIGJsb2NrSWRlbnRpZmllclxufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghYWRkcmVzcykgdGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcyBpcyByZXF1aXJlZFwiKTtcbiAgICBpZiAoIWNvbnRyYWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJjb250cmFjdCBpcyByZXF1aXJlZFwiKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgfTtcbiAgICBjb25zdCBpc05hdGl2ZUN1cnJlbmN5ID0gdG9rZW4gPT09IGNoYWluLm5hdGl2ZUN1cnJlbmN5LmFkZHJlc3M7XG4gICAgbGV0IHN5bWJvbCA9IGNoYWluLm5hdGl2ZUN1cnJlbmN5LnN5bWJvbDtcbiAgICBpZiAoIWlzTmF0aXZlQ3VycmVuY3kpIHtcbiAgICAgIGNvbnN0IHN5bWJvbF8gPSBhd2FpdCBjb250cmFjdC5zeW1ib2wob3B0aW9ucyk7XG4gICAgICBzeW1ib2wgPSBzaG9ydFN0cmluZy5kZWNvZGVTaG9ydFN0cmluZyhudW0udG9IZXgoc3ltYm9sXykpO1xuICAgIH1cbiAgICBsZXQgZGVjaW1hbHMgPSBjaGFpbi5uYXRpdmVDdXJyZW5jeS5kZWNpbWFscztcbiAgICBpZiAoIWlzTmF0aXZlQ3VycmVuY3kpIHtcbiAgICAgIGNvbnN0IGRlY2ltYWxzXyA9IGF3YWl0IGNvbnRyYWN0LmRlY2ltYWxzKG9wdGlvbnMpO1xuICAgICAgZGVjaW1hbHMgPSBOdW1iZXIoZGVjaW1hbHNfKTtcbiAgICB9XG4gICAgY29uc3QgYmFsYW5jZU9mID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKGFkZHJlc3MsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdFVuaXRzKGJhbGFuY2VPZiwgZGVjaW1hbHMpO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYmFsYW5jZU9mLFxuICAgICAgZGVjaW1hbHMsXG4gICAgICBzeW1ib2wsXG4gICAgICBmb3JtYXR0ZWRcbiAgICB9O1xuICB9O1xufVxudmFyIGJhbGFuY2VBQklGcmFnbWVudCA9IFtcbiAge1xuICAgIG5hbWU6IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiLFxuICAgIHR5cGU6IFwic3RydWN0XCIsXG4gICAgbWVtYmVyczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImxvd1wiLFxuICAgICAgICB0eXBlOiBcImNvcmU6OmludGVnZXI6OnUxMjhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJoaWdoXCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiYWNjb3VudFwiLFxuICAgICAgICB0eXBlOiBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImNvcmU6OmludGVnZXI6OnUyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVfbXV0YWJpbGl0eTogXCJ2aWV3XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwic3ltYm9sXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIGlucHV0czogW10sXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImNvcmU6OmZlbHQyNTJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVfbXV0YWJpbGl0eTogXCJ2aWV3XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiZGVjaW1hbHNcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXSxcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiY29yZTo6aW50ZWdlcjo6dThcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVfbXV0YWJpbGl0eTogXCJ2aWV3XCJcbiAgfVxuXTtcblxuLy8gc3JjL2hvb2tzL3VzZS1ibG9jay50c1xuaW1wb3J0IHtcbiAgQmxvY2tUYWcgYXMgQmxvY2tUYWczXG59IGZyb20gXCJzdGFya25ldFwiO1xuZnVuY3Rpb24gdXNlQmxvY2soe1xuICBibG9ja0lkZW50aWZpZXIgPSBCbG9ja1RhZzMuTEFURVNULFxuICAuLi5wcm9wc1xufSA9IHt9KSB7XG4gIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHVzZVN0YXJrbmV0KCk7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5Myh7IGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICBxdWVyeUZuOiBxdWVyeUZuMyh7IHByb3ZpZGVyLCBibG9ja0lkZW50aWZpZXIgfSksXG4gICAgLi4ucHJvcHNcbiAgfSk7XG59XG5mdW5jdGlvbiBxdWVyeUtleTMoeyBibG9ja0lkZW50aWZpZXIgfSkge1xuICByZXR1cm4gW3sgZW50aXR5OiBcImJsb2NrXCIsIGJsb2NrSWRlbnRpZmllciB9XTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5Rm4zKHtcbiAgcHJvdmlkZXIsXG4gIGJsb2NrSWRlbnRpZmllclxufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyKTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1jYWxsLnRzXG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW80IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBCbG9ja1RhZyBhcyBCbG9ja1RhZzRcbn0gZnJvbSBcInN0YXJrbmV0XCI7XG52YXIgREVGQVVMVF9GRVRDSF9JTlRFUlZBTDIgPSA1ZTM7XG5mdW5jdGlvbiB1c2VDYWxsKHtcbiAgYWJpOiBhYmkyLFxuICBhZGRyZXNzLFxuICBmdW5jdGlvbk5hbWUsXG4gIGFyZ3MsXG4gIGJsb2NrSWRlbnRpZmllciA9IEJsb2NrVGFnNC5MQVRFU1QsXG4gIHJlZmV0Y2hJbnRlcnZhbDogcmVmZXRjaEludGVydmFsXyxcbiAgd2F0Y2ggPSBmYWxzZSxcbiAgZW5hYmxlZDogZW5hYmxlZF8gPSB0cnVlLFxuICBwYXJzZUFyZ3MsXG4gIHBhcnNlUmVzdWx0LFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IGNoYWluIH0gPSB1c2VOZXR3b3JrKCk7XG4gIGNvbnN0IHsgY29udHJhY3QgfSA9IHVzZUNvbnRyYWN0KHsgYWJpOiBhYmkyLCBhZGRyZXNzIH0pO1xuICBjb25zdCBxdWVyeUtleV8gPSB1c2VNZW1vNChcbiAgICAoKSA9PiBxdWVyeUtleTQoe1xuICAgICAgY2hhaW4sXG4gICAgICBjb250cmFjdCxcbiAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgIGFyZ3MsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9KSxcbiAgICBbY2hhaW4sIGNvbnRyYWN0LCBmdW5jdGlvbk5hbWUsIGFyZ3MsIGJsb2NrSWRlbnRpZmllcl1cbiAgKTtcbiAgY29uc3QgZW5hYmxlZCA9IHVzZU1lbW80KFxuICAgICgpID0+IEJvb2xlYW4oZW5hYmxlZF8gJiYgY29udHJhY3QgJiYgZnVuY3Rpb25OYW1lICYmIGFyZ3MpLFxuICAgIFtlbmFibGVkXywgY29udHJhY3QsIGZ1bmN0aW9uTmFtZSwgYXJnc11cbiAgKTtcbiAgY29uc3QgcmVmZXRjaEludGVydmFsID0gcmVmZXRjaEludGVydmFsXyA/PyAoYmxvY2tJZGVudGlmaWVyID09PSBCbG9ja1RhZzQuUEVORElORyAmJiB3YXRjaCA/IERFRkFVTFRfRkVUQ0hfSU5URVJWQUwyIDogdm9pZCAwKTtcbiAgdXNlSW52YWxpZGF0ZU9uQmxvY2soe1xuICAgIGVuYWJsZWQ6IEJvb2xlYW4oZW5hYmxlZCAmJiB3YXRjaCksXG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5X1xuICB9KTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXlfLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm40KHtcbiAgICAgIGNvbnRyYWN0LFxuICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgYXJncyxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHBhcnNlQXJncyxcbiAgICAgIHBhcnNlUmVzdWx0XG4gICAgfSksXG4gICAgcmVmZXRjaEludGVydmFsLFxuICAgIGVuYWJsZWQsXG4gICAgLi4ucHJvcHNcbiAgfSk7XG59XG5mdW5jdGlvbiBxdWVyeUtleTQoe1xuICBjaGFpbixcbiAgY29udHJhY3QsXG4gIGZ1bmN0aW9uTmFtZSxcbiAgYXJncyxcbiAgYmxvY2tJZGVudGlmaWVyXG59KSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZW50aXR5OiBcInJlYWRDb250cmFjdFwiLFxuICAgICAgY2hhaW5JZDogY2hhaW4/Lm5hbWUsXG4gICAgICBjb250cmFjdDogY29udHJhY3Q/LmFkZHJlc3MsXG4gICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICBhcmdzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgYXJncyxcbiAgICAgICAgKF8sIHYpID0+IHR5cGVvZiB2ID09PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygxMCkgOiB2XG4gICAgICApLFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gcXVlcnlGbjQoe1xuICBjb250cmFjdCxcbiAgZnVuY3Rpb25OYW1lLFxuICBhcmdzLFxuICBibG9ja0lkZW50aWZpZXIsXG4gIHBhcnNlQXJncyA9IHRydWUsXG4gIHBhcnNlUmVzdWx0ID0gdHJ1ZVxufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghY29udHJhY3QpIHRocm93IG5ldyBFcnJvcihcImNvbnRyYWN0IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmIChjb250cmFjdC5mdW5jdGlvbnNbZnVuY3Rpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSBub3QgZm91bmQgaW4gY29udHJhY3RgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25OYW1lLCBhcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHBhcnNlQXJncyxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHBhcnNlUmVzdWx0LFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgfSk7XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtY29ubmVjdC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s1IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VDb25uZWN0KHByb3BzID0ge30pIHtcbiAgY29uc3QgeyBjb25uZWN0b3IsIGNvbm5lY3RvcnMsIGNvbm5lY3Q6IGNvbm5lY3RfLCBjaGFpbiB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgY29uc3QgeyBtdXRhdGUsIG11dGF0ZUFzeW5jLCB2YXJpYWJsZXMsIC4uLnJlc3VsdCB9ID0gdXNlTXV0YXRpb24oe1xuICAgIG11dGF0aW9uS2V5OiBbeyBlbnRpdHk6IFwiY29ubmVjdFwiLCBjaGFpbklkOiBjaGFpbi5uYW1lIH1dLFxuICAgIG11dGF0aW9uRm46IGNvbm5lY3RfLFxuICAgIC4uLnByb3BzXG4gIH0pO1xuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2s1KFxuICAgIChhcmdzKSA9PiBtdXRhdGUoYXJncyA/PyB7IGNvbm5lY3RvciB9KSxcbiAgICBbbXV0YXRlLCBjb25uZWN0b3JdXG4gICk7XG4gIGNvbnN0IGNvbm5lY3RBc3luYyA9IHVzZUNhbGxiYWNrNShcbiAgICAoYXJncykgPT4gbXV0YXRlQXN5bmMoYXJncyA/PyB7IGNvbm5lY3RvciB9KSxcbiAgICBbbXV0YXRlQXN5bmMsIGNvbm5lY3Rvcl1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0b3IsXG4gICAgY29ubmVjdG9ycyxcbiAgICBwZW5kaW5nQ29ubmVjdG9yOiB2YXJpYWJsZXM/LmNvbm5lY3RvcixcbiAgICBjb25uZWN0LFxuICAgIGNvbm5lY3RBc3luYyxcbiAgICB2YXJpYWJsZXMsXG4gICAgLi4ucmVzdWx0XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtY29udHJhY3QtZmFjdG9yeS50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vNSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQ29udHJhY3RGYWN0b3J5IH0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VDb250cmFjdEZhY3Rvcnkoe1xuICBjb21waWxlZENvbnRyYWN0LFxuICBjbGFzc0hhc2gsXG4gIGFiaTogYWJpMlxufSkge1xuICBjb25zdCB7IGFjY291bnQgfSA9IHVzZUFjY291bnQoKTtcbiAgY29uc3QgY29udHJhY3RGYWN0b3J5ID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIGlmIChjb21waWxlZENvbnRyYWN0ICYmIGFjY291bnQgJiYgY2xhc3NIYXNoKSB7XG4gICAgICByZXR1cm4gbmV3IENvbnRyYWN0RmFjdG9yeSh7XG4gICAgICAgIGNvbXBpbGVkQ29udHJhY3QsXG4gICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgYWJpOiBhYmkyXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSwgW2NvbXBpbGVkQ29udHJhY3QsIGNsYXNzSGFzaCwgYWNjb3VudCwgYWJpMl0pO1xuICByZXR1cm4geyBjb250cmFjdEZhY3RvcnkgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1kZWNsYXJlLWNvbnRyYWN0LnRzXG5mdW5jdGlvbiB1c2VEZWNsYXJlQ29udHJhY3QocHJvcHMpIHtcbiAgY29uc3QgeyBwYXJhbXMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICBjb25zdCB7IHJlcXVlc3QsIHJlcXVlc3RBc3luYywgLi4ucmVzdWx0IH0gPSB1c2VXYWxsZXRSZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIixcbiAgICBwYXJhbXMsXG4gICAgLi4ucmVzdFxuICB9KTtcbiAgY29uc3QgZGVjbGFyZSA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3QoXG4gICAgICBhcmdzID8ge1xuICAgICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgZGVjbGFyZUFzeW5jID0gKGFyZ3MpID0+IHtcbiAgICByZXR1cm4gcmVxdWVzdEFzeW5jKFxuICAgICAgYXJncyA/IHtcbiAgICAgICAgcGFyYW1zOiBhcmdzLFxuICAgICAgICB0eXBlOiBcIndhbGxldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZGVjbGFyZSxcbiAgICBkZWNsYXJlQXN5bmMsXG4gICAgLi4ucmVzdWx0XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtZGVwbG95LWFjY291bnQudHNcbmZ1bmN0aW9uIHVzZURlcGxveUFjY291bnQoe1xuICBjbGFzc0hhc2gsXG4gIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gIGFkZHJlc3NTYWx0LFxuICBjb250cmFjdEFkZHJlc3MsXG4gIG9wdGlvbnMsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgYWNjb3VudCB9ID0gdXNlQWNjb3VudCgpO1xuICBjb25zdCB7IG11dGF0ZSwgbXV0YXRlQXN5bmMsIC4uLnJlc3VsdCB9ID0gdXNlTXV0YXRpb24oe1xuICAgIG11dGF0aW9uS2V5OiBtdXRhdGlvbktleTIoe1xuICAgICAgYWNjb3VudCxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KSxcbiAgICBtdXRhdGlvbkZuOiBtdXRhdGlvbkZuMih7XG4gICAgICBhY2NvdW50LFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgb3B0aW9uc1xuICAgIH0pLFxuICAgIC4uLnByb3BzXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRlcGxveUFjY291bnQ6IG11dGF0ZSxcbiAgICBkZXBsb3lBY2NvdW50QXN5bmM6IG11dGF0ZUFzeW5jLFxuICAgIC4uLnJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gbXV0YXRpb25LZXkyKHByb3BzKSB7XG4gIHJldHVybiBbeyBlbnRpdHk6IFwiZGVwbG95QWNjb3VudFwiLCAuLi5wcm9wcyB9XTtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uRm4yKHtcbiAgYWNjb3VudCxcbiAgY2xhc3NIYXNoLFxuICBjb25zdHJ1Y3RvckNhbGxkYXRhLFxuICBhZGRyZXNzU2FsdCxcbiAgY29udHJhY3RBZGRyZXNzLFxuICBvcHRpb25zXG59KSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFhY2NvdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJhY2NvdW50IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmICghY2xhc3NIYXNoKSB0aHJvdyBuZXcgRXJyb3IoXCJjbGFzc0hhc2ggaXMgcmVxdWlyZWRcIik7XG4gICAgcmV0dXJuIGF3YWl0IGFjY291bnQuZGVwbG95QWNjb3VudChcbiAgICAgIHsgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBhZGRyZXNzU2FsdCwgY29udHJhY3RBZGRyZXNzIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1kaXNjb25uZWN0LnRzXG5mdW5jdGlvbiB1c2VEaXNjb25uZWN0KHByb3BzID0ge30pIHtcbiAgY29uc3QgeyBkaXNjb25uZWN0LCBjaGFpbiB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgY29uc3QgeyBtdXRhdGUsIG11dGF0ZUFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZU11dGF0aW9uKHtcbiAgICBtdXRhdGlvbktleTogW3sgZW50aXR5OiBcImRpc2Nvbm5lY3RcIiwgY2hhaW5JZDogY2hhaW4ubmFtZSB9XSxcbiAgICBtdXRhdGlvbkZuOiBkaXNjb25uZWN0LFxuICAgIC4uLnByb3BzXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc2Nvbm5lY3Q6IG11dGF0ZSxcbiAgICBkaXNjb25uZWN0QXN5bmM6IG11dGF0ZUFzeW5jLFxuICAgIC4uLnJlc3VsdFxuICB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWVzdGltYXRlLWZlZXMudHNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzYgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUVzdGltYXRlRmVlcyh7XG4gIGNhbGxzLFxuICBvcHRpb25zLFxuICB3YXRjaCA9IGZhbHNlLFxuICBlbmFibGVkOiBlbmFibGVkXyA9IHRydWUsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgYWNjb3VudCB9ID0gdXNlQWNjb3VudCgpO1xuICBjb25zdCBxdWVyeUtleV8gPSB1c2VNZW1vNihcbiAgICAoKSA9PiBxdWVyeUtleTUoeyBjYWxscywgb3B0aW9ucyB9KSxcbiAgICBbY2FsbHMsIG9wdGlvbnNdXG4gICk7XG4gIGNvbnN0IGVuYWJsZWQgPSB1c2VNZW1vNigoKSA9PiBCb29sZWFuKGVuYWJsZWRfICYmIGNhbGxzKSwgW2VuYWJsZWRfLCBjYWxsc10pO1xuICB1c2VJbnZhbGlkYXRlT25CbG9jayh7XG4gICAgZW5hYmxlZDogQm9vbGVhbihlbmFibGVkICYmIHdhdGNoKSxcbiAgICBxdWVyeUtleTogcXVlcnlLZXlfXG4gIH0pO1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBxdWVyeUtleV8sXG4gICAgcXVlcnlGbjogcXVlcnlGbjUoe1xuICAgICAgYWNjb3VudCxcbiAgICAgIGNhbGxzLFxuICAgICAgb3B0aW9uc1xuICAgIH0pLFxuICAgIGVuYWJsZWQsXG4gICAgLi4ucHJvcHNcbiAgfSk7XG59XG5mdW5jdGlvbiBxdWVyeUtleTUoeyBjYWxscywgb3B0aW9ucyB9KSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZW50aXR5OiBcImVzdGltYXRlSW52b2tlRmVlXCIsXG4gICAgICBjYWxscyxcbiAgICAgIG9wdGlvbnNcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBxdWVyeUZuNSh7XG4gIGFjY291bnQsXG4gIGNhbGxzLFxuICBvcHRpb25zXG59KSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFhY2NvdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJhY2NvdW50IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmICghY2FsbHMgfHwgY2FsbHMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJjYWxscyBhcmUgcmVxdWlyZWRcIik7XG4gICAgcmV0dXJuIGFjY291bnQ/LmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBvcHRpb25zKTtcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1leHBsb3Jlci50c1xuZnVuY3Rpb24gdXNlRXhwbG9yZXIoKSB7XG4gIGNvbnN0IHsgZXhwbG9yZXIsIGNoYWluIH0gPSB1c2VTdGFya25ldCgpO1xuICBpZiAoIWV4cGxvcmVyKVxuICAgIHRocm93IEVycm9yKFwiRXhwbG9yZXIgaXMgdW5kZWZpbmVkLiBUcnkgYWRkaW5nIGl0IHRvIFN0YXJrbmV0Q29uZmlnLlwiKTtcbiAgY29uc3QgZXhwbG9yZXJJbnN0YW5jZSA9IGV4cGxvcmVyKGNoYWluKTtcbiAgaWYgKCFleHBsb3Jlckluc3RhbmNlKSB0aHJvdyBFcnJvcihcIkV4cGxvcmVyIEluc3RhbmNlIGlzIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIGV4cGxvcmVySW5zdGFuY2U7XG59XG5cbi8vIHNyYy9ob29rcy91c2Utbm9uY2UtZm9yLWFkZHJlc3MudHNcbmltcG9ydCB7XG4gIEJsb2NrVGFnIGFzIEJsb2NrVGFnNVxufSBmcm9tIFwic3RhcmtuZXRcIjtcbmZ1bmN0aW9uIHVzZU5vbmNlRm9yQWRkcmVzcyh7XG4gIGFkZHJlc3MsXG4gIGJsb2NrSWRlbnRpZmllciA9IEJsb2NrVGFnNS5MQVRFU1QsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHVzZVN0YXJrbmV0KCk7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5Nih7IGFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICBxdWVyeUZuOiBxdWVyeUZuNih7IGFkZHJlc3MsIHByb3ZpZGVyLCBibG9ja0lkZW50aWZpZXIgfSksXG4gICAgLi4ucHJvcHNcbiAgfSk7XG59XG5mdW5jdGlvbiBxdWVyeUtleTYoe1xuICBhZGRyZXNzLFxuICBibG9ja0lkZW50aWZpZXJcbn0pIHtcbiAgcmV0dXJuIFt7IGVudGl0eTogXCJub25jZVwiLCBibG9ja0lkZW50aWZpZXIsIGFkZHJlc3MgfV07XG59XG5mdW5jdGlvbiBxdWVyeUZuNih7XG4gIHByb3ZpZGVyLFxuICBibG9ja0lkZW50aWZpZXIsXG4gIGFkZHJlc3Ncbn0pIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBub25jZSA9IGF3YWl0IHByb3ZpZGVyLmdldE5vbmNlRm9yQWRkcmVzcyhhZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIHJldHVybiBub25jZTtcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1yZWFkLWNvbnRyYWN0LnRzXG5mdW5jdGlvbiB1c2VSZWFkQ29udHJhY3QocHJvcHMpIHtcbiAgcmV0dXJuIHVzZUNhbGwocHJvcHMpO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXNlbmQtdHJhbnNhY3Rpb24udHNcbmZ1bmN0aW9uIHVzZVNlbmRUcmFuc2FjdGlvbihwcm9wcykge1xuICBjb25zdCB7IGNhbGxzLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgY29uc3QgcGFyYW1zID0gY2FsbHMgPyB7IGNhbGxzOiB0cmFuc2Zvcm1DYWxsczIoY2FsbHMpIH0gOiB2b2lkIDA7XG4gIGNvbnN0IHsgcmVxdWVzdCwgcmVxdWVzdEFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZVdhbGxldFJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCIsXG4gICAgcGFyYW1zLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IHNlbmQgPSAoYXJncykgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0KFxuICAgICAgYXJncyA/IHtcbiAgICAgICAgcGFyYW1zOiB7IGNhbGxzOiB0cmFuc2Zvcm1DYWxsczIoYXJncykgfSxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHNlbmRBc3luYyA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyhcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogeyBjYWxsczogdHJhbnNmb3JtQ2FsbHMyKGFyZ3MpIH0sXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCJcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHNlbmQsXG4gICAgc2VuZEFzeW5jLFxuICAgIC4uLnJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ2FsbHMyKGNhbGxzKSB7XG4gIHJldHVybiBjYWxscy5tYXAoXG4gICAgKGNhbGwpID0+ICh7XG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGVudHJ5X3BvaW50OiBjYWxsLmVudHJ5cG9pbnQsXG4gICAgICBjYWxsZGF0YTogY2FsbC5jYWxsZGF0YVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy9ob29rcy91c2Utc2lnbi50c1xuZnVuY3Rpb24gdXNlU2lnblR5cGVkRGF0YShwcm9wcykge1xuICBjb25zdCB7IHBhcmFtcywgLi4ucmVzdCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgcmVxdWVzdCwgcmVxdWVzdEFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZVdhbGxldFJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3NpZ25UeXBlZERhdGFcIixcbiAgICBwYXJhbXMsXG4gICAgLi4ucmVzdFxuICB9KTtcbiAgY29uc3Qgc2lnblR5cGVkRGF0YSA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3QoXG4gICAgICBhcmdzID8ge1xuICAgICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X3NpZ25UeXBlZERhdGFcIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHNpZ25UeXBlZERhdGFBc3luYyA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyhcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfc2lnblR5cGVkRGF0YVwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzaWduVHlwZWREYXRhLFxuICAgIHNpZ25UeXBlZERhdGFBc3luYyxcbiAgICAuLi5yZXN1bHRcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1zdGFyay1hZGRyZXNzLnRzXG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW83IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBDYWxsRGF0YSxcbiAgUHJvdmlkZXIsXG4gIHN0YXJrbmV0SWRcbn0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VTdGFya0FkZHJlc3Moe1xuICBuYW1lLFxuICBjb250cmFjdCxcbiAgZW5hYmxlZDogZW5hYmxlZF8gPSB0cnVlLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IHByb3ZpZGVyIH0gPSB1c2VQcm92aWRlcigpO1xuICBjb25zdCB7IGNoYWluIH0gPSB1c2VOZXR3b3JrKCk7XG4gIGNvbnN0IGVuYWJsZWQgPSB1c2VNZW1vNygoKSA9PiBCb29sZWFuKGVuYWJsZWRfICYmIG5hbWUpLCBbZW5hYmxlZF8sIG5hbWVdKTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXk3KHsgbmFtZSwgY29udHJhY3QsIG5ldHdvcms6IGNoYWluLm5ldHdvcmsgfSksXG4gICAgcXVlcnlGbjogcXVlcnlGbjcoeyBuYW1lLCBjb250cmFjdCwgcHJvdmlkZXIsIG5ldHdvcms6IGNoYWluLm5ldHdvcmsgfSksXG4gICAgZW5hYmxlZCxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5Nyh7XG4gIG5hbWUsXG4gIGNvbnRyYWN0LFxuICBuZXR3b3JrXG59KSB7XG4gIHJldHVybiBbeyBlbnRpdHk6IFwiYWRkcmVzc0Zyb21TdGFya05hbWVcIiwgbmFtZSwgY29udHJhY3QsIG5ldHdvcmsgfV07XG59XG5mdW5jdGlvbiBxdWVyeUZuNyh7XG4gIG5hbWUsXG4gIGNvbnRyYWN0LFxuICBwcm92aWRlcixcbiAgbmV0d29ya1xufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgICBjb25zdCBuYW1pbmdDb250cmFjdCA9IGNvbnRyYWN0ID8/IFN0YXJrbmV0SWROYW1pbmdDb250cmFjdFtuZXR3b3JrXTtcbiAgICBjb25zdCBwID0gbmV3IFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICBjb25zdCBlbmNvZGVkRG9tYWluID0gZW5jb2RlRG9tYWluKG5hbWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHAuY2FsbENvbnRyYWN0KHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogbmFtaW5nQ29udHJhY3QsXG4gICAgICBlbnRyeXBvaW50OiBcImRvbWFpbl90b19hZGRyZXNzXCIsXG4gICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7IGRvbWFpbjogZW5jb2RlZERvbWFpbiwgaGludDogW10gfSlcbiAgICB9KTtcbiAgICBpZiAoQmlnSW50KHJlc3VsdFswXSkgPT09IEJpZ0ludCgwKSkgdGhyb3cgbmV3IEVycm9yKFwiQWRkcmVzcyBub3QgZm91bmRcIik7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfTtcbn1cbnZhciBTdGFya25ldElkTmFtaW5nQ29udHJhY3QgPSB7XG4gIHNlcG9saWE6IFwiMHgxNTRiYzJlMWFmOTI2MGI5ZTY2YWYwZTljNDZmYzc1N2ZmODkzYjNmZjZhODU3MThhODEwYmFmMTQ3NFwiLFxuICBtYWlubmV0OiBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCJcbn07XG52YXIgZW5jb2RlRG9tYWluID0gKGRvbWFpbikgPT4ge1xuICBpZiAoIWRvbWFpbikgcmV0dXJuIFtcIjBcIl07XG4gIGNvbnN0IGVuY29kZWQgPSBbXTtcbiAgZm9yIChjb25zdCBzdWJkb21haW4gb2YgZG9tYWluLnJlcGxhY2UoXCIuc3RhcmtcIiwgXCJcIikuc3BsaXQoXCIuXCIpKVxuICAgIGVuY29kZWQucHVzaChzdGFya25ldElkLnVzZUVuY29kZWQoc3ViZG9tYWluKS50b1N0cmluZygxMCkpO1xuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8vIHNyYy9ob29rcy91c2Utc3RhcmstbmFtZS50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vOCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUHJvdmlkZXIgYXMgUHJvdmlkZXIyIH0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VTdGFya05hbWUoe1xuICBhZGRyZXNzLFxuICBjb250cmFjdCxcbiAgZW5hYmxlZDogZW5hYmxlZF8gPSB0cnVlLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IHByb3ZpZGVyIH0gPSB1c2VQcm92aWRlcigpO1xuICBjb25zdCB7IGNoYWluIH0gPSB1c2VOZXR3b3JrKCk7XG4gIGNvbnN0IGVuYWJsZWQgPSB1c2VNZW1vOChcbiAgICAoKSA9PiBCb29sZWFuKGVuYWJsZWRfICYmIGFkZHJlc3MpLFxuICAgIFtlbmFibGVkXywgYWRkcmVzc11cbiAgKTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXk4KHsgYWRkcmVzcywgY29udHJhY3QsIG5ldHdvcms6IGNoYWluLm5ldHdvcmsgfSksXG4gICAgcXVlcnlGbjogcXVlcnlGbjgoeyBhZGRyZXNzLCBjb250cmFjdCwgcHJvdmlkZXIsIG5ldHdvcms6IGNoYWluLm5ldHdvcmsgfSksXG4gICAgZW5hYmxlZCxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5OCh7XG4gIGFkZHJlc3MsXG4gIGNvbnRyYWN0LFxuICBuZXR3b3JrXG59KSB7XG4gIHJldHVybiBbeyBlbnRpdHk6IFwic3RhcmtOYW1lXCIsIGFkZHJlc3MsIGNvbnRyYWN0LCBuZXR3b3JrIH1dO1xufVxuZnVuY3Rpb24gcXVlcnlGbjgoe1xuICBhZGRyZXNzLFxuICBjb250cmFjdCxcbiAgcHJvdmlkZXIsXG4gIG5ldHdvcmtcbn0pIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWFkZHJlc3MpIHRocm93IG5ldyBFcnJvcihcImFkZHJlc3MgaXMgcmVxdWlyZWRcIik7XG4gICAgY29uc3QgbmFtaW5nQ29udHJhY3QgPSBjb250cmFjdCA/PyBTdGFya25ldElkTmFtaW5nQ29udHJhY3QyW25ldHdvcmtdO1xuICAgIGNvbnN0IHAgPSBuZXcgUHJvdmlkZXIyKHByb3ZpZGVyKTtcbiAgICByZXR1cm4gYXdhaXQgcC5nZXRTdGFya05hbWUoYWRkcmVzcywgbmFtaW5nQ29udHJhY3QpO1xuICB9O1xufVxudmFyIFN0YXJrbmV0SWROYW1pbmdDb250cmFjdDIgPSB7XG4gIHNlcG9saWE6IFwiMHgxNTRiYzJlMWFmOTI2MGI5ZTY2YWYwZTljNDZmYzc1N2ZmODkzYjNmZjZhODU3MThhODEwYmFmMTQ3NFwiLFxuICBtYWlubmV0OiBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCJcbn07XG5cbi8vIHNyYy9ob29rcy91c2Utc3RhcmstcHJvZmlsZS50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vOSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQ2Fpcm9DdXN0b21FbnVtLFxuICBjYWlybyxcbiAgaGFzaCxcbiAgc2hvcnRTdHJpbmcgYXMgc2hvcnRTdHJpbmcyLFxuICBzdGFya25ldElkIGFzIHN0YXJrbmV0SWQyXG59IGZyb20gXCJzdGFya25ldFwiO1xuZnVuY3Rpb24gdXNlU3RhcmtQcm9maWxlKHtcbiAgYWRkcmVzcyxcbiAgdXNlRGVmYXVsdFBmcCA9IHRydWUsXG4gIG5hbWluZ0NvbnRyYWN0LFxuICBpZGVudGl0eUNvbnRyYWN0LFxuICBlbmFibGVkOiBlbmFibGVkXyA9IHRydWUsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHVzZVByb3ZpZGVyKCk7XG4gIGNvbnN0IHsgY2hhaW4gfSA9IHVzZU5ldHdvcmsoKTtcbiAgaWYgKCFTdGFya25ldElkY29udHJhY3RzW2NoYWluLm5ldHdvcmtdKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgbm90IHN1cHBvcnRlZFwiKTtcbiAgY29uc3QgeyBjb250cmFjdDogbXVsdGljYWxsQ29udHJhY3QgfSA9IHVzZUNvbnRyYWN0KHtcbiAgICBhYmk6IG11bHRpY2FsbEFCSSxcbiAgICBhZGRyZXNzOiBTdGFya25ldElkY29udHJhY3RzW2NoYWluLm5ldHdvcmtdW1wibXVsdGljYWxsXCJdXG4gIH0pO1xuICBjb25zdCBlbmFibGVkID0gdXNlTWVtbzkoXG4gICAgKCkgPT4gQm9vbGVhbihlbmFibGVkXyAmJiBhZGRyZXNzKSxcbiAgICBbZW5hYmxlZF8sIGFkZHJlc3NdXG4gICk7XG4gIGNvbnN0IHsgcmVmZXRjaEludGVydmFsLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXk5KHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBuYW1pbmdDb250cmFjdCxcbiAgICAgIGlkZW50aXR5Q29udHJhY3QsXG4gICAgICBuZXR3b3JrOiBjaGFpbi5uZXR3b3JrLFxuICAgICAgdXNlRGVmYXVsdFBmcFxuICAgIH0pLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm45KHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICB1c2VEZWZhdWx0UGZwLFxuICAgICAgbmFtaW5nQ29udHJhY3QsXG4gICAgICBuZXR3b3JrOiBjaGFpbi5uZXR3b3JrLFxuICAgICAgaWRlbnRpdHlDb250cmFjdCxcbiAgICAgIG11bHRpY2FsbENvbnRyYWN0XG4gICAgfSksXG4gICAgZW5hYmxlZCxcbiAgICByZWZldGNoSW50ZXJ2YWwsXG4gICAgLi4ucmVzdFxuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5OSh7XG4gIGFkZHJlc3MsXG4gIG5hbWluZ0NvbnRyYWN0LFxuICBpZGVudGl0eUNvbnRyYWN0LFxuICBuZXR3b3JrLFxuICB1c2VEZWZhdWx0UGZwXG59KSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZW50aXR5OiBcInN0YXJrcHJvZmlsZVwiLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIG5hbWluZ0NvbnRyYWN0LFxuICAgICAgaWRlbnRpdHlDb250cmFjdCxcbiAgICAgIG5ldHdvcmssXG4gICAgICB1c2VEZWZhdWx0UGZwXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gcXVlcnlGbjkoe1xuICBhZGRyZXNzLFxuICB1c2VEZWZhdWx0UGZwLFxuICBuYW1pbmdDb250cmFjdCxcbiAgaWRlbnRpdHlDb250cmFjdCxcbiAgbmV0d29yayxcbiAgbXVsdGljYWxsQ29udHJhY3Rcbn0pIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWFkZHJlc3MpIHRocm93IG5ldyBFcnJvcihcImFkZHJlc3MgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKCFtdWx0aWNhbGxDb250cmFjdCkgdGhyb3cgbmV3IEVycm9yKFwibXVsdGljYWxsQ29udHJhY3QgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKCFuZXR3b3JrKSB0aHJvdyBuZXcgRXJyb3IoXCJuZXR3b3JrIGlzIHJlcXVpcmVkXCIpO1xuICAgIGNvbnN0IGNvbnRyYWN0cyA9IFN0YXJrbmV0SWRjb250cmFjdHNbbmV0d29ya107XG4gICAgY29uc3QgaWRlbnRpdHkgPSBpZGVudGl0eUNvbnRyYWN0ID8/IGNvbnRyYWN0c1tcImlkZW50aXR5XCJdO1xuICAgIGNvbnN0IG5hbWluZyA9IG5hbWluZ0NvbnRyYWN0ID8/IGNvbnRyYWN0c1tcIm5hbWluZ1wiXTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgbXVsdGljYWxsQ29udHJhY3QuY2FsbChcImFnZ3JlZ2F0ZVwiLCBbXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IHN0YXRpY0V4ZWN1dGlvbigpLFxuICAgICAgICAgIHRvOiBoYXJkY29kZWQobmFtaW5nKSxcbiAgICAgICAgICBzZWxlY3RvcjogaGFyZGNvZGVkKGhhc2guZ2V0U2VsZWN0b3JGcm9tTmFtZShcImFkZHJlc3NfdG9fZG9tYWluXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW2hhcmRjb2RlZChhZGRyZXNzKSwgaGFyZGNvZGVkKDApXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBzdGF0aWNFeGVjdXRpb24oKSxcbiAgICAgICAgICB0bzogaGFyZGNvZGVkKG5hbWluZyksXG4gICAgICAgICAgc2VsZWN0b3I6IGhhcmRjb2RlZChoYXNoLmdldFNlbGVjdG9yRnJvbU5hbWUoXCJkb21haW5fdG9faWRcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbYXJyYXlSZWZlcmVuY2UoMCwgMCldXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IHN0YXRpY0V4ZWN1dGlvbigpLFxuICAgICAgICAgIHRvOiBoYXJkY29kZWQoaWRlbnRpdHkpLFxuICAgICAgICAgIHNlbGVjdG9yOiBoYXJkY29kZWQoaGFzaC5nZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICByZWZlcmVuY2UoMSwgMCksXG4gICAgICAgICAgICBoYXJkY29kZWQoc2hvcnRTdHJpbmcyLmVuY29kZVNob3J0U3RyaW5nKFwidHdpdHRlclwiKSksXG4gICAgICAgICAgICBoYXJkY29kZWQoY29udHJhY3RzW1widmVyaWZpZXJcIl0pLFxuICAgICAgICAgICAgaGFyZGNvZGVkKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogc3RhdGljRXhlY3V0aW9uKCksXG4gICAgICAgICAgdG86IGhhcmRjb2RlZChpZGVudGl0eSksXG4gICAgICAgICAgc2VsZWN0b3I6IGhhcmRjb2RlZChoYXNoLmdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIHJlZmVyZW5jZSgxLCAwKSxcbiAgICAgICAgICAgIGhhcmRjb2RlZChzaG9ydFN0cmluZzIuZW5jb2RlU2hvcnRTdHJpbmcoXCJnaXRodWJcIikpLFxuICAgICAgICAgICAgaGFyZGNvZGVkKGNvbnRyYWN0c1tcInZlcmlmaWVyXCJdKSxcbiAgICAgICAgICAgIGhhcmRjb2RlZChcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IHN0YXRpY0V4ZWN1dGlvbigpLFxuICAgICAgICAgIHRvOiBoYXJkY29kZWQoaWRlbnRpdHkpLFxuICAgICAgICAgIHNlbGVjdG9yOiBoYXJkY29kZWQoaGFzaC5nZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICByZWZlcmVuY2UoMSwgMCksXG4gICAgICAgICAgICBoYXJkY29kZWQoc2hvcnRTdHJpbmcyLmVuY29kZVNob3J0U3RyaW5nKFwiZGlzY29yZFwiKSksXG4gICAgICAgICAgICBoYXJkY29kZWQoY29udHJhY3RzW1widmVyaWZpZXJcIl0pLFxuICAgICAgICAgICAgaGFyZGNvZGVkKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogc3RhdGljRXhlY3V0aW9uKCksXG4gICAgICAgICAgdG86IGhhcmRjb2RlZChpZGVudGl0eSksXG4gICAgICAgICAgc2VsZWN0b3I6IGhhcmRjb2RlZChoYXNoLmdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIHJlZmVyZW5jZSgxLCAwKSxcbiAgICAgICAgICAgIGhhcmRjb2RlZChzaG9ydFN0cmluZzIuZW5jb2RlU2hvcnRTdHJpbmcoXCJwcm9vZl9vZl9wZXJzb25ob29kXCIpKSxcbiAgICAgICAgICAgIGhhcmRjb2RlZChjb250cmFjdHNbXCJ2ZXJpZmllcl9wb3BcIl0pLFxuICAgICAgICAgICAgaGFyZGNvZGVkKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gUEZQXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IHN0YXRpY0V4ZWN1dGlvbigpLFxuICAgICAgICAgIHRvOiBoYXJkY29kZWQoaWRlbnRpdHkpLFxuICAgICAgICAgIHNlbGVjdG9yOiBoYXJkY29kZWQoaGFzaC5nZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICByZWZlcmVuY2UoMSwgMCksXG4gICAgICAgICAgICBoYXJkY29kZWQoc2hvcnRTdHJpbmcyLmVuY29kZVNob3J0U3RyaW5nKFwibmZ0X3BwX2NvbnRyYWN0XCIpKSxcbiAgICAgICAgICAgIGhhcmRjb2RlZChjb250cmFjdHNbXCJ2ZXJpZmllcl9wZnBcIl0pLFxuICAgICAgICAgICAgaGFyZGNvZGVkKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogc3RhdGljRXhlY3V0aW9uKCksXG4gICAgICAgICAgdG86IGhhcmRjb2RlZChpZGVudGl0eSksXG4gICAgICAgICAgc2VsZWN0b3I6IGhhcmRjb2RlZChcbiAgICAgICAgICAgIGhhc2guZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF9leHRlbmRlZF92ZXJpZmllcl9kYXRhXCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgcmVmZXJlbmNlKDEsIDApLFxuICAgICAgICAgICAgaGFyZGNvZGVkKHNob3J0U3RyaW5nMi5lbmNvZGVTaG9ydFN0cmluZyhcIm5mdF9wcF9pZFwiKSksXG4gICAgICAgICAgICBoYXJkY29kZWQoXCIyXCIpLFxuICAgICAgICAgICAgaGFyZGNvZGVkKGNvbnRyYWN0c1tcInZlcmlmaWVyX3BmcFwiXSksXG4gICAgICAgICAgICBoYXJkY29kZWQoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBub3RFcXVhbCg2LCAwLCAwKSxcbiAgICAgICAgICB0bzogcmVmZXJlbmNlKDYsIDApLFxuICAgICAgICAgIHNlbGVjdG9yOiBoYXJkY29kZWQoaGFzaC5nZXRTZWxlY3RvckZyb21OYW1lKFwidG9rZW5VUklcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbcmVmZXJlbmNlKDcsIDEpLCByZWZlcmVuY2UoNywgMildXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgY29uc3QgbmFtZSA9IGRhdGFbMF1bMF0gIT09IEJpZ0ludCgwKSA/IHN0YXJrbmV0SWQyLnVzZURlY29kZWQoZGF0YVswXS5zbGljZSgxKS5tYXAoKHZhbCkgPT4gQmlnSW50KHZhbCkpKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHR3aXR0ZXIgPSBkYXRhWzJdWzBdICE9PSBCaWdJbnQoMCkgPyBkYXRhWzJdWzBdLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICBjb25zdCBnaXRodWIgPSBkYXRhWzNdWzBdICE9PSBCaWdJbnQoMCkgPyBkYXRhWzNdWzBdLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICBjb25zdCBkaXNjb3JkID0gZGF0YVs0XVswXSAhPT0gQmlnSW50KDApID8gZGF0YVs0XVswXS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgY29uc3QgcHJvb2ZPZlBlcnNvbmhvb2QgPSBkYXRhWzVdWzBdID09PSBCaWdJbnQoMSk7XG4gICAgICBjb25zdCBwcm9maWxlID0gZGF0YS5sZW5ndGggPT09IDkgPyBkYXRhWzhdLnNsaWNlKDEpLm1hcCgodmFsKSA9PiBzaG9ydFN0cmluZzIuZGVjb2RlU2hvcnRTdHJpbmcodmFsLnRvU3RyaW5nKCkpKS5qb2luKFwiXCIpIDogdm9pZCAwO1xuICAgICAgY29uc3QgcHJvZmlsZVBpY3R1cmUgPSBwcm9maWxlID8gcHJvZmlsZS5pbmNsdWRlcyhcImJhc2U2NFwiKSA/IHBhcnNlQmFzZTY0SW1hZ2UocHJvZmlsZSkgOiBhd2FpdCBmZXRjaEltYWdlVXJsKHByb2ZpbGUpIDogdXNlRGVmYXVsdFBmcCA/IGBodHRwczovL3N0YXJrbmV0LmlkL2FwaS9pZGVudGljb25zLyR7ZGF0YVsxXVswXS50b1N0cmluZygpfWAgOiB2b2lkIDA7XG4gICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR3aXR0ZXIsXG4gICAgICAgIGdpdGh1YixcbiAgICAgICAgZGlzY29yZCxcbiAgICAgICAgcHJvb2ZPZlBlcnNvbmhvb2QsXG4gICAgICAgIHByb2ZpbGVQaWN0dXJlLFxuICAgICAgICBwcm9maWxlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3Igd2hpbGUgZmV0Y2hpbmcgZGF0YVwiKTtcbiAgfTtcbn1cbnZhciBoYXJkY29kZWQgPSAoYXJnKSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBIYXJkY29kZWQ6IGFyZ1xuICB9KTtcbn07XG52YXIgcmVmZXJlbmNlID0gKGNhbGwsIHBvcykgPT4ge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgUmVmZXJlbmNlOiBjYWlyby50dXBsZShjYWxsLCBwb3MpXG4gIH0pO1xufTtcbnZhciBhcnJheVJlZmVyZW5jZSA9IChjYWxsLCBwb3MpID0+IHtcbiAgcmV0dXJuIG5ldyBDYWlyb0N1c3RvbUVudW0oe1xuICAgIEFycmF5UmVmZXJlbmNlOiBjYWlyby50dXBsZShjYWxsLCBwb3MpXG4gIH0pO1xufTtcbnZhciBzdGF0aWNFeGVjdXRpb24gPSAoKSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBTdGF0aWM6IHt9XG4gIH0pO1xufTtcbnZhciBub3RFcXVhbCA9IChjYWxsLCBwb3MsIHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBJZk5vdEVxdWFsOiBjYWlyby50dXBsZShjYWxsLCBwb3MsIHZhbHVlKVxuICB9KTtcbn07XG52YXIgcGFyc2VCYXNlNjRJbWFnZSA9IChtZXRhZGF0YSkgPT4ge1xuICByZXR1cm4gSlNPTi5wYXJzZShhdG9iKG1ldGFkYXRhLnNwbGl0KFwiLFwiKVsxXS5zbGljZSgwLCAtMSkpKS5pbWFnZTtcbn07XG52YXIgcGFyc2VJbWFnZVVybCA9ICh1cmwpID0+IHtcbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKFwiaXBmczovL1wiKSA/IHVybC5yZXBsYWNlKFwiaXBmczovL1wiLCBcImh0dHBzOi8vaXBmcy5pby9pcGZzL1wiKSA6IHVybDtcbn07XG52YXIgZmV0Y2hJbWFnZVVybCA9IGFzeW5jICh1cmwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHBhcnNlSW1hZ2VVcmwodXJsKSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rXCIpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChkYXRhLmltYWdlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbWFnZVVybChkYXRhLmltYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVGhlcmUgd2FzIGEgcHJvYmxlbSBmZXRjaGluZyB0aGUgaW1hZ2UgVVJMOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcbnZhciBTdGFya25ldElkY29udHJhY3RzID0ge1xuICBzZXBvbGlhOiB7XG4gICAgbmFtaW5nOiBcIjB4MTU0YmMyZTFhZjkyNjBiOWU2NmFmMGU5YzQ2ZmM3NTdmZjg5M2IzZmY2YTg1NzE4YTgxMGJhZjE0NzRcIixcbiAgICBpZGVudGl0eTogXCIweDM2OTc2NjBhMDk4MWQ3MzQ3ODA3MzE5NDllY2IyYjRhMzhkNmE1OGZjNDE2MjllZDYxMWU4ZGVmZGFcIixcbiAgICB2ZXJpZmllcjogXCIweDYwQjk0ZkVEZTUyNWY4MTVBRTVFODM3N0E0NjNlMTIxQzc4N2NDQ2YzYTM2MzU4QWE5QjE4YzEyYzRENTY2XCIsXG4gICAgdmVyaWZpZXJfcG9wOiBcIjB4MTVhZTg4YWUwNTRjYWE3NDA5MGI4OTAyNWMxNTk1NjgzZjEyZWRmN2E0ZWQyYWQwMjc0ZGUzZTFkNGFcIixcbiAgICB2ZXJpZmllcl9wZnA6IFwiMHg5ZTdiZGI4ZGFiZDAyZWE4Y2ZjMjNiMWQxYzUyNzhlNDY0OTBmMTkzZjg3NTE2ZWQ1ZmYyZGZlYzAyXCIsXG4gICAgbXVsdGljYWxsOiBcIjB4MDdhOTAxMzY5NzM3MWNlNDBkMDMwNmI0YzgxMGM2YTRkYjliZmRhMTE5ZGQ5YWUxZTg3MDFjOGUyODhkNzM0YlwiXG4gIH0sXG4gIG1haW5uZXQ6IHtcbiAgICBuYW1pbmc6IFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIixcbiAgICBpZGVudGl0eTogXCIweDA1ZGJkZWRjMjAzZTkyNzQ5ZTJlNzQ2ZTJkNDBhNzY4ZDk2NmJkMjQzZGYwNGE2YjcxMmUyMjJiYzA0MGE5YWZcIixcbiAgICB2ZXJpZmllcjogXCIweDA3ZDE0ZGZkOGVlOTViNDFmY2UxNzkxNzBkODhiYTFmMGQ1YTUxMmUxM2FlYjIzMmYxOWNmZWVjMGE4OGY4YmZcIixcbiAgICB2ZXJpZmllcl9wb3A6IFwiMHgwMjkzZWIyYmE5ODYyZjc2MmJkMzAzNjU4NmQ1NzU1YTc4MmJkMjJlNmY1MDI4MzIwZjFkMDQwNWZkNDdiZmY0XCIsXG4gICAgdmVyaWZpZXJfcGZwOiBcIjB4MDcwYWFhMjBlYzRhNDZkYTU3YzkzMmQ5ZmQ4OWNhNWU2YmI5Y2EzMTg4ZDNkZjM2MWEzMjMwNmFmZjdkNTljN1wiLFxuICAgIG11bHRpY2FsbDogXCIweDAzNGZmYjhmNDQ1MmRmN2E2MTNhMDIxMDgyNGQ2NDE0ZGJhZGNkZGNlNmM2ZTE5YmY0ZGRjOWUyMmNlNWY5NzBcIlxuICB9XG59O1xudmFyIG11bHRpY2FsbEFCSSA9IFtcbiAge1xuICAgIG5hbWU6IFwiQ29tcG9zYWJsZU11bHRpY2FsbEltcGxcIixcbiAgICB0eXBlOiBcImltcGxcIixcbiAgICBpbnRlcmZhY2VfbmFtZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6SUNvbXBvc2FibGVNdWx0aWNhbGxcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6RXhlY3V0aW9uXCIsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTdGF0aWNcIixcbiAgICAgICAgdHlwZTogXCIoKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIklmRXF1YWxcIixcbiAgICAgICAgdHlwZTogXCIoY29yZTo6aW50ZWdlcjo6dTMyLCBjb3JlOjppbnRlZ2VyOjp1MzIsIGNvcmU6OmZlbHQyNTIpXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiSWZOb3RFcXVhbFwiLFxuICAgICAgICB0eXBlOiBcIihjb3JlOjppbnRlZ2VyOjp1MzIsIGNvcmU6OmludGVnZXI6OnUzMiwgY29yZTo6ZmVsdDI1MilcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiY29tcG9zYWJsZV9tdWx0aWNhbGw6OkR5bmFtaWNGZWx0XCIsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJIYXJkY29kZWRcIixcbiAgICAgICAgdHlwZTogXCJjb3JlOjpmZWx0MjUyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiUmVmZXJlbmNlXCIsXG4gICAgICAgIHR5cGU6IFwiKGNvcmU6OmludGVnZXI6OnUzMiwgY29yZTo6aW50ZWdlcjo6dTMyKVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6RHluYW1pY0NhbGxkYXRhXCIsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJIYXJkY29kZWRcIixcbiAgICAgICAgdHlwZTogXCJjb3JlOjpmZWx0MjUyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiUmVmZXJlbmNlXCIsXG4gICAgICAgIHR5cGU6IFwiKGNvcmU6OmludGVnZXI6OnUzMiwgY29yZTo6aW50ZWdlcjo6dTMyKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIkFycmF5UmVmZXJlbmNlXCIsXG4gICAgICAgIHR5cGU6IFwiKGNvcmU6OmludGVnZXI6OnUzMiwgY29yZTo6aW50ZWdlcjo6dTMyKVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6RHluYW1pY0NhbGxcIixcbiAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgIG1lbWJlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJleGVjdXRpb25cIixcbiAgICAgICAgdHlwZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6RXhlY3V0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgdHlwZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6RHluYW1pY0ZlbHRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJzZWxlY3RvclwiLFxuICAgICAgICB0eXBlOiBcImNvbXBvc2FibGVfbXVsdGljYWxsOjpEeW5hbWljRmVsdFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcImNhbGxkYXRhXCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6YXJyYXk6OkFycmF5Ojo8Y29tcG9zYWJsZV9tdWx0aWNhbGw6OkR5bmFtaWNDYWxsZGF0YT5cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiY29yZTo6YXJyYXk6OlNwYW46Ojxjb3JlOjpmZWx0MjUyPlwiLFxuICAgIHR5cGU6IFwic3RydWN0XCIsXG4gICAgbWVtYmVyczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcInNuYXBzaG90XCIsXG4gICAgICAgIHR5cGU6IFwiQGNvcmU6OmFycmF5OjpBcnJheTo6PGNvcmU6OmZlbHQyNTI+XCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcImNvbXBvc2FibGVfbXVsdGljYWxsOjpJQ29tcG9zYWJsZU11bHRpY2FsbFwiLFxuICAgIHR5cGU6IFwiaW50ZXJmYWNlXCIsXG4gICAgaXRlbXM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJhZ2dyZWdhdGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcImNhbGxzXCIsXG4gICAgICAgICAgICB0eXBlOiBcImNvcmU6OmFycmF5OjpBcnJheTo6PGNvbXBvc2FibGVfbXVsdGljYWxsOjpEeW5hbWljQ2FsbD5cIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29yZTo6YXJyYXk6OkFycmF5Ojo8Y29yZTo6YXJyYXk6OlNwYW46Ojxjb3JlOjpmZWx0MjUyPj5cIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVfbXV0YWJpbGl0eTogXCJ2aWV3XCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBraW5kOiBcImVudW1cIixcbiAgICBuYW1lOiBcImNvbXBvc2FibGVfbXVsdGljYWxsOjpjb250cmFjdDo6Q29tcG9zYWJsZU11bHRpY2FsbDo6RXZlbnRcIixcbiAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgdmFyaWFudHM6IFtdXG4gIH1cbl07XG5cbi8vIHNyYy9ob29rcy91c2Utc3dpdGNoLWNoYWluLnRzXG5mdW5jdGlvbiB1c2VTd2l0Y2hDaGFpbihwcm9wcykge1xuICBjb25zdCB7IHBhcmFtcywgLi4ucmVzdCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgcmVxdWVzdCwgcmVxdWVzdEFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZVdhbGxldFJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3N3aXRjaFN0YXJrbmV0Q2hhaW5cIixcbiAgICBwYXJhbXMsXG4gICAgLi4ucmVzdFxuICB9KTtcbiAgY29uc3Qgc3dpdGNoQ2hhaW4gPSAoYXJncykgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0KFxuICAgICAgYXJncyA/IHtcbiAgICAgICAgcGFyYW1zOiBhcmdzLFxuICAgICAgICB0eXBlOiBcIndhbGxldF9zd2l0Y2hTdGFya25ldENoYWluXCJcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICB9O1xuICBjb25zdCBzd2l0Y2hDaGFpbkFzeW5jID0gKGFyZ3MpID0+IHtcbiAgICByZXR1cm4gcmVxdWVzdEFzeW5jKFxuICAgICAgYXJncyA/IHtcbiAgICAgICAgcGFyYW1zOiBhcmdzLFxuICAgICAgICB0eXBlOiBcIndhbGxldF9zd2l0Y2hTdGFya25ldENoYWluXCJcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHN3aXRjaENoYWluLFxuICAgIHN3aXRjaENoYWluQXN5bmMsXG4gICAgLi4ucmVzdWx0XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtdHJhbnNhY3Rpb24tcmVjZWlwdC50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vMTAgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uUmVjZWlwdCh7XG4gIGhhc2g6IGhhc2gzLFxuICB3YXRjaCxcbiAgZW5hYmxlZDogZW5hYmxlZF8gPSB0cnVlLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IHByb3ZpZGVyLCBjaGFpbiB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgY29uc3QgcXVlcnlLZXlfID0gdXNlTWVtbzEwKCgpID0+IHF1ZXJ5S2V5MTAoeyBjaGFpbiwgaGFzaDogaGFzaDMgfSksIFtjaGFpbiwgaGFzaDNdKTtcbiAgY29uc3QgZW5hYmxlZCA9IHVzZU1lbW8xMCgoKSA9PiBCb29sZWFuKGVuYWJsZWRfICYmIGhhc2gzKSwgW2VuYWJsZWRfLCBoYXNoM10pO1xuICB1c2VJbnZhbGlkYXRlT25CbG9jayh7XG4gICAgZW5hYmxlZDogQm9vbGVhbihlbmFibGVkICYmIHdhdGNoKSxcbiAgICBxdWVyeUtleTogcXVlcnlLZXlfXG4gIH0pO1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBxdWVyeUtleV8sXG4gICAgcXVlcnlGbjogcXVlcnlGbjEwKHsgcHJvdmlkZXIsIGhhc2g6IGhhc2gzIH0pLFxuICAgIGVuYWJsZWQsXG4gICAgLi4ucHJvcHNcbiAgfSk7XG59XG5mdW5jdGlvbiBxdWVyeUtleTEwKHsgY2hhaW4sIGhhc2g6IGhhc2gzIH0pIHtcbiAgcmV0dXJuIFtcbiAgICB7IGVudGl0eTogXCJ0cmFuc2FjdGlvblJlY2VpcHRcIiwgY2hhaW5JZDogY2hhaW4/Lm5hbWUsIGhhc2g6IGhhc2gzIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5Rm4xMCh7XG4gIHByb3ZpZGVyLFxuICBoYXNoOiBoYXNoM1xufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaGFzaDMpIHRocm93IG5ldyBFcnJvcihcImhhc2ggaXMgcmVxdWlyZWRcIik7XG4gICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoMyk7XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2Utd2F0Y2gtYXNzZXQudHNcbmZ1bmN0aW9uIHVzZVdhdGNoQXNzZXQocHJvcHMpIHtcbiAgY29uc3QgeyBwYXJhbXMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICBjb25zdCB7IHJlcXVlc3QsIHJlcXVlc3RBc3luYywgLi4ucmVzdWx0IH0gPSB1c2VXYWxsZXRSZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF93YXRjaEFzc2V0XCIsXG4gICAgcGFyYW1zLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IHdhdGNoQXNzZXQgPSAoYXJncykgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0KFxuICAgICAgYXJncyA/IHtcbiAgICAgICAgcGFyYW1zOiBhcmdzLFxuICAgICAgICB0eXBlOiBcIndhbGxldF93YXRjaEFzc2V0XCJcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICB9O1xuICBjb25zdCB3YXRjaEFzc2V0QXN5bmMgPSAoYXJncykgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0QXN5bmMoXG4gICAgICBhcmdzID8ge1xuICAgICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X3dhdGNoQXNzZXRcIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgd2F0Y2hBc3NldCxcbiAgICB3YXRjaEFzc2V0QXN5bmMsXG4gICAgLi4ucmVzdWx0XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtdW5pdmVyc2FsLWRlcGxveWVyLWNvbnRyYWN0LnRzeFxuZnVuY3Rpb24gdXNlVW5pdmVyc2FsRGVwbG95ZXJDb250cmFjdChwcm9wcykge1xuICBjb25zdCB7IGFkZHJlc3MsIHByb3ZpZGVyIH0gPSBwcm9wcyB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICB1ZGM6IHVzZUNvbnRyYWN0KHtcbiAgICAgIGFiaSxcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MgPz8gXCIweDA0YTY0Y2QwOWE4NTM4Njg2MjFkOTRjYWU5OTUyYjEwNmYyYzM2YTNmODEyNjBmODVkZTY2OTZjNmIwNTAyMjFcIixcbiAgICAgIHByb3ZpZGVyXG4gICAgfSkuY29udHJhY3RcbiAgfTtcbn1cbnZhciBhYmkgPSBbXG4gIHtcbiAgICBuYW1lOiBcIlVuaXZlcnNhbERlcGxveWVySW1wbFwiLFxuICAgIHR5cGU6IFwiaW1wbFwiLFxuICAgIGludGVyZmFjZV9uYW1lOiBcIm9wZW56ZXBwZWxpbjo6dXRpbHM6OnVuaXZlcnNhbF9kZXBsb3llcjo6aW50ZXJmYWNlOjpJVW5pdmVyc2FsRGVwbG95ZXJcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJjb3JlOjpib29sXCIsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJGYWxzZVwiLFxuICAgICAgICB0eXBlOiBcIigpXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiVHJ1ZVwiLFxuICAgICAgICB0eXBlOiBcIigpXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcImNvcmU6OmFycmF5OjpTcGFuOjo8Y29yZTo6ZmVsdDI1Mj5cIixcbiAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgIG1lbWJlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJzbmFwc2hvdFwiLFxuICAgICAgICB0eXBlOiBcIkBjb3JlOjphcnJheTo6QXJyYXk6Ojxjb3JlOjpmZWx0MjUyPlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJvcGVuemVwcGVsaW46OnV0aWxzOjp1bml2ZXJzYWxfZGVwbG95ZXI6OmludGVyZmFjZTo6SVVuaXZlcnNhbERlcGxveWVyXCIsXG4gICAgdHlwZTogXCJpbnRlcmZhY2VcIixcbiAgICBpdGVtczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImRlcGxveV9jb250cmFjdFwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiY2xhc3NfaGFzaFwiLFxuICAgICAgICAgICAgdHlwZTogXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwic2FsdFwiLFxuICAgICAgICAgICAgdHlwZTogXCJjb3JlOjpmZWx0MjUyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiZnJvbV96ZXJvXCIsXG4gICAgICAgICAgICB0eXBlOiBcImNvcmU6OmJvb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJjYWxsZGF0YVwiLFxuICAgICAgICAgICAgdHlwZTogXCJjb3JlOjphcnJheTo6U3Bhbjo6PGNvcmU6OmZlbHQyNTI+XCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVfbXV0YWJpbGl0eTogXCJleHRlcm5hbFwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAga2luZDogXCJzdHJ1Y3RcIixcbiAgICBuYW1lOiBcIm9wZW56ZXBwZWxpbjo6cHJlc2V0czo6dW5pdmVyc2FsX2RlcGxveWVyOjpVbml2ZXJzYWxEZXBsb3llcjo6Q29udHJhY3REZXBsb3llZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICBtZW1iZXJzOiBbXG4gICAgICB7XG4gICAgICAgIGtpbmQ6IFwiZGF0YVwiLFxuICAgICAgICBuYW1lOiBcImFkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJjb3JlOjpzdGFya25ldDo6Y29udHJhY3RfYWRkcmVzczo6Q29udHJhY3RBZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtpbmQ6IFwiZGF0YVwiLFxuICAgICAgICBuYW1lOiBcImRlcGxveWVyXCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBraW5kOiBcImRhdGFcIixcbiAgICAgICAgbmFtZTogXCJmcm9tX3plcm9cIixcbiAgICAgICAgdHlwZTogXCJjb3JlOjpib29sXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtpbmQ6IFwiZGF0YVwiLFxuICAgICAgICBuYW1lOiBcImNsYXNzX2hhc2hcIixcbiAgICAgICAgdHlwZTogXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtpbmQ6IFwiZGF0YVwiLFxuICAgICAgICBuYW1lOiBcImNhbGxkYXRhXCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6YXJyYXk6OlNwYW46Ojxjb3JlOjpmZWx0MjUyPlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBraW5kOiBcImRhdGFcIixcbiAgICAgICAgbmFtZTogXCJzYWx0XCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6ZmVsdDI1MlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAga2luZDogXCJlbnVtXCIsXG4gICAgbmFtZTogXCJvcGVuemVwcGVsaW46OnByZXNldHM6OnVuaXZlcnNhbF9kZXBsb3llcjo6VW5pdmVyc2FsRGVwbG95ZXI6OkV2ZW50XCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGtpbmQ6IFwibmVzdGVkXCIsXG4gICAgICAgIG5hbWU6IFwiQ29udHJhY3REZXBsb3llZFwiLFxuICAgICAgICB0eXBlOiBcIm9wZW56ZXBwZWxpbjo6cHJlc2V0czo6dW5pdmVyc2FsX2RlcGxveWVyOjpVbml2ZXJzYWxEZXBsb3llcjo6Q29udHJhY3REZXBsb3llZFwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dO1xuXG4vLyBzcmMvaG9va3MvdXNlLWV2ZW50cy50c1xuaW1wb3J0IHtcbiAgQmxvY2tUYWcgYXMgQmxvY2tUYWc2LFxuICBoYXNoIGFzIGhhc2gyLFxuICBudW0gYXMgbnVtMlxufSBmcm9tIFwic3RhcmtuZXRcIjtcbnZhciBERUZBVUxUX1BBR0VfU0laRSA9IDU7XG5mdW5jdGlvbiB1c2VFdmVudHMoe1xuICBhZGRyZXNzLFxuICBldmVudE5hbWUsXG4gIGZyb21CbG9jazogZnJvbUJsb2NrXyxcbiAgdG9CbG9jazogdG9CbG9ja18sXG4gIHBhZ2VTaXplXG59KSB7XG4gIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHVzZVByb3ZpZGVyKCk7XG4gIGNvbnN0IHJwY1Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gIGNvbnN0IGtleUZpbHRlciA9IGV2ZW50TmFtZSA/IFtudW0yLnRvSGV4KGhhc2gyLnN0YXJrbmV0S2VjY2FrKGV2ZW50TmFtZSkpXSA6IFtdO1xuICBjb25zdCBrZXlzID0gW2tleUZpbHRlcl07XG4gIGNvbnN0IGZyb21CbG9jayA9IGZyb21CbG9ja18gPyBibG9ja0lkZW50aWZpZXJUb0Jsb2NrSWQoZnJvbUJsb2NrXykgOiB2b2lkIDA7XG4gIGNvbnN0IHRvQmxvY2sgPSB0b0Jsb2NrXyA/IGJsb2NrSWRlbnRpZmllclRvQmxvY2tJZCh0b0Jsb2NrXykgOiB2b2lkIDA7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHBhZ2VTaXplID8gcGFnZVNpemUgOiBERUZBVUxUX1BBR0VfU0laRTtcbiAgY29uc3QgZmV0Y2hFdmVudHMgPSBhc3luYyAoe1xuICAgIHBhZ2VQYXJhbVxuICB9KSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcnBjUHJvdmlkZXIuZ2V0RXZlbnRzKHtcbiAgICAgIGZyb21fYmxvY2s6IGZyb21CbG9jayxcbiAgICAgIHRvX2Jsb2NrOiB0b0Jsb2NrLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGtleXMsXG4gICAgICBjaHVua19zaXplOiBjaHVua1NpemUsXG4gICAgICBjb250aW51YXRpb25fdG9rZW46IHBhZ2VQYXJhbSA9PT0gXCIwXCIgPyB2b2lkIDAgOiBwYWdlUGFyYW1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZXR1cm4gdXNlSW5maW5pdGVRdWVyeSh7XG4gICAgLy8gVE9ETzogdXNlTWVtbyA/XG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5MTEoe1xuICAgICAgYWRkcmVzcyxcbiAgICAgIGV2ZW50TmFtZSxcbiAgICAgIGZyb21CbG9jazogZnJvbUJsb2NrXyxcbiAgICAgIHRvQmxvY2s6IHRvQmxvY2tfLFxuICAgICAgcGFnZVNpemVcbiAgICB9KSxcbiAgICBxdWVyeUZuOiBmZXRjaEV2ZW50cyxcbiAgICBpbml0aWFsUGFnZVBhcmFtOiBcIjBcIixcbiAgICBnZXROZXh0UGFnZVBhcmFtOiAobGFzdFBhZ2UsIHBhZ2VzKSA9PiBsYXN0UGFnZS5jb250aW51YXRpb25fdG9rZW5cbiAgfSk7XG59XG5mdW5jdGlvbiBxdWVyeUtleTExKHtcbiAgYWRkcmVzcyxcbiAgZXZlbnROYW1lLFxuICBmcm9tQmxvY2ssXG4gIHRvQmxvY2ssXG4gIHBhZ2VTaXplXG59KSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZW50aXR5OiBcImV2ZW50c1wiLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGV2ZW50TmFtZSxcbiAgICAgIGZyb21CbG9jayxcbiAgICAgIHRvQmxvY2ssXG4gICAgICBwYWdlU2l6ZVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGJsb2NrSWRlbnRpZmllclRvQmxvY2tJZChibG9ja0lkZW50aWZpZXIpIHtcbiAgaWYgKGJsb2NrSWRlbnRpZmllciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBCbG9ja1RhZzYuUEVORElORztcbiAgfVxuICBpZiAodHlwZW9mIGJsb2NrSWRlbnRpZmllciA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7IGJsb2NrX251bWJlcjogYmxvY2tJZGVudGlmaWVyIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBibG9ja0lkZW50aWZpZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYmxvY2tJZGVudGlmaWVyID09PSBcImxhdGVzdFwiIHx8IGJsb2NrSWRlbnRpZmllciA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHJldHVybiBibG9ja0lkZW50aWZpZXI7XG4gICAgfVxuICAgIHJldHVybiB7IGJsb2NrX2hhc2g6IGJsb2NrSWRlbnRpZmllciB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVW5zdXBwb3J0ZWQgQmxvY2tJZGVudGlmaWVyIHR5cGU6ICR7dHlwZW9mIGJsb2NrSWRlbnRpZmllcn1gXG4gICk7XG59XG5cbi8vIHNyYy9wcm92aWRlcnMvanNvbnJwYy50c1xuaW1wb3J0IHsgUnBjUHJvdmlkZXIgfSBmcm9tIFwic3RhcmtuZXRcIjtcbmZ1bmN0aW9uIGpzb25ScGNQcm92aWRlcih7XG4gIHJwY1xufSkge1xuICByZXR1cm4gKGNoYWluKSA9PiB7XG4gICAgY29uc3QgY29uZmlnID0gcnBjKGNoYWluKTtcbiAgICBpZiAoIWNvbmZpZykgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY2hhaW5JZCA9IHN0YXJrbmV0Q2hhaW5JZChjaGFpbi5pZCk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIoeyAuLi5jb25maWcsIGNoYWluSWQgfSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xuICB9O1xufVxuXG4vLyBzcmMvcHJvdmlkZXJzL3B1YmxpYy50c1xuZnVuY3Rpb24gcHVibGljUHJvdmlkZXIoKSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKGNoYWluKSA9PiB7XG4gICAgICBjb25zdCBycGNzID0gY2hhaW4ucnBjVXJscy5wdWJsaWMuaHR0cDtcbiAgICAgIGNvbnN0IG5vZGVVcmwgPSBycGNzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJwY3MubGVuZ3RoKV07XG4gICAgICBpZiAoIW5vZGVVcmwpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHsgbm9kZVVybCB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9wcm92aWRlcnMvYWxjaGVteS50c1xuZnVuY3Rpb24gYWxjaGVteVByb3ZpZGVyKHsgYXBpS2V5IH0pIHtcbiAgcmV0dXJuIGpzb25ScGNQcm92aWRlcih7XG4gICAgcnBjOiAoY2hhaW4pID0+IHtcbiAgICAgIGNvbnN0IGJhc2VIdHRwVXJsID0gY2hhaW4ucnBjVXJsc1tcImFsY2hlbXlcIl0/Lmh0dHBbMF07XG4gICAgICBpZiAoIWJhc2VIdHRwVXJsKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG5vZGVVcmwgPSBgJHtiYXNlSHR0cFVybH0vJHthcGlLZXl9YDtcbiAgICAgIHJldHVybiB7IG5vZGVVcmwgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXJzL2JsYXN0LnRzXG5mdW5jdGlvbiBibGFzdFByb3ZpZGVyKHsgYXBpS2V5IH0pIHtcbiAgcmV0dXJuIGpzb25ScGNQcm92aWRlcih7XG4gICAgcnBjOiAoY2hhaW4pID0+IHtcbiAgICAgIGNvbnN0IGJhc2VIdHRwVXJsID0gY2hhaW4ucnBjVXJsc1tcImJsYXN0XCJdPy5odHRwWzBdO1xuICAgICAgaWYgKCFiYXNlSHR0cFVybCkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBub2RlVXJsID0gYCR7YmFzZUh0dHBVcmx9LyR7YXBpS2V5fWA7XG4gICAgICByZXR1cm4geyBub2RlVXJsIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9jYXJ0cmlkZ2UudHNcbmZ1bmN0aW9uIGNhcnRyaWRnZVByb3ZpZGVyKCkge1xuICByZXR1cm4ganNvblJwY1Byb3ZpZGVyKHtcbiAgICBycGM6IChjaGFpbikgPT4ge1xuICAgICAgY29uc3Qgbm9kZVVybCA9IGNoYWluLnJwY1VybHNbXCJjYXJ0cmlkZ2VcIl0/Lmh0dHBbMF07XG4gICAgICBpZiAoIW5vZGVVcmwpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHsgbm9kZVVybCB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9wcm92aWRlcnMvaW5mdXJhLnRzXG5mdW5jdGlvbiBpbmZ1cmFQcm92aWRlcih7IGFwaUtleSB9KSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKGNoYWluKSA9PiB7XG4gICAgICBjb25zdCBiYXNlSHR0cFVybCA9IGNoYWluLnJwY1VybHNbXCJpbmZ1cmFcIl0/Lmh0dHBbMF07XG4gICAgICBpZiAoIWJhc2VIdHRwVXJsKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG5vZGVVcmwgPSBgJHtiYXNlSHR0cFVybH0vJHthcGlLZXl9YDtcbiAgICAgIHJldHVybiB7IG5vZGVVcmwgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXJzL2xhdmEudHNcbmZ1bmN0aW9uIGxhdmFQcm92aWRlcih7IGFwaUtleSB9KSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKGNoYWluKSA9PiB7XG4gICAgICBjb25zdCBiYXNlSHR0cFVybCA9IGNoYWluLnJwY1VybHNbXCJsYXZhXCJdPy5odHRwWzBdO1xuICAgICAgaWYgKCFiYXNlSHR0cFVybCkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBub2RlVXJsID0gYCR7YmFzZUh0dHBVcmx9LyR7YXBpS2V5fWA7XG4gICAgICByZXR1cm4geyBub2RlVXJsIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9uZXRoZXJtaW5kLnRzXG5mdW5jdGlvbiBuZXRoZXJtaW5kUHJvdmlkZXIoeyBhcGlLZXkgfSkge1xuICByZXR1cm4ganNvblJwY1Byb3ZpZGVyKHtcbiAgICBycGM6IChjaGFpbikgPT4ge1xuICAgICAgY29uc3QgYmFzZUh0dHBVcmwgPSBjaGFpbi5ycGNVcmxzW1wibmV0aGVybWluZFwiXT8uaHR0cFswXTtcbiAgICAgIGlmICghYmFzZUh0dHBVcmwpIHJldHVybiBudWxsO1xuICAgICAgY29uc3Qgbm9kZVVybCA9IGAke2Jhc2VIdHRwVXJsfS8/YXBpa2V5PSR7YXBpS2V5fWA7XG4gICAgICByZXR1cm4geyBub2RlVXJsIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9yZWRkaW8udHNcbmZ1bmN0aW9uIHJlZGRpb1Byb3ZpZGVyKHsgYXBpS2V5IH0pIHtcbiAgcmV0dXJuIGpzb25ScGNQcm92aWRlcih7XG4gICAgcnBjOiAoY2hhaW4pID0+IHtcbiAgICAgIGNvbnN0IGJhc2VIdHRwVXJsID0gY2hhaW4ucnBjVXJsc1tcInJlZGRpb1wiXT8uaHR0cFswXTtcbiAgICAgIGlmICghYmFzZUh0dHBVcmwpIHJldHVybiBudWxsO1xuICAgICAgY29uc3Qgbm9kZVVybCA9IGAke2Jhc2VIdHRwVXJsfS8ke2FwaUtleX1gO1xuICAgICAgcmV0dXJuIHsgbm9kZVVybCB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9wcm92aWRlcnMvc2xvdC50c1xuaW1wb3J0IHsgZ2V0U2xvdENoYWluIH0gZnJvbSBcIkBzdGFya25ldC1yZWFjdC9jaGFpbnNcIjtcbmZ1bmN0aW9uIHNsb3RQcm92aWRlcih7IHByb2plY3RJZCB9KSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKCkgPT4ge1xuICAgICAgY29uc3QgY2hhaW4gPSBnZXRTbG90Q2hhaW4ocHJvamVjdElkKTtcbiAgICAgIGNvbnN0IG5vZGVVcmwgPSBjaGFpbi5ycGNVcmxzLnB1YmxpYy5odHRwWzBdO1xuICAgICAgcmV0dXJuIHsgbm9kZVVybCB9O1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnQge1xuICBDb25uZWN0b3IsXG4gIENvbm5lY3RvckFscmVhZHlDb25uZWN0ZWRFcnJvcixcbiAgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IsXG4gIENvbm5lY3Rvck5vdEZvdW5kRXJyb3IsXG4gIEluamVjdGVkQ29ubmVjdG9yLFxuICBMZWdhY3lJbmplY3RlZENvbm5lY3RvcixcbiAgTW9ja0Nvbm5lY3RvcixcbiAgQWNjb3VudFByb3ZpZGVyIGFzIE92ZXJyaWRlQWNjb3VudCxcbiAgU3RhcmtuZXRDb25maWcsXG4gIFN0YXJrc2NhbkV4cGxvcmVyLFxuICBVbnN1cHBvcnRlZEFjY291bnRJbnRlcmZhY2VFcnJvcixcbiAgVXNlck5vdENvbm5lY3RlZEVycm9yLFxuICBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsXG4gIFZpZXdibG9ja0V4cGxvcmVyLFxuICBWb3lhZ2VyRXhwbG9yZXIsXG4gIGFsY2hlbXlQcm92aWRlcixcbiAgYXJnZW50LFxuICBibGFzdFByb3ZpZGVyLFxuICBicmFhdm9zLFxuICBjYXJ0cmlkZ2VQcm92aWRlcixcbiAgZ2V0QWRkcmVzcyxcbiAgaW5mdXJhUHJvdmlkZXIsXG4gIGluamVjdGVkLFxuICBqc29uUnBjUHJvdmlkZXIsXG4gIGxhdmFQcm92aWRlcixcbiAgbGVnYWN5SW5qZWN0ZWQsXG4gIG5ldGhlcm1pbmRQcm92aWRlcixcbiAgcHVibGljUHJvdmlkZXIsXG4gIHJlZGRpb1Byb3ZpZGVyLFxuICBzbG90UHJvdmlkZXIsXG4gIHN0YXJrbmV0Q2hhaW5JZCxcbiAgc3RhcmtzY2FuLFxuICB1c2VBY2NvdW50LFxuICB1c2VBZGRDaGFpbixcbiAgdXNlQmFsYW5jZSxcbiAgdXNlQmxvY2ssXG4gIHVzZUJsb2NrTnVtYmVyLFxuICB1c2VDYWxsLFxuICB1c2VDb25uZWN0LFxuICB1c2VDb250cmFjdCxcbiAgdXNlQ29udHJhY3RGYWN0b3J5LFxuICB1c2VEZWNsYXJlQ29udHJhY3QsXG4gIHVzZURlcGxveUFjY291bnQsXG4gIHVzZURpc2Nvbm5lY3QsXG4gIHVzZUVzdGltYXRlRmVlcyxcbiAgdXNlRXZlbnRzLFxuICB1c2VFeHBsb3JlcixcbiAgdXNlSW5qZWN0ZWRDb25uZWN0b3JzLFxuICB1c2VJbnZhbGlkYXRlT25CbG9jayxcbiAgdXNlTmV0d29yayxcbiAgdXNlTm9uY2VGb3JBZGRyZXNzLFxuICB1c2VQcm92aWRlcixcbiAgdXNlUmVhZENvbnRyYWN0LFxuICB1c2VTZW5kVHJhbnNhY3Rpb24sXG4gIHVzZVNpZ25UeXBlZERhdGEsXG4gIHVzZVN0YXJrQWRkcmVzcyxcbiAgdXNlU3RhcmtOYW1lLFxuICB1c2VTdGFya1Byb2ZpbGUsXG4gIHVzZVN3aXRjaENoYWluLFxuICB1c2VUcmFuc2FjdGlvblJlY2VpcHQsXG4gIHVzZVVuaXZlcnNhbERlcGxveWVyQ29udHJhY3QsXG4gIHVzZVdhbGxldFJlcXVlc3QsXG4gIHVzZVdhdGNoQXNzZXQsXG4gIHZpZXdibG9jayxcbiAgdm95YWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@starknet-react/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/focusManager.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusManager: () => (/* binding */ FocusManager),\n/* harmony export */   focusManager: () => (/* binding */ focusManager)\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/focusManager.ts\n\n\nvar FocusManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\n\n//# sourceMappingURL=focusManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vZm9jdXNNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNpRDtBQUNYO0FBQ3RDLGlDQUFpQywwREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vZm9jdXNNYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9mb2N1c01hbmFnZXIudHNcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gXCIuL3N1YnNjcmliYWJsZS5qc1wiO1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xudmFyIEZvY3VzTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgI2ZvY3VzZWQ7XG4gICNjbGVhbnVwO1xuICAjc2V0dXA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jc2V0dXAgPSAob25Gb2N1cykgPT4ge1xuICAgICAgaWYgKCFpc1NlcnZlciAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IG9uRm9jdXMoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIG9uU3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy4jY2xlYW51cCkge1xuICAgICAgdGhpcy5zZXRFdmVudExpc3RlbmVyKHRoaXMuI3NldHVwKTtcbiAgICB9XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgICAgdGhpcy4jY2xlYW51cCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2V0RXZlbnRMaXN0ZW5lcihzZXR1cCkge1xuICAgIHRoaXMuI3NldHVwID0gc2V0dXA7XG4gICAgdGhpcy4jY2xlYW51cD8uKCk7XG4gICAgdGhpcy4jY2xlYW51cCA9IHNldHVwKChmb2N1c2VkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZvY3VzZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXNlZChmb2N1c2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25Gb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldEZvY3VzZWQoZm9jdXNlZCkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLiNmb2N1c2VkICE9PSBmb2N1c2VkO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNmb2N1c2VkID0gZm9jdXNlZDtcbiAgICAgIHRoaXMub25Gb2N1cygpO1xuICAgIH1cbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIGNvbnN0IGlzRm9jdXNlZCA9IHRoaXMuaXNGb2N1c2VkKCk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgIGxpc3RlbmVyKGlzRm9jdXNlZCk7XG4gICAgfSk7XG4gIH1cbiAgaXNGb2N1c2VkKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy4jZm9jdXNlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNmb2N1c2VkO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5kb2N1bWVudD8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiO1xuICB9XG59O1xudmFyIGZvY3VzTWFuYWdlciA9IG5ldyBGb2N1c01hbmFnZXIoKTtcbmV4cG9ydCB7XG4gIEZvY3VzTWFuYWdlcixcbiAgZm9jdXNNYW5hZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNNYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasNextPage: () => (/* binding */ hasNextPage),\n/* harmony export */   hasPreviousPage: () => (/* binding */ hasPreviousPage),\n/* harmony export */   infiniteQueryBehavior: () => (/* binding */ infiniteQueryBehavior)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/infiniteQueryBehavior.ts\n\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = { pages: [], pageParams: [] };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureQueryFn)(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            client: context.client,\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(\n            queryFnContext\n          );\n          const { maxPages } = context.options;\n          const addTo = previous ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToStart : _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data)\n    return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam)\n    return false;\n  return getPreviousPageParam(options, data) != null;\n}\n\n//# sourceMappingURL=infiniteQueryBehavior.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vaW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx3QkFBd0Isd0RBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0IsbUNBQW1DLGlEQUFVLEdBQUcsK0NBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vaW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IudHNcbmltcG9ydCB7IGFkZFRvRW5kLCBhZGRUb1N0YXJ0LCBlbnN1cmVRdWVyeUZuIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIGluZmluaXRlUXVlcnlCZWhhdmlvcihwYWdlcykge1xuICByZXR1cm4ge1xuICAgIG9uRmV0Y2g6IChjb250ZXh0LCBxdWVyeSkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNvbnRleHQuZmV0Y2hPcHRpb25zPy5tZXRhPy5mZXRjaE1vcmU/LmRpcmVjdGlvbjtcbiAgICAgIGNvbnN0IG9sZFBhZ2VzID0gY29udGV4dC5zdGF0ZS5kYXRhPy5wYWdlcyB8fCBbXTtcbiAgICAgIGNvbnN0IG9sZFBhZ2VQYXJhbXMgPSBjb250ZXh0LnN0YXRlLmRhdGE/LnBhZ2VQYXJhbXMgfHwgW107XG4gICAgICBsZXQgcmVzdWx0ID0geyBwYWdlczogW10sIHBhZ2VQYXJhbXM6IFtdIH07XG4gICAgICBsZXQgY3VycmVudFBhZ2UgPSAwO1xuICAgICAgY29uc3QgZmV0Y2hGbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhZGRTaWduYWxQcm9wZXJ0eSA9IChvYmplY3QpID0+IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcInNpZ25hbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5zaWduYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHF1ZXJ5Rm4gPSBlbnN1cmVRdWVyeUZuKGNvbnRleHQub3B0aW9ucywgY29udGV4dC5mZXRjaE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmZXRjaFBhZ2UgPSBhc3luYyAoZGF0YSwgcGFyYW0sIHByZXZpb3VzKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhbSA9PSBudWxsICYmIGRhdGEucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBxdWVyeUZuQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGNsaWVudDogY29udGV4dC5jbGllbnQsXG4gICAgICAgICAgICBxdWVyeUtleTogY29udGV4dC5xdWVyeUtleSxcbiAgICAgICAgICAgIHBhZ2VQYXJhbTogcGFyYW0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IHByZXZpb3VzID8gXCJiYWNrd2FyZFwiIDogXCJmb3J3YXJkXCIsXG4gICAgICAgICAgICBtZXRhOiBjb250ZXh0Lm9wdGlvbnMubWV0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWRkU2lnbmFsUHJvcGVydHkocXVlcnlGbkNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBxdWVyeUZuKFxuICAgICAgICAgICAgcXVlcnlGbkNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHsgbWF4UGFnZXMgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCBhZGRUbyA9IHByZXZpb3VzID8gYWRkVG9TdGFydCA6IGFkZFRvRW5kO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlczogYWRkVG8oZGF0YS5wYWdlcywgcGFnZSwgbWF4UGFnZXMpLFxuICAgICAgICAgICAgcGFnZVBhcmFtczogYWRkVG8oZGF0YS5wYWdlUGFyYW1zLCBwYXJhbSwgbWF4UGFnZXMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmJiBvbGRQYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiO1xuICAgICAgICAgIGNvbnN0IHBhZ2VQYXJhbUZuID0gcHJldmlvdXMgPyBnZXRQcmV2aW91c1BhZ2VQYXJhbSA6IGdldE5leHRQYWdlUGFyYW07XG4gICAgICAgICAgY29uc3Qgb2xkRGF0YSA9IHtcbiAgICAgICAgICAgIHBhZ2VzOiBvbGRQYWdlcyxcbiAgICAgICAgICAgIHBhZ2VQYXJhbXM6IG9sZFBhZ2VQYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHBhcmFtID0gcGFnZVBhcmFtRm4ob3B0aW9ucywgb2xkRGF0YSk7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKG9sZERhdGEsIHBhcmFtLCBwcmV2aW91cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nUGFnZXMgPSBwYWdlcyA/PyBvbGRQYWdlcy5sZW5ndGg7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBjdXJyZW50UGFnZSA9PT0gMCA/IG9sZFBhZ2VQYXJhbXNbMF0gPz8gb3B0aW9ucy5pbml0aWFsUGFnZVBhcmFtIDogZ2V0TmV4dFBhZ2VQYXJhbShvcHRpb25zLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYWdlID4gMCAmJiBwYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKHJlc3VsdCwgcGFyYW0pO1xuICAgICAgICAgICAgY3VycmVudFBhZ2UrKztcbiAgICAgICAgICB9IHdoaWxlIChjdXJyZW50UGFnZSA8IHJlbWFpbmluZ1BhZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMucGVyc2lzdGVyKSB7XG4gICAgICAgIGNvbnRleHQuZmV0Y2hGbiA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5vcHRpb25zLnBlcnNpc3Rlcj8uKFxuICAgICAgICAgICAgZmV0Y2hGbixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xpZW50OiBjb250ZXh0LmNsaWVudCxcbiAgICAgICAgICAgICAgcXVlcnlLZXk6IGNvbnRleHQucXVlcnlLZXksXG4gICAgICAgICAgICAgIG1ldGE6IGNvbnRleHQub3B0aW9ucy5tZXRhLFxuICAgICAgICAgICAgICBzaWduYWw6IGNvbnRleHQuc2lnbmFsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5mZXRjaEZuID0gZmV0Y2hGbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIHsgcGFnZXMsIHBhZ2VQYXJhbXMgfSkge1xuICBjb25zdCBsYXN0SW5kZXggPSBwYWdlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gcGFnZXMubGVuZ3RoID4gMCA/IG9wdGlvbnMuZ2V0TmV4dFBhZ2VQYXJhbShcbiAgICBwYWdlc1tsYXN0SW5kZXhdLFxuICAgIHBhZ2VzLFxuICAgIHBhZ2VQYXJhbXNbbGFzdEluZGV4XSxcbiAgICBwYWdlUGFyYW1zXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCB7IHBhZ2VzLCBwYWdlUGFyYW1zIH0pIHtcbiAgcmV0dXJuIHBhZ2VzLmxlbmd0aCA+IDAgPyBvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtPy4ocGFnZXNbMF0sIHBhZ2VzLCBwYWdlUGFyYW1zWzBdLCBwYWdlUGFyYW1zKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGhhc05leHRQYWdlKG9wdGlvbnMsIGRhdGEpIHtcbiAgaWYgKCFkYXRhKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGdldE5leHRQYWdlUGFyYW0ob3B0aW9ucywgZGF0YSkgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhc1ByZXZpb3VzUGFnZShvcHRpb25zLCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhb3B0aW9ucy5nZXRQcmV2aW91c1BhZ2VQYXJhbSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCBkYXRhKSAhPSBudWxsO1xufVxuZXhwb3J0IHtcbiAgaGFzTmV4dFBhZ2UsXG4gIGhhc1ByZXZpb3VzUGFnZSxcbiAgaW5maW5pdGVRdWVyeUJlaGF2aW9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfiniteQueryObserver: () => (/* binding */ InfiniteQueryObserver)\n/* harmony export */ });\n/* harmony import */ var _queryObserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queryObserver.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryObserver.js\");\n/* harmony import */ var _infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./infiniteQueryBehavior.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\");\n// src/infiniteQueryObserver.ts\n\n\nvar InfiniteQueryObserver = class extends _queryObserver_js__WEBPACK_IMPORTED_MODULE_0__.QueryObserver {\n  constructor(client, options) {\n    super(client, options);\n  }\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n  setOptions(options, notifyOptions) {\n    super.setOptions(\n      {\n        ...options,\n        behavior: (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_1__.infiniteQueryBehavior)()\n      },\n      notifyOptions\n    );\n  }\n  getOptimisticResult(options) {\n    options.behavior = (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_1__.infiniteQueryBehavior)();\n    return super.getOptimisticResult(options);\n  }\n  fetchNextPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"forward\" }\n      }\n    });\n  }\n  fetchPreviousPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"backward\" }\n      }\n    });\n  }\n  createResult(query, options) {\n    const { state } = query;\n    const parentResult = super.createResult(query, options);\n    const { isFetching, isRefetching, isError, isRefetchError } = parentResult;\n    const fetchDirection = state.fetchMeta?.fetchMore?.direction;\n    const isFetchNextPageError = isError && fetchDirection === \"forward\";\n    const isFetchingNextPage = isFetching && fetchDirection === \"forward\";\n    const isFetchPreviousPageError = isError && fetchDirection === \"backward\";\n    const isFetchingPreviousPage = isFetching && fetchDirection === \"backward\";\n    const result = {\n      ...parentResult,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_1__.hasNextPage)(options, state.data),\n      hasPreviousPage: (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_1__.hasPreviousPage)(options, state.data),\n      isFetchNextPageError,\n      isFetchingNextPage,\n      isFetchPreviousPageError,\n      isFetchingPreviousPage,\n      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n    return result;\n  }\n};\n\n//# sourceMappingURL=infiniteQueryObserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vaW5maW5pdGVRdWVyeU9ic2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ21EO0FBS2Y7QUFDcEMsMENBQTBDLDREQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRkFBcUI7QUFDdkMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdGQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNFQUFXO0FBQzlCLHVCQUF1QiwwRUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL2luZmluaXRlUXVlcnlPYnNlcnZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5maW5pdGVRdWVyeU9ic2VydmVyLnRzXG5pbXBvcnQgeyBRdWVyeU9ic2VydmVyIH0gZnJvbSBcIi4vcXVlcnlPYnNlcnZlci5qc1wiO1xuaW1wb3J0IHtcbiAgaGFzTmV4dFBhZ2UsXG4gIGhhc1ByZXZpb3VzUGFnZSxcbiAgaW5maW5pdGVRdWVyeUJlaGF2aW9yXG59IGZyb20gXCIuL2luZmluaXRlUXVlcnlCZWhhdmlvci5qc1wiO1xudmFyIEluZmluaXRlUXVlcnlPYnNlcnZlciA9IGNsYXNzIGV4dGVuZHMgUXVlcnlPYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucykge1xuICAgIHN1cGVyKGNsaWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgYmluZE1ldGhvZHMoKSB7XG4gICAgc3VwZXIuYmluZE1ldGhvZHMoKTtcbiAgICB0aGlzLmZldGNoTmV4dFBhZ2UgPSB0aGlzLmZldGNoTmV4dFBhZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLmZldGNoUHJldmlvdXNQYWdlID0gdGhpcy5mZXRjaFByZXZpb3VzUGFnZS5iaW5kKHRoaXMpO1xuICB9XG4gIHNldE9wdGlvbnMob3B0aW9ucywgbm90aWZ5T3B0aW9ucykge1xuICAgIHN1cGVyLnNldE9wdGlvbnMoXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGJlaGF2aW9yOiBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IoKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU9wdGlvbnNcbiAgICApO1xuICB9XG4gIGdldE9wdGltaXN0aWNSZXN1bHQob3B0aW9ucykge1xuICAgIG9wdGlvbnMuYmVoYXZpb3IgPSBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IoKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0T3B0aW1pc3RpY1Jlc3VsdChvcHRpb25zKTtcbiAgfVxuICBmZXRjaE5leHRQYWdlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbWV0YToge1xuICAgICAgICBmZXRjaE1vcmU6IHsgZGlyZWN0aW9uOiBcImZvcndhcmRcIiB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2hQcmV2aW91c1BhZ2Uob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIGZldGNoTW9yZTogeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUmVzdWx0KHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gcXVlcnk7XG4gICAgY29uc3QgcGFyZW50UmVzdWx0ID0gc3VwZXIuY3JlYXRlUmVzdWx0KHF1ZXJ5LCBvcHRpb25zKTtcbiAgICBjb25zdCB7IGlzRmV0Y2hpbmcsIGlzUmVmZXRjaGluZywgaXNFcnJvciwgaXNSZWZldGNoRXJyb3IgfSA9IHBhcmVudFJlc3VsdDtcbiAgICBjb25zdCBmZXRjaERpcmVjdGlvbiA9IHN0YXRlLmZldGNoTWV0YT8uZmV0Y2hNb3JlPy5kaXJlY3Rpb247XG4gICAgY29uc3QgaXNGZXRjaE5leHRQYWdlRXJyb3IgPSBpc0Vycm9yICYmIGZldGNoRGlyZWN0aW9uID09PSBcImZvcndhcmRcIjtcbiAgICBjb25zdCBpc0ZldGNoaW5nTmV4dFBhZ2UgPSBpc0ZldGNoaW5nICYmIGZldGNoRGlyZWN0aW9uID09PSBcImZvcndhcmRcIjtcbiAgICBjb25zdCBpc0ZldGNoUHJldmlvdXNQYWdlRXJyb3IgPSBpc0Vycm9yICYmIGZldGNoRGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCI7XG4gICAgY29uc3QgaXNGZXRjaGluZ1ByZXZpb3VzUGFnZSA9IGlzRmV0Y2hpbmcgJiYgZmV0Y2hEaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIjtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAuLi5wYXJlbnRSZXN1bHQsXG4gICAgICBmZXRjaE5leHRQYWdlOiB0aGlzLmZldGNoTmV4dFBhZ2UsXG4gICAgICBmZXRjaFByZXZpb3VzUGFnZTogdGhpcy5mZXRjaFByZXZpb3VzUGFnZSxcbiAgICAgIGhhc05leHRQYWdlOiBoYXNOZXh0UGFnZShvcHRpb25zLCBzdGF0ZS5kYXRhKSxcbiAgICAgIGhhc1ByZXZpb3VzUGFnZTogaGFzUHJldmlvdXNQYWdlKG9wdGlvbnMsIHN0YXRlLmRhdGEpLFxuICAgICAgaXNGZXRjaE5leHRQYWdlRXJyb3IsXG4gICAgICBpc0ZldGNoaW5nTmV4dFBhZ2UsXG4gICAgICBpc0ZldGNoUHJldmlvdXNQYWdlRXJyb3IsXG4gICAgICBpc0ZldGNoaW5nUHJldmlvdXNQYWdlLFxuICAgICAgaXNSZWZldGNoRXJyb3I6IGlzUmVmZXRjaEVycm9yICYmICFpc0ZldGNoTmV4dFBhZ2VFcnJvciAmJiAhaXNGZXRjaFByZXZpb3VzUGFnZUVycm9yLFxuICAgICAgaXNSZWZldGNoaW5nOiBpc1JlZmV0Y2hpbmcgJiYgIWlzRmV0Y2hpbmdOZXh0UGFnZSAmJiAhaXNGZXRjaGluZ1ByZXZpb3VzUGFnZVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEluZmluaXRlUXVlcnlPYnNlcnZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmluaXRlUXVlcnlPYnNlcnZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mutation: () => (/* binding */ Mutation),\n/* harmony export */   getDefaultState: () => (/* binding */ getDefaultState)\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\");\n// src/mutation.ts\n\n\n\nvar Mutation = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #observers;\n  #mutationCache;\n  #retryer;\n  constructor(config) {\n    super();\n    this.mutationId = config.mutationId;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  setOptions(options) {\n    this.options = options;\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter((x) => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: \"observerRemoved\",\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === \"pending\") {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  async execute(variables) {\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_1__.createRetryer)({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error(\"No mutationFn found\"));\n        }\n        return this.options.mutationFn(variables);\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this)\n    });\n    const restored = this.state.status === \"pending\";\n    const isPaused = !this.#retryer.canStart();\n    try {\n      if (!restored) {\n        this.#dispatch({ type: \"pending\", variables, isPaused });\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this\n        );\n        const context = await this.options.onMutate?.(variables);\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: \"pending\",\n            context,\n            variables,\n            isPaused\n          });\n        }\n      }\n      const data = await this.#retryer.start();\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSuccess?.(data, variables, this.state.context);\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSettled?.(data, null, variables, this.state.context);\n      this.#dispatch({ type: \"success\", data });\n      return data;\n    } catch (error) {\n      try {\n        await this.#mutationCache.config.onError?.(\n          error,\n          variables,\n          this.state.context,\n          this\n        );\n        await this.options.onError?.(\n          error,\n          variables,\n          this.state.context\n        );\n        await this.#mutationCache.config.onSettled?.(\n          void 0,\n          error,\n          this.state.variables,\n          this.state.context,\n          this\n        );\n        await this.options.onSettled?.(\n          void 0,\n          error,\n          variables,\n          this.state.context\n        );\n        throw error;\n      } finally {\n        this.#dispatch({ type: \"error\", error });\n      }\n    } finally {\n      this.#mutationCache.runNext(this);\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            isPaused: true\n          };\n        case \"continue\":\n          return {\n            ...state,\n            isPaused: false\n          };\n        case \"pending\":\n          return {\n            ...state,\n            context: action.context,\n            data: void 0,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: \"pending\",\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: \"success\",\n            isPaused: false\n          };\n        case \"error\":\n          return {\n            ...state,\n            data: void 0,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: \"error\"\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState() {\n  return {\n    context: void 0,\n    data: void 0,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: \"idle\",\n    variables: void 0,\n    submittedAt: 0\n  };\n}\n\n//# sourceMappingURL=mutation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNtRDtBQUNSO0FBQ0U7QUFDN0MsNkJBQTZCLG9EQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEMsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0NBQXNDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL211dGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9tdXRhdGlvbi50c1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IFJlbW92YWJsZSB9IGZyb20gXCIuL3JlbW92YWJsZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlUmV0cnllciB9IGZyb20gXCIuL3JldHJ5ZXIuanNcIjtcbnZhciBNdXRhdGlvbiA9IGNsYXNzIGV4dGVuZHMgUmVtb3ZhYmxlIHtcbiAgI29ic2VydmVycztcbiAgI211dGF0aW9uQ2FjaGU7XG4gICNyZXRyeWVyO1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubXV0YXRpb25JZCA9IGNvbmZpZy5tdXRhdGlvbklkO1xuICAgIHRoaXMuI211dGF0aW9uQ2FjaGUgPSBjb25maWcubXV0YXRpb25DYWNoZTtcbiAgICB0aGlzLiNvYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0gY29uZmlnLnN0YXRlIHx8IGdldERlZmF1bHRTdGF0ZSgpO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnVwZGF0ZUdjVGltZSh0aGlzLm9wdGlvbnMuZ2NUaW1lKTtcbiAgfVxuICBnZXQgbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1ldGE7XG4gIH1cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICBpZiAoIXRoaXMuI29ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMuI29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgICAgIHRoaXMuI211dGF0aW9uQ2FjaGUubm90aWZ5KHtcbiAgICAgICAgdHlwZTogXCJvYnNlcnZlckFkZGVkXCIsXG4gICAgICAgIG11dGF0aW9uOiB0aGlzLFxuICAgICAgICBvYnNlcnZlclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgdGhpcy4jb2JzZXJ2ZXJzID0gdGhpcy4jb2JzZXJ2ZXJzLmZpbHRlcigoeCkgPT4geCAhPT0gb2JzZXJ2ZXIpO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICAgIHRoaXMuI211dGF0aW9uQ2FjaGUubm90aWZ5KHtcbiAgICAgIHR5cGU6IFwib2JzZXJ2ZXJSZW1vdmVkXCIsXG4gICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgIG9ic2VydmVyXG4gICAgfSk7XG4gIH1cbiAgb3B0aW9uYWxSZW1vdmUoKSB7XG4gICAgaWYgKCF0aGlzLiNvYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jbXV0YXRpb25DYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnRpbnVlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZXRyeWVyPy5jb250aW51ZSgpID8/IC8vIGNvbnRpbnVpbmcgYSBtdXRhdGlvbiBhc3N1bWVzIHRoYXQgdmFyaWFibGVzIGFyZSBzZXQsIG11dGF0aW9uIG11c3QgaGF2ZSBiZWVuIGRlaHlkcmF0ZWQgYmVmb3JlXG4gICAgdGhpcy5leGVjdXRlKHRoaXMuc3RhdGUudmFyaWFibGVzKTtcbiAgfVxuICBhc3luYyBleGVjdXRlKHZhcmlhYmxlcykge1xuICAgIHRoaXMuI3JldHJ5ZXIgPSBjcmVhdGVSZXRyeWVyKHtcbiAgICAgIGZuOiAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11dGF0aW9uRm4pIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gbXV0YXRpb25GbiBmb3VuZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tdXRhdGlvbkZuKHZhcmlhYmxlcyk7XG4gICAgICB9LFxuICAgICAgb25GYWlsOiAoZmFpbHVyZUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiZmFpbGVkXCIsIGZhaWx1cmVDb3VudCwgZXJyb3IgfSk7XG4gICAgICB9LFxuICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwicGF1c2VcIiB9KTtcbiAgICAgIH0sXG4gICAgICBvbkNvbnRpbnVlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJjb250aW51ZVwiIH0pO1xuICAgICAgfSxcbiAgICAgIHJldHJ5OiB0aGlzLm9wdGlvbnMucmV0cnkgPz8gMCxcbiAgICAgIHJldHJ5RGVsYXk6IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5LFxuICAgICAgbmV0d29ya01vZGU6IHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZSxcbiAgICAgIGNhblJ1bjogKCkgPT4gdGhpcy4jbXV0YXRpb25DYWNoZS5jYW5SdW4odGhpcylcbiAgICB9KTtcbiAgICBjb25zdCByZXN0b3JlZCA9IHRoaXMuc3RhdGUuc3RhdHVzID09PSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCBpc1BhdXNlZCA9ICF0aGlzLiNyZXRyeWVyLmNhblN0YXJ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcmVzdG9yZWQpIHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInBlbmRpbmdcIiwgdmFyaWFibGVzLCBpc1BhdXNlZCB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25NdXRhdGU/LihcbiAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5vcHRpb25zLm9uTXV0YXRlPy4odmFyaWFibGVzKTtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHRoaXMuc3RhdGUuY29udGV4dCkge1xuICAgICAgICAgIHRoaXMuI2Rpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgIGlzUGF1c2VkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNyZXRyeWVyLnN0YXJ0KCk7XG4gICAgICBhd2FpdCB0aGlzLiNtdXRhdGlvbkNhY2hlLmNvbmZpZy5vblN1Y2Nlc3M/LihcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMub25TdWNjZXNzPy4oZGF0YSwgdmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQpO1xuICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMuc3RhdGUudmFyaWFibGVzLFxuICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMub25TZXR0bGVkPy4oZGF0YSwgbnVsbCwgdmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInN1Y2Nlc3NcIiwgZGF0YSB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLiNtdXRhdGlvbkNhY2hlLmNvbmZpZy5vbkVycm9yPy4oXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy5vbkVycm9yPy4oXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLiNtdXRhdGlvbkNhY2hlLmNvbmZpZy5vblNldHRsZWQ/LihcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhpcy5zdGF0ZS52YXJpYWJsZXMsXG4gICAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0LFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uU2V0dGxlZD8uKFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0XG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLnJ1bk5leHQodGhpcyk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBjb25zdCByZWR1Y2VyID0gKHN0YXRlKSA9PiB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IGFjdGlvbi5mYWlsdXJlQ291bnQsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicGF1c2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc1BhdXNlZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgY29udGV4dDogYWN0aW9uLmNvbnRleHQsXG4gICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc1BhdXNlZDogYWN0aW9uLmlzUGF1c2VkLFxuICAgICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIHZhcmlhYmxlczogYWN0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHN1Ym1pdHRlZEF0OiBEYXRlLm5vdygpXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICAgICAgICAgIGZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiBzdGF0ZS5mYWlsdXJlQ291bnQgKyAxLFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCJcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHJlZHVjZXIodGhpcy5zdGF0ZSk7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLiNvYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIub25NdXRhdGlvblVwZGF0ZShhY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICAgIG11dGF0aW9uOiB0aGlzLFxuICAgICAgICB0eXBlOiBcInVwZGF0ZWRcIixcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiB2b2lkIDAsXG4gICAgZGF0YTogdm9pZCAwLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICBzdGF0dXM6IFwiaWRsZVwiLFxuICAgIHZhcmlhYmxlczogdm9pZCAwLFxuICAgIHN1Ym1pdHRlZEF0OiAwXG4gIH07XG59XG5leHBvcnQge1xuICBNdXRhdGlvbixcbiAgZ2V0RGVmYXVsdFN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV0YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutationCache.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MutationCache: () => (/* binding */ MutationCache)\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _mutation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutation.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/mutationCache.ts\n\n\n\n\nvar MutationCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new _mutation_js__WEBPACK_IMPORTED_MODULE_1__.Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(filters, mutation));\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(_utils_js__WEBPACK_IMPORTED_MODULE_3__.noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\n\n//# sourceMappingURL=mutationCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb25DYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ21EO0FBQ1Y7QUFDUTtBQUNBO0FBQ2pELGtDQUFrQywwREFBWTtBQUM5Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0Esb0JBQW9CLHdEQUFhO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQWE7QUFDeEI7QUFDQSxvRUFBb0UsMkNBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9tdXRhdGlvbkNhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9tdXRhdGlvbkNhY2hlLnRzXG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSBcIi4vbm90aWZ5TWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgTXV0YXRpb24gfSBmcm9tIFwiLi9tdXRhdGlvbi5qc1wiO1xuaW1wb3J0IHsgbWF0Y2hNdXRhdGlvbiwgbm9vcCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbnZhciBNdXRhdGlvbkNhY2hlID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy4jbXV0YXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLiNzY29wZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuI211dGF0aW9uSWQgPSAwO1xuICB9XG4gICNtdXRhdGlvbnM7XG4gICNzY29wZXM7XG4gICNtdXRhdGlvbklkO1xuICBidWlsZChjbGllbnQsIG9wdGlvbnMsIHN0YXRlKSB7XG4gICAgY29uc3QgbXV0YXRpb24gPSBuZXcgTXV0YXRpb24oe1xuICAgICAgbXV0YXRpb25DYWNoZTogdGhpcyxcbiAgICAgIG11dGF0aW9uSWQ6ICsrdGhpcy4jbXV0YXRpb25JZCxcbiAgICAgIG9wdGlvbnM6IGNsaWVudC5kZWZhdWx0TXV0YXRpb25PcHRpb25zKG9wdGlvbnMpLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICB0aGlzLmFkZChtdXRhdGlvbik7XG4gICAgcmV0dXJuIG11dGF0aW9uO1xuICB9XG4gIGFkZChtdXRhdGlvbikge1xuICAgIHRoaXMuI211dGF0aW9ucy5hZGQobXV0YXRpb24pO1xuICAgIGNvbnN0IHNjb3BlID0gc2NvcGVGb3IobXV0YXRpb24pO1xuICAgIGlmICh0eXBlb2Ygc2NvcGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHNjb3BlZE11dGF0aW9ucyA9IHRoaXMuI3Njb3Blcy5nZXQoc2NvcGUpO1xuICAgICAgaWYgKHNjb3BlZE11dGF0aW9ucykge1xuICAgICAgICBzY29wZWRNdXRhdGlvbnMucHVzaChtdXRhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNzY29wZXMuc2V0KHNjb3BlLCBbbXV0YXRpb25dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ub3RpZnkoeyB0eXBlOiBcImFkZGVkXCIsIG11dGF0aW9uIH0pO1xuICB9XG4gIHJlbW92ZShtdXRhdGlvbikge1xuICAgIGlmICh0aGlzLiNtdXRhdGlvbnMuZGVsZXRlKG11dGF0aW9uKSkge1xuICAgICAgY29uc3Qgc2NvcGUgPSBzY29wZUZvcihtdXRhdGlvbik7XG4gICAgICBpZiAodHlwZW9mIHNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZE11dGF0aW9ucyA9IHRoaXMuI3Njb3Blcy5nZXQoc2NvcGUpO1xuICAgICAgICBpZiAoc2NvcGVkTXV0YXRpb25zKSB7XG4gICAgICAgICAgaWYgKHNjb3BlZE11dGF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNjb3BlZE11dGF0aW9ucy5pbmRleE9mKG11dGF0aW9uKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc2NvcGVkTXV0YXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzY29wZWRNdXRhdGlvbnNbMF0gPT09IG11dGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLiNzY29wZXMuZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ub3RpZnkoeyB0eXBlOiBcInJlbW92ZWRcIiwgbXV0YXRpb24gfSk7XG4gIH1cbiAgY2FuUnVuKG11dGF0aW9uKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBzY29wZUZvcihtdXRhdGlvbik7XG4gICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgbXV0YXRpb25zV2l0aFNhbWVTY29wZSA9IHRoaXMuI3Njb3Blcy5nZXQoc2NvcGUpO1xuICAgICAgY29uc3QgZmlyc3RQZW5kaW5nTXV0YXRpb24gPSBtdXRhdGlvbnNXaXRoU2FtZVNjb3BlPy5maW5kKFxuICAgICAgICAobSkgPT4gbS5zdGF0ZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiXG4gICAgICApO1xuICAgICAgcmV0dXJuICFmaXJzdFBlbmRpbmdNdXRhdGlvbiB8fCBmaXJzdFBlbmRpbmdNdXRhdGlvbiA9PT0gbXV0YXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBydW5OZXh0KG11dGF0aW9uKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBzY29wZUZvcihtdXRhdGlvbik7XG4gICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZm91bmRNdXRhdGlvbiA9IHRoaXMuI3Njb3Blcy5nZXQoc2NvcGUpPy5maW5kKChtKSA9PiBtICE9PSBtdXRhdGlvbiAmJiBtLnN0YXRlLmlzUGF1c2VkKTtcbiAgICAgIHJldHVybiBmb3VuZE11dGF0aW9uPy5jb250aW51ZSgpID8/IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy4jbXV0YXRpb25zLmZvckVhY2goKG11dGF0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJyZW1vdmVkXCIsIG11dGF0aW9uIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiNtdXRhdGlvbnMuY2xlYXIoKTtcbiAgICAgIHRoaXMuI3Njb3Blcy5jbGVhcigpO1xuICAgIH0pO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNtdXRhdGlvbnMpO1xuICB9XG4gIGZpbmQoZmlsdGVycykge1xuICAgIGNvbnN0IGRlZmF1bHRlZEZpbHRlcnMgPSB7IGV4YWN0OiB0cnVlLCAuLi5maWx0ZXJzIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsKCkuZmluZChcbiAgICAgIChtdXRhdGlvbikgPT4gbWF0Y2hNdXRhdGlvbihkZWZhdWx0ZWRGaWx0ZXJzLCBtdXRhdGlvbilcbiAgICApO1xuICB9XG4gIGZpbmRBbGwoZmlsdGVycyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsKCkuZmlsdGVyKChtdXRhdGlvbikgPT4gbWF0Y2hNdXRhdGlvbihmaWx0ZXJzLCBtdXRhdGlvbikpO1xuICB9XG4gIG5vdGlmeShldmVudCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lUGF1c2VkTXV0YXRpb25zKCkge1xuICAgIGNvbnN0IHBhdXNlZE11dGF0aW9ucyA9IHRoaXMuZ2V0QWxsKCkuZmlsdGVyKCh4KSA9PiB4LnN0YXRlLmlzUGF1c2VkKTtcbiAgICByZXR1cm4gbm90aWZ5TWFuYWdlci5iYXRjaChcbiAgICAgICgpID0+IFByb21pc2UuYWxsKFxuICAgICAgICBwYXVzZWRNdXRhdGlvbnMubWFwKChtdXRhdGlvbikgPT4gbXV0YXRpb24uY29udGludWUoKS5jYXRjaChub29wKSlcbiAgICAgIClcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gc2NvcGVGb3IobXV0YXRpb24pIHtcbiAgcmV0dXJuIG11dGF0aW9uLm9wdGlvbnMuc2NvcGU/LmlkO1xufVxuZXhwb3J0IHtcbiAgTXV0YXRpb25DYWNoZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11dGF0aW9uQ2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationObserver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutationObserver.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MutationObserver: () => (/* binding */ MutationObserver)\n/* harmony export */ });\n/* harmony import */ var _mutation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mutation.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/mutationObserver.ts\n\n\n\n\nvar MutationObserver = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #client;\n  #currentResult = void 0;\n  #currentMutation;\n  #mutateOptions;\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.#updateResult();\n  }\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.#client.defaultMutationOptions(options);\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: \"observerOptionsUpdated\",\n        mutation: this.#currentMutation,\n        observer: this\n      });\n    }\n    if (prevOptions?.mutationKey && this.options.mutationKey && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashKey)(prevOptions.mutationKey) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashKey)(this.options.mutationKey)) {\n      this.reset();\n    } else if (this.#currentMutation?.state.status === \"pending\") {\n      this.#currentMutation.setOptions(this.options);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this);\n    }\n  }\n  onMutationUpdate(action) {\n    this.#updateResult();\n    this.#notify(action);\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  reset() {\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = void 0;\n    this.#updateResult();\n    this.#notify();\n  }\n  mutate(variables, options) {\n    this.#mutateOptions = options;\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);\n    this.#currentMutation.addObserver(this);\n    return this.#currentMutation.execute(variables);\n  }\n  #updateResult() {\n    const state = this.#currentMutation?.state ?? (0,_mutation_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultState)();\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === \"pending\",\n      isSuccess: state.status === \"success\",\n      isError: state.status === \"error\",\n      isIdle: state.status === \"idle\",\n      mutate: this.mutate,\n      reset: this.reset\n    };\n  }\n  #notify(action) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables;\n        const context = this.#currentResult.context;\n        if (action?.type === \"success\") {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context);\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context);\n        } else if (action?.type === \"error\") {\n          this.#mutateOptions.onError?.(action.error, variables, context);\n          this.#mutateOptions.onSettled?.(\n            void 0,\n            action.error,\n            variables,\n            context\n          );\n        }\n      }\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult);\n      });\n    });\n  }\n};\n\n//# sourceMappingURL=mutationObserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb25PYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ2dEO0FBQ0c7QUFDRjtBQUNTO0FBQzFELHFDQUFxQywwREFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdFQUFnRSxrREFBTyw4QkFBOEIsa0RBQU87QUFDNUc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2REFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL211dGF0aW9uT2JzZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL211dGF0aW9uT2JzZXJ2ZXIudHNcbmltcG9ydCB7IGdldERlZmF1bHRTdGF0ZSB9IGZyb20gXCIuL211dGF0aW9uLmpzXCI7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSBcIi4vbm90aWZ5TWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG5pbXBvcnQgeyBoYXNoS2V5LCBzaGFsbG93RXF1YWxPYmplY3RzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBNdXRhdGlvbk9ic2VydmVyID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICAjY2xpZW50O1xuICAjY3VycmVudFJlc3VsdCA9IHZvaWQgMDtcbiAgI2N1cnJlbnRNdXRhdGlvbjtcbiAgI211dGF0ZU9wdGlvbnM7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmJpbmRNZXRob2RzKCk7XG4gICAgdGhpcy4jdXBkYXRlUmVzdWx0KCk7XG4gIH1cbiAgYmluZE1ldGhvZHMoKSB7XG4gICAgdGhpcy5tdXRhdGUgPSB0aGlzLm11dGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcyk7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgcHJldk9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy4jY2xpZW50LmRlZmF1bHRNdXRhdGlvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKCFzaGFsbG93RXF1YWxPYmplY3RzKHRoaXMub3B0aW9ucywgcHJldk9wdGlvbnMpKSB7XG4gICAgICB0aGlzLiNjbGllbnQuZ2V0TXV0YXRpb25DYWNoZSgpLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2ZXJPcHRpb25zVXBkYXRlZFwiLFxuICAgICAgICBtdXRhdGlvbjogdGhpcy4jY3VycmVudE11dGF0aW9uLFxuICAgICAgICBvYnNlcnZlcjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcmV2T3B0aW9ucz8ubXV0YXRpb25LZXkgJiYgdGhpcy5vcHRpb25zLm11dGF0aW9uS2V5ICYmIGhhc2hLZXkocHJldk9wdGlvbnMubXV0YXRpb25LZXkpICE9PSBoYXNoS2V5KHRoaXMub3B0aW9ucy5tdXRhdGlvbktleSkpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2N1cnJlbnRNdXRhdGlvbj8uc3RhdGUuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgdGhpcy4jY3VycmVudE11dGF0aW9uLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRNdXRhdGlvbj8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIG9uTXV0YXRpb25VcGRhdGUoYWN0aW9uKSB7XG4gICAgdGhpcy4jdXBkYXRlUmVzdWx0KCk7XG4gICAgdGhpcy4jbm90aWZ5KGFjdGlvbik7XG4gIH1cbiAgZ2V0Q3VycmVudFJlc3VsdCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFJlc3VsdDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLiNjdXJyZW50TXV0YXRpb24/LnJlbW92ZU9ic2VydmVyKHRoaXMpO1xuICAgIHRoaXMuI2N1cnJlbnRNdXRhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLiN1cGRhdGVSZXN1bHQoKTtcbiAgICB0aGlzLiNub3RpZnkoKTtcbiAgfVxuICBtdXRhdGUodmFyaWFibGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy4jbXV0YXRlT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy4jY3VycmVudE11dGF0aW9uPy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICB0aGlzLiNjdXJyZW50TXV0YXRpb24gPSB0aGlzLiNjbGllbnQuZ2V0TXV0YXRpb25DYWNoZSgpLmJ1aWxkKHRoaXMuI2NsaWVudCwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiNjdXJyZW50TXV0YXRpb24uYWRkT2JzZXJ2ZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRNdXRhdGlvbi5leGVjdXRlKHZhcmlhYmxlcyk7XG4gIH1cbiAgI3VwZGF0ZVJlc3VsdCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI2N1cnJlbnRNdXRhdGlvbj8uc3RhdGUgPz8gZ2V0RGVmYXVsdFN0YXRlKCk7XG4gICAgdGhpcy4jY3VycmVudFJlc3VsdCA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgaXNQZW5kaW5nOiBzdGF0ZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiLFxuICAgICAgaXNTdWNjZXNzOiBzdGF0ZS5zdGF0dXMgPT09IFwic3VjY2Vzc1wiLFxuICAgICAgaXNFcnJvcjogc3RhdGUuc3RhdHVzID09PSBcImVycm9yXCIsXG4gICAgICBpc0lkbGU6IHN0YXRlLnN0YXR1cyA9PT0gXCJpZGxlXCIsXG4gICAgICBtdXRhdGU6IHRoaXMubXV0YXRlLFxuICAgICAgcmVzZXQ6IHRoaXMucmVzZXRcbiAgICB9O1xuICB9XG4gICNub3RpZnkoYWN0aW9uKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbXV0YXRlT3B0aW9ucyAmJiB0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuI2N1cnJlbnRSZXN1bHQudmFyaWFibGVzO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jY3VycmVudFJlc3VsdC5jb250ZXh0O1xuICAgICAgICBpZiAoYWN0aW9uPy50eXBlID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICAgIHRoaXMuI211dGF0ZU9wdGlvbnMub25TdWNjZXNzPy4oYWN0aW9uLmRhdGEsIHZhcmlhYmxlcywgY29udGV4dCk7XG4gICAgICAgICAgdGhpcy4jbXV0YXRlT3B0aW9ucy5vblNldHRsZWQ/LihhY3Rpb24uZGF0YSwgbnVsbCwgdmFyaWFibGVzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24/LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRoaXMuI211dGF0ZU9wdGlvbnMub25FcnJvcj8uKGFjdGlvbi5lcnJvciwgdmFyaWFibGVzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLiNtdXRhdGVPcHRpb25zLm9uU2V0dGxlZD8uKFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKHRoaXMuI2N1cnJlbnRSZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBNdXRhdGlvbk9ic2VydmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV0YXRpb25PYnNlcnZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationObserver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/notifyManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotifyManager: () => (/* binding */ createNotifyManager),\n/* harmony export */   notifyManager: () => (/* binding */ notifyManager)\n/* harmony export */ });\n// src/notifyManager.ts\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = (cb) => setTimeout(cb, 0);\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  return {\n    batch: (callback) => {\n      let result;\n      transactions++;\n      try {\n        result = callback();\n      } finally {\n        transactions--;\n        if (!transactions) {\n          flush();\n        }\n      }\n      return result;\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: (callback) => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args);\n        });\n      };\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn) => {\n      notifyFn = fn;\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn) => {\n      batchNotifyFn = fn;\n    },\n    setScheduler: (fn) => {\n      scheduleFn = fn;\n    }\n  };\n}\nvar notifyManager = createNotifyManager();\n\n//# sourceMappingURL=notifyManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbm90aWZ5TWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9ub3RpZnlNYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ub3RpZnlNYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlNYW5hZ2VyKCkge1xuICBsZXQgcXVldWUgPSBbXTtcbiAgbGV0IHRyYW5zYWN0aW9ucyA9IDA7XG4gIGxldCBub3RpZnlGbiA9IChjYWxsYmFjaykgPT4ge1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG4gIGxldCBiYXRjaE5vdGlmeUZuID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcbiAgbGV0IHNjaGVkdWxlRm4gPSAoY2IpID0+IHNldFRpbWVvdXQoY2IsIDApO1xuICBjb25zdCBzY2hlZHVsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0cmFuc2FjdGlvbnMpIHtcbiAgICAgIHF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZuKCgpID0+IHtcbiAgICAgICAgbm90aWZ5Rm4oY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpZiAob3JpZ2luYWxRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHNjaGVkdWxlRm4oKCkgPT4ge1xuICAgICAgICBiYXRjaE5vdGlmeUZuKCgpID0+IHtcbiAgICAgICAgICBvcmlnaW5hbFF1ZXVlLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBub3RpZnlGbihjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGJhdGNoOiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICB0cmFuc2FjdGlvbnMrKztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cmFuc2FjdGlvbnMtLTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWxsIGNhbGxzIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHdpbGwgYmUgYmF0Y2hlZC5cbiAgICAgKi9cbiAgICBiYXRjaENhbGxzOiAoY2FsbGJhY2spID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBzY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHNjaGVkdWxlLFxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gbm90aWZ5IGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZm9yIGV4YW1wbGUgd3JhcCBub3RpZmljYXRpb25zIHdpdGggYFJlYWN0LmFjdGAgd2hpbGUgcnVubmluZyB0ZXN0cy5cbiAgICAgKi9cbiAgICBzZXROb3RpZnlGdW5jdGlvbjogKGZuKSA9PiB7XG4gICAgICBub3RpZnlGbiA9IGZuO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBhIGN1c3RvbSBmdW5jdGlvbiB0byBiYXRjaCBub3RpZmljYXRpb25zIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgdGljay5cbiAgICAgKiBCeSBkZWZhdWx0IFJlYWN0IFF1ZXJ5IHdpbGwgdXNlIHRoZSBiYXRjaCBmdW5jdGlvbiBwcm92aWRlZCBieSBSZWFjdERPTSBvciBSZWFjdCBOYXRpdmUuXG4gICAgICovXG4gICAgc2V0QmF0Y2hOb3RpZnlGdW5jdGlvbjogKGZuKSA9PiB7XG4gICAgICBiYXRjaE5vdGlmeUZuID0gZm47XG4gICAgfSxcbiAgICBzZXRTY2hlZHVsZXI6IChmbikgPT4ge1xuICAgICAgc2NoZWR1bGVGbiA9IGZuO1xuICAgIH1cbiAgfTtcbn1cbnZhciBub3RpZnlNYW5hZ2VyID0gY3JlYXRlTm90aWZ5TWFuYWdlcigpO1xuZXhwb3J0IHtcbiAgY3JlYXRlTm90aWZ5TWFuYWdlcixcbiAgbm90aWZ5TWFuYWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlmeU1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/onlineManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnlineManager: () => (/* binding */ OnlineManager),\n/* harmony export */   onlineManager: () => (/* binding */ onlineManager)\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/onlineManager.ts\n\n\nvar OnlineManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\n\n//# sourceMappingURL=onlineManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vb25saW5lTWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDaUQ7QUFDWDtBQUN0QyxrQ0FBa0MsMERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL29ubGluZU1hbmFnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL29ubGluZU1hbmFnZXIudHNcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gXCIuL3N1YnNjcmliYWJsZS5qc1wiO1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xudmFyIE9ubGluZU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gICNvbmxpbmUgPSB0cnVlO1xuICAjY2xlYW51cDtcbiAgI3NldHVwO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3NldHVwID0gKG9uT25saW5lKSA9PiB7XG4gICAgICBpZiAoIWlzU2VydmVyICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IG9ubGluZUxpc3RlbmVyID0gKCkgPT4gb25PbmxpbmUodHJ1ZSk7XG4gICAgICAgIGNvbnN0IG9mZmxpbmVMaXN0ZW5lciA9ICgpID0+IG9uT25saW5lKGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25saW5lTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9mZmxpbmVMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9ubGluZUxpc3RlbmVyKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb2ZmbGluZUxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIG9uU3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy4jY2xlYW51cCkge1xuICAgICAgdGhpcy5zZXRFdmVudExpc3RlbmVyKHRoaXMuI3NldHVwKTtcbiAgICB9XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgICAgdGhpcy4jY2xlYW51cCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2V0RXZlbnRMaXN0ZW5lcihzZXR1cCkge1xuICAgIHRoaXMuI3NldHVwID0gc2V0dXA7XG4gICAgdGhpcy4jY2xlYW51cD8uKCk7XG4gICAgdGhpcy4jY2xlYW51cCA9IHNldHVwKHRoaXMuc2V0T25saW5lLmJpbmQodGhpcykpO1xuICB9XG4gIHNldE9ubGluZShvbmxpbmUpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy4jb25saW5lICE9PSBvbmxpbmU7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuI29ubGluZSA9IG9ubGluZTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKG9ubGluZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaXNPbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ubGluZTtcbiAgfVxufTtcbnZhciBvbmxpbmVNYW5hZ2VyID0gbmV3IE9ubGluZU1hbmFnZXIoKTtcbmV4cG9ydCB7XG4gIE9ubGluZU1hbmFnZXIsXG4gIG9ubGluZU1hbmFnZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmxpbmVNYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/query.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   fetchState: () => (/* binding */ fetchState)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\");\n// src/query.ts\n\n\n\n\nvar Query = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_1__.skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || this.state.data === void 0 || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timeUntilStale)(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (true) {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureQueryFn)(this.options, fetchOptions);\n      const queryFnContext = {\n        client: this.#client,\n        queryKey: this.queryKey,\n        meta: this.meta\n      };\n      addSignalProperty(queryFnContext);\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      client: this.#client,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!(0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      this.scheduleGc();\n    };\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.createRetryer)({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (true) {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        this.scheduleGc();\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if ((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.canFetch)(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\n//# sourceMappingURL=query.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFRb0I7QUFDK0I7QUFDc0I7QUFDOUI7QUFDM0MsMEJBQTBCLG9EQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJDQUFJLFFBQVEsMkNBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdEQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHlEQUFjO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFnRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0EsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyw2REFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0EsdUpBQXVKLGVBQWU7QUFDdEs7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEMsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWdCO0FBQzlCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLHNDQUFzQztBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5LnRzXG5pbXBvcnQge1xuICBlbnN1cmVRdWVyeUZuLFxuICBub29wLFxuICByZXBsYWNlRGF0YSxcbiAgcmVzb2x2ZUVuYWJsZWQsXG4gIHNraXBUb2tlbixcbiAgdGltZVVudGlsU3RhbGVcbn0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBjYW5GZXRjaCwgY3JlYXRlUmV0cnllciwgaXNDYW5jZWxsZWRFcnJvciB9IGZyb20gXCIuL3JldHJ5ZXIuanNcIjtcbmltcG9ydCB7IFJlbW92YWJsZSB9IGZyb20gXCIuL3JlbW92YWJsZS5qc1wiO1xudmFyIFF1ZXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZW1vdmFibGUge1xuICAjaW5pdGlhbFN0YXRlO1xuICAjcmV2ZXJ0U3RhdGU7XG4gICNjYWNoZTtcbiAgI2NsaWVudDtcbiAgI3JldHJ5ZXI7XG4gICNkZWZhdWx0T3B0aW9ucztcbiAgI2Fib3J0U2lnbmFsQ29uc3VtZWQ7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCA9IGZhbHNlO1xuICAgIHRoaXMuI2RlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLiNjbGllbnQgPSBjb25maWcuY2xpZW50O1xuICAgIHRoaXMuI2NhY2hlID0gdGhpcy4jY2xpZW50LmdldFF1ZXJ5Q2FjaGUoKTtcbiAgICB0aGlzLnF1ZXJ5S2V5ID0gY29uZmlnLnF1ZXJ5S2V5O1xuICAgIHRoaXMucXVlcnlIYXNoID0gY29uZmlnLnF1ZXJ5SGFzaDtcbiAgICB0aGlzLiNpbml0aWFsU3RhdGUgPSBnZXREZWZhdWx0U3RhdGUodGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnN0YXRlID0gY29uZmlnLnN0YXRlID8/IHRoaXMuI2luaXRpYWxTdGF0ZTtcbiAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgfVxuICBnZXQgbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1ldGE7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JldHJ5ZXI/LnByb21pc2U7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMudXBkYXRlR2NUaW1lKHRoaXMub3B0aW9ucy5nY1RpbWUpO1xuICB9XG4gIG9wdGlvbmFsUmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwiaWRsZVwiKSB7XG4gICAgICB0aGlzLiNjYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldERhdGEobmV3RGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRhdGEgPSByZXBsYWNlRGF0YSh0aGlzLnN0YXRlLmRhdGEsIG5ld0RhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4jZGlzcGF0Y2goe1xuICAgICAgZGF0YSxcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgZGF0YVVwZGF0ZWRBdDogb3B0aW9ucz8udXBkYXRlZEF0LFxuICAgICAgbWFudWFsOiBvcHRpb25zPy5tYW51YWxcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzZXRTdGF0ZShzdGF0ZSwgc2V0U3RhdGVPcHRpb25zKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInNldFN0YXRlXCIsIHN0YXRlLCBzZXRTdGF0ZU9wdGlvbnMgfSk7XG4gIH1cbiAgY2FuY2VsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy4jcmV0cnllcj8ucHJvbWlzZTtcbiAgICB0aGlzLiNyZXRyeWVyPy5jYW5jZWwob3B0aW9ucyk7XG4gICAgcmV0dXJuIHByb21pc2UgPyBwcm9taXNlLnRoZW4obm9vcCkuY2F0Y2gobm9vcCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbmNlbCh7IHNpbGVudDogdHJ1ZSB9KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuI2luaXRpYWxTdGF0ZSk7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNvbWUoXG4gICAgICAob2JzZXJ2ZXIpID0+IHJlc29sdmVFbmFibGVkKG9ic2VydmVyLm9wdGlvbnMuZW5hYmxlZCwgdGhpcykgIT09IGZhbHNlXG4gICAgKTtcbiAgfVxuICBpc0Rpc2FibGVkKCkge1xuICAgIGlmICh0aGlzLmdldE9ic2VydmVyc0NvdW50KCkgPiAwKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNBY3RpdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5xdWVyeUZuID09PSBza2lwVG9rZW4gfHwgdGhpcy5zdGF0ZS5kYXRhVXBkYXRlQ291bnQgKyB0aGlzLnN0YXRlLmVycm9yVXBkYXRlQ291bnQgPT09IDA7XG4gIH1cbiAgaXNTdGFsZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0ludmFsaWRhdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0T2JzZXJ2ZXJzQ291bnQoKSA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5zb21lKFxuICAgICAgICAob2JzZXJ2ZXIpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKS5pc1N0YWxlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kYXRhID09PSB2b2lkIDA7XG4gIH1cbiAgaXNTdGFsZUJ5VGltZShzdGFsZVRpbWUgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCB8fCB0aGlzLnN0YXRlLmRhdGEgPT09IHZvaWQgMCB8fCAhdGltZVVudGlsU3RhbGUodGhpcy5zdGF0ZS5kYXRhVXBkYXRlZEF0LCBzdGFsZVRpbWUpO1xuICB9XG4gIG9uRm9jdXMoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVycy5maW5kKCh4KSA9PiB4LnNob3VsZEZldGNoT25XaW5kb3dGb2N1cygpKTtcbiAgICBvYnNlcnZlcj8ucmVmZXRjaCh7IGNhbmNlbFJlZmV0Y2g6IGZhbHNlIH0pO1xuICAgIHRoaXMuI3JldHJ5ZXI/LmNvbnRpbnVlKCk7XG4gIH1cbiAgb25PbmxpbmUoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVycy5maW5kKCh4KSA9PiB4LnNob3VsZEZldGNoT25SZWNvbm5lY3QoKSk7XG4gICAgb2JzZXJ2ZXI/LnJlZmV0Y2goeyBjYW5jZWxSZWZldGNoOiBmYWxzZSB9KTtcbiAgICB0aGlzLiNyZXRyeWVyPy5jb250aW51ZSgpO1xuICB9XG4gIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICAgICAgdGhpcy4jY2FjaGUubm90aWZ5KHsgdHlwZTogXCJvYnNlcnZlckFkZGVkXCIsIHF1ZXJ5OiB0aGlzLCBvYnNlcnZlciB9KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICBpZiAodGhpcy5vYnNlcnZlcnMuaW5jbHVkZXMob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzLmZpbHRlcigoeCkgPT4geCAhPT0gb2JzZXJ2ZXIpO1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3JldHJ5ZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCkge1xuICAgICAgICAgICAgdGhpcy4jcmV0cnllci5jYW5jZWwoeyByZXZlcnQ6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3JldHJ5ZXIuY2FuY2VsUmV0cnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNjYWNoZS5ub3RpZnkoeyB0eXBlOiBcIm9ic2VydmVyUmVtb3ZlZFwiLCBxdWVyeTogdGhpcywgb2JzZXJ2ZXIgfSk7XG4gICAgfVxuICB9XG4gIGdldE9ic2VydmVyc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGg7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCkge1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImludmFsaWRhdGVcIiB9KTtcbiAgICB9XG4gIH1cbiAgZmV0Y2gob3B0aW9ucywgZmV0Y2hPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5kYXRhICE9PSB2b2lkIDAgJiYgZmV0Y2hPcHRpb25zPy5jYW5jZWxSZWZldGNoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNyZXRyeWVyKSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ZXIuY29udGludWVSZXRyeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy4jcmV0cnllci5wcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5xdWVyeUZuKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoKHgpID0+IHgub3B0aW9ucy5xdWVyeUZuKTtcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob2JzZXJ2ZXIub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMucXVlcnlLZXkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEFzIG9mIHY0LCBxdWVyeUtleSBuZWVkcyB0byBiZSBhbiBBcnJheS4gSWYgeW91IGFyZSB1c2luZyBhIHN0cmluZyBsaWtlICdyZXBvRGF0YScsIHBsZWFzZSBjaGFuZ2UgaXQgdG8gYW4gQXJyYXksIGUuZy4gWydyZXBvRGF0YSddYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgYWRkU2lnbmFsUHJvcGVydHkgPSAob2JqZWN0KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcInNpZ25hbFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2Fib3J0U2lnbmFsQ29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeUZuID0gZW5zdXJlUXVlcnlGbih0aGlzLm9wdGlvbnMsIGZldGNoT3B0aW9ucyk7XG4gICAgICBjb25zdCBxdWVyeUZuQ29udGV4dCA9IHtcbiAgICAgICAgY2xpZW50OiB0aGlzLiNjbGllbnQsXG4gICAgICAgIHF1ZXJ5S2V5OiB0aGlzLnF1ZXJ5S2V5LFxuICAgICAgICBtZXRhOiB0aGlzLm1ldGFcbiAgICAgIH07XG4gICAgICBhZGRTaWduYWxQcm9wZXJ0eShxdWVyeUZuQ29udGV4dCk7XG4gICAgICB0aGlzLiNhYm9ydFNpZ25hbENvbnN1bWVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlcnNpc3Rlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBlcnNpc3RlcihcbiAgICAgICAgICBxdWVyeUZuLFxuICAgICAgICAgIHF1ZXJ5Rm5Db250ZXh0LFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBxdWVyeUZuKHF1ZXJ5Rm5Db250ZXh0KTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBxdWVyeUtleTogdGhpcy5xdWVyeUtleSxcbiAgICAgIGNsaWVudDogdGhpcy4jY2xpZW50LFxuICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICBmZXRjaEZuXG4gICAgfTtcbiAgICBhZGRTaWduYWxQcm9wZXJ0eShjb250ZXh0KTtcbiAgICB0aGlzLm9wdGlvbnMuYmVoYXZpb3I/Lm9uRmV0Y2goXG4gICAgICBjb250ZXh0LFxuICAgICAgdGhpc1xuICAgICk7XG4gICAgdGhpcy4jcmV2ZXJ0U3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0aGlzLnN0YXRlLmZldGNoU3RhdHVzID09PSBcImlkbGVcIiB8fCB0aGlzLnN0YXRlLmZldGNoTWV0YSAhPT0gY29udGV4dC5mZXRjaE9wdGlvbnM/Lm1ldGEpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJmZXRjaFwiLCBtZXRhOiBjb250ZXh0LmZldGNoT3B0aW9ucz8ubWV0YSB9KTtcbiAgICB9XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgaWYgKCEoaXNDYW5jZWxsZWRFcnJvcihlcnJvcikgJiYgZXJyb3Iuc2lsZW50KSkge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0NhbmNlbGxlZEVycm9yKGVycm9yKSkge1xuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25FcnJvcj8uKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy4jY2FjaGUuY29uZmlnLm9uU2V0dGxlZD8uKFxuICAgICAgICAgIHRoaXMuc3RhdGUuZGF0YSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICB9O1xuICAgIHRoaXMuI3JldHJ5ZXIgPSBjcmVhdGVSZXRyeWVyKHtcbiAgICAgIGluaXRpYWxQcm9taXNlOiBmZXRjaE9wdGlvbnM/LmluaXRpYWxQcm9taXNlLFxuICAgICAgZm46IGNvbnRleHQuZmV0Y2hGbixcbiAgICAgIGFib3J0OiBhYm9ydENvbnRyb2xsZXIuYWJvcnQuYmluZChhYm9ydENvbnRyb2xsZXIpLFxuICAgICAgb25TdWNjZXNzOiAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYFF1ZXJ5IGRhdGEgY2Fubm90IGJlIHVuZGVmaW5lZC4gUGxlYXNlIG1ha2Ugc3VyZSB0byByZXR1cm4gYSB2YWx1ZSBvdGhlciB0aGFuIHVuZGVmaW5lZCBmcm9tIHlvdXIgcXVlcnkgZnVuY3Rpb24uIEFmZmVjdGVkIHF1ZXJ5IGtleTogJHt0aGlzLnF1ZXJ5SGFzaH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihgJHt0aGlzLnF1ZXJ5SGFzaH0gZGF0YSBpcyB1bmRlZmluZWRgKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5zZXREYXRhKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25TdWNjZXNzPy4oZGF0YSwgdGhpcyk7XG4gICAgICAgIHRoaXMuI2NhY2hlLmNvbmZpZy5vblNldHRsZWQ/LihcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yLFxuICAgICAgb25GYWlsOiAoZmFpbHVyZUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiZmFpbGVkXCIsIGZhaWx1cmVDb3VudCwgZXJyb3IgfSk7XG4gICAgICB9LFxuICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwicGF1c2VcIiB9KTtcbiAgICAgIH0sXG4gICAgICBvbkNvbnRpbnVlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJjb250aW51ZVwiIH0pO1xuICAgICAgfSxcbiAgICAgIHJldHJ5OiBjb250ZXh0Lm9wdGlvbnMucmV0cnksXG4gICAgICByZXRyeURlbGF5OiBjb250ZXh0Lm9wdGlvbnMucmV0cnlEZWxheSxcbiAgICAgIG5ldHdvcmtNb2RlOiBjb250ZXh0Lm9wdGlvbnMubmV0d29ya01vZGUsXG4gICAgICBjYW5SdW46ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy4jcmV0cnllci5zdGFydCgpO1xuICB9XG4gICNkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBjb25zdCByZWR1Y2VyID0gKHN0YXRlKSA9PiB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmZXRjaEZhaWx1cmVDb3VudDogYWN0aW9uLmZhaWx1cmVDb3VudCxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInBhdXNlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IFwicGF1c2VkXCJcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogXCJmZXRjaGluZ1wiXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImZldGNoXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgLi4uZmV0Y2hTdGF0ZShzdGF0ZS5kYXRhLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICAgICAgZmV0Y2hNZXRhOiBhY3Rpb24ubWV0YSA/PyBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGRhdGFVcGRhdGVDb3VudDogc3RhdGUuZGF0YVVwZGF0ZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGRhdGFVcGRhdGVkQXQ6IGFjdGlvbi5kYXRhVXBkYXRlZEF0ID8/IERhdGUubm93KCksXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGlzSW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIC4uLiFhY3Rpb24ubWFudWFsICYmIHtcbiAgICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBmZXRjaEZhaWx1cmVDb3VudDogMCxcbiAgICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgaWYgKGlzQ2FuY2VsbGVkRXJyb3IoZXJyb3IpICYmIGVycm9yLnJldmVydCAmJiB0aGlzLiNyZXZlcnRTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4udGhpcy4jcmV2ZXJ0U3RhdGUsIGZldGNoU3RhdHVzOiBcImlkbGVcIiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGVycm9yVXBkYXRlQ291bnQ6IHN0YXRlLmVycm9yVXBkYXRlQ291bnQgKyAxLFxuICAgICAgICAgICAgZXJyb3JVcGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICBmZXRjaEZhaWx1cmVDb3VudDogc3RhdGUuZmV0Y2hGYWlsdXJlQ291bnQgKyAxLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBlcnJvcixcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiBcImlkbGVcIixcbiAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImludmFsaWRhdGVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc0ludmFsaWRhdGVkOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInNldFN0YXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgLi4uYWN0aW9uLnN0YXRlXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSByZWR1Y2VyKHRoaXMuc3RhdGUpO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIub25RdWVyeVVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiNjYWNoZS5ub3RpZnkoeyBxdWVyeTogdGhpcywgdHlwZTogXCJ1cGRhdGVkXCIsIGFjdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZldGNoU3RhdGUoZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgIGZldGNoRmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICBmZXRjaFN0YXR1czogY2FuRmV0Y2gob3B0aW9ucy5uZXR3b3JrTW9kZSkgPyBcImZldGNoaW5nXCIgOiBcInBhdXNlZFwiLFxuICAgIC4uLmRhdGEgPT09IHZvaWQgMCAmJiB7XG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCJcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U3RhdGUob3B0aW9ucykge1xuICBjb25zdCBkYXRhID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbERhdGEgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbERhdGEoKSA6IG9wdGlvbnMuaW5pdGlhbERhdGE7XG4gIGNvbnN0IGhhc0RhdGEgPSBkYXRhICE9PSB2b2lkIDA7XG4gIGNvbnN0IGluaXRpYWxEYXRhVXBkYXRlZEF0ID0gaGFzRGF0YSA/IHR5cGVvZiBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0ID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0KCkgOiBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0IDogMDtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGRhdGFVcGRhdGVDb3VudDogMCxcbiAgICBkYXRhVXBkYXRlZEF0OiBoYXNEYXRhID8gaW5pdGlhbERhdGFVcGRhdGVkQXQgPz8gRGF0ZS5ub3coKSA6IDAsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgZXJyb3JVcGRhdGVDb3VudDogMCxcbiAgICBlcnJvclVwZGF0ZWRBdDogMCxcbiAgICBmZXRjaEZhaWx1cmVDb3VudDogMCxcbiAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgZmV0Y2hNZXRhOiBudWxsLFxuICAgIGlzSW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgIHN0YXR1czogaGFzRGF0YSA/IFwic3VjY2Vzc1wiIDogXCJwZW5kaW5nXCIsXG4gICAgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiXG4gIH07XG59XG5leHBvcnQge1xuICBRdWVyeSxcbiAgZmV0Y2hTdGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryCache.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryCache: () => (/* binding */ QueryCache)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/queryCache.ts\n\n\n\n\nvar QueryCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashQueryKeyByOptions)(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new _query_js__WEBPACK_IMPORTED_MODULE_2__.Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(filters, query)) : queries;\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\n\n//# sourceMappingURL=queryCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQytEO0FBQzVCO0FBQ2dCO0FBQ0Y7QUFDakQsK0JBQStCLDBEQUFZO0FBQzNDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnRUFBcUI7QUFDaEU7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHVFQUF1RSxxREFBVTtBQUNqRjtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnlDYWNoZS50c1xuaW1wb3J0IHsgaGFzaFF1ZXJ5S2V5QnlPcHRpb25zLCBtYXRjaFF1ZXJ5IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIi4vcXVlcnkuanNcIjtcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbnZhciBRdWVyeUNhY2hlID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy4jcXVlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgI3F1ZXJpZXM7XG4gIGJ1aWxkKGNsaWVudCwgb3B0aW9ucywgc3RhdGUpIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG9wdGlvbnMucXVlcnlLZXk7XG4gICAgY29uc3QgcXVlcnlIYXNoID0gb3B0aW9ucy5xdWVyeUhhc2ggPz8gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBvcHRpb25zKTtcbiAgICBsZXQgcXVlcnkgPSB0aGlzLmdldChxdWVyeUhhc2gpO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHtcbiAgICAgICAgY2xpZW50LFxuICAgICAgICBxdWVyeUtleSxcbiAgICAgICAgcXVlcnlIYXNoLFxuICAgICAgICBvcHRpb25zOiBjbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBjbGllbnQuZ2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGQocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgYWRkKHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLiNxdWVyaWVzLmhhcyhxdWVyeS5xdWVyeUhhc2gpKSB7XG4gICAgICB0aGlzLiNxdWVyaWVzLnNldChxdWVyeS5xdWVyeUhhc2gsIHF1ZXJ5KTtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogXCJhZGRlZFwiLFxuICAgICAgICBxdWVyeVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZShxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW5NYXAgPSB0aGlzLiNxdWVyaWVzLmdldChxdWVyeS5xdWVyeUhhc2gpO1xuICAgIGlmIChxdWVyeUluTWFwKSB7XG4gICAgICBxdWVyeS5kZXN0cm95KCk7XG4gICAgICBpZiAocXVlcnlJbk1hcCA9PT0gcXVlcnkpIHtcbiAgICAgICAgdGhpcy4jcXVlcmllcy5kZWxldGUocXVlcnkucXVlcnlIYXNoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJyZW1vdmVkXCIsIHF1ZXJ5IH0pO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUocXVlcnkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KHF1ZXJ5SGFzaCkge1xuICAgIHJldHVybiB0aGlzLiNxdWVyaWVzLmdldChxdWVyeUhhc2gpO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuI3F1ZXJpZXMudmFsdWVzKCldO1xuICB9XG4gIGZpbmQoZmlsdGVycykge1xuICAgIGNvbnN0IGRlZmF1bHRlZEZpbHRlcnMgPSB7IGV4YWN0OiB0cnVlLCAuLi5maWx0ZXJzIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsKCkuZmluZChcbiAgICAgIChxdWVyeSkgPT4gbWF0Y2hRdWVyeShkZWZhdWx0ZWRGaWx0ZXJzLCBxdWVyeSlcbiAgICApO1xuICB9XG4gIGZpbmRBbGwoZmlsdGVycyA9IHt9KSB7XG4gICAgY29uc3QgcXVlcmllcyA9IHRoaXMuZ2V0QWxsKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbHRlcnMpLmxlbmd0aCA+IDAgPyBxdWVyaWVzLmZpbHRlcigocXVlcnkpID0+IG1hdGNoUXVlcnkoZmlsdGVycywgcXVlcnkpKSA6IHF1ZXJpZXM7XG4gIH1cbiAgbm90aWZ5KGV2ZW50KSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5nZXRBbGwoKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeS5vbkZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbk9ubGluZSgpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgcXVlcnkub25PbmxpbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgUXVlcnlDYWNoZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5Q2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClient: () => (/* binding */ QueryClient)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _queryCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queryCache.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js\");\n/* harmony import */ var _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutationCache.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js\");\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./infiniteQueryBehavior.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\");\n// src/queryClient.ts\n\n\n\n\n\n\n\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new _queryCache_js__WEBPACK_IMPORTED_MODULE_0__.QueryCache();\n    this.#mutationCache = config.mutationCache || new _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__.MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1)\n      return;\n    this.#unsubscribeFocus = _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0)\n      return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveStaleTime)(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.functionalUpdate)(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(\n      options.queryHash\n    )?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    const refetchFilters = {\n      type: \"active\",\n      ...filters\n    };\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(filters, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  invalidateQueries(filters, options = {}) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: filters?.refetchType ?? filters?.type ?? \"active\"\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(filters, options = {}) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveStaleTime)(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__.infiniteQueryBehavior)(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__.infiniteQueryBehavior)(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (_onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashQueryKeyByOptions)(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_4__.skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\n\n//# sourceMappingURL=queryClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQVNvQjtBQUN5QjtBQUNNO0FBQ0Y7QUFDRTtBQUNBO0FBQ2dCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixnREFBZ0Qsc0RBQVU7QUFDMUQsc0RBQXNELDREQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwREFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEIsNERBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEU7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyREFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSwwQkFBMEI7QUFDcEc7QUFDQTtBQUNBLFdBQVcsNERBQWE7QUFDeEIscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQWE7QUFDeEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQztBQUMzQyxxQ0FBcUM7QUFDckMscUJBQXFCLDREQUFhO0FBQ2xDO0FBQ0E7QUFDQSxzQ0FBc0MsMkNBQUksUUFBUSwyQ0FBSTtBQUN0RDtBQUNBLHlDQUF5QztBQUN6QyxXQUFXLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkNBQUk7QUFDdEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQywyQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyREFBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJDQUFJLFFBQVEsMkNBQUk7QUFDekQ7QUFDQTtBQUNBLHVCQUF1QixnRkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJDQUFJLFFBQVEsMkNBQUk7QUFDakU7QUFDQTtBQUNBLHVCQUF1QixnRkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtEQUFPO0FBQ25DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMERBQWU7QUFDekI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQU87QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBZTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdEQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnlDbGllbnQudHNcbmltcG9ydCB7XG4gIGZ1bmN0aW9uYWxVcGRhdGUsXG4gIGhhc2hLZXksXG4gIGhhc2hRdWVyeUtleUJ5T3B0aW9ucyxcbiAgbm9vcCxcbiAgcGFydGlhbE1hdGNoS2V5LFxuICByZXNvbHZlU3RhbGVUaW1lLFxuICBza2lwVG9rZW5cbn0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IFF1ZXJ5Q2FjaGUgfSBmcm9tIFwiLi9xdWVyeUNhY2hlLmpzXCI7XG5pbXBvcnQgeyBNdXRhdGlvbkNhY2hlIH0gZnJvbSBcIi4vbXV0YXRpb25DYWNoZS5qc1wiO1xuaW1wb3J0IHsgZm9jdXNNYW5hZ2VyIH0gZnJvbSBcIi4vZm9jdXNNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBvbmxpbmVNYW5hZ2VyIH0gZnJvbSBcIi4vb25saW5lTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGluZmluaXRlUXVlcnlCZWhhdmlvciB9IGZyb20gXCIuL2luZmluaXRlUXVlcnlCZWhhdmlvci5qc1wiO1xudmFyIFF1ZXJ5Q2xpZW50ID0gY2xhc3Mge1xuICAjcXVlcnlDYWNoZTtcbiAgI211dGF0aW9uQ2FjaGU7XG4gICNkZWZhdWx0T3B0aW9ucztcbiAgI3F1ZXJ5RGVmYXVsdHM7XG4gICNtdXRhdGlvbkRlZmF1bHRzO1xuICAjbW91bnRDb3VudDtcbiAgI3Vuc3Vic2NyaWJlRm9jdXM7XG4gICN1bnN1YnNjcmliZU9ubGluZTtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLiNxdWVyeUNhY2hlID0gY29uZmlnLnF1ZXJ5Q2FjaGUgfHwgbmV3IFF1ZXJ5Q2FjaGUoKTtcbiAgICB0aGlzLiNtdXRhdGlvbkNhY2hlID0gY29uZmlnLm11dGF0aW9uQ2FjaGUgfHwgbmV3IE11dGF0aW9uQ2FjaGUoKTtcbiAgICB0aGlzLiNkZWZhdWx0T3B0aW9ucyA9IGNvbmZpZy5kZWZhdWx0T3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLiNxdWVyeURlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNtdXRhdGlvbkRlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNtb3VudENvdW50ID0gMDtcbiAgfVxuICBtb3VudCgpIHtcbiAgICB0aGlzLiNtb3VudENvdW50Kys7XG4gICAgaWYgKHRoaXMuI21vdW50Q291bnQgIT09IDEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVGb2N1cyA9IGZvY3VzTWFuYWdlci5zdWJzY3JpYmUoYXN5bmMgKGZvY3VzZWQpID0+IHtcbiAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdW1lUGF1c2VkTXV0YXRpb25zKCk7XG4gICAgICAgIHRoaXMuI3F1ZXJ5Q2FjaGUub25Gb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlT25saW5lID0gb25saW5lTWFuYWdlci5zdWJzY3JpYmUoYXN5bmMgKG9ubGluZSkgPT4ge1xuICAgICAgaWYgKG9ubGluZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3VtZVBhdXNlZE11dGF0aW9ucygpO1xuICAgICAgICB0aGlzLiNxdWVyeUNhY2hlLm9uT25saW5lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5tb3VudCgpIHtcbiAgICB0aGlzLiNtb3VudENvdW50LS07XG4gICAgaWYgKHRoaXMuI21vdW50Q291bnQgIT09IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVGb2N1cz8uKCk7XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVGb2N1cyA9IHZvaWQgMDtcbiAgICB0aGlzLiN1bnN1YnNjcmliZU9ubGluZT8uKCk7XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVPbmxpbmUgPSB2b2lkIDA7XG4gIH1cbiAgaXNGZXRjaGluZyhmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuI3F1ZXJ5Q2FjaGUuZmluZEFsbCh7IC4uLmZpbHRlcnMsIGZldGNoU3RhdHVzOiBcImZldGNoaW5nXCIgfSkubGVuZ3RoO1xuICB9XG4gIGlzTXV0YXRpbmcoZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLiNtdXRhdGlvbkNhY2hlLmZpbmRBbGwoeyAuLi5maWx0ZXJzLCBzdGF0dXM6IFwicGVuZGluZ1wiIH0pLmxlbmd0aDtcbiAgfVxuICBnZXRRdWVyeURhdGEocXVlcnlLZXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKHsgcXVlcnlLZXkgfSk7XG4gICAgcmV0dXJuIHRoaXMuI3F1ZXJ5Q2FjaGUuZ2V0KG9wdGlvbnMucXVlcnlIYXNoKT8uc3RhdGUuZGF0YTtcbiAgfVxuICBlbnN1cmVRdWVyeURhdGEob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB0aGlzLmRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBxdWVyeS5zdGF0ZS5kYXRhO1xuICAgIGlmIChjYWNoZWREYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJldmFsaWRhdGVJZlN0YWxlICYmIHF1ZXJ5LmlzU3RhbGVCeVRpbWUocmVzb2x2ZVN0YWxlVGltZShkZWZhdWx0ZWRPcHRpb25zLnN0YWxlVGltZSwgcXVlcnkpKSkge1xuICAgICAgdm9pZCB0aGlzLnByZWZldGNoUXVlcnkoZGVmYXVsdGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkRGF0YSk7XG4gIH1cbiAgZ2V0UXVlcmllc0RhdGEoZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykubWFwKCh7IHF1ZXJ5S2V5LCBzdGF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc3RhdGUuZGF0YTtcbiAgICAgIHJldHVybiBbcXVlcnlLZXksIGRhdGFdO1xuICAgIH0pO1xuICB9XG4gIHNldFF1ZXJ5RGF0YShxdWVyeUtleSwgdXBkYXRlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB0aGlzLmRlZmF1bHRRdWVyeU9wdGlvbnMoeyBxdWVyeUtleSB9KTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuI3F1ZXJ5Q2FjaGUuZ2V0KFxuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2hcbiAgICApO1xuICAgIGNvbnN0IHByZXZEYXRhID0gcXVlcnk/LnN0YXRlLmRhdGE7XG4gICAgY29uc3QgZGF0YSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgcHJldkRhdGEpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpLnNldERhdGEoZGF0YSwgeyAuLi5vcHRpb25zLCBtYW51YWw6IHRydWUgfSk7XG4gIH1cbiAgc2V0UXVlcmllc0RhdGEoZmlsdGVycywgdXBkYXRlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLm1hcCgoeyBxdWVyeUtleSB9KSA9PiBbXG4gICAgICAgIHF1ZXJ5S2V5LFxuICAgICAgICB0aGlzLnNldFF1ZXJ5RGF0YShxdWVyeUtleSwgdXBkYXRlciwgb3B0aW9ucylcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBnZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyh7IHF1ZXJ5S2V5IH0pO1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmdldChcbiAgICAgIG9wdGlvbnMucXVlcnlIYXNoXG4gICAgKT8uc3RhdGU7XG4gIH1cbiAgcmVtb3ZlUXVlcmllcyhmaWx0ZXJzKSB7XG4gICAgY29uc3QgcXVlcnlDYWNoZSA9IHRoaXMuI3F1ZXJ5Q2FjaGU7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICBxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgcXVlcnlDYWNoZS5yZW1vdmUocXVlcnkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRRdWVyaWVzKGZpbHRlcnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeUNhY2hlID0gdGhpcy4jcXVlcnlDYWNoZTtcbiAgICBjb25zdCByZWZldGNoRmlsdGVycyA9IHtcbiAgICAgIHR5cGU6IFwiYWN0aXZlXCIsXG4gICAgICAuLi5maWx0ZXJzXG4gICAgfTtcbiAgICByZXR1cm4gbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICBxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgcXVlcnkucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucmVmZXRjaFF1ZXJpZXMocmVmZXRjaEZpbHRlcnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIGNhbmNlbFF1ZXJpZXMoZmlsdGVycywgY2FuY2VsT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZGVmYXVsdGVkQ2FuY2VsT3B0aW9ucyA9IHsgcmV2ZXJ0OiB0cnVlLCAuLi5jYW5jZWxPcHRpb25zIH07XG4gICAgY29uc3QgcHJvbWlzZXMgPSBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLm1hcCgocXVlcnkpID0+IHF1ZXJ5LmNhbmNlbChkZWZhdWx0ZWRDYW5jZWxPcHRpb25zKSlcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuICBpbnZhbGlkYXRlUXVlcmllcyhmaWx0ZXJzLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgcXVlcnkuaW52YWxpZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZmlsdGVycz8ucmVmZXRjaFR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZmV0Y2hGaWx0ZXJzID0ge1xuICAgICAgICAuLi5maWx0ZXJzLFxuICAgICAgICB0eXBlOiBmaWx0ZXJzPy5yZWZldGNoVHlwZSA/PyBmaWx0ZXJzPy50eXBlID8/IFwiYWN0aXZlXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5yZWZldGNoUXVlcmllcyhyZWZldGNoRmlsdGVycywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgcmVmZXRjaFF1ZXJpZXMoZmlsdGVycywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNhbmNlbFJlZmV0Y2g6IG9wdGlvbnMuY2FuY2VsUmVmZXRjaCA/PyB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlcyA9IG5vdGlmeU1hbmFnZXIuYmF0Y2goXG4gICAgICAoKSA9PiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZmlsdGVyKChxdWVyeSkgPT4gIXF1ZXJ5LmlzRGlzYWJsZWQoKSkubWFwKChxdWVyeSkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IHF1ZXJ5LmZldGNoKHZvaWQgMCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgaWYgKCFmZXRjaE9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2gobm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnN0YXRlLmZldGNoU3RhdHVzID09PSBcInBhdXNlZFwiID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKTtcbiAgfVxuICBmZXRjaFF1ZXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmIChkZWZhdWx0ZWRPcHRpb25zLnJldHJ5ID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucmV0cnkgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgIHJldHVybiBxdWVyeS5pc1N0YWxlQnlUaW1lKFxuICAgICAgcmVzb2x2ZVN0YWxlVGltZShkZWZhdWx0ZWRPcHRpb25zLnN0YWxlVGltZSwgcXVlcnkpXG4gICAgKSA/IHF1ZXJ5LmZldGNoKGRlZmF1bHRlZE9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5LnN0YXRlLmRhdGEpO1xuICB9XG4gIHByZWZldGNoUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkob3B0aW9ucykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuICBmZXRjaEluZmluaXRlUXVlcnkob3B0aW9ucykge1xuICAgIG9wdGlvbnMuYmVoYXZpb3IgPSBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3Iob3B0aW9ucy5wYWdlcyk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hRdWVyeShvcHRpb25zKTtcbiAgfVxuICBwcmVmZXRjaEluZmluaXRlUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoSW5maW5pdGVRdWVyeShvcHRpb25zKS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApO1xuICB9XG4gIGVuc3VyZUluZmluaXRlUXVlcnlEYXRhKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmJlaGF2aW9yID0gaW5maW5pdGVRdWVyeUJlaGF2aW9yKG9wdGlvbnMucGFnZXMpO1xuICAgIHJldHVybiB0aGlzLmVuc3VyZVF1ZXJ5RGF0YShvcHRpb25zKTtcbiAgfVxuICByZXN1bWVQYXVzZWRNdXRhdGlvbnMoKSB7XG4gICAgaWYgKG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI211dGF0aW9uQ2FjaGUucmVzdW1lUGF1c2VkTXV0YXRpb25zKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBnZXRRdWVyeUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlO1xuICB9XG4gIGdldE11dGF0aW9uQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI211dGF0aW9uQ2FjaGU7XG4gIH1cbiAgZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlZmF1bHRPcHRpb25zO1xuICB9XG4gIHNldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLiNkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgc2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSwgb3B0aW9ucykge1xuICAgIHRoaXMuI3F1ZXJ5RGVmYXVsdHMuc2V0KGhhc2hLZXkocXVlcnlLZXkpLCB7XG4gICAgICBxdWVyeUtleSxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgZ2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gWy4uLnRoaXMuI3F1ZXJ5RGVmYXVsdHMudmFsdWVzKCldO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGRlZmF1bHRzLmZvckVhY2goKHF1ZXJ5RGVmYXVsdCkgPT4ge1xuICAgICAgaWYgKHBhcnRpYWxNYXRjaEtleShxdWVyeUtleSwgcXVlcnlEZWZhdWx0LnF1ZXJ5S2V5KSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgcXVlcnlEZWZhdWx0LmRlZmF1bHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHNldE11dGF0aW9uRGVmYXVsdHMobXV0YXRpb25LZXksIG9wdGlvbnMpIHtcbiAgICB0aGlzLiNtdXRhdGlvbkRlZmF1bHRzLnNldChoYXNoS2V5KG11dGF0aW9uS2V5KSwge1xuICAgICAgbXV0YXRpb25LZXksXG4gICAgICBkZWZhdWx0T3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGdldE11dGF0aW9uRGVmYXVsdHMobXV0YXRpb25LZXkpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IFsuLi50aGlzLiNtdXRhdGlvbkRlZmF1bHRzLnZhbHVlcygpXTtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZGVmYXVsdHMuZm9yRWFjaCgocXVlcnlEZWZhdWx0KSA9PiB7XG4gICAgICBpZiAocGFydGlhbE1hdGNoS2V5KG11dGF0aW9uS2V5LCBxdWVyeURlZmF1bHQubXV0YXRpb25LZXkpKSB7XG4gICAgICAgIHJlc3VsdCA9IHsgLi4ucmVzdWx0LCAuLi5xdWVyeURlZmF1bHQuZGVmYXVsdE9wdGlvbnMgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLl9kZWZhdWx0ZWQpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0ge1xuICAgICAgLi4udGhpcy4jZGVmYXVsdE9wdGlvbnMucXVlcmllcyxcbiAgICAgIC4uLnRoaXMuZ2V0UXVlcnlEZWZhdWx0cyhvcHRpb25zLnF1ZXJ5S2V5KSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBfZGVmYXVsdGVkOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoIWRlZmF1bHRlZE9wdGlvbnMucXVlcnlIYXNoKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5SGFzaCA9IGhhc2hRdWVyeUtleUJ5T3B0aW9ucyhcbiAgICAgICAgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUtleSxcbiAgICAgICAgZGVmYXVsdGVkT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRlZE9wdGlvbnMucmVmZXRjaE9uUmVjb25uZWN0ID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucmVmZXRjaE9uUmVjb25uZWN0ID0gZGVmYXVsdGVkT3B0aW9ucy5uZXR3b3JrTW9kZSAhPT0gXCJhbHdheXNcIjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRlZE9wdGlvbnMudGhyb3dPbkVycm9yID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMudGhyb3dPbkVycm9yID0gISFkZWZhdWx0ZWRPcHRpb25zLnN1c3BlbnNlO1xuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRlZE9wdGlvbnMubmV0d29ya01vZGUgJiYgZGVmYXVsdGVkT3B0aW9ucy5wZXJzaXN0ZXIpIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMubmV0d29ya01vZGUgPSBcIm9mZmxpbmVGaXJzdFwiO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUZuID09PSBza2lwVG9rZW4pIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdGVkT3B0aW9ucztcbiAgfVxuICBkZWZhdWx0TXV0YXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8uX2RlZmF1bHRlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucy5tdXRhdGlvbnMsXG4gICAgICAuLi5vcHRpb25zPy5tdXRhdGlvbktleSAmJiB0aGlzLmdldE11dGF0aW9uRGVmYXVsdHMob3B0aW9ucy5tdXRhdGlvbktleSksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgX2RlZmF1bHRlZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy4jcXVlcnlDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI211dGF0aW9uQ2FjaGUuY2xlYXIoKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIFF1ZXJ5Q2xpZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryObserver.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryObserver.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryObserver: () => (/* binding */ QueryObserver)\n/* harmony export */ });\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _thenable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thenable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/thenable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/queryObserver.ts\n\n\n\n\n\n\nvar QueryObserver = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = (0,_thenable_js__WEBPACK_IMPORTED_MODULE_1__.pendingThenable)();\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.shallowEqualObjects)(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(prevOptions.enabled, this.#currentQuery) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveStaleTime)(this.options.staleTime, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveStaleTime)(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_2__.noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveStaleTime)(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_2__.isServer || this.#currentResult.isStale || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isValidTimeout)(staleTime)) {\n      return;\n    }\n    const time = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.timeUntilStale)(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_2__.isServer || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(this.options.enabled, this.#currentQuery) === false || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isValidTimeout)(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || _focusManager_js__WEBPACK_IMPORTED_MODULE_3__.focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...(0,_query_js__WEBPACK_IMPORTED_MODULE_4__.fetchState)(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(newState.data);\n          data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.replaceData)(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.replaceData)(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = (0,_thenable_js__WEBPACK_IMPORTED_MODULE_1__.pendingThenable)();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.shallowEqualObjects)(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnabled)(options.enabled, query) !== false && query.isStaleByTime((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.resolveStaleTime)(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.shallowEqualObjects)(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\n\n//# sourceMappingURL=queryObserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlPYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDaUQ7QUFDRTtBQUNYO0FBQ1M7QUFDRDtBQVU1QjtBQUNwQixrQ0FBa0MsMERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkkseURBQWM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhEQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlEQUFjLCtDQUErQyx5REFBYyw2Q0FBNkMsMkRBQWdCLGlEQUFpRCwyREFBZ0I7QUFDalE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlEQUFjLCtDQUErQyx5REFBYztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWEsSUFBSTtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFRLG9DQUFvQyx5REFBYztBQUNsRTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFRLElBQUkseURBQWMseURBQXlELHlEQUFjO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwwREFBWTtBQUNsRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDZEQUFlO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQTJDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5REFBYztBQUMvQztBQUNBO0FBQ0EsU0FBUyx5REFBYywwREFBMEQsMkRBQWdCO0FBQ2pHO0FBQ0E7QUFDQSxPQUFPLDhEQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3F1ZXJ5T2JzZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5T2JzZXJ2ZXIudHNcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gXCIuL2ZvY3VzTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGZldGNoU3RhdGUgfSBmcm9tIFwiLi9xdWVyeS5qc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG5pbXBvcnQgeyBwZW5kaW5nVGhlbmFibGUgfSBmcm9tIFwiLi90aGVuYWJsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNTZXJ2ZXIsXG4gIGlzVmFsaWRUaW1lb3V0LFxuICBub29wLFxuICByZXBsYWNlRGF0YSxcbiAgcmVzb2x2ZUVuYWJsZWQsXG4gIHJlc29sdmVTdGFsZVRpbWUsXG4gIHNoYWxsb3dFcXVhbE9iamVjdHMsXG4gIHRpbWVVbnRpbFN0YWxlXG59IGZyb20gXCIuL3V0aWxzLmpzXCI7XG52YXIgUXVlcnlPYnNlcnZlciA9IGNsYXNzIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLiNzZWxlY3RFcnJvciA9IG51bGw7XG4gICAgdGhpcy4jY3VycmVudFRoZW5hYmxlID0gcGVuZGluZ1RoZW5hYmxlKCk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhwZXJpbWVudGFsX3ByZWZldGNoSW5SZW5kZXIpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRUaGVuYWJsZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihcImV4cGVyaW1lbnRhbF9wcmVmZXRjaEluUmVuZGVyIGZlYXR1cmUgZmxhZyBpcyBub3QgZW5hYmxlZFwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5iaW5kTWV0aG9kcygpO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAjY2xpZW50O1xuICAjY3VycmVudFF1ZXJ5ID0gdm9pZCAwO1xuICAjY3VycmVudFF1ZXJ5SW5pdGlhbFN0YXRlID0gdm9pZCAwO1xuICAjY3VycmVudFJlc3VsdCA9IHZvaWQgMDtcbiAgI2N1cnJlbnRSZXN1bHRTdGF0ZTtcbiAgI2N1cnJlbnRSZXN1bHRPcHRpb25zO1xuICAjY3VycmVudFRoZW5hYmxlO1xuICAjc2VsZWN0RXJyb3I7XG4gICNzZWxlY3RGbjtcbiAgI3NlbGVjdFJlc3VsdDtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBrZWVwcyB0cmFjayBvZiB0aGUgbGFzdCBxdWVyeSB3aXRoIGRlZmluZWQgZGF0YS5cbiAgLy8gSXQgd2lsbCBiZSB1c2VkIHRvIHBhc3MgdGhlIHByZXZpb3VzIGRhdGEgYW5kIHF1ZXJ5IHRvIHRoZSBwbGFjZWhvbGRlciBmdW5jdGlvbiBiZXR3ZWVuIHJlbmRlcnMuXG4gICNsYXN0UXVlcnlXaXRoRGVmaW5lZERhdGE7XG4gICNzdGFsZVRpbWVvdXRJZDtcbiAgI3JlZmV0Y2hJbnRlcnZhbElkO1xuICAjY3VycmVudFJlZmV0Y2hJbnRlcnZhbDtcbiAgI3RyYWNrZWRQcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGJpbmRNZXRob2RzKCkge1xuICAgIHRoaXMucmVmZXRjaCA9IHRoaXMucmVmZXRjaC5iaW5kKHRoaXMpO1xuICB9XG4gIG9uU3Vic2NyaWJlKCkge1xuICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID09PSAxKSB7XG4gICAgICB0aGlzLiNjdXJyZW50UXVlcnkuYWRkT2JzZXJ2ZXIodGhpcyk7XG4gICAgICBpZiAoc2hvdWxkRmV0Y2hPbk1vdW50KHRoaXMuI2N1cnJlbnRRdWVyeSwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICB0aGlzLiNleGVjdXRlRmV0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN1cGRhdGVUaW1lcnMoKTtcbiAgICB9XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBzaG91bGRGZXRjaE9uUmVjb25uZWN0KCkge1xuICAgIHJldHVybiBzaG91bGRGZXRjaE9uKFxuICAgICAgdGhpcy4jY3VycmVudFF1ZXJ5LFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5vcHRpb25zLnJlZmV0Y2hPblJlY29ubmVjdFxuICAgICk7XG4gIH1cbiAgc2hvdWxkRmV0Y2hPbldpbmRvd0ZvY3VzKCkge1xuICAgIHJldHVybiBzaG91bGRGZXRjaE9uKFxuICAgICAgdGhpcy4jY3VycmVudFF1ZXJ5LFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5vcHRpb25zLnJlZmV0Y2hPbldpbmRvd0ZvY3VzXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLiNjbGVhclN0YWxlVGltZW91dCgpO1xuICAgIHRoaXMuI2NsZWFyUmVmZXRjaEludGVydmFsKCk7XG4gICAgdGhpcy4jY3VycmVudFF1ZXJ5LnJlbW92ZU9ic2VydmVyKHRoaXMpO1xuICB9XG4gIHNldE9wdGlvbnMob3B0aW9ucywgbm90aWZ5T3B0aW9ucykge1xuICAgIGNvbnN0IHByZXZPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHByZXZRdWVyeSA9IHRoaXMuI2N1cnJlbnRRdWVyeTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLiNjbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgIT09IHZvaWQgMCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVuYWJsZWQgIT09IFwiYm9vbGVhblwiICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZW5hYmxlZCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZXNvbHZlRW5hYmxlZCh0aGlzLm9wdGlvbnMuZW5hYmxlZCwgdGhpcy4jY3VycmVudFF1ZXJ5KSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBlbmFibGVkIHRvIGJlIGEgYm9vbGVhbiBvciBhIGNhbGxiYWNrIHRoYXQgcmV0dXJucyBhIGJvb2xlYW5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlUXVlcnkoKTtcbiAgICB0aGlzLiNjdXJyZW50UXVlcnkuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIGlmIChwcmV2T3B0aW9ucy5fZGVmYXVsdGVkICYmICFzaGFsbG93RXF1YWxPYmplY3RzKHRoaXMub3B0aW9ucywgcHJldk9wdGlvbnMpKSB7XG4gICAgICB0aGlzLiNjbGllbnQuZ2V0UXVlcnlDYWNoZSgpLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2ZXJPcHRpb25zVXBkYXRlZFwiLFxuICAgICAgICBxdWVyeTogdGhpcy4jY3VycmVudFF1ZXJ5LFxuICAgICAgICBvYnNlcnZlcjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1vdW50ZWQgPSB0aGlzLmhhc0xpc3RlbmVycygpO1xuICAgIGlmIChtb3VudGVkICYmIHNob3VsZEZldGNoT3B0aW9uYWxseShcbiAgICAgIHRoaXMuI2N1cnJlbnRRdWVyeSxcbiAgICAgIHByZXZRdWVyeSxcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHByZXZPcHRpb25zXG4gICAgKSkge1xuICAgICAgdGhpcy4jZXhlY3V0ZUZldGNoKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUmVzdWx0KG5vdGlmeU9wdGlvbnMpO1xuICAgIGlmIChtb3VudGVkICYmICh0aGlzLiNjdXJyZW50UXVlcnkgIT09IHByZXZRdWVyeSB8fCByZXNvbHZlRW5hYmxlZCh0aGlzLm9wdGlvbnMuZW5hYmxlZCwgdGhpcy4jY3VycmVudFF1ZXJ5KSAhPT0gcmVzb2x2ZUVuYWJsZWQocHJldk9wdGlvbnMuZW5hYmxlZCwgdGhpcy4jY3VycmVudFF1ZXJ5KSB8fCByZXNvbHZlU3RhbGVUaW1lKHRoaXMub3B0aW9ucy5zdGFsZVRpbWUsIHRoaXMuI2N1cnJlbnRRdWVyeSkgIT09IHJlc29sdmVTdGFsZVRpbWUocHJldk9wdGlvbnMuc3RhbGVUaW1lLCB0aGlzLiNjdXJyZW50UXVlcnkpKSkge1xuICAgICAgdGhpcy4jdXBkYXRlU3RhbGVUaW1lb3V0KCk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRSZWZldGNoSW50ZXJ2YWwgPSB0aGlzLiNjb21wdXRlUmVmZXRjaEludGVydmFsKCk7XG4gICAgaWYgKG1vdW50ZWQgJiYgKHRoaXMuI2N1cnJlbnRRdWVyeSAhPT0gcHJldlF1ZXJ5IHx8IHJlc29sdmVFbmFibGVkKHRoaXMub3B0aW9ucy5lbmFibGVkLCB0aGlzLiNjdXJyZW50UXVlcnkpICE9PSByZXNvbHZlRW5hYmxlZChwcmV2T3B0aW9ucy5lbmFibGVkLCB0aGlzLiNjdXJyZW50UXVlcnkpIHx8IG5leHRSZWZldGNoSW50ZXJ2YWwgIT09IHRoaXMuI2N1cnJlbnRSZWZldGNoSW50ZXJ2YWwpKSB7XG4gICAgICB0aGlzLiN1cGRhdGVSZWZldGNoSW50ZXJ2YWwobmV4dFJlZmV0Y2hJbnRlcnZhbCk7XG4gICAgfVxuICB9XG4gIGdldE9wdGltaXN0aWNSZXN1bHQob3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy4jY2xpZW50LmdldFF1ZXJ5Q2FjaGUoKS5idWlsZCh0aGlzLiNjbGllbnQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlUmVzdWx0KHF1ZXJ5LCBvcHRpb25zKTtcbiAgICBpZiAoc2hvdWxkQXNzaWduT2JzZXJ2ZXJDdXJyZW50UHJvcGVydGllcyh0aGlzLCByZXN1bHQpKSB7XG4gICAgICB0aGlzLiNjdXJyZW50UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgdGhpcy4jY3VycmVudFJlc3VsdE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB0aGlzLiNjdXJyZW50UmVzdWx0U3RhdGUgPSB0aGlzLiNjdXJyZW50UXVlcnkuc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0Q3VycmVudFJlc3VsdCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFJlc3VsdDtcbiAgfVxuICB0cmFja1Jlc3VsdChyZXN1bHQsIG9uUHJvcFRyYWNrZWQpIHtcbiAgICBjb25zdCB0cmFja2VkUmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFja2VkUmVzdWx0LCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmFja1Byb3Aoa2V5KTtcbiAgICAgICAgICBvblByb3BUcmFja2VkPy4oa2V5KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cmFja2VkUmVzdWx0O1xuICB9XG4gIHRyYWNrUHJvcChrZXkpIHtcbiAgICB0aGlzLiN0cmFja2VkUHJvcHMuYWRkKGtleSk7XG4gIH1cbiAgZ2V0Q3VycmVudFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UXVlcnk7XG4gIH1cbiAgcmVmZXRjaCh7IC4uLm9wdGlvbnMgfSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2goe1xuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGZldGNoT3B0aW1pc3RpYyhvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdGVkT3B0aW9ucyA9IHRoaXMuI2NsaWVudC5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy4jY2xpZW50LmdldFF1ZXJ5Q2FjaGUoKS5idWlsZCh0aGlzLiNjbGllbnQsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgIHJldHVybiBxdWVyeS5mZXRjaCgpLnRoZW4oKCkgPT4gdGhpcy5jcmVhdGVSZXN1bHQocXVlcnksIGRlZmF1bHRlZE9wdGlvbnMpKTtcbiAgfVxuICBmZXRjaChmZXRjaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy4jZXhlY3V0ZUZldGNoKHtcbiAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgIGNhbmNlbFJlZmV0Y2g6IGZldGNoT3B0aW9ucy5jYW5jZWxSZWZldGNoID8/IHRydWVcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XG4gICAgICByZXR1cm4gdGhpcy4jY3VycmVudFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICAjZXhlY3V0ZUZldGNoKGZldGNoT3B0aW9ucykge1xuICAgIHRoaXMuI3VwZGF0ZVF1ZXJ5KCk7XG4gICAgbGV0IHByb21pc2UgPSB0aGlzLiNjdXJyZW50UXVlcnkuZmV0Y2goXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICBmZXRjaE9wdGlvbnNcbiAgICApO1xuICAgIGlmICghZmV0Y2hPcHRpb25zPy50aHJvd09uRXJyb3IpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLmNhdGNoKG5vb3ApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAjdXBkYXRlU3RhbGVUaW1lb3V0KCkge1xuICAgIHRoaXMuI2NsZWFyU3RhbGVUaW1lb3V0KCk7XG4gICAgY29uc3Qgc3RhbGVUaW1lID0gcmVzb2x2ZVN0YWxlVGltZShcbiAgICAgIHRoaXMub3B0aW9ucy5zdGFsZVRpbWUsXG4gICAgICB0aGlzLiNjdXJyZW50UXVlcnlcbiAgICApO1xuICAgIGlmIChpc1NlcnZlciB8fCB0aGlzLiNjdXJyZW50UmVzdWx0LmlzU3RhbGUgfHwgIWlzVmFsaWRUaW1lb3V0KHN0YWxlVGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IHRpbWVVbnRpbFN0YWxlKHRoaXMuI2N1cnJlbnRSZXN1bHQuZGF0YVVwZGF0ZWRBdCwgc3RhbGVUaW1lKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gdGltZSArIDE7XG4gICAgdGhpcy4jc3RhbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy4jY3VycmVudFJlc3VsdC5pc1N0YWxlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCk7XG4gIH1cbiAgI2NvbXB1dGVSZWZldGNoSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbCh0aGlzLiNjdXJyZW50UXVlcnkpIDogdGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbCkgPz8gZmFsc2U7XG4gIH1cbiAgI3VwZGF0ZVJlZmV0Y2hJbnRlcnZhbChuZXh0SW50ZXJ2YWwpIHtcbiAgICB0aGlzLiNjbGVhclJlZmV0Y2hJbnRlcnZhbCgpO1xuICAgIHRoaXMuI2N1cnJlbnRSZWZldGNoSW50ZXJ2YWwgPSBuZXh0SW50ZXJ2YWw7XG4gICAgaWYgKGlzU2VydmVyIHx8IHJlc29sdmVFbmFibGVkKHRoaXMub3B0aW9ucy5lbmFibGVkLCB0aGlzLiNjdXJyZW50UXVlcnkpID09PSBmYWxzZSB8fCAhaXNWYWxpZFRpbWVvdXQodGhpcy4jY3VycmVudFJlZmV0Y2hJbnRlcnZhbCkgfHwgdGhpcy4jY3VycmVudFJlZmV0Y2hJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXRjaEludGVydmFsSW5CYWNrZ3JvdW5kIHx8IGZvY3VzTWFuYWdlci5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLiNleGVjdXRlRmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLiNjdXJyZW50UmVmZXRjaEludGVydmFsKTtcbiAgfVxuICAjdXBkYXRlVGltZXJzKCkge1xuICAgIHRoaXMuI3VwZGF0ZVN0YWxlVGltZW91dCgpO1xuICAgIHRoaXMuI3VwZGF0ZVJlZmV0Y2hJbnRlcnZhbCh0aGlzLiNjb21wdXRlUmVmZXRjaEludGVydmFsKCkpO1xuICB9XG4gICNjbGVhclN0YWxlVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy4jc3RhbGVUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNzdGFsZVRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNzdGFsZVRpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgI2NsZWFyUmVmZXRjaEludGVydmFsKCkge1xuICAgIGlmICh0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgY3JlYXRlUmVzdWx0KHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJldlF1ZXJ5ID0gdGhpcy4jY3VycmVudFF1ZXJ5O1xuICAgIGNvbnN0IHByZXZPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHByZXZSZXN1bHQgPSB0aGlzLiNjdXJyZW50UmVzdWx0O1xuICAgIGNvbnN0IHByZXZSZXN1bHRTdGF0ZSA9IHRoaXMuI2N1cnJlbnRSZXN1bHRTdGF0ZTtcbiAgICBjb25zdCBwcmV2UmVzdWx0T3B0aW9ucyA9IHRoaXMuI2N1cnJlbnRSZXN1bHRPcHRpb25zO1xuICAgIGNvbnN0IHF1ZXJ5Q2hhbmdlID0gcXVlcnkgIT09IHByZXZRdWVyeTtcbiAgICBjb25zdCBxdWVyeUluaXRpYWxTdGF0ZSA9IHF1ZXJ5Q2hhbmdlID8gcXVlcnkuc3RhdGUgOiB0aGlzLiNjdXJyZW50UXVlcnlJbml0aWFsU3RhdGU7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gcXVlcnk7XG4gICAgbGV0IG5ld1N0YXRlID0geyAuLi5zdGF0ZSB9O1xuICAgIGxldCBpc1BsYWNlaG9sZGVyRGF0YSA9IGZhbHNlO1xuICAgIGxldCBkYXRhO1xuICAgIGlmIChvcHRpb25zLl9vcHRpbWlzdGljUmVzdWx0cykge1xuICAgICAgY29uc3QgbW91bnRlZCA9IHRoaXMuaGFzTGlzdGVuZXJzKCk7XG4gICAgICBjb25zdCBmZXRjaE9uTW91bnQgPSAhbW91bnRlZCAmJiBzaG91bGRGZXRjaE9uTW91bnQocXVlcnksIG9wdGlvbnMpO1xuICAgICAgY29uc3QgZmV0Y2hPcHRpb25hbGx5ID0gbW91bnRlZCAmJiBzaG91bGRGZXRjaE9wdGlvbmFsbHkocXVlcnksIHByZXZRdWVyeSwgb3B0aW9ucywgcHJldk9wdGlvbnMpO1xuICAgICAgaWYgKGZldGNoT25Nb3VudCB8fCBmZXRjaE9wdGlvbmFsbHkpIHtcbiAgICAgICAgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgLi4uZmV0Y2hTdGF0ZShzdGF0ZS5kYXRhLCBxdWVyeS5vcHRpb25zKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuX29wdGltaXN0aWNSZXN1bHRzID09PSBcImlzUmVzdG9yaW5nXCIpIHtcbiAgICAgICAgbmV3U3RhdGUuZmV0Y2hTdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHsgZXJyb3IsIGVycm9yVXBkYXRlZEF0LCBzdGF0dXMgfSA9IG5ld1N0YXRlO1xuICAgIGlmIChvcHRpb25zLnNlbGVjdCAmJiBuZXdTdGF0ZS5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChwcmV2UmVzdWx0ICYmIG5ld1N0YXRlLmRhdGEgPT09IHByZXZSZXN1bHRTdGF0ZT8uZGF0YSAmJiBvcHRpb25zLnNlbGVjdCA9PT0gdGhpcy4jc2VsZWN0Rm4pIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuI3NlbGVjdFJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy4jc2VsZWN0Rm4gPSBvcHRpb25zLnNlbGVjdDtcbiAgICAgICAgICBkYXRhID0gb3B0aW9ucy5zZWxlY3QobmV3U3RhdGUuZGF0YSk7XG4gICAgICAgICAgZGF0YSA9IHJlcGxhY2VEYXRhKHByZXZSZXN1bHQ/LmRhdGEsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuI3NlbGVjdFJlc3VsdCA9IGRhdGE7XG4gICAgICAgICAgdGhpcy4jc2VsZWN0RXJyb3IgPSBudWxsO1xuICAgICAgICB9IGNhdGNoIChzZWxlY3RFcnJvcikge1xuICAgICAgICAgIHRoaXMuI3NlbGVjdEVycm9yID0gc2VsZWN0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IG5ld1N0YXRlLmRhdGE7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyRGF0YSAhPT0gdm9pZCAwICYmIGRhdGEgPT09IHZvaWQgMCAmJiBzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICBsZXQgcGxhY2Vob2xkZXJEYXRhO1xuICAgICAgaWYgKHByZXZSZXN1bHQ/LmlzUGxhY2Vob2xkZXJEYXRhICYmIG9wdGlvbnMucGxhY2Vob2xkZXJEYXRhID09PSBwcmV2UmVzdWx0T3B0aW9ucz8ucGxhY2Vob2xkZXJEYXRhKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyRGF0YSA9IHByZXZSZXN1bHQuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsYWNlaG9sZGVyRGF0YSA9IHR5cGVvZiBvcHRpb25zLnBsYWNlaG9sZGVyRGF0YSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5wbGFjZWhvbGRlckRhdGEoXG4gICAgICAgICAgdGhpcy4jbGFzdFF1ZXJ5V2l0aERlZmluZWREYXRhPy5zdGF0ZS5kYXRhLFxuICAgICAgICAgIHRoaXMuI2xhc3RRdWVyeVdpdGhEZWZpbmVkRGF0YVxuICAgICAgICApIDogb3B0aW9ucy5wbGFjZWhvbGRlckRhdGE7XG4gICAgICAgIGlmIChvcHRpb25zLnNlbGVjdCAmJiBwbGFjZWhvbGRlckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlckRhdGEgPSBvcHRpb25zLnNlbGVjdChwbGFjZWhvbGRlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy4jc2VsZWN0RXJyb3IgPSBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKHNlbGVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNzZWxlY3RFcnJvciA9IHNlbGVjdEVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYWNlaG9sZGVyRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICBkYXRhID0gcmVwbGFjZURhdGEoXG4gICAgICAgICAgcHJldlJlc3VsdD8uZGF0YSxcbiAgICAgICAgICBwbGFjZWhvbGRlckRhdGEsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBpc1BsYWNlaG9sZGVyRGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLiNzZWxlY3RFcnJvcikge1xuICAgICAgZXJyb3IgPSB0aGlzLiNzZWxlY3RFcnJvcjtcbiAgICAgIGRhdGEgPSB0aGlzLiNzZWxlY3RSZXN1bHQ7XG4gICAgICBlcnJvclVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBzdGF0dXMgPSBcImVycm9yXCI7XG4gICAgfVxuICAgIGNvbnN0IGlzRmV0Y2hpbmcgPSBuZXdTdGF0ZS5mZXRjaFN0YXR1cyA9PT0gXCJmZXRjaGluZ1wiO1xuICAgIGNvbnN0IGlzUGVuZGluZyA9IHN0YXR1cyA9PT0gXCJwZW5kaW5nXCI7XG4gICAgY29uc3QgaXNFcnJvciA9IHN0YXR1cyA9PT0gXCJlcnJvclwiO1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IGlzUGVuZGluZyAmJiBpc0ZldGNoaW5nO1xuICAgIGNvbnN0IGhhc0RhdGEgPSBkYXRhICE9PSB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgc3RhdHVzLFxuICAgICAgZmV0Y2hTdGF0dXM6IG5ld1N0YXRlLmZldGNoU3RhdHVzLFxuICAgICAgaXNQZW5kaW5nLFxuICAgICAgaXNTdWNjZXNzOiBzdGF0dXMgPT09IFwic3VjY2Vzc1wiLFxuICAgICAgaXNFcnJvcixcbiAgICAgIGlzSW5pdGlhbExvYWRpbmc6IGlzTG9hZGluZyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGRhdGEsXG4gICAgICBkYXRhVXBkYXRlZEF0OiBuZXdTdGF0ZS5kYXRhVXBkYXRlZEF0LFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvclVwZGF0ZWRBdCxcbiAgICAgIGZhaWx1cmVDb3VudDogbmV3U3RhdGUuZmV0Y2hGYWlsdXJlQ291bnQsXG4gICAgICBmYWlsdXJlUmVhc29uOiBuZXdTdGF0ZS5mZXRjaEZhaWx1cmVSZWFzb24sXG4gICAgICBlcnJvclVwZGF0ZUNvdW50OiBuZXdTdGF0ZS5lcnJvclVwZGF0ZUNvdW50LFxuICAgICAgaXNGZXRjaGVkOiBuZXdTdGF0ZS5kYXRhVXBkYXRlQ291bnQgPiAwIHx8IG5ld1N0YXRlLmVycm9yVXBkYXRlQ291bnQgPiAwLFxuICAgICAgaXNGZXRjaGVkQWZ0ZXJNb3VudDogbmV3U3RhdGUuZGF0YVVwZGF0ZUNvdW50ID4gcXVlcnlJbml0aWFsU3RhdGUuZGF0YVVwZGF0ZUNvdW50IHx8IG5ld1N0YXRlLmVycm9yVXBkYXRlQ291bnQgPiBxdWVyeUluaXRpYWxTdGF0ZS5lcnJvclVwZGF0ZUNvdW50LFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGlzUmVmZXRjaGluZzogaXNGZXRjaGluZyAmJiAhaXNQZW5kaW5nLFxuICAgICAgaXNMb2FkaW5nRXJyb3I6IGlzRXJyb3IgJiYgIWhhc0RhdGEsXG4gICAgICBpc1BhdXNlZDogbmV3U3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwicGF1c2VkXCIsXG4gICAgICBpc1BsYWNlaG9sZGVyRGF0YSxcbiAgICAgIGlzUmVmZXRjaEVycm9yOiBpc0Vycm9yICYmIGhhc0RhdGEsXG4gICAgICBpc1N0YWxlOiBpc1N0YWxlKHF1ZXJ5LCBvcHRpb25zKSxcbiAgICAgIHJlZmV0Y2g6IHRoaXMucmVmZXRjaCxcbiAgICAgIHByb21pc2U6IHRoaXMuI2N1cnJlbnRUaGVuYWJsZVxuICAgIH07XG4gICAgY29uc3QgbmV4dFJlc3VsdCA9IHJlc3VsdDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmV4cGVyaW1lbnRhbF9wcmVmZXRjaEluUmVuZGVyKSB7XG4gICAgICBjb25zdCBmaW5hbGl6ZVRoZW5hYmxlSWZQb3NzaWJsZSA9ICh0aGVuYWJsZSkgPT4ge1xuICAgICAgICBpZiAobmV4dFJlc3VsdC5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRoZW5hYmxlLnJlamVjdChuZXh0UmVzdWx0LmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0UmVzdWx0LmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoZW5hYmxlLnJlc29sdmUobmV4dFJlc3VsdC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlY3JlYXRlVGhlbmFibGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLiNjdXJyZW50VGhlbmFibGUgPSBuZXh0UmVzdWx0LnByb21pc2UgPSBwZW5kaW5nVGhlbmFibGUoKTtcbiAgICAgICAgZmluYWxpemVUaGVuYWJsZUlmUG9zc2libGUocGVuZGluZyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJldlRoZW5hYmxlID0gdGhpcy4jY3VycmVudFRoZW5hYmxlO1xuICAgICAgc3dpdGNoIChwcmV2VGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5SGFzaCA9PT0gcHJldlF1ZXJ5LnF1ZXJ5SGFzaCkge1xuICAgICAgICAgICAgZmluYWxpemVUaGVuYWJsZUlmUG9zc2libGUocHJldlRoZW5hYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICBpZiAobmV4dFJlc3VsdC5zdGF0dXMgPT09IFwiZXJyb3JcIiB8fCBuZXh0UmVzdWx0LmRhdGEgIT09IHByZXZUaGVuYWJsZS52YWx1ZSkge1xuICAgICAgICAgICAgcmVjcmVhdGVUaGVuYWJsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgaWYgKG5leHRSZXN1bHQuc3RhdHVzICE9PSBcImVycm9yXCIgfHwgbmV4dFJlc3VsdC5lcnJvciAhPT0gcHJldlRoZW5hYmxlLnJlYXNvbikge1xuICAgICAgICAgICAgcmVjcmVhdGVUaGVuYWJsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRSZXN1bHQ7XG4gIH1cbiAgdXBkYXRlUmVzdWx0KG5vdGlmeU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmV2UmVzdWx0ID0gdGhpcy4jY3VycmVudFJlc3VsdDtcbiAgICBjb25zdCBuZXh0UmVzdWx0ID0gdGhpcy5jcmVhdGVSZXN1bHQodGhpcy4jY3VycmVudFF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuI2N1cnJlbnRSZXN1bHRTdGF0ZSA9IHRoaXMuI2N1cnJlbnRRdWVyeS5zdGF0ZTtcbiAgICB0aGlzLiNjdXJyZW50UmVzdWx0T3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy4jY3VycmVudFJlc3VsdFN0YXRlLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy4jbGFzdFF1ZXJ5V2l0aERlZmluZWREYXRhID0gdGhpcy4jY3VycmVudFF1ZXJ5O1xuICAgIH1cbiAgICBpZiAoc2hhbGxvd0VxdWFsT2JqZWN0cyhuZXh0UmVzdWx0LCBwcmV2UmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50UmVzdWx0ID0gbmV4dFJlc3VsdDtcbiAgICBjb25zdCBkZWZhdWx0Tm90aWZ5T3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IHNob3VsZE5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIGlmICghcHJldlJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbm90aWZ5T25DaGFuZ2VQcm9wcyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3Qgbm90aWZ5T25DaGFuZ2VQcm9wc1ZhbHVlID0gdHlwZW9mIG5vdGlmeU9uQ2hhbmdlUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IG5vdGlmeU9uQ2hhbmdlUHJvcHMoKSA6IG5vdGlmeU9uQ2hhbmdlUHJvcHM7XG4gICAgICBpZiAobm90aWZ5T25DaGFuZ2VQcm9wc1ZhbHVlID09PSBcImFsbFwiIHx8ICFub3RpZnlPbkNoYW5nZVByb3BzVmFsdWUgJiYgIXRoaXMuI3RyYWNrZWRQcm9wcy5zaXplKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5jbHVkZWRQcm9wcyA9IG5ldyBTZXQoXG4gICAgICAgIG5vdGlmeU9uQ2hhbmdlUHJvcHNWYWx1ZSA/PyB0aGlzLiN0cmFja2VkUHJvcHNcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRocm93T25FcnJvcikge1xuICAgICAgICBpbmNsdWRlZFByb3BzLmFkZChcImVycm9yXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuI2N1cnJlbnRSZXN1bHQpLnNvbWUoKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleTtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuI2N1cnJlbnRSZXN1bHRbdHlwZWRLZXldICE9PSBwcmV2UmVzdWx0W3R5cGVkS2V5XTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQgJiYgaW5jbHVkZWRQcm9wcy5oYXModHlwZWRLZXkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAobm90aWZ5T3B0aW9ucz8ubGlzdGVuZXJzICE9PSBmYWxzZSAmJiBzaG91bGROb3RpZnlMaXN0ZW5lcnMoKSkge1xuICAgICAgZGVmYXVsdE5vdGlmeU9wdGlvbnMubGlzdGVuZXJzID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4jbm90aWZ5KHsgLi4uZGVmYXVsdE5vdGlmeU9wdGlvbnMsIC4uLm5vdGlmeU9wdGlvbnMgfSk7XG4gIH1cbiAgI3VwZGF0ZVF1ZXJ5KCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy4jY2xpZW50LmdldFF1ZXJ5Q2FjaGUoKS5idWlsZCh0aGlzLiNjbGllbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKHF1ZXJ5ID09PSB0aGlzLiNjdXJyZW50UXVlcnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldlF1ZXJ5ID0gdGhpcy4jY3VycmVudFF1ZXJ5O1xuICAgIHRoaXMuI2N1cnJlbnRRdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMuI2N1cnJlbnRRdWVyeUluaXRpYWxTdGF0ZSA9IHF1ZXJ5LnN0YXRlO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICBwcmV2UXVlcnk/LnJlbW92ZU9ic2VydmVyKHRoaXMpO1xuICAgICAgcXVlcnkuYWRkT2JzZXJ2ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIG9uUXVlcnlVcGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVSZXN1bHQoKTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgdGhpcy4jdXBkYXRlVGltZXJzKCk7XG4gICAgfVxuICB9XG4gICNub3RpZnkobm90aWZ5T3B0aW9ucykge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgaWYgKG5vdGlmeU9wdGlvbnMubGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXIodGhpcy4jY3VycmVudFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy4jY2xpZW50LmdldFF1ZXJ5Q2FjaGUoKS5ub3RpZnkoe1xuICAgICAgICBxdWVyeTogdGhpcy4jY3VycmVudFF1ZXJ5LFxuICAgICAgICB0eXBlOiBcIm9ic2VydmVyUmVzdWx0c1VwZGF0ZWRcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRMb2FkT25Nb3VudChxdWVyeSwgb3B0aW9ucykge1xuICByZXR1cm4gcmVzb2x2ZUVuYWJsZWQob3B0aW9ucy5lbmFibGVkLCBxdWVyeSkgIT09IGZhbHNlICYmIHF1ZXJ5LnN0YXRlLmRhdGEgPT09IHZvaWQgMCAmJiAhKHF1ZXJ5LnN0YXRlLnN0YXR1cyA9PT0gXCJlcnJvclwiICYmIG9wdGlvbnMucmV0cnlPbk1vdW50ID09PSBmYWxzZSk7XG59XG5mdW5jdGlvbiBzaG91bGRGZXRjaE9uTW91bnQocXVlcnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNob3VsZExvYWRPbk1vdW50KHF1ZXJ5LCBvcHRpb25zKSB8fCBxdWVyeS5zdGF0ZS5kYXRhICE9PSB2b2lkIDAgJiYgc2hvdWxkRmV0Y2hPbihxdWVyeSwgb3B0aW9ucywgb3B0aW9ucy5yZWZldGNoT25Nb3VudCk7XG59XG5mdW5jdGlvbiBzaG91bGRGZXRjaE9uKHF1ZXJ5LCBvcHRpb25zLCBmaWVsZCkge1xuICBpZiAocmVzb2x2ZUVuYWJsZWQob3B0aW9ucy5lbmFibGVkLCBxdWVyeSkgIT09IGZhbHNlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgZmllbGQgPT09IFwiZnVuY3Rpb25cIiA/IGZpZWxkKHF1ZXJ5KSA6IGZpZWxkO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gXCJhbHdheXNcIiB8fCB2YWx1ZSAhPT0gZmFsc2UgJiYgaXNTdGFsZShxdWVyeSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkRmV0Y2hPcHRpb25hbGx5KHF1ZXJ5LCBwcmV2UXVlcnksIG9wdGlvbnMsIHByZXZPcHRpb25zKSB7XG4gIHJldHVybiAocXVlcnkgIT09IHByZXZRdWVyeSB8fCByZXNvbHZlRW5hYmxlZChwcmV2T3B0aW9ucy5lbmFibGVkLCBxdWVyeSkgPT09IGZhbHNlKSAmJiAoIW9wdGlvbnMuc3VzcGVuc2UgfHwgcXVlcnkuc3RhdGUuc3RhdHVzICE9PSBcImVycm9yXCIpICYmIGlzU3RhbGUocXVlcnksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaXNTdGFsZShxdWVyeSwgb3B0aW9ucykge1xuICByZXR1cm4gcmVzb2x2ZUVuYWJsZWQob3B0aW9ucy5lbmFibGVkLCBxdWVyeSkgIT09IGZhbHNlICYmIHF1ZXJ5LmlzU3RhbGVCeVRpbWUocmVzb2x2ZVN0YWxlVGltZShvcHRpb25zLnN0YWxlVGltZSwgcXVlcnkpKTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFzc2lnbk9ic2VydmVyQ3VycmVudFByb3BlcnRpZXMob2JzZXJ2ZXIsIG9wdGltaXN0aWNSZXN1bHQpIHtcbiAgaWYgKCFzaGFsbG93RXF1YWxPYmplY3RzKG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKSwgb3B0aW1pc3RpY1Jlc3VsdCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQge1xuICBRdWVyeU9ic2VydmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlPYnNlcnZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryObserver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/removable.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Removable: () => (/* binding */ Removable)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/removable.ts\n\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isValidTimeout)(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\n\n//# sourceMappingURL=removable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmVtb3ZhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9yZW1vdmFibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3JlbW92YWJsZS50c1xuaW1wb3J0IHsgaXNTZXJ2ZXIsIGlzVmFsaWRUaW1lb3V0IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBSZW1vdmFibGUgPSBjbGFzcyB7XG4gICNnY1RpbWVvdXQ7XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICB9XG4gIHNjaGVkdWxlR2MoKSB7XG4gICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICAgIGlmIChpc1ZhbGlkVGltZW91dCh0aGlzLmdjVGltZSkpIHtcbiAgICAgIHRoaXMuI2djVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm9wdGlvbmFsUmVtb3ZlKCk7XG4gICAgICB9LCB0aGlzLmdjVGltZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUdjVGltZShuZXdHY1RpbWUpIHtcbiAgICB0aGlzLmdjVGltZSA9IE1hdGgubWF4KFxuICAgICAgdGhpcy5nY1RpbWUgfHwgMCxcbiAgICAgIG5ld0djVGltZSA/PyAoaXNTZXJ2ZXIgPyBJbmZpbml0eSA6IDUgKiA2MCAqIDFlMylcbiAgICApO1xuICB9XG4gIGNsZWFyR2NUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLiNnY1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNnY1RpbWVvdXQpO1xuICAgICAgdGhpcy4jZ2NUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCB7XG4gIFJlbW92YWJsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92YWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/retryer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancelledError: () => (/* binding */ CancelledError),\n/* harmony export */   canFetch: () => (/* binding */ canFetch),\n/* harmony export */   createRetryer: () => (/* binding */ createRetryer),\n/* harmony export */   isCancelledError: () => (/* binding */ isCancelledError)\n/* harmony export */ });\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _thenable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thenable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/thenable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/retryer.ts\n\n\n\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  const thenable = (0,_thenable_js__WEBPACK_IMPORTED_MODULE_1__.pendingThenable)();\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.isFocused() && (config.networkMode === \"always\" || _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      thenable.resolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      thenable.reject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (_utils_js__WEBPACK_IMPORTED_MODULE_3__.isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.sleep)(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return thenable;\n    }\n  };\n}\n\n//# sourceMappingURL=retryer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmV0cnllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ2lEO0FBQ0U7QUFDSDtBQUNIO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDREQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwREFBWSxvREFBb0QsNERBQWE7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQ0FBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdEQUFLO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmV0cnllci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcmV0cnllci50c1xuaW1wb3J0IHsgZm9jdXNNYW5hZ2VyIH0gZnJvbSBcIi4vZm9jdXNNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBvbmxpbmVNYW5hZ2VyIH0gZnJvbSBcIi4vb25saW5lTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgcGVuZGluZ1RoZW5hYmxlIH0gZnJvbSBcIi4vdGhlbmFibGUuanNcIjtcbmltcG9ydCB7IGlzU2VydmVyLCBzbGVlcCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiBkZWZhdWx0UmV0cnlEZWxheShmYWlsdXJlQ291bnQpIHtcbiAgcmV0dXJuIE1hdGgubWluKDFlMyAqIDIgKiogZmFpbHVyZUNvdW50LCAzZTQpO1xufVxuZnVuY3Rpb24gY2FuRmV0Y2gobmV0d29ya01vZGUpIHtcbiAgcmV0dXJuIChuZXR3b3JrTW9kZSA/PyBcIm9ubGluZVwiKSA9PT0gXCJvbmxpbmVcIiA/IG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSA6IHRydWU7XG59XG52YXIgQ2FuY2VsbGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwiQ2FuY2VsbGVkRXJyb3JcIik7XG4gICAgdGhpcy5yZXZlcnQgPSBvcHRpb25zPy5yZXZlcnQ7XG4gICAgdGhpcy5zaWxlbnQgPSBvcHRpb25zPy5zaWxlbnQ7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0NhbmNlbGxlZEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENhbmNlbGxlZEVycm9yO1xufVxuZnVuY3Rpb24gY3JlYXRlUmV0cnllcihjb25maWcpIHtcbiAgbGV0IGlzUmV0cnlDYW5jZWxsZWQgPSBmYWxzZTtcbiAgbGV0IGZhaWx1cmVDb3VudCA9IDA7XG4gIGxldCBpc1Jlc29sdmVkID0gZmFsc2U7XG4gIGxldCBjb250aW51ZUZuO1xuICBjb25zdCB0aGVuYWJsZSA9IHBlbmRpbmdUaGVuYWJsZSgpO1xuICBjb25zdCBjYW5jZWwgPSAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgcmVqZWN0KG5ldyBDYW5jZWxsZWRFcnJvcihjYW5jZWxPcHRpb25zKSk7XG4gICAgICBjb25maWcuYWJvcnQ/LigpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2FuY2VsUmV0cnkgPSAoKSA9PiB7XG4gICAgaXNSZXRyeUNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG4gIGNvbnN0IGNvbnRpbnVlUmV0cnkgPSAoKSA9PiB7XG4gICAgaXNSZXRyeUNhbmNlbGxlZCA9IGZhbHNlO1xuICB9O1xuICBjb25zdCBjYW5Db250aW51ZSA9ICgpID0+IGZvY3VzTWFuYWdlci5pc0ZvY3VzZWQoKSAmJiAoY29uZmlnLm5ldHdvcmtNb2RlID09PSBcImFsd2F5c1wiIHx8IG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSkgJiYgY29uZmlnLmNhblJ1bigpO1xuICBjb25zdCBjYW5TdGFydCA9ICgpID0+IGNhbkZldGNoKGNvbmZpZy5uZXR3b3JrTW9kZSkgJiYgY29uZmlnLmNhblJ1bigpO1xuICBjb25zdCByZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5vblN1Y2Nlc3M/Lih2YWx1ZSk7XG4gICAgICBjb250aW51ZUZuPy4oKTtcbiAgICAgIHRoZW5hYmxlLnJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5vbkVycm9yPy4odmFsdWUpO1xuICAgICAgY29udGludWVGbj8uKCk7XG4gICAgICB0aGVuYWJsZS5yZWplY3QodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF1c2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChjb250aW51ZVJlc29sdmUpID0+IHtcbiAgICAgIGNvbnRpbnVlRm4gPSAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzUmVzb2x2ZWQgfHwgY2FuQ29udGludWUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25maWcub25QYXVzZT8uKCk7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBjb250aW51ZUZuID0gdm9pZCAwO1xuICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgIGNvbmZpZy5vbkNvbnRpbnVlPy4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcm9taXNlT3JWYWx1ZTtcbiAgICBjb25zdCBpbml0aWFsUHJvbWlzZSA9IGZhaWx1cmVDb3VudCA9PT0gMCA/IGNvbmZpZy5pbml0aWFsUHJvbWlzZSA6IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZU9yVmFsdWUgPSBpbml0aWFsUHJvbWlzZSA/PyBjb25maWcuZm4oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJvbWlzZU9yVmFsdWUgPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlT3JWYWx1ZSkudGhlbihyZXNvbHZlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHJ5ID0gY29uZmlnLnJldHJ5ID8/IChpc1NlcnZlciA/IDAgOiAzKTtcbiAgICAgIGNvbnN0IHJldHJ5RGVsYXkgPSBjb25maWcucmV0cnlEZWxheSA/PyBkZWZhdWx0UmV0cnlEZWxheTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gdHlwZW9mIHJldHJ5RGVsYXkgPT09IFwiZnVuY3Rpb25cIiA/IHJldHJ5RGVsYXkoZmFpbHVyZUNvdW50LCBlcnJvcikgOiByZXRyeURlbGF5O1xuICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSByZXRyeSA9PT0gdHJ1ZSB8fCB0eXBlb2YgcmV0cnkgPT09IFwibnVtYmVyXCIgJiYgZmFpbHVyZUNvdW50IDwgcmV0cnkgfHwgdHlwZW9mIHJldHJ5ID09PSBcImZ1bmN0aW9uXCIgJiYgcmV0cnkoZmFpbHVyZUNvdW50LCBlcnJvcik7XG4gICAgICBpZiAoaXNSZXRyeUNhbmNlbGxlZCB8fCAhc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFpbHVyZUNvdW50Kys7XG4gICAgICBjb25maWcub25GYWlsPy4oZmFpbHVyZUNvdW50LCBlcnJvcik7XG4gICAgICBzbGVlcChkZWxheSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBjYW5Db250aW51ZSgpID8gdm9pZCAwIDogcGF1c2UoKTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNSZXRyeUNhbmNlbGxlZCkge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHByb21pc2U6IHRoZW5hYmxlLFxuICAgIGNhbmNlbCxcbiAgICBjb250aW51ZTogKCkgPT4ge1xuICAgICAgY29udGludWVGbj8uKCk7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfSxcbiAgICBjYW5jZWxSZXRyeSxcbiAgICBjb250aW51ZVJldHJ5LFxuICAgIGNhblN0YXJ0LFxuICAgIHN0YXJ0OiAoKSA9PiB7XG4gICAgICBpZiAoY2FuU3RhcnQoKSkge1xuICAgICAgICBydW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdXNlKCkudGhlbihydW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIENhbmNlbGxlZEVycm9yLFxuICBjYW5GZXRjaCxcbiAgY3JlYXRlUmV0cnllcixcbiAgaXNDYW5jZWxsZWRFcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/subscribable.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subscribable: () => (/* binding */ Subscribable)\n/* harmony export */ });\n// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\n\n//# sourceMappingURL=subscribable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vc3Vic2NyaWJhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3N1YnNjcmliYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3Vic2NyaWJhYmxlLnRzXG52YXIgU3Vic2NyaWJhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICB9XG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgdGhpcy5vblN1YnNjcmliZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgdGhpcy5vblVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfVxuICBoYXNMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnNpemUgPiAwO1xuICB9XG4gIG9uU3Vic2NyaWJlKCkge1xuICB9XG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gIH1cbn07XG5leHBvcnQge1xuICBTdWJzY3JpYmFibGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmFibGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/thenable.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/thenable.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pendingThenable: () => (/* binding */ pendingThenable)\n/* harmony export */ });\n// src/thenable.ts\nfunction pendingThenable() {\n  let resolve;\n  let reject;\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  thenable.status = \"pending\";\n  thenable.catch(() => {\n  });\n  function finalize(data) {\n    Object.assign(thenable, data);\n    delete thenable.resolve;\n    delete thenable.reject;\n  }\n  thenable.resolve = (value) => {\n    finalize({\n      status: \"fulfilled\",\n      value\n    });\n    resolve(value);\n  };\n  thenable.reject = (reason) => {\n    finalize({\n      status: \"rejected\",\n      reason\n    });\n    reject(reason);\n  };\n  return thenable;\n}\n\n//# sourceMappingURL=thenable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdGhlbmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3RoZW5hYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy90aGVuYWJsZS50c1xuZnVuY3Rpb24gcGVuZGluZ1RoZW5hYmxlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgdGhlbmFibGUgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgcmVqZWN0ID0gX3JlamVjdDtcbiAgfSk7XG4gIHRoZW5hYmxlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICB0aGVuYWJsZS5jYXRjaCgoKSA9PiB7XG4gIH0pO1xuICBmdW5jdGlvbiBmaW5hbGl6ZShkYXRhKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGVuYWJsZSwgZGF0YSk7XG4gICAgZGVsZXRlIHRoZW5hYmxlLnJlc29sdmU7XG4gICAgZGVsZXRlIHRoZW5hYmxlLnJlamVjdDtcbiAgfVxuICB0aGVuYWJsZS5yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgZmluYWxpemUoe1xuICAgICAgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfTtcbiAgdGhlbmFibGUucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgIGZpbmFsaXplKHtcbiAgICAgIHN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgcmVhc29uXG4gICAgfSk7XG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH07XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cbmV4cG9ydCB7XG4gIHBlbmRpbmdUaGVuYWJsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoZW5hYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/thenable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToEnd: () => (/* binding */ addToEnd),\n/* harmony export */   addToStart: () => (/* binding */ addToStart),\n/* harmony export */   ensureQueryFn: () => (/* binding */ ensureQueryFn),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   hashKey: () => (/* binding */ hashKey),\n/* harmony export */   hashQueryKeyByOptions: () => (/* binding */ hashQueryKeyByOptions),\n/* harmony export */   isPlainArray: () => (/* binding */ isPlainArray),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isServer: () => (/* binding */ isServer),\n/* harmony export */   isValidTimeout: () => (/* binding */ isValidTimeout),\n/* harmony export */   keepPreviousData: () => (/* binding */ keepPreviousData),\n/* harmony export */   matchMutation: () => (/* binding */ matchMutation),\n/* harmony export */   matchQuery: () => (/* binding */ matchQuery),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   partialMatchKey: () => (/* binding */ partialMatchKey),\n/* harmony export */   replaceData: () => (/* binding */ replaceData),\n/* harmony export */   replaceEqualDeep: () => (/* binding */ replaceEqualDeep),\n/* harmony export */   resolveEnabled: () => (/* binding */ resolveEnabled),\n/* harmony export */   resolveStaleTime: () => (/* binding */ resolveStaleTime),\n/* harmony export */   shallowEqualObjects: () => (/* binding */ shallowEqualObjects),\n/* harmony export */   skipToken: () => (/* binding */ skipToken),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeUntilStale: () => (/* binding */ timeUntilStale)\n/* harmony export */ });\n// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (true) {\n      try {\n        return replaceEqualDeep(prevData, data);\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (true) {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9LQUFvSyxrQkFBa0IsS0FBSyxNQUFNO0FBQ2pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQSxpSEFBaUgsa0JBQWtCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBO0FBQ0E7QUF5QkU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLnRzXG52YXIgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IFwiRGVub1wiIGluIGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBub29wKCkge1xufVxuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSAhPT0gSW5maW5pdHk7XG59XG5mdW5jdGlvbiB0aW1lVW50aWxTdGFsZSh1cGRhdGVkQXQsIHN0YWxlVGltZSkge1xuICByZXR1cm4gTWF0aC5tYXgodXBkYXRlZEF0ICsgKHN0YWxlVGltZSB8fCAwKSAtIERhdGUubm93KCksIDApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVN0YWxlVGltZShzdGFsZVRpbWUsIHF1ZXJ5KSB7XG4gIHJldHVybiB0eXBlb2Ygc3RhbGVUaW1lID09PSBcImZ1bmN0aW9uXCIgPyBzdGFsZVRpbWUocXVlcnkpIDogc3RhbGVUaW1lO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWQoZW5hYmxlZCwgcXVlcnkpIHtcbiAgcmV0dXJuIHR5cGVvZiBlbmFibGVkID09PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVkKHF1ZXJ5KSA6IGVuYWJsZWQ7XG59XG5mdW5jdGlvbiBtYXRjaFF1ZXJ5KGZpbHRlcnMsIHF1ZXJ5KSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlID0gXCJhbGxcIixcbiAgICBleGFjdCxcbiAgICBmZXRjaFN0YXR1cyxcbiAgICBwcmVkaWNhdGUsXG4gICAgcXVlcnlLZXksXG4gICAgc3RhbGVcbiAgfSA9IGZpbHRlcnM7XG4gIGlmIChxdWVyeUtleSkge1xuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5SGFzaCAhPT0gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBxdWVyeS5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcGFydGlhbE1hdGNoS2V5KHF1ZXJ5LnF1ZXJ5S2V5LCBxdWVyeUtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUgIT09IFwiYWxsXCIpIHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHF1ZXJ5LmlzQWN0aXZlKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiYWN0aXZlXCIgJiYgIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImluYWN0aXZlXCIgJiYgaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFsZSA9PT0gXCJib29sZWFuXCIgJiYgcXVlcnkuaXNTdGFsZSgpICE9PSBzdGFsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmV0Y2hTdGF0dXMgJiYgZmV0Y2hTdGF0dXMgIT09IHF1ZXJ5LnN0YXRlLmZldGNoU3RhdHVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwcmVkaWNhdGUgJiYgIXByZWRpY2F0ZShxdWVyeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaE11dGF0aW9uKGZpbHRlcnMsIG11dGF0aW9uKSB7XG4gIGNvbnN0IHsgZXhhY3QsIHN0YXR1cywgcHJlZGljYXRlLCBtdXRhdGlvbktleSB9ID0gZmlsdGVycztcbiAgaWYgKG11dGF0aW9uS2V5KSB7XG4gICAgaWYgKCFtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKGhhc2hLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSkgIT09IGhhc2hLZXkobXV0YXRpb25LZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwYXJ0aWFsTWF0Y2hLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSwgbXV0YXRpb25LZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0dXMgJiYgbXV0YXRpb24uc3RhdGUuc3RhdHVzICE9PSBzdGF0dXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKG11dGF0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc2hRdWVyeUtleUJ5T3B0aW9ucyhxdWVyeUtleSwgb3B0aW9ucykge1xuICBjb25zdCBoYXNoRm4gPSBvcHRpb25zPy5xdWVyeUtleUhhc2hGbiB8fCBoYXNoS2V5O1xuICByZXR1cm4gaGFzaEZuKHF1ZXJ5S2V5KTtcbn1cbmZ1bmN0aW9uIGhhc2hLZXkocXVlcnlLZXkpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIHF1ZXJ5S2V5LFxuICAgIChfLCB2YWwpID0+IGlzUGxhaW5PYmplY3QodmFsKSA/IE9iamVjdC5rZXlzKHZhbCkuc29ydCgpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KSA6IHZhbFxuICApO1xufVxuZnVuY3Rpb24gcGFydGlhbE1hdGNoS2V5KGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKGIpLnNvbWUoKGtleSkgPT4gIXBhcnRpYWxNYXRjaEtleShhW2tleV0sIGJba2V5XSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VFcXVhbERlZXAoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGNvbnN0IGFycmF5ID0gaXNQbGFpbkFycmF5KGEpICYmIGlzUGxhaW5BcnJheShiKTtcbiAgaWYgKGFycmF5IHx8IGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgIGNvbnN0IGFJdGVtcyA9IGFycmF5ID8gYSA6IE9iamVjdC5rZXlzKGEpO1xuICAgIGNvbnN0IGFTaXplID0gYUl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBiSXRlbXMgPSBhcnJheSA/IGIgOiBPYmplY3Qua2V5cyhiKTtcbiAgICBjb25zdCBiU2l6ZSA9IGJJdGVtcy5sZW5ndGg7XG4gICAgY29uc3QgY29weSA9IGFycmF5ID8gW10gOiB7fTtcbiAgICBsZXQgZXF1YWxJdGVtcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcnJheSA/IGkgOiBiSXRlbXNbaV07XG4gICAgICBpZiAoKCFhcnJheSAmJiBhSXRlbXMuaW5jbHVkZXMoa2V5KSB8fCBhcnJheSkgJiYgYVtrZXldID09PSB2b2lkIDAgJiYgYltrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgY29weVtrZXldID0gdm9pZCAwO1xuICAgICAgICBlcXVhbEl0ZW1zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5W2tleV0gPSByZXBsYWNlRXF1YWxEZWVwKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgaWYgKGNvcHlba2V5XSA9PT0gYVtrZXldICYmIGFba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZXF1YWxJdGVtcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhU2l6ZSA9PT0gYlNpemUgJiYgZXF1YWxJdGVtcyA9PT0gYVNpemUgPyBhIDogY29weTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbE9iamVjdHMoYSwgYikge1xuICBpZiAoIWIgfHwgT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAoY3RvciA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoIWhhc09iamVjdFByb3RvdHlwZShwcm90KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXByb3QuaGFzT3duUHJvcGVydHkoXCJpc1Byb3RvdHlwZU9mXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YobykgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBoYXNPYmplY3RQcm90b3R5cGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gc2xlZXAodGltZW91dCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VEYXRhKHByZXZEYXRhLCBkYXRhLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5zdHJ1Y3R1cmFsU2hhcmluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuc3RydWN0dXJhbFNoYXJpbmcocHJldkRhdGEsIGRhdGEpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RydWN0dXJhbFNoYXJpbmcgIT09IGZhbHNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VFcXVhbERlZXAocHJldkRhdGEsIGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgU3RydWN0dXJhbCBzaGFyaW5nIHJlcXVpcmVzIGRhdGEgdG8gYmUgSlNPTiBzZXJpYWxpemFibGUuIFRvIGZpeCB0aGlzLCB0dXJuIG9mZiBzdHJ1Y3R1cmFsU2hhcmluZyBvciByZXR1cm4gSlNPTi1zZXJpYWxpemFibGUgZGF0YSBmcm9tIHlvdXIgcXVlcnlGbi4gWyR7b3B0aW9ucy5xdWVyeUhhc2h9XTogJHtlcnJvcn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlRXF1YWxEZWVwKHByZXZEYXRhLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGtlZXBQcmV2aW91c0RhdGEocHJldmlvdXNEYXRhKSB7XG4gIHJldHVybiBwcmV2aW91c0RhdGE7XG59XG5mdW5jdGlvbiBhZGRUb0VuZChpdGVtcywgaXRlbSwgbWF4ID0gMCkge1xuICBjb25zdCBuZXdJdGVtcyA9IFsuLi5pdGVtcywgaXRlbV07XG4gIHJldHVybiBtYXggJiYgbmV3SXRlbXMubGVuZ3RoID4gbWF4ID8gbmV3SXRlbXMuc2xpY2UoMSkgOiBuZXdJdGVtcztcbn1cbmZ1bmN0aW9uIGFkZFRvU3RhcnQoaXRlbXMsIGl0ZW0sIG1heCA9IDApIHtcbiAgY29uc3QgbmV3SXRlbXMgPSBbaXRlbSwgLi4uaXRlbXNdO1xuICByZXR1cm4gbWF4ICYmIG5ld0l0ZW1zLmxlbmd0aCA+IG1heCA/IG5ld0l0ZW1zLnNsaWNlKDAsIC0xKSA6IG5ld0l0ZW1zO1xufVxudmFyIHNraXBUb2tlbiA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZW5zdXJlUXVlcnlGbihvcHRpb25zLCBmZXRjaE9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChvcHRpb25zLnF1ZXJ5Rm4gPT09IHNraXBUb2tlbikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byBpbnZva2UgcXVlcnlGbiB3aGVuIHNldCB0byBza2lwVG9rZW4uIFRoaXMgaXMgbGlrZWx5IGEgY29uZmlndXJhdGlvbiBlcnJvci4gUXVlcnkgaGFzaDogJyR7b3B0aW9ucy5xdWVyeUhhc2h9J2BcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICghb3B0aW9ucy5xdWVyeUZuICYmIGZldGNoT3B0aW9ucz8uaW5pdGlhbFByb21pc2UpIHtcbiAgICByZXR1cm4gKCkgPT4gZmV0Y2hPcHRpb25zLmluaXRpYWxQcm9taXNlO1xuICB9XG4gIGlmICghb3B0aW9ucy5xdWVyeUZuIHx8IG9wdGlvbnMucXVlcnlGbiA9PT0gc2tpcFRva2VuKSB7XG4gICAgcmV0dXJuICgpID0+IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgTWlzc2luZyBxdWVyeUZuOiAnJHtvcHRpb25zLnF1ZXJ5SGFzaH0nYCkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zLnF1ZXJ5Rm47XG59XG5leHBvcnQge1xuICBhZGRUb0VuZCxcbiAgYWRkVG9TdGFydCxcbiAgZW5zdXJlUXVlcnlGbixcbiAgZnVuY3Rpb25hbFVwZGF0ZSxcbiAgaGFzaEtleSxcbiAgaGFzaFF1ZXJ5S2V5QnlPcHRpb25zLFxuICBpc1BsYWluQXJyYXksXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzU2VydmVyLFxuICBpc1ZhbGlkVGltZW91dCxcbiAga2VlcFByZXZpb3VzRGF0YSxcbiAgbWF0Y2hNdXRhdGlvbixcbiAgbWF0Y2hRdWVyeSxcbiAgbm9vcCxcbiAgcGFydGlhbE1hdGNoS2V5LFxuICByZXBsYWNlRGF0YSxcbiAgcmVwbGFjZUVxdWFsRGVlcCxcbiAgcmVzb2x2ZUVuYWJsZWQsXG4gIHJlc29sdmVTdGFsZVRpbWUsXG4gIHNoYWxsb3dFcXVhbE9iamVjdHMsXG4gIHNraXBUb2tlbixcbiAgc2xlZXAsXG4gIHRpbWVVbnRpbFN0YWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClientContext: () => (/* binding */ QueryClientContext),\n/* harmony export */   QueryClientProvider: () => (/* binding */ QueryClientProvider),\n/* harmony export */   useQueryClient: () => (/* binding */ useQueryClient)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryClientContext,QueryClientProvider,useQueryClient auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryClientProvider.tsx\n\n\nvar QueryClientContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar useQueryClient = (queryClient)=>{\n    _s();\n    const client = react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryClientContext);\n    if (queryClient) {\n        return queryClient;\n    }\n    if (!client) {\n        throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    }\n    return client;\n};\n_s(useQueryClient, \"6C1IqtdJdCPZ/voWsX/6r3Oc32M=\");\nvar QueryClientProvider = (param)=>{\n    let { client, children } = param;\n    _s1();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"QueryClientProvider.useEffect\": ()=>{\n            client.mount();\n            return ({\n                \"QueryClientProvider.useEffect\": ()=>{\n                    client.unmount();\n                }\n            })[\"QueryClientProvider.useEffect\"];\n        }\n    }[\"QueryClientProvider.useEffect\"], [\n        client\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryClientContext.Provider, {\n        value: client,\n        children\n    });\n};\n_s1(QueryClientProvider, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = QueryClientProvider;\n //# sourceMappingURL=QueryClientProvider.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryClientProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL1F1ZXJ5Q2xpZW50UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUN1QjtBQXVDbkI7QUFuQ0csSUFBTSxtQ0FBMkIsaURBQ3RDO0FBR0sscUJBQXVCLENBQUM7O0lBQzdCLE1BQU0sU0FBZSw4Q0FBVyxrQkFBa0I7SUFFbEQsSUFBSSxhQUFhO1FBQ2YsT0FBTztJQUNUO0lBRUEsSUFBSSxDQUFDLFFBQVE7UUFDWCxNQUFNLElBQUksTUFBTSx3REFBd0Q7SUFDMUU7SUFFQSxPQUFPO0FBQ1Q7R0FaYTtBQW1CTiwwQkFBNEI7UUFBQyxFQUNsQyxRQUNBLFVBQ0YsS0FBbUQ7O0lBQzNDO3lDQUFVO1lBQ2QsT0FBTyxNQUFNO1lBQ2I7aURBQU87b0JBQ0wsT0FBTyxRQUFRO2dCQUNqQjs7UUFDRjt3Q0FBRztRQUFDLE1BQU07S0FBQztJQUVYLE9BQ0UsdUVBQUMsbUJBQW1CLFVBQW5CO1FBQTRCLE9BQU87UUFDakM7SUFBQSxDQUNIO0FBRUo7O0tBaEJhIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvc3JjL1F1ZXJ5Q2xpZW50UHJvdmlkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCB0eXBlIHsgUXVlcnlDbGllbnQgfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcblxuZXhwb3J0IGNvbnN0IFF1ZXJ5Q2xpZW50Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8UXVlcnlDbGllbnQgfCB1bmRlZmluZWQ+KFxuICB1bmRlZmluZWQsXG4pXG5cbmV4cG9ydCBjb25zdCB1c2VRdWVyeUNsaWVudCA9IChxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50KSA9PiB7XG4gIGNvbnN0IGNsaWVudCA9IFJlYWN0LnVzZUNvbnRleHQoUXVlcnlDbGllbnRDb250ZXh0KVxuXG4gIGlmIChxdWVyeUNsaWVudCkge1xuICAgIHJldHVybiBxdWVyeUNsaWVudFxuICB9XG5cbiAgaWYgKCFjbGllbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFF1ZXJ5Q2xpZW50IHNldCwgdXNlIFF1ZXJ5Q2xpZW50UHJvdmlkZXIgdG8gc2V0IG9uZScpXG4gIH1cblxuICByZXR1cm4gY2xpZW50XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5Q2xpZW50UHJvdmlkZXJQcm9wcyA9IHtcbiAgY2xpZW50OiBRdWVyeUNsaWVudFxuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5leHBvcnQgY29uc3QgUXVlcnlDbGllbnRQcm92aWRlciA9ICh7XG4gIGNsaWVudCxcbiAgY2hpbGRyZW4sXG59OiBRdWVyeUNsaWVudFByb3ZpZGVyUHJvcHMpOiBSZWFjdC5KU1guRWxlbWVudCA9PiB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2xpZW50Lm1vdW50KClcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xpZW50LnVubW91bnQoKVxuICAgIH1cbiAgfSwgW2NsaWVudF0pXG5cbiAgcmV0dXJuIChcbiAgICA8UXVlcnlDbGllbnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjbGllbnR9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvUXVlcnlDbGllbnRDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryErrorResetBoundary: () => (/* binding */ QueryErrorResetBoundary),\n/* harmony export */   useQueryErrorResetBoundary: () => (/* binding */ useQueryErrorResetBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryErrorResetBoundary,useQueryErrorResetBoundary auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryErrorResetBoundary.tsx\n\n\nfunction createValue() {\n    let isReset = false;\n    return {\n        clearReset: ()=>{\n            isReset = false;\n        },\n        reset: ()=>{\n            isReset = true;\n        },\n        isReset: ()=>{\n            return isReset;\n        }\n    };\n}\nvar QueryErrorResetBoundaryContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(createValue());\nvar useQueryErrorResetBoundary = ()=>{\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryErrorResetBoundaryContext);\n};\n_s(useQueryErrorResetBoundary, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar QueryErrorResetBoundary = (param)=>{\n    let { children } = param;\n    _s1();\n    const [value] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"QueryErrorResetBoundary.useState\": ()=>createValue()\n    }[\"QueryErrorResetBoundary.useState\"]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryErrorResetBoundaryContext.Provider, {\n        value,\n        children: typeof children === \"function\" ? children(value) : children\n    });\n};\n_s1(QueryErrorResetBoundary, \"kCGIjwI+ZhZMd320rkpKrBSJczs=\");\n_c = QueryErrorResetBoundary;\n //# sourceMappingURL=QueryErrorResetBoundary.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryErrorResetBoundary\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL1F1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUN1QjtBQWtEbkI7QUFyQ0osU0FBUyxjQUE0QztJQUNuRCxJQUFJLFVBQVU7SUFDZCxPQUFPO1FBQ0wsWUFBWTtZQUNWLFVBQVU7UUFDWjtRQUNBLE9BQU87WUFDTCxVQUFVO1FBQ1o7UUFDQSxTQUFTO1lBQ1AsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVBLElBQU0sK0NBQXVDLGlEQUFjLFlBQVksQ0FBQztBQUlqRSxpQ0FBbUM7O1dBQ2xDLDhDQUFXO0FBQThCO0dBRHBDO0FBYU4sOEJBQWdDO1FBQUMsRUFDdEMsVUFDRixLQUFvQzs7SUFDbEMsTUFBTSxDQUFDLEtBQUssSUFBVTs0Q0FBUyxJQUFNLFlBQVksQ0FBQzs7SUFDbEQsT0FDRSx1RUFBQywrQkFBK0IsVUFBL0I7UUFBd0M7UUFDdEMsaUJBQU8sYUFBYSxhQUFhLFNBQVMsS0FBSyxJQUFJO0lBQUEsQ0FDdEQ7QUFFSjs7S0FUYSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL3NyYy9RdWVyeUVycm9yUmVzZXRCb3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuLy8gQ09OVEVYVFxuZXhwb3J0IHR5cGUgUXVlcnlFcnJvclJlc2V0RnVuY3Rpb24gPSAoKSA9PiB2b2lkXG5leHBvcnQgdHlwZSBRdWVyeUVycm9ySXNSZXNldEZ1bmN0aW9uID0gKCkgPT4gYm9vbGVhblxuZXhwb3J0IHR5cGUgUXVlcnlFcnJvckNsZWFyUmVzZXRGdW5jdGlvbiA9ICgpID0+IHZvaWRcblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlIHtcbiAgY2xlYXJSZXNldDogUXVlcnlFcnJvckNsZWFyUmVzZXRGdW5jdGlvblxuICBpc1Jlc2V0OiBRdWVyeUVycm9ySXNSZXNldEZ1bmN0aW9uXG4gIHJlc2V0OiBRdWVyeUVycm9yUmVzZXRGdW5jdGlvblxufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWx1ZSgpOiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlIHtcbiAgbGV0IGlzUmVzZXQgPSBmYWxzZVxuICByZXR1cm4ge1xuICAgIGNsZWFyUmVzZXQ6ICgpID0+IHtcbiAgICAgIGlzUmVzZXQgPSBmYWxzZVxuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIGlzUmVzZXQgPSB0cnVlXG4gICAgfSxcbiAgICBpc1Jlc2V0OiAoKSA9PiB7XG4gICAgICByZXR1cm4gaXNSZXNldFxuICAgIH0sXG4gIH1cbn1cblxuY29uc3QgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChjcmVhdGVWYWx1ZSgpKVxuXG4vLyBIT09LXG5cbmV4cG9ydCBjb25zdCB1c2VRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSA9ICgpID0+XG4gIFJlYWN0LnVzZUNvbnRleHQoUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0KVxuXG4vLyBDT01QT05FTlRcblxuZXhwb3J0IHR5cGUgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlGdW5jdGlvbiA9IChcbiAgdmFsdWU6IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5VmFsdWUsXG4pID0+IFJlYWN0LlJlYWN0Tm9kZVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5UHJvcHMge1xuICBjaGlsZHJlbjogUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlGdW5jdGlvbiB8IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5leHBvcnQgY29uc3QgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkgPSAoe1xuICBjaGlsZHJlbixcbn06IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5UHJvcHMpID0+IHtcbiAgY29uc3QgW3ZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNyZWF0ZVZhbHVlKCkpXG4gIHJldHVybiAoXG4gICAgPFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PlxuICAgICAge3R5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHZhbHVlKSA6IGNoaWxkcmVufVxuICAgIDwvUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensurePreventErrorBoundaryRetry: () => (/* binding */ ensurePreventErrorBoundaryRetry),\n/* harmony export */   getHasError: () => (/* binding */ getHasError),\n/* harmony export */   useClearResetErrorBoundary: () => (/* binding */ useClearResetErrorBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js\");\n/* __next_internal_client_entry_do_not_use__ ensurePreventErrorBoundaryRetry,getHasError,useClearResetErrorBoundary auto */ var _s = $RefreshSig$();\n// src/errorBoundaryUtils.ts\n\n\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary)=>{\n    if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {\n        if (!errorResetBoundary.isReset()) {\n            options.retryOnMount = false;\n        }\n    }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary)=>{\n    _s();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useClearResetErrorBoundary.useEffect\": ()=>{\n            errorResetBoundary.clearReset();\n        }\n    }[\"useClearResetErrorBoundary.useEffect\"], [\n        errorResetBoundary\n    ]);\n};\n_s(useClearResetErrorBoundary, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nvar getHasError = (param)=>{\n    let { result, errorResetBoundary, throwOnError, query, suspense } = param;\n    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shouldThrowError)(throwOnError, [\n        result.error,\n        query\n    ]));\n};\n //# sourceMappingURL=errorBoundaryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL2Vycm9yQm91bmRhcnlVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ3VCO0FBQ1U7QUFVMUIsSUFBTSxrQ0FBa0MsQ0FPN0MsU0FPQTtJQUVBLElBQ0UsUUFBUSxZQUNSLFFBQVEsZ0JBQ1IsUUFBUSwrQkFDUjtRQUVBLElBQUksQ0FBQyxtQkFBbUIsUUFBUSxHQUFHO1lBQ2pDLFFBQVEsZUFBZTtRQUN6QjtJQUNGO0FBQ0Y7QUFFTyxpQ0FBbUMsQ0FDeEM7O0lBRU07Z0RBQVU7WUFDZCxtQkFBbUIsV0FBVztRQUNoQzsrQ0FBRztRQUFDLGtCQUFrQjtLQUFDO0FBQ3pCO0dBTmE7QUFRTixJQUFNLGNBQWM7UUFNekIsRUFDQSxRQUNBLG9CQUNBLGNBQ0EsT0FDQSxVQUNGLEtBTU07SUFDSixPQUNFLE9BQU8sV0FDUCxDQUFDLG1CQUFtQixRQUFRLEtBQzVCLENBQUMsT0FBTyxjQUNSLFVBQ0UsWUFBWSxPQUFPLFNBQVMsVUFDNUIsMkRBQWdCLENBQUMsY0FBYztRQUFDLE9BQU87UUFBTyxLQUFLO01BQUM7QUFFMUQiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9zcmMvZXJyb3JCb3VuZGFyeVV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBzaG91bGRUaHJvd0Vycm9yIH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB0eXBlIHtcbiAgRGVmYXVsdGVkUXVlcnlPYnNlcnZlck9wdGlvbnMsXG4gIFF1ZXJ5LFxuICBRdWVyeUtleSxcbiAgUXVlcnlPYnNlcnZlclJlc3VsdCxcbiAgVGhyb3dPbkVycm9yLFxufSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcbmltcG9ydCB0eXBlIHsgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlWYWx1ZSB9IGZyb20gJy4vUXVlcnlFcnJvclJlc2V0Qm91bmRhcnknXG5cbmV4cG9ydCBjb25zdCBlbnN1cmVQcmV2ZW50RXJyb3JCb3VuZGFyeVJldHJ5ID0gPFxuICBUUXVlcnlGbkRhdGEsXG4gIFRFcnJvcixcbiAgVERhdGEsXG4gIFRRdWVyeURhdGEsXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5LFxuPihcbiAgb3B0aW9uczogRGVmYXVsdGVkUXVlcnlPYnNlcnZlck9wdGlvbnM8XG4gICAgVFF1ZXJ5Rm5EYXRhLFxuICAgIFRFcnJvcixcbiAgICBURGF0YSxcbiAgICBUUXVlcnlEYXRhLFxuICAgIFRRdWVyeUtleVxuICA+LFxuICBlcnJvclJlc2V0Qm91bmRhcnk6IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5VmFsdWUsXG4pID0+IHtcbiAgaWYgKFxuICAgIG9wdGlvbnMuc3VzcGVuc2UgfHxcbiAgICBvcHRpb25zLnRocm93T25FcnJvciB8fFxuICAgIG9wdGlvbnMuZXhwZXJpbWVudGFsX3ByZWZldGNoSW5SZW5kZXJcbiAgKSB7XG4gICAgLy8gUHJldmVudCByZXRyeWluZyBmYWlsZWQgcXVlcnkgaWYgdGhlIGVycm9yIGJvdW5kYXJ5IGhhcyBub3QgYmVlbiByZXNldCB5ZXRcbiAgICBpZiAoIWVycm9yUmVzZXRCb3VuZGFyeS5pc1Jlc2V0KCkpIHtcbiAgICAgIG9wdGlvbnMucmV0cnlPbk1vdW50ID0gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5ID0gKFxuICBlcnJvclJlc2V0Qm91bmRhcnk6IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5VmFsdWUsXG4pID0+IHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBlcnJvclJlc2V0Qm91bmRhcnkuY2xlYXJSZXNldCgpXG4gIH0sIFtlcnJvclJlc2V0Qm91bmRhcnldKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0SGFzRXJyb3IgPSA8XG4gIFREYXRhLFxuICBURXJyb3IsXG4gIFRRdWVyeUZuRGF0YSxcbiAgVFF1ZXJ5RGF0YSxcbiAgVFF1ZXJ5S2V5IGV4dGVuZHMgUXVlcnlLZXksXG4+KHtcbiAgcmVzdWx0LFxuICBlcnJvclJlc2V0Qm91bmRhcnksXG4gIHRocm93T25FcnJvcixcbiAgcXVlcnksXG4gIHN1c3BlbnNlLFxufToge1xuICByZXN1bHQ6IFF1ZXJ5T2JzZXJ2ZXJSZXN1bHQ8VERhdGEsIFRFcnJvcj5cbiAgZXJyb3JSZXNldEJvdW5kYXJ5OiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlXG4gIHRocm93T25FcnJvcjogVGhyb3dPbkVycm9yPFRRdWVyeUZuRGF0YSwgVEVycm9yLCBUUXVlcnlEYXRhLCBUUXVlcnlLZXk+XG4gIHF1ZXJ5OiBRdWVyeTxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVFF1ZXJ5RGF0YSwgVFF1ZXJ5S2V5PiB8IHVuZGVmaW5lZFxuICBzdXNwZW5zZTogYm9vbGVhbiB8IHVuZGVmaW5lZFxufSkgPT4ge1xuICByZXR1cm4gKFxuICAgIHJlc3VsdC5pc0Vycm9yICYmXG4gICAgIWVycm9yUmVzZXRCb3VuZGFyeS5pc1Jlc2V0KCkgJiZcbiAgICAhcmVzdWx0LmlzRmV0Y2hpbmcgJiZcbiAgICBxdWVyeSAmJlxuICAgICgoc3VzcGVuc2UgJiYgcmVzdWx0LmRhdGEgPT09IHVuZGVmaW5lZCkgfHxcbiAgICAgIHNob3VsZFRocm93RXJyb3IodGhyb3dPbkVycm9yLCBbcmVzdWx0LmVycm9yLCBxdWVyeV0pKVxuICApXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/isRestoring.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/isRestoring.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsRestoringProvider: () => (/* binding */ IsRestoringProvider),\n/* harmony export */   useIsRestoring: () => (/* binding */ useIsRestoring)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ IsRestoringProvider,useIsRestoring auto */ var _s = $RefreshSig$();\n// src/isRestoring.ts\n\nvar IsRestoringContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(false);\nvar useIsRestoring = ()=>{\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsRestoringContext);\n};\n_s(useIsRestoring, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar IsRestoringProvider = IsRestoringContext.Provider;\n //# sourceMappingURL=isRestoring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL2lzUmVzdG9yaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ3VCO0FBRXZCLElBQU0sbUNBQTJCLGlEQUFjLEtBQUs7QUFFN0MscUJBQXVCOztJQUFZLHFEQUFXO0FBQWtCO0dBQTFEO0FBQ04sSUFBTSxzQkFBc0IsbUJBQW1CIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvc3JjL2lzUmVzdG9yaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmNvbnN0IElzUmVzdG9yaW5nQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZmFsc2UpXG5cbmV4cG9ydCBjb25zdCB1c2VJc1Jlc3RvcmluZyA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoSXNSZXN0b3JpbmdDb250ZXh0KVxuZXhwb3J0IGNvbnN0IElzUmVzdG9yaW5nUHJvdmlkZXIgPSBJc1Jlc3RvcmluZ0NvbnRleHQuUHJvdmlkZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/isRestoring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/suspense.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/suspense.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultThrowOnError: () => (/* binding */ defaultThrowOnError),\n/* harmony export */   ensureSuspenseTimers: () => (/* binding */ ensureSuspenseTimers),\n/* harmony export */   fetchOptimistic: () => (/* binding */ fetchOptimistic),\n/* harmony export */   shouldSuspend: () => (/* binding */ shouldSuspend),\n/* harmony export */   willFetch: () => (/* binding */ willFetch)\n/* harmony export */ });\n// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  const originalStaleTime = defaultedOptions.staleTime;\n  if (defaultedOptions.suspense) {\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\n\n//# sourceMappingURL=suspense.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3N1c3BlbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQU9DO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9zdXNwZW5zZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3VzcGVuc2UudHNcbnZhciBkZWZhdWx0VGhyb3dPbkVycm9yID0gKF9lcnJvciwgcXVlcnkpID0+IHF1ZXJ5LnN0YXRlLmRhdGEgPT09IHZvaWQgMDtcbnZhciBlbnN1cmVTdXNwZW5zZVRpbWVycyA9IChkZWZhdWx0ZWRPcHRpb25zKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsU3RhbGVUaW1lID0gZGVmYXVsdGVkT3B0aW9ucy5zdGFsZVRpbWU7XG4gIGlmIChkZWZhdWx0ZWRPcHRpb25zLnN1c3BlbnNlKSB7XG4gICAgZGVmYXVsdGVkT3B0aW9ucy5zdGFsZVRpbWUgPSB0eXBlb2Ygb3JpZ2luYWxTdGFsZVRpbWUgPT09IFwiZnVuY3Rpb25cIiA/ICguLi5hcmdzKSA9PiBNYXRoLm1heChvcmlnaW5hbFN0YWxlVGltZSguLi5hcmdzKSwgMWUzKSA6IE1hdGgubWF4KG9yaWdpbmFsU3RhbGVUaW1lID8/IDFlMywgMWUzKTtcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRlZE9wdGlvbnMuZ2NUaW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLmdjVGltZSA9IE1hdGgubWF4KGRlZmF1bHRlZE9wdGlvbnMuZ2NUaW1lLCAxZTMpO1xuICAgIH1cbiAgfVxufTtcbnZhciB3aWxsRmV0Y2ggPSAocmVzdWx0LCBpc1Jlc3RvcmluZykgPT4gcmVzdWx0LmlzTG9hZGluZyAmJiByZXN1bHQuaXNGZXRjaGluZyAmJiAhaXNSZXN0b3Jpbmc7XG52YXIgc2hvdWxkU3VzcGVuZCA9IChkZWZhdWx0ZWRPcHRpb25zLCByZXN1bHQpID0+IGRlZmF1bHRlZE9wdGlvbnM/LnN1c3BlbnNlICYmIHJlc3VsdC5pc1BlbmRpbmc7XG52YXIgZmV0Y2hPcHRpbWlzdGljID0gKGRlZmF1bHRlZE9wdGlvbnMsIG9ic2VydmVyLCBlcnJvclJlc2V0Qm91bmRhcnkpID0+IG9ic2VydmVyLmZldGNoT3B0aW1pc3RpYyhkZWZhdWx0ZWRPcHRpb25zKS5jYXRjaCgoKSA9PiB7XG4gIGVycm9yUmVzZXRCb3VuZGFyeS5jbGVhclJlc2V0KCk7XG59KTtcbmV4cG9ydCB7XG4gIGRlZmF1bHRUaHJvd09uRXJyb3IsXG4gIGVuc3VyZVN1c3BlbnNlVGltZXJzLFxuICBmZXRjaE9wdGltaXN0aWMsXG4gIHNob3VsZFN1c3BlbmQsXG4gIHdpbGxGZXRjaFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1c3BlbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/suspense.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBaseQuery: () => (/* binding */ useBaseQuery)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QueryClientProvider.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var _QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QueryErrorResetBoundary.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js\");\n/* harmony import */ var _errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errorBoundaryUtils.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js\");\n/* harmony import */ var _isRestoring_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isRestoring.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/isRestoring.js\");\n/* harmony import */ var _suspense_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./suspense.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/suspense.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js\");\n/* __next_internal_client_entry_do_not_use__ useBaseQuery auto */ var _s = $RefreshSig$();\n// src/useBaseQuery.ts\n\n\n\n\n\n\n\n\nfunction useBaseQuery(options, Observer, queryClient) {\n    var _client_getDefaultOptions_queries__experimental_beforeQuery, _client_getDefaultOptions_queries, _client_getDefaultOptions_queries__experimental_afterQuery, _client_getDefaultOptions_queries1;\n    _s();\n    if (true) {\n        if (typeof options !== \"object\" || Array.isArray(options)) {\n            throw new Error('Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object');\n        }\n    }\n    const client = (0,_QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient)(queryClient);\n    const isRestoring = (0,_isRestoring_js__WEBPACK_IMPORTED_MODULE_2__.useIsRestoring)();\n    const errorResetBoundary = (0,_QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__.useQueryErrorResetBoundary)();\n    const defaultedOptions = client.defaultQueryOptions(options);\n    (_client_getDefaultOptions_queries = client.getDefaultOptions().queries) === null || _client_getDefaultOptions_queries === void 0 ? void 0 : (_client_getDefaultOptions_queries__experimental_beforeQuery = _client_getDefaultOptions_queries._experimental_beforeQuery) === null || _client_getDefaultOptions_queries__experimental_beforeQuery === void 0 ? void 0 : _client_getDefaultOptions_queries__experimental_beforeQuery.call(_client_getDefaultOptions_queries, defaultedOptions);\n    defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n    (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.ensureSuspenseTimers)(defaultedOptions);\n    (0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.ensurePreventErrorBoundaryRetry)(defaultedOptions, errorResetBoundary);\n    (0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.useClearResetErrorBoundary)(errorResetBoundary);\n    const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n    const [observer] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"useBaseQuery.useState\": ()=>new Observer(client, defaultedOptions)\n    }[\"useBaseQuery.useState\"]);\n    const result = observer.getOptimisticResult(defaultedOptions);\n    const shouldSubscribe = !isRestoring && options.subscribed !== false;\n    react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"useBaseQuery.useSyncExternalStore.useCallback\": (onStoreChange)=>{\n            const unsubscribe = shouldSubscribe ? observer.subscribe(_tanstack_query_core__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batchCalls(onStoreChange)) : _utils_js__WEBPACK_IMPORTED_MODULE_7__.noop;\n            observer.updateResult();\n            return unsubscribe;\n        }\n    }[\"useBaseQuery.useSyncExternalStore.useCallback\"], [\n        observer,\n        shouldSubscribe\n    ]), {\n        \"useBaseQuery.useSyncExternalStore\": ()=>observer.getCurrentResult()\n    }[\"useBaseQuery.useSyncExternalStore\"], {\n        \"useBaseQuery.useSyncExternalStore\": ()=>observer.getCurrentResult()\n    }[\"useBaseQuery.useSyncExternalStore\"]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useBaseQuery.useEffect\": ()=>{\n            observer.setOptions(defaultedOptions, {\n                listeners: false\n            });\n        }\n    }[\"useBaseQuery.useEffect\"], [\n        defaultedOptions,\n        observer\n    ]);\n    if ((0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.shouldSuspend)(defaultedOptions, result)) {\n        throw (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.fetchOptimistic)(defaultedOptions, observer, errorResetBoundary);\n    }\n    if ((0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.getHasError)({\n        result,\n        errorResetBoundary,\n        throwOnError: defaultedOptions.throwOnError,\n        query: client.getQueryCache().get(defaultedOptions.queryHash),\n        suspense: defaultedOptions.suspense\n    })) {\n        throw result.error;\n    }\n    ;\n    (_client_getDefaultOptions_queries1 = client.getDefaultOptions().queries) === null || _client_getDefaultOptions_queries1 === void 0 ? void 0 : (_client_getDefaultOptions_queries__experimental_afterQuery = _client_getDefaultOptions_queries1._experimental_afterQuery) === null || _client_getDefaultOptions_queries__experimental_afterQuery === void 0 ? void 0 : _client_getDefaultOptions_queries__experimental_afterQuery.call(_client_getDefaultOptions_queries1, defaultedOptions, result);\n    if (defaultedOptions.experimental_prefetchInRender && !_tanstack_query_core__WEBPACK_IMPORTED_MODULE_8__.isServer && (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.willFetch)(result, isRestoring)) {\n        var // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        _client_getQueryCache_get;\n        const promise = isNewCacheEntry ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.fetchOptimistic)(defaultedOptions, observer, errorResetBoundary) : (_client_getQueryCache_get = client.getQueryCache().get(defaultedOptions.queryHash)) === null || _client_getQueryCache_get === void 0 ? void 0 : _client_getQueryCache_get.promise;\n        promise === null || promise === void 0 ? void 0 : promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_7__.noop).finally(()=>{\n            observer.updateResult();\n        });\n    }\n    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n_s(useBaseQuery, \"CyxE5xccZG2TrSzRRH2uajM5OLk=\", false, function() {\n    return [\n        _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient,\n        _isRestoring_js__WEBPACK_IMPORTED_MODULE_2__.useIsRestoring,\n        _QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__.useQueryErrorResetBoundary,\n        _errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.useClearResetErrorBoundary\n    ];\n});\n //# sourceMappingURL=useBaseQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3VzZUJhc2VRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDdUI7QUFFaUI7QUFDVDtBQUNZO0FBS3BDO0FBQ3dCO0FBTXhCO0FBQ2M7QUFTZCxzQkFPTCxTQU9BLFVBQ0EsYUFDb0M7UUFjbEMsNEpBaUZBOztJQTlGRixJQUFJLElBQXlCLEVBQWM7UUFDekMsSUFBSSxPQUFPLFlBQVksWUFBWSxNQUFNLFFBQVEsT0FBTyxHQUFHO1lBQ3pELE1BQU0sSUFBSSxNQUNSO1FBRUo7SUFDRjtJQUVBLE1BQU0sU0FBUyx1RUFBYyxDQUFDLFdBQVc7SUFDekMsTUFBTSxjQUFjLCtEQUFjO0lBQ2xDLE1BQU0scUJBQXFCLHVGQUEwQjtJQUNyRCxNQUFNLG1CQUFtQixPQUFPLG9CQUFvQixPQUFPO2dEQUVsRCxrQkFBa0IsRUFBRSw4S0FBaUIsNk5BQzVDO0lBSUYsaUJBQWlCLHFCQUFxQixjQUNsQyxnQkFDQTtJQUVKLGtFQUFvQixDQUFDLGdCQUFnQjtJQUNyQyx1RkFBK0IsQ0FBQyxrQkFBa0Isa0JBQWtCO0lBRXBFLGtGQUEwQixDQUFDLGtCQUFrQjtJQUc3QyxNQUFNLGtCQUFrQixDQUFDLE9BQ3RCLGNBQWMsRUFDZCxJQUFJLGlCQUFpQixTQUFTO0lBRWpDLE1BQU0sQ0FBQyxRQUFRLElBQVU7aUNBQ3ZCLElBQ0UsSUFBSSxTQUNGLFFBQ0E7O0lBS04sTUFBTSxTQUFTLFNBQVMsb0JBQW9CLGdCQUFnQjtJQUU1RCxNQUFNLGtCQUFrQixDQUFDLGVBQWUsUUFBUSxlQUFlO0lBQ3pELHdEQUNFO3lEQUNKLENBQUM7WUFDQyxNQUFNLGNBQWMsa0JBQ2hCLFNBQVMsVUFBVSwrREFBYSxDQUFDLFdBQVcsYUFBYSxDQUFDLElBQzFELDJDQUFJO1lBSVIsU0FBUyxhQUFhO1lBRXRCLE9BQU87UUFDVDt3REFDQTtRQUFDO1FBQVUsZUFBZTtLQUFBOzZDQUU1QixJQUFNLFNBQVMsaUJBQWlCOzs2Q0FDaEMsSUFBTSxTQUFTLGlCQUFpQjs7SUFHNUI7a0NBQVU7WUFHZCxTQUFTLFdBQVcsa0JBQWtCO2dCQUFFLFdBQVc7WUFBTSxDQUFDO1FBQzVEO2lDQUFHO1FBQUM7UUFBa0IsUUFBUTtLQUFDO0lBRy9CLElBQUksMkRBQWEsQ0FBQyxrQkFBa0IsTUFBTSxHQUFHO1FBQzNDLE1BQU0sNkRBQWUsQ0FBQyxrQkFBa0IsVUFBVSxrQkFBa0I7SUFDdEU7SUFHQSxJQUNFLG1FQUFXLENBQUM7UUFDVjtRQUNBO1FBQ0EsY0FBYyxpQkFBaUI7UUFDL0IsT0FBTyxPQUNKLGNBQWMsRUFDZCxJQUtDLGlCQUFpQixTQUFTO1FBQzlCLFVBQVUsaUJBQWlCO0lBQzdCLENBQUMsR0FDRDtRQUNBLE1BQU0sT0FBTztJQUNmOztpREFFUyxrQkFBa0IsRUFBRSwrS0FBaUIsMk5BQzVDLGtCQUNBO0lBR0YsSUFDRSxpQkFBaUIsaUNBQ2pCLENBQUMsMERBQVEsSUFDVCx1REFBUyxDQUFDLFFBQVEsV0FBVyxHQUM3QjtZQUdrRTtRQUU5RDtRQUpKLE1BQU0sVUFBVTtRQUVaLDZEQUFlLENBQUMsa0JBQWtCLFVBQVUsa0JBQWtCLHdDQUV2RCxjQUFjLEVBQUUsSUFBSSxpQkFBaUIsU0FBUyx5RkFBRztRQUU1RCwwREFBUyxNQUFNLDJDQUFJLEVBQUUsUUFBUTtZQUUzQixTQUFTLGFBQWE7UUFDeEIsQ0FBQztJQUNIO0lBR0EsT0FBTyxDQUFDLGlCQUFpQixzQkFDckIsU0FBUyxZQUFZLE1BQU0sSUFDM0I7QUFDTjtHQXpJZ0I7O1FBeUJDLG1FQUFjO1FBQ1QsMkRBQWMsQ0FBQztRQUNSLG1GQUEwQixDQUFDO1FBZXRELDhFQUEwQiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL3NyYy91c2VCYXNlUXVlcnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgaXNTZXJ2ZXIsIG5vdGlmeU1hbmFnZXIgfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcbmltcG9ydCB7IHVzZVF1ZXJ5Q2xpZW50IH0gZnJvbSAnLi9RdWVyeUNsaWVudFByb3ZpZGVyJ1xuaW1wb3J0IHsgdXNlUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkgfSBmcm9tICcuL1F1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5J1xuaW1wb3J0IHtcbiAgZW5zdXJlUHJldmVudEVycm9yQm91bmRhcnlSZXRyeSxcbiAgZ2V0SGFzRXJyb3IsXG4gIHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5LFxufSBmcm9tICcuL2Vycm9yQm91bmRhcnlVdGlscydcbmltcG9ydCB7IHVzZUlzUmVzdG9yaW5nIH0gZnJvbSAnLi9pc1Jlc3RvcmluZydcbmltcG9ydCB7XG4gIGVuc3VyZVN1c3BlbnNlVGltZXJzLFxuICBmZXRjaE9wdGltaXN0aWMsXG4gIHNob3VsZFN1c3BlbmQsXG4gIHdpbGxGZXRjaCxcbn0gZnJvbSAnLi9zdXNwZW5zZSdcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHR5cGUge1xuICBRdWVyeUNsaWVudCxcbiAgUXVlcnlLZXksXG4gIFF1ZXJ5T2JzZXJ2ZXIsXG4gIFF1ZXJ5T2JzZXJ2ZXJSZXN1bHQsXG59IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuaW1wb3J0IHR5cGUgeyBVc2VCYXNlUXVlcnlPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhLFxuICBURXJyb3IsXG4gIFREYXRhLFxuICBUUXVlcnlEYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSxcbj4oXG4gIG9wdGlvbnM6IFVzZUJhc2VRdWVyeU9wdGlvbnM8XG4gICAgVFF1ZXJ5Rm5EYXRhLFxuICAgIFRFcnJvcixcbiAgICBURGF0YSxcbiAgICBUUXVlcnlEYXRhLFxuICAgIFRRdWVyeUtleVxuICA+LFxuICBPYnNlcnZlcjogdHlwZW9mIFF1ZXJ5T2JzZXJ2ZXIsXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBRdWVyeU9ic2VydmVyUmVzdWx0PFREYXRhLCBURXJyb3I+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0JhZCBhcmd1bWVudCB0eXBlLiBTdGFydGluZyB3aXRoIHY1LCBvbmx5IHRoZSBcIk9iamVjdFwiIGZvcm0gaXMgYWxsb3dlZCB3aGVuIGNhbGxpbmcgcXVlcnkgcmVsYXRlZCBmdW5jdGlvbnMuIFBsZWFzZSB1c2UgdGhlIGVycm9yIHN0YWNrIHRvIGZpbmQgdGhlIGN1bHByaXQgY2FsbC4gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vdGFuc3RhY2suY29tL3F1ZXJ5L2xhdGVzdC9kb2NzL3JlYWN0L2d1aWRlcy9taWdyYXRpbmctdG8tdjUjc3VwcG9ydHMtYS1zaW5nbGUtc2lnbmF0dXJlLW9uZS1vYmplY3QnLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNsaWVudCA9IHVzZVF1ZXJ5Q2xpZW50KHF1ZXJ5Q2xpZW50KVxuICBjb25zdCBpc1Jlc3RvcmluZyA9IHVzZUlzUmVzdG9yaW5nKClcbiAgY29uc3QgZXJyb3JSZXNldEJvdW5kYXJ5ID0gdXNlUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkoKVxuICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gY2xpZW50LmRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICA7KGNsaWVudC5nZXREZWZhdWx0T3B0aW9ucygpLnF1ZXJpZXMgYXMgYW55KT8uX2V4cGVyaW1lbnRhbF9iZWZvcmVRdWVyeT8uKFxuICAgIGRlZmF1bHRlZE9wdGlvbnMsXG4gIClcblxuICAvLyBNYWtlIHN1cmUgcmVzdWx0cyBhcmUgb3B0aW1pc3RpY2FsbHkgc2V0IGluIGZldGNoaW5nIHN0YXRlIGJlZm9yZSBzdWJzY3JpYmluZyBvciB1cGRhdGluZyBvcHRpb25zXG4gIGRlZmF1bHRlZE9wdGlvbnMuX29wdGltaXN0aWNSZXN1bHRzID0gaXNSZXN0b3JpbmdcbiAgICA/ICdpc1Jlc3RvcmluZydcbiAgICA6ICdvcHRpbWlzdGljJ1xuXG4gIGVuc3VyZVN1c3BlbnNlVGltZXJzKGRlZmF1bHRlZE9wdGlvbnMpXG4gIGVuc3VyZVByZXZlbnRFcnJvckJvdW5kYXJ5UmV0cnkoZGVmYXVsdGVkT3B0aW9ucywgZXJyb3JSZXNldEJvdW5kYXJ5KVxuXG4gIHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5KGVycm9yUmVzZXRCb3VuZGFyeSlcblxuICAvLyB0aGlzIG5lZWRzIHRvIGJlIGludm9rZWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBPYnNlcnZlciBiZWNhdXNlIHRoYXQgY2FuIGNyZWF0ZSBhIGNhY2hlIGVudHJ5XG4gIGNvbnN0IGlzTmV3Q2FjaGVFbnRyeSA9ICFjbGllbnRcbiAgICAuZ2V0UXVlcnlDYWNoZSgpXG4gICAgLmdldChkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5SGFzaClcblxuICBjb25zdCBbb2JzZXJ2ZXJdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgKCkgPT5cbiAgICAgIG5ldyBPYnNlcnZlcjxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeURhdGEsIFRRdWVyeUtleT4oXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgZGVmYXVsdGVkT3B0aW9ucyxcbiAgICAgICksXG4gIClcblxuICAvLyBub3RlOiB0aGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVxuICBjb25zdCByZXN1bHQgPSBvYnNlcnZlci5nZXRPcHRpbWlzdGljUmVzdWx0KGRlZmF1bHRlZE9wdGlvbnMpXG5cbiAgY29uc3Qgc2hvdWxkU3Vic2NyaWJlID0gIWlzUmVzdG9yaW5nICYmIG9wdGlvbnMuc3Vic2NyaWJlZCAhPT0gZmFsc2VcbiAgUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAob25TdG9yZUNoYW5nZSkgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHNob3VsZFN1YnNjcmliZVxuICAgICAgICAgID8gb2JzZXJ2ZXIuc3Vic2NyaWJlKG5vdGlmeU1hbmFnZXIuYmF0Y2hDYWxscyhvblN0b3JlQ2hhbmdlKSlcbiAgICAgICAgICA6IG5vb3BcblxuICAgICAgICAvLyBVcGRhdGUgcmVzdWx0IHRvIG1ha2Ugc3VyZSB3ZSBkaWQgbm90IG1pc3MgYW55IHF1ZXJ5IHVwZGF0ZXNcbiAgICAgICAgLy8gYmV0d2VlbiBjcmVhdGluZyB0aGUgb2JzZXJ2ZXIgYW5kIHN1YnNjcmliaW5nIHRvIGl0LlxuICAgICAgICBvYnNlcnZlci51cGRhdGVSZXN1bHQoKVxuXG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZVxuICAgICAgfSxcbiAgICAgIFtvYnNlcnZlciwgc2hvdWxkU3Vic2NyaWJlXSxcbiAgICApLFxuICAgICgpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKSxcbiAgICAoKSA9PiBvYnNlcnZlci5nZXRDdXJyZW50UmVzdWx0KCksXG4gIClcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERvIG5vdCBub3RpZnkgb24gdXBkYXRlcyBiZWNhdXNlIG9mIGNoYW5nZXMgaW4gdGhlIG9wdGlvbnMgYmVjYXVzZVxuICAgIC8vIHRoZXNlIGNoYW5nZXMgc2hvdWxkIGFscmVhZHkgYmUgcmVmbGVjdGVkIGluIHRoZSBvcHRpbWlzdGljIHJlc3VsdC5cbiAgICBvYnNlcnZlci5zZXRPcHRpb25zKGRlZmF1bHRlZE9wdGlvbnMsIHsgbGlzdGVuZXJzOiBmYWxzZSB9KVxuICB9LCBbZGVmYXVsdGVkT3B0aW9ucywgb2JzZXJ2ZXJdKVxuXG4gIC8vIEhhbmRsZSBzdXNwZW5zZVxuICBpZiAoc2hvdWxkU3VzcGVuZChkZWZhdWx0ZWRPcHRpb25zLCByZXN1bHQpKSB7XG4gICAgdGhyb3cgZmV0Y2hPcHRpbWlzdGljKGRlZmF1bHRlZE9wdGlvbnMsIG9ic2VydmVyLCBlcnJvclJlc2V0Qm91bmRhcnkpXG4gIH1cblxuICAvLyBIYW5kbGUgZXJyb3IgYm91bmRhcnlcbiAgaWYgKFxuICAgIGdldEhhc0Vycm9yKHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIGVycm9yUmVzZXRCb3VuZGFyeSxcbiAgICAgIHRocm93T25FcnJvcjogZGVmYXVsdGVkT3B0aW9ucy50aHJvd09uRXJyb3IsXG4gICAgICBxdWVyeTogY2xpZW50XG4gICAgICAgIC5nZXRRdWVyeUNhY2hlKClcbiAgICAgICAgLmdldDxcbiAgICAgICAgICBUUXVlcnlGbkRhdGEsXG4gICAgICAgICAgVEVycm9yLFxuICAgICAgICAgIFRRdWVyeURhdGEsXG4gICAgICAgICAgVFF1ZXJ5S2V5XG4gICAgICAgID4oZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2gpLFxuICAgICAgc3VzcGVuc2U6IGRlZmF1bHRlZE9wdGlvbnMuc3VzcGVuc2UsXG4gICAgfSlcbiAgKSB7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yXG4gIH1cblxuICA7KGNsaWVudC5nZXREZWZhdWx0T3B0aW9ucygpLnF1ZXJpZXMgYXMgYW55KT8uX2V4cGVyaW1lbnRhbF9hZnRlclF1ZXJ5Py4oXG4gICAgZGVmYXVsdGVkT3B0aW9ucyxcbiAgICByZXN1bHQsXG4gIClcblxuICBpZiAoXG4gICAgZGVmYXVsdGVkT3B0aW9ucy5leHBlcmltZW50YWxfcHJlZmV0Y2hJblJlbmRlciAmJlxuICAgICFpc1NlcnZlciAmJlxuICAgIHdpbGxGZXRjaChyZXN1bHQsIGlzUmVzdG9yaW5nKVxuICApIHtcbiAgICBjb25zdCBwcm9taXNlID0gaXNOZXdDYWNoZUVudHJ5XG4gICAgICA/IC8vIEZldGNoIGltbWVkaWF0ZWx5IG9uIHJlbmRlciBpbiBvcmRlciB0byBlbnN1cmUgYC5wcm9taXNlYCBpcyByZXNvbHZlZCBldmVuIGlmIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkXG4gICAgICAgIGZldGNoT3B0aW1pc3RpYyhkZWZhdWx0ZWRPcHRpb25zLCBvYnNlcnZlciwgZXJyb3JSZXNldEJvdW5kYXJ5KVxuICAgICAgOiAvLyBzdWJzY3JpYmUgdG8gdGhlIFwiY2FjaGUgcHJvbWlzZVwiIHNvIHRoYXQgd2UgY2FuIGZpbmFsaXplIHRoZSBjdXJyZW50VGhlbmFibGUgb25jZSBkYXRhIGNvbWVzIGluXG4gICAgICAgIGNsaWVudC5nZXRRdWVyeUNhY2hlKCkuZ2V0KGRlZmF1bHRlZE9wdGlvbnMucXVlcnlIYXNoKT8ucHJvbWlzZVxuXG4gICAgcHJvbWlzZT8uY2F0Y2gobm9vcCkuZmluYWxseSgoKSA9PiB7XG4gICAgICAvLyBgLnVwZGF0ZVJlc3VsdCgpYCB3aWxsIHRyaWdnZXIgYC4jY3VycmVudFRoZW5hYmxlYCB0byBmaW5hbGl6ZVxuICAgICAgb2JzZXJ2ZXIudXBkYXRlUmVzdWx0KClcbiAgICB9KVxuICB9XG5cbiAgLy8gSGFuZGxlIHJlc3VsdCBwcm9wZXJ0eSB1c2FnZSB0cmFja2luZ1xuICByZXR1cm4gIWRlZmF1bHRlZE9wdGlvbnMubm90aWZ5T25DaGFuZ2VQcm9wc1xuICAgID8gb2JzZXJ2ZXIudHJhY2tSZXN1bHQocmVzdWx0KVxuICAgIDogcmVzdWx0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInfiniteQuery: () => (/* binding */ useInfiniteQuery)\n/* harmony export */ });\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js\");\n/* harmony import */ var _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useBaseQuery.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js\");\n/* __next_internal_client_entry_do_not_use__ useInfiniteQuery auto */ var _s = $RefreshSig$();\n// src/useInfiniteQuery.ts\n\n\nfunction useInfiniteQuery(options, queryClient) {\n    _s();\n    return (0,_useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery)(options, _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__.InfiniteQueryObserver, queryClient);\n}\n_s(useInfiniteQuery, \"KQLwJ9Hz54v54vEsUujw5Lh1nqo=\", false, function() {\n    return [\n        _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery\n    ];\n});\n //# sourceMappingURL=useInfiniteQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3VzZUluZmluaXRlUXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDc0M7QUFDVDtBQXNFdEIsMEJBQ0wsU0FDQSxhQUNBOztJQUNBLE9BQU8sOERBQVksQ0FDakIsU0FDQSx1RUFBcUIsRUFDckI7QUFFSjtHQVRnQjs7UUFJUCwwREFBWSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL3NyYy91c2VJbmZpbml0ZVF1ZXJ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IHsgSW5maW5pdGVRdWVyeU9ic2VydmVyIH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5pbXBvcnQgeyB1c2VCYXNlUXVlcnkgfSBmcm9tICcuL3VzZUJhc2VRdWVyeSdcbmltcG9ydCB0eXBlIHtcbiAgRGVmYXVsdEVycm9yLFxuICBJbmZpbml0ZURhdGEsXG4gIFF1ZXJ5Q2xpZW50LFxuICBRdWVyeUtleSxcbiAgUXVlcnlPYnNlcnZlcixcbn0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5pbXBvcnQgdHlwZSB7XG4gIERlZmluZWRVc2VJbmZpbml0ZVF1ZXJ5UmVzdWx0LFxuICBVc2VJbmZpbml0ZVF1ZXJ5T3B0aW9ucyxcbiAgVXNlSW5maW5pdGVRdWVyeVJlc3VsdCxcbn0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRGVmaW5lZEluaXRpYWxEYXRhSW5maW5pdGVPcHRpb25zLFxuICBVbmRlZmluZWRJbml0aWFsRGF0YUluZmluaXRlT3B0aW9ucyxcbn0gZnJvbSAnLi9pbmZpbml0ZVF1ZXJ5T3B0aW9ucydcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUluZmluaXRlUXVlcnk8XG4gIFRRdWVyeUZuRGF0YSxcbiAgVEVycm9yID0gRGVmYXVsdEVycm9yLFxuICBURGF0YSA9IEluZmluaXRlRGF0YTxUUXVlcnlGbkRhdGE+LFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSA9IFF1ZXJ5S2V5LFxuICBUUGFnZVBhcmFtID0gdW5rbm93bixcbj4oXG4gIG9wdGlvbnM6IERlZmluZWRJbml0aWFsRGF0YUluZmluaXRlT3B0aW9uczxcbiAgICBUUXVlcnlGbkRhdGEsXG4gICAgVEVycm9yLFxuICAgIFREYXRhLFxuICAgIFRRdWVyeUtleSxcbiAgICBUUGFnZVBhcmFtXG4gID4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBEZWZpbmVkVXNlSW5maW5pdGVRdWVyeVJlc3VsdDxURGF0YSwgVEVycm9yPlxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5maW5pdGVRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhLFxuICBURXJyb3IgPSBEZWZhdWx0RXJyb3IsXG4gIFREYXRhID0gSW5maW5pdGVEYXRhPFRRdWVyeUZuRGF0YT4sXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5ID0gUXVlcnlLZXksXG4gIFRQYWdlUGFyYW0gPSB1bmtub3duLFxuPihcbiAgb3B0aW9uczogVW5kZWZpbmVkSW5pdGlhbERhdGFJbmZpbml0ZU9wdGlvbnM8XG4gICAgVFF1ZXJ5Rm5EYXRhLFxuICAgIFRFcnJvcixcbiAgICBURGF0YSxcbiAgICBUUXVlcnlLZXksXG4gICAgVFBhZ2VQYXJhbVxuICA+LFxuICBxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50LFxuKTogVXNlSW5maW5pdGVRdWVyeVJlc3VsdDxURGF0YSwgVEVycm9yPlxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5maW5pdGVRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhLFxuICBURXJyb3IgPSBEZWZhdWx0RXJyb3IsXG4gIFREYXRhID0gSW5maW5pdGVEYXRhPFRRdWVyeUZuRGF0YT4sXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5ID0gUXVlcnlLZXksXG4gIFRQYWdlUGFyYW0gPSB1bmtub3duLFxuPihcbiAgb3B0aW9uczogVXNlSW5maW5pdGVRdWVyeU9wdGlvbnM8XG4gICAgVFF1ZXJ5Rm5EYXRhLFxuICAgIFRFcnJvcixcbiAgICBURGF0YSxcbiAgICBUUXVlcnlGbkRhdGEsXG4gICAgVFF1ZXJ5S2V5LFxuICAgIFRQYWdlUGFyYW1cbiAgPixcbiAgcXVlcnlDbGllbnQ/OiBRdWVyeUNsaWVudCxcbik6IFVzZUluZmluaXRlUXVlcnlSZXN1bHQ8VERhdGEsIFRFcnJvcj5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUluZmluaXRlUXVlcnkoXG4gIG9wdGlvbnM6IFVzZUluZmluaXRlUXVlcnlPcHRpb25zLFxuICBxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50LFxuKSB7XG4gIHJldHVybiB1c2VCYXNlUXVlcnkoXG4gICAgb3B0aW9ucyxcbiAgICBJbmZpbml0ZVF1ZXJ5T2JzZXJ2ZXIgYXMgdHlwZW9mIFF1ZXJ5T2JzZXJ2ZXIsXG4gICAgcXVlcnlDbGllbnQsXG4gIClcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useMutation.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/useMutation.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMutation: () => (/* binding */ useMutation)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationObserver.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QueryClientProvider.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js\");\n/* __next_internal_client_entry_do_not_use__ useMutation auto */ var _s = $RefreshSig$();\n// src/useMutation.ts\n\n\n\n\nfunction useMutation(options, queryClient) {\n    _s();\n    const client = (0,_QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient)(queryClient);\n    const [observer] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"useMutation.useState\": ()=>new _tanstack_query_core__WEBPACK_IMPORTED_MODULE_2__.MutationObserver(client, options)\n    }[\"useMutation.useState\"]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useMutation.useEffect\": ()=>{\n            observer.setOptions(options);\n        }\n    }[\"useMutation.useEffect\"], [\n        observer,\n        options\n    ]);\n    const result = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"useMutation.useSyncExternalStore[result]\": (onStoreChange)=>observer.subscribe(_tanstack_query_core__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batchCalls(onStoreChange))\n    }[\"useMutation.useSyncExternalStore[result]\"], [\n        observer\n    ]), {\n        \"useMutation.useSyncExternalStore[result]\": ()=>observer.getCurrentResult()\n    }[\"useMutation.useSyncExternalStore[result]\"], {\n        \"useMutation.useSyncExternalStore[result]\": ()=>observer.getCurrentResult()\n    }[\"useMutation.useSyncExternalStore[result]\"]);\n    const mutate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"useMutation.useCallback[mutate]\": (variables, mutateOptions)=>{\n            observer.mutate(variables, mutateOptions).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n        }\n    }[\"useMutation.useCallback[mutate]\"], [\n        observer\n    ]);\n    if (result.error && (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.shouldThrowError)(observer.options.throwOnError, [\n        result.error\n    ])) {\n        throw result.error;\n    }\n    return {\n        ...result,\n        mutate,\n        mutateAsync: result.mutate\n    };\n}\n_s(useMutation, \"RnjiJpQzu1E7HRDDZFqTIXneRKU=\", false, function() {\n    return [\n        _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient\n    ];\n});\n //# sourceMappingURL=useMutation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3VzZU11dGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ3VCO0FBQ3lCO0FBQ2pCO0FBQ1E7QUFVaEMscUJBTUwsU0FDQSxhQUN3RDs7SUFDeEQsTUFBTSxTQUFTLHVFQUFjLENBQUMsV0FBVztJQUV6QyxNQUFNLENBQUMsUUFBUSxJQUFVO2dDQUN2QixJQUNFLElBQUksa0VBQWdCLENBQ2xCLFFBQ0E7O0lBSUE7aUNBQVU7WUFDZCxTQUFTLFdBQVcsT0FBTztRQUM3QjtnQ0FBRztRQUFDO1FBQVUsT0FBTztLQUFDO0lBRXRCLE1BQU0sU0FBZSx3REFDYjtvREFDSixDQUFDLGdCQUNDLFNBQVMsVUFBVSwrREFBYSxDQUFDLFdBQVcsYUFBYSxDQUFDO21EQUM1RDtRQUFDLFFBQVE7S0FBQTtvREFFWCxJQUFNLFNBQVMsaUJBQWlCOztvREFDaEMsSUFBTSxTQUFTLGlCQUFpQjs7SUFHbEMsTUFBTSxTQUFlOzJDQUduQixDQUFDLFdBQVc7WUFDVixTQUFTLE9BQU8sV0FBVyxhQUFhLEVBQUUsTUFBTSwyQ0FBSTtRQUN0RDswQ0FDQTtRQUFDLFFBQVE7S0FBQTtJQUdYLElBQ0UsT0FBTyxTQUNQLDJEQUFnQixDQUFDLFNBQVMsUUFBUSxjQUFjO1FBQUMsT0FBTyxLQUFLO0tBQUMsR0FDOUQ7UUFDQSxNQUFNLE9BQU87SUFDZjtJQUVBLE9BQU87UUFBRSxHQUFHO1FBQVE7UUFBUSxhQUFhLE9BQU87SUFBTztBQUN6RDtHQWxEZ0I7O1FBU0MsbUVBQWMiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9zcmMvdXNlTXV0YXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE11dGF0aW9uT2JzZXJ2ZXIsIG5vdGlmeU1hbmFnZXIgfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcbmltcG9ydCB7IHVzZVF1ZXJ5Q2xpZW50IH0gZnJvbSAnLi9RdWVyeUNsaWVudFByb3ZpZGVyJ1xuaW1wb3J0IHsgbm9vcCwgc2hvdWxkVGhyb3dFcnJvciB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgdHlwZSB7XG4gIFVzZU11dGF0ZUZ1bmN0aW9uLFxuICBVc2VNdXRhdGlvbk9wdGlvbnMsXG4gIFVzZU11dGF0aW9uUmVzdWx0LFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBEZWZhdWx0RXJyb3IsIFF1ZXJ5Q2xpZW50IH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5cbi8vIEhPT0tcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU11dGF0aW9uPFxuICBURGF0YSA9IHVua25vd24sXG4gIFRFcnJvciA9IERlZmF1bHRFcnJvcixcbiAgVFZhcmlhYmxlcyA9IHZvaWQsXG4gIFRDb250ZXh0ID0gdW5rbm93bixcbj4oXG4gIG9wdGlvbnM6IFVzZU11dGF0aW9uT3B0aW9uczxURGF0YSwgVEVycm9yLCBUVmFyaWFibGVzLCBUQ29udGV4dD4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBVc2VNdXRhdGlvblJlc3VsdDxURGF0YSwgVEVycm9yLCBUVmFyaWFibGVzLCBUQ29udGV4dD4ge1xuICBjb25zdCBjbGllbnQgPSB1c2VRdWVyeUNsaWVudChxdWVyeUNsaWVudClcblxuICBjb25zdCBbb2JzZXJ2ZXJdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgKCkgPT5cbiAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyPFREYXRhLCBURXJyb3IsIFRWYXJpYWJsZXMsIFRDb250ZXh0PihcbiAgICAgICAgY2xpZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKSxcbiAgKVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgb2JzZXJ2ZXIuc2V0T3B0aW9ucyhvcHRpb25zKVxuICB9LCBbb2JzZXJ2ZXIsIG9wdGlvbnNdKVxuXG4gIGNvbnN0IHJlc3VsdCA9IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKG9uU3RvcmVDaGFuZ2UpID0+XG4gICAgICAgIG9ic2VydmVyLnN1YnNjcmliZShub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMob25TdG9yZUNoYW5nZSkpLFxuICAgICAgW29ic2VydmVyXSxcbiAgICApLFxuICAgICgpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKSxcbiAgICAoKSA9PiBvYnNlcnZlci5nZXRDdXJyZW50UmVzdWx0KCksXG4gIClcblxuICBjb25zdCBtdXRhdGUgPSBSZWFjdC51c2VDYWxsYmFjazxcbiAgICBVc2VNdXRhdGVGdW5jdGlvbjxURGF0YSwgVEVycm9yLCBUVmFyaWFibGVzLCBUQ29udGV4dD5cbiAgPihcbiAgICAodmFyaWFibGVzLCBtdXRhdGVPcHRpb25zKSA9PiB7XG4gICAgICBvYnNlcnZlci5tdXRhdGUodmFyaWFibGVzLCBtdXRhdGVPcHRpb25zKS5jYXRjaChub29wKVxuICAgIH0sXG4gICAgW29ic2VydmVyXSxcbiAgKVxuXG4gIGlmIChcbiAgICByZXN1bHQuZXJyb3IgJiZcbiAgICBzaG91bGRUaHJvd0Vycm9yKG9ic2VydmVyLm9wdGlvbnMudGhyb3dPbkVycm9yLCBbcmVzdWx0LmVycm9yXSlcbiAgKSB7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yXG4gIH1cblxuICByZXR1cm4geyAuLi5yZXN1bHQsIG11dGF0ZSwgbXV0YXRlQXN5bmM6IHJlc3VsdC5tdXRhdGUgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useMutation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/useQuery.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useQuery: () => (/* binding */ useQuery)\n/* harmony export */ });\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryObserver.js\");\n/* harmony import */ var _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useBaseQuery.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js\");\n/* __next_internal_client_entry_do_not_use__ useQuery auto */ var _s = $RefreshSig$();\n// src/useQuery.ts\n\n\nfunction useQuery(options, queryClient) {\n    _s();\n    return (0,_useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery)(options, _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__.QueryObserver, queryClient);\n}\n_s(useQuery, \"KQLwJ9Hz54v54vEsUujw5Lh1nqo=\", false, function() {\n    return [\n        _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery\n    ];\n});\n //# sourceMappingURL=useQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3VzZVF1ZXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQzhCO0FBQ0Q7QUEwQ3RCLGtCQUFrQixTQUEwQixhQUEyQjs7SUFDNUUsT0FBTyw4REFBWSxDQUFDLFNBQVMsK0RBQWEsRUFBRSxXQUFXO0FBQ3pEO0dBRmdCOztRQUNQLDBEQUFZIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvc3JjL3VzZVF1ZXJ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IHsgUXVlcnlPYnNlcnZlciB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuaW1wb3J0IHsgdXNlQmFzZVF1ZXJ5IH0gZnJvbSAnLi91c2VCYXNlUXVlcnknXG5pbXBvcnQgdHlwZSB7IERlZmF1bHRFcnJvciwgUXVlcnlDbGllbnQsIFF1ZXJ5S2V5IH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5pbXBvcnQgdHlwZSB7XG4gIERlZmluZWRVc2VRdWVyeVJlc3VsdCxcbiAgVXNlUXVlcnlPcHRpb25zLFxuICBVc2VRdWVyeVJlc3VsdCxcbn0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRGVmaW5lZEluaXRpYWxEYXRhT3B0aW9ucyxcbiAgVW5kZWZpbmVkSW5pdGlhbERhdGFPcHRpb25zLFxufSBmcm9tICcuL3F1ZXJ5T3B0aW9ucydcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVF1ZXJ5PFxuICBUUXVlcnlGbkRhdGEgPSB1bmtub3duLFxuICBURXJyb3IgPSBEZWZhdWx0RXJyb3IsXG4gIFREYXRhID0gVFF1ZXJ5Rm5EYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSA9IFF1ZXJ5S2V5LFxuPihcbiAgb3B0aW9uczogRGVmaW5lZEluaXRpYWxEYXRhT3B0aW9uczxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeUtleT4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBEZWZpbmVkVXNlUXVlcnlSZXN1bHQ8VERhdGEsIFRFcnJvcj5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVF1ZXJ5PFxuICBUUXVlcnlGbkRhdGEgPSB1bmtub3duLFxuICBURXJyb3IgPSBEZWZhdWx0RXJyb3IsXG4gIFREYXRhID0gVFF1ZXJ5Rm5EYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSA9IFF1ZXJ5S2V5LFxuPihcbiAgb3B0aW9uczogVW5kZWZpbmVkSW5pdGlhbERhdGFPcHRpb25zPFRRdWVyeUZuRGF0YSwgVEVycm9yLCBURGF0YSwgVFF1ZXJ5S2V5PixcbiAgcXVlcnlDbGllbnQ/OiBRdWVyeUNsaWVudCxcbik6IFVzZVF1ZXJ5UmVzdWx0PFREYXRhLCBURXJyb3I+XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhID0gdW5rbm93bixcbiAgVEVycm9yID0gRGVmYXVsdEVycm9yLFxuICBURGF0YSA9IFRRdWVyeUZuRGF0YSxcbiAgVFF1ZXJ5S2V5IGV4dGVuZHMgUXVlcnlLZXkgPSBRdWVyeUtleSxcbj4oXG4gIG9wdGlvbnM6IFVzZVF1ZXJ5T3B0aW9uczxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeUtleT4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBVc2VRdWVyeVJlc3VsdDxURGF0YSwgVEVycm9yPlxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUXVlcnkob3B0aW9uczogVXNlUXVlcnlPcHRpb25zLCBxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50KSB7XG4gIHJldHVybiB1c2VCYXNlUXVlcnkob3B0aW9ucywgUXVlcnlPYnNlcnZlciwgcXVlcnlDbGllbnQpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   shouldThrowError: () => (/* binding */ shouldThrowError)\n/* harmony export */ });\n// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy50c1xuZnVuY3Rpb24gc2hvdWxkVGhyb3dFcnJvcih0aHJvd0Vycm9yLCBwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiB0aHJvd0Vycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvciguLi5wYXJhbXMpO1xuICB9XG4gIHJldHVybiAhIXRocm93RXJyb3I7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuZXhwb3J0IHtcbiAgbm9vcCxcbiAgc2hvdWxkVGhyb3dFcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/eventemitter3/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/eventemitter3/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(app-pages-browser)/./node_modules/eventemitter3/index.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7O0FBRWQ7QUFDdkIsaUVBQWUsc0NBQVkiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2luZGV4LmpzJ1xuXG5leHBvcnQgeyBFdmVudEVtaXR0ZXIgfVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/eventemitter3/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fetch-cookie/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/fetch-cookie/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("var tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fetchCookie)\n/* harmony export */ });\n/* harmony import */ var tough_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tough-cookie */ \"(app-pages-browser)/./node_modules/tough-cookie/dist/cookie/index.js\");\n/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! set-cookie-parser */ \"(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\n\n\nfunction isDomainOrSubdomain(destination, original) {\n  const orig = new URL(original).hostname;\n  const dest = new URL(destination).hostname;\n  return orig === dest || orig.endsWith(`.${dest}`);\n}\nconst referrerPolicy = /* @__PURE__ */ new Set([\n  \"\",\n  \"no-referrer\",\n  \"no-referrer-when-downgrade\",\n  \"same-origin\",\n  \"origin\",\n  \"strict-origin\",\n  \"origin-when-cross-origin\",\n  \"strict-origin-when-cross-origin\",\n  \"unsafe-url\"\n]);\nfunction parseReferrerPolicy(policyHeader) {\n  const policyTokens = policyHeader.split(/[,\\s]+/);\n  let policy = \"\";\n  for (const token of policyTokens) {\n    if (token !== \"\" && referrerPolicy.has(token)) {\n      policy = token;\n    }\n  }\n  return policy;\n}\nfunction doNothing(init, name) {\n}\nfunction callDeleteMethod(init, name) {\n  init.headers.delete(name);\n}\nfunction deleteFromObject(init, name) {\n  const headers = init.headers;\n  for (const key of Object.keys(headers)) {\n    if (key.toLowerCase() === name) {\n      delete headers[key];\n    }\n  }\n}\nfunction identifyDeleteHeader(init) {\n  if (init.headers == null) {\n    return doNothing;\n  }\n  if (typeof init.headers.delete === \"function\") {\n    return callDeleteMethod;\n  }\n  return deleteFromObject;\n}\nconst redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nfunction isRedirect(status) {\n  return redirectStatus.has(status);\n}\nasync function handleRedirect(fetchImpl, init, response) {\n  switch (init.redirect ?? \"follow\") {\n    case \"error\":\n      throw new TypeError(`URI requested responded with a redirect and redirect mode is set to error: ${response.url}`);\n    case \"manual\":\n      return response;\n    case \"follow\":\n      break;\n    default:\n      throw new TypeError(`Invalid redirect option: ${init.redirect}`);\n  }\n  const locationUrl = response.headers.get(\"location\");\n  if (locationUrl === null) {\n    return response;\n  }\n  const requestUrl = response.url;\n  const redirectUrl = new URL(locationUrl, requestUrl).toString();\n  const redirectCount = init.redirectCount ?? 0;\n  const maxRedirect = init.maxRedirect ?? 20;\n  if (redirectCount >= maxRedirect) {\n    throw new TypeError(`Reached maximum redirect of ${maxRedirect} for URL: ${requestUrl}`);\n  }\n  init = {\n    ...init,\n    redirectCount: redirectCount + 1\n  };\n  const deleteHeader = identifyDeleteHeader(init);\n  if (!isDomainOrSubdomain(requestUrl, redirectUrl)) {\n    for (const name of [\"authorization\", \"www-authenticate\", \"cookie\", \"cookie2\"]) {\n      deleteHeader(init, name);\n    }\n  }\n  const maybeNodeStreamBody = init.body;\n  const maybeStreamBody = init.body;\n  if (response.status !== 303 && init.body != null && (typeof maybeNodeStreamBody.pipe === \"function\" || typeof maybeStreamBody.pipeTo === \"function\")) {\n    throw new TypeError(\"Cannot follow redirect with body being a readable stream\");\n  }\n  if (response.status === 303 || (response.status === 301 || response.status === 302) && init.method === \"POST\") {\n    init.method = \"GET\";\n    init.body = void 0;\n    deleteHeader(init, \"content-length\");\n  }\n  if (response.headers.has(\"referrer-policy\")) {\n    init.referrerPolicy = parseReferrerPolicy(response.headers.get(\"referrer-policy\"));\n  }\n  deleteHeader(init, \"host\");\n  return await fetchImpl(redirectUrl, init);\n}\nfunction addCookiesToRequest(input, init, cookie) {\n  if (cookie === \"\") {\n    return init;\n  }\n  const maybeRequest = input;\n  const maybeHeaders = init.headers;\n  if (maybeRequest.headers && typeof maybeRequest.headers.append === \"function\") {\n    maybeRequest.headers.append(\"cookie\", cookie);\n  } else if (maybeHeaders && typeof maybeHeaders.append === \"function\") {\n    maybeHeaders.append(\"cookie\", cookie);\n  } else if (Array.isArray(init.headers)) {\n    const headers = [...init.headers];\n    const cookieHeaderIndex = headers.findIndex((header) => header[0].toLowerCase() === \"cookie\");\n    if (cookieHeaderIndex === -1) {\n      headers.push([\"cookie\", cookie]);\n    } else {\n      headers[cookieHeaderIndex] = [\"cookie\", cookie];\n    }\n    init = { ...init, headers };\n  } else {\n    init = { ...init, headers: { ...init.headers, cookie } };\n  }\n  return init;\n}\nfunction getCookiesFromResponse(response) {\n  const maybeNodeFetchHeaders = response.headers;\n  if (typeof maybeNodeFetchHeaders.getAll === \"function\") {\n    return maybeNodeFetchHeaders.getAll(\"set-cookie\");\n  }\n  if (typeof maybeNodeFetchHeaders.raw === \"function\") {\n    const headers = maybeNodeFetchHeaders.raw();\n    if (Array.isArray(headers[\"set-cookie\"])) {\n      return headers[\"set-cookie\"];\n    }\n    return [];\n  }\n  const cookieString = response.headers.get(\"set-cookie\");\n  if (cookieString !== null) {\n    return (0,set_cookie_parser__WEBPACK_IMPORTED_MODULE_1__.splitCookiesString)(cookieString);\n  }\n  return [];\n}\nfunction fetchCookie(fetch, jar, ignoreError = true) {\n  const actualFetch = fetch;\n  const actualJar = jar ?? new tough_cookie__WEBPACK_IMPORTED_MODULE_0__.CookieJar();\n  async function fetchCookieWrapper(input, init) {\n    const originalInit = init ?? {};\n    init = { ...init, redirect: \"manual\" };\n    const requestUrl = typeof input === \"string\" ? input : \"href\" in input ? input.href : input.url;\n    const cookie = await actualJar.getCookieString(requestUrl);\n    init = addCookiesToRequest(input, init, cookie);\n    const response = await actualFetch(input, init);\n    const cookies = getCookiesFromResponse(response);\n    await Promise.all(cookies.map(async (cookie2) => await actualJar.setCookie(cookie2, response.url, { ignoreError })));\n    if ((init.redirectCount ?? 0) > 0) {\n      Object.defineProperty(response, \"redirected\", { value: true });\n    }\n    if (!isRedirect(response.status)) {\n      return response;\n    }\n    return await handleRedirect(fetchCookieWrapper, originalInit, response);\n  }\n  fetchCookieWrapper.toughCookie = /*#__PURE__*/ (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(tough_cookie__WEBPACK_IMPORTED_MODULE_0__, 2)));\n  fetchCookieWrapper.cookieJar = actualJar;\n  return fetchCookieWrapper;\n}\nfetchCookie.toughCookie = /*#__PURE__*/ (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(tough_cookie__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mZXRjaC1jb29raWUvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0M7QUFDaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGFBQWE7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWEsV0FBVyxXQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbURBQWU7QUFDOUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGFBQWE7QUFDckg7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOE1BQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhNQUFLO0FBRzdCIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2ZldGNoLWNvb2tpZS9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdG91Z2ggZnJvbSBcInRvdWdoLWNvb2tpZVwiO1xuaW1wb3J0IHsgc3BsaXRDb29raWVzU3RyaW5nIH0gZnJvbSBcInNldC1jb29raWUtcGFyc2VyXCI7XG5mdW5jdGlvbiBpc0RvbWFpbk9yU3ViZG9tYWluKGRlc3RpbmF0aW9uLCBvcmlnaW5hbCkge1xuICBjb25zdCBvcmlnID0gbmV3IFVSTChvcmlnaW5hbCkuaG9zdG5hbWU7XG4gIGNvbnN0IGRlc3QgPSBuZXcgVVJMKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcbiAgcmV0dXJuIG9yaWcgPT09IGRlc3QgfHwgb3JpZy5lbmRzV2l0aChgLiR7ZGVzdH1gKTtcbn1cbmNvbnN0IHJlZmVycmVyUG9saWN5ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIlwiLFxuICBcIm5vLXJlZmVycmVyXCIsXG4gIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIixcbiAgXCJzYW1lLW9yaWdpblwiLFxuICBcIm9yaWdpblwiLFxuICBcInN0cmljdC1vcmlnaW5cIixcbiAgXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcbiAgXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXG4gIFwidW5zYWZlLXVybFwiXG5dKTtcbmZ1bmN0aW9uIHBhcnNlUmVmZXJyZXJQb2xpY3kocG9saWN5SGVhZGVyKSB7XG4gIGNvbnN0IHBvbGljeVRva2VucyA9IHBvbGljeUhlYWRlci5zcGxpdCgvWyxcXHNdKy8pO1xuICBsZXQgcG9saWN5ID0gXCJcIjtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBwb2xpY3lUb2tlbnMpIHtcbiAgICBpZiAodG9rZW4gIT09IFwiXCIgJiYgcmVmZXJyZXJQb2xpY3kuaGFzKHRva2VuKSkge1xuICAgICAgcG9saWN5ID0gdG9rZW47XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2xpY3k7XG59XG5mdW5jdGlvbiBkb05vdGhpbmcoaW5pdCwgbmFtZSkge1xufVxuZnVuY3Rpb24gY2FsbERlbGV0ZU1ldGhvZChpbml0LCBuYW1lKSB7XG4gIGluaXQuaGVhZGVycy5kZWxldGUobmFtZSk7XG59XG5mdW5jdGlvbiBkZWxldGVGcm9tT2JqZWN0KGluaXQsIG5hbWUpIHtcbiAgY29uc3QgaGVhZGVycyA9IGluaXQuaGVhZGVycztcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IG5hbWUpIHtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpZGVudGlmeURlbGV0ZUhlYWRlcihpbml0KSB7XG4gIGlmIChpbml0LmhlYWRlcnMgPT0gbnVsbCkge1xuICAgIHJldHVybiBkb05vdGhpbmc7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0LmhlYWRlcnMuZGVsZXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY2FsbERlbGV0ZU1ldGhvZDtcbiAgfVxuICByZXR1cm4gZGVsZXRlRnJvbU9iamVjdDtcbn1cbmNvbnN0IHJlZGlyZWN0U3RhdHVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5mdW5jdGlvbiBpc1JlZGlyZWN0KHN0YXR1cykge1xuICByZXR1cm4gcmVkaXJlY3RTdGF0dXMuaGFzKHN0YXR1cyk7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZWRpcmVjdChmZXRjaEltcGwsIGluaXQsIHJlc3BvbnNlKSB7XG4gIHN3aXRjaCAoaW5pdC5yZWRpcmVjdCA/PyBcImZvbGxvd1wiKSB7XG4gICAgY2FzZSBcImVycm9yXCI6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVUkkgcmVxdWVzdGVkIHJlc3BvbmRlZCB3aXRoIGEgcmVkaXJlY3QgYW5kIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3Jlc3BvbnNlLnVybH1gKTtcbiAgICBjYXNlIFwibWFudWFsXCI6XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgY2FzZSBcImZvbGxvd1wiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiAke2luaXQucmVkaXJlY3R9YCk7XG4gIH1cbiAgY29uc3QgbG9jYXRpb25VcmwgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImxvY2F0aW9uXCIpO1xuICBpZiAobG9jYXRpb25VcmwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgY29uc3QgcmVxdWVzdFVybCA9IHJlc3BvbnNlLnVybDtcbiAgY29uc3QgcmVkaXJlY3RVcmwgPSBuZXcgVVJMKGxvY2F0aW9uVXJsLCByZXF1ZXN0VXJsKS50b1N0cmluZygpO1xuICBjb25zdCByZWRpcmVjdENvdW50ID0gaW5pdC5yZWRpcmVjdENvdW50ID8/IDA7XG4gIGNvbnN0IG1heFJlZGlyZWN0ID0gaW5pdC5tYXhSZWRpcmVjdCA/PyAyMDtcbiAgaWYgKHJlZGlyZWN0Q291bnQgPj0gbWF4UmVkaXJlY3QpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWFjaGVkIG1heGltdW0gcmVkaXJlY3Qgb2YgJHttYXhSZWRpcmVjdH0gZm9yIFVSTDogJHtyZXF1ZXN0VXJsfWApO1xuICB9XG4gIGluaXQgPSB7XG4gICAgLi4uaW5pdCxcbiAgICByZWRpcmVjdENvdW50OiByZWRpcmVjdENvdW50ICsgMVxuICB9O1xuICBjb25zdCBkZWxldGVIZWFkZXIgPSBpZGVudGlmeURlbGV0ZUhlYWRlcihpbml0KTtcbiAgaWYgKCFpc0RvbWFpbk9yU3ViZG9tYWluKHJlcXVlc3RVcmwsIHJlZGlyZWN0VXJsKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbXCJhdXRob3JpemF0aW9uXCIsIFwid3d3LWF1dGhlbnRpY2F0ZVwiLCBcImNvb2tpZVwiLCBcImNvb2tpZTJcIl0pIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihpbml0LCBuYW1lKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF5YmVOb2RlU3RyZWFtQm9keSA9IGluaXQuYm9keTtcbiAgY29uc3QgbWF5YmVTdHJlYW1Cb2R5ID0gaW5pdC5ib2R5O1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAzMDMgJiYgaW5pdC5ib2R5ICE9IG51bGwgJiYgKHR5cGVvZiBtYXliZU5vZGVTdHJlYW1Cb2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgbWF5YmVTdHJlYW1Cb2R5LnBpcGVUbyA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgZm9sbG93IHJlZGlyZWN0IHdpdGggYm9keSBiZWluZyBhIHJlYWRhYmxlIHN0cmVhbVwiKTtcbiAgfVxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAzMDMgfHwgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMzAyKSAmJiBpbml0Lm1ldGhvZCA9PT0gXCJQT1NUXCIpIHtcbiAgICBpbml0Lm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgaW5pdC5ib2R5ID0gdm9pZCAwO1xuICAgIGRlbGV0ZUhlYWRlcihpbml0LCBcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICB9XG4gIGlmIChyZXNwb25zZS5oZWFkZXJzLmhhcyhcInJlZmVycmVyLXBvbGljeVwiKSkge1xuICAgIGluaXQucmVmZXJyZXJQb2xpY3kgPSBwYXJzZVJlZmVycmVyUG9saWN5KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmVmZXJyZXItcG9saWN5XCIpKTtcbiAgfVxuICBkZWxldGVIZWFkZXIoaW5pdCwgXCJob3N0XCIpO1xuICByZXR1cm4gYXdhaXQgZmV0Y2hJbXBsKHJlZGlyZWN0VXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGFkZENvb2tpZXNUb1JlcXVlc3QoaW5wdXQsIGluaXQsIGNvb2tpZSkge1xuICBpZiAoY29va2llID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cbiAgY29uc3QgbWF5YmVSZXF1ZXN0ID0gaW5wdXQ7XG4gIGNvbnN0IG1heWJlSGVhZGVycyA9IGluaXQuaGVhZGVycztcbiAgaWYgKG1heWJlUmVxdWVzdC5oZWFkZXJzICYmIHR5cGVvZiBtYXliZVJlcXVlc3QuaGVhZGVycy5hcHBlbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG1heWJlUmVxdWVzdC5oZWFkZXJzLmFwcGVuZChcImNvb2tpZVwiLCBjb29raWUpO1xuICB9IGVsc2UgaWYgKG1heWJlSGVhZGVycyAmJiB0eXBlb2YgbWF5YmVIZWFkZXJzLmFwcGVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbWF5YmVIZWFkZXJzLmFwcGVuZChcImNvb2tpZVwiLCBjb29raWUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5pdC5oZWFkZXJzKSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBbLi4uaW5pdC5oZWFkZXJzXTtcbiAgICBjb25zdCBjb29raWVIZWFkZXJJbmRleCA9IGhlYWRlcnMuZmluZEluZGV4KChoZWFkZXIpID0+IGhlYWRlclswXS50b0xvd2VyQ2FzZSgpID09PSBcImNvb2tpZVwiKTtcbiAgICBpZiAoY29va2llSGVhZGVySW5kZXggPT09IC0xKSB7XG4gICAgICBoZWFkZXJzLnB1c2goW1wiY29va2llXCIsIGNvb2tpZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzW2Nvb2tpZUhlYWRlckluZGV4XSA9IFtcImNvb2tpZVwiLCBjb29raWVdO1xuICAgIH1cbiAgICBpbml0ID0geyAuLi5pbml0LCBoZWFkZXJzIH07XG4gIH0gZWxzZSB7XG4gICAgaW5pdCA9IHsgLi4uaW5pdCwgaGVhZGVyczogeyAuLi5pbml0LmhlYWRlcnMsIGNvb2tpZSB9IH07XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59XG5mdW5jdGlvbiBnZXRDb29raWVzRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIGNvbnN0IG1heWJlTm9kZUZldGNoSGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gIGlmICh0eXBlb2YgbWF5YmVOb2RlRmV0Y2hIZWFkZXJzLmdldEFsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG1heWJlTm9kZUZldGNoSGVhZGVycy5nZXRBbGwoXCJzZXQtY29va2llXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgbWF5YmVOb2RlRmV0Y2hIZWFkZXJzLnJhdyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG1heWJlTm9kZUZldGNoSGVhZGVycy5yYXcoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzW1wic2V0LWNvb2tpZVwiXSkpIHtcbiAgICAgIHJldHVybiBoZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGNvb2tpZVN0cmluZyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwic2V0LWNvb2tpZVwiKTtcbiAgaWYgKGNvb2tpZVN0cmluZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBmZXRjaENvb2tpZShmZXRjaCwgamFyLCBpZ25vcmVFcnJvciA9IHRydWUpIHtcbiAgY29uc3QgYWN0dWFsRmV0Y2ggPSBmZXRjaDtcbiAgY29uc3QgYWN0dWFsSmFyID0gamFyID8/IG5ldyB0b3VnaC5Db29raWVKYXIoKTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb29raWVXcmFwcGVyKGlucHV0LCBpbml0KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxJbml0ID0gaW5pdCA/PyB7fTtcbiAgICBpbml0ID0geyAuLi5pbml0LCByZWRpcmVjdDogXCJtYW51YWxcIiB9O1xuICAgIGNvbnN0IHJlcXVlc3RVcmwgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBpbnB1dCA6IFwiaHJlZlwiIGluIGlucHV0ID8gaW5wdXQuaHJlZiA6IGlucHV0LnVybDtcbiAgICBjb25zdCBjb29raWUgPSBhd2FpdCBhY3R1YWxKYXIuZ2V0Q29va2llU3RyaW5nKHJlcXVlc3RVcmwpO1xuICAgIGluaXQgPSBhZGRDb29raWVzVG9SZXF1ZXN0KGlucHV0LCBpbml0LCBjb29raWUpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWN0dWFsRmV0Y2goaW5wdXQsIGluaXQpO1xuICAgIGNvbnN0IGNvb2tpZXMgPSBnZXRDb29raWVzRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChjb29raWVzLm1hcChhc3luYyAoY29va2llMikgPT4gYXdhaXQgYWN0dWFsSmFyLnNldENvb2tpZShjb29raWUyLCByZXNwb25zZS51cmwsIHsgaWdub3JlRXJyb3IgfSkpKTtcbiAgICBpZiAoKGluaXQucmVkaXJlY3RDb3VudCA/PyAwKSA+IDApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgXCJyZWRpcmVjdGVkXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgfVxuICAgIGlmICghaXNSZWRpcmVjdChyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBoYW5kbGVSZWRpcmVjdChmZXRjaENvb2tpZVdyYXBwZXIsIG9yaWdpbmFsSW5pdCwgcmVzcG9uc2UpO1xuICB9XG4gIGZldGNoQ29va2llV3JhcHBlci50b3VnaENvb2tpZSA9IHRvdWdoO1xuICBmZXRjaENvb2tpZVdyYXBwZXIuY29va2llSmFyID0gYWN0dWFsSmFyO1xuICByZXR1cm4gZmV0Y2hDb29raWVXcmFwcGVyO1xufVxuZmV0Y2hDb29raWUudG91Z2hDb29raWUgPSB0b3VnaDtcbmV4cG9ydCB7XG4gIGZldGNoQ29va2llIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fetch-cookie/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js":
/*!**************************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/LosslessNumber.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: () => (/* binding */ LosslessNumber),\n/* harmony export */   isLosslessNumber: () => (/* binding */ isLosslessNumber),\n/* harmony export */   toLosslessNumber: () => (/* binding */ toLosslessNumber)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nclass LosslessNumber {\n  // numeric value as string\n\n  // type information\n  isLosslessNumber = true;\n  constructor(value) {\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value)) {\n      throw new Error(`Invalid number (value: \"${value}\")`);\n    }\n    this.value = value;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf() {\n    const unsafeReason = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getUnsafeNumberReason)(this.value);\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === _utils_js__WEBPACK_IMPORTED_MODULE_0__.UnsafeNumberReason.truncate_float) {\n      return Number.parseFloat(this.value);\n    }\n\n    // truncate_integer\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(this.value)) {\n      return BigInt(this.value);\n    }\n\n    // overflow or underflow\n    throw new Error(`Cannot safely convert to number: the value '${this.value}' would ${unsafeReason} and become ${Number.parseFloat(this.value)}`);\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString() {\n    return this.value;\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nfunction isLosslessNumber(value) {\n  // @ts-ignore\n  return value && typeof value === 'object' && value.isLosslessNumber === true || false;\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nfunction toLosslessNumber(value) {\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extractSignificantDigits)(String(value)).length > 15) {\n    throw new Error(`Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${value})`);\n  }\n  if (Number.isNaN(value)) {\n    throw new Error('Invalid number: NaN');\n  }\n  if (!Number.isFinite(value)) {\n    throw new Error(`Invalid number: ${value}`);\n  }\n  return new LosslessNumber(String(value));\n}\n//# sourceMappingURL=LosslessNumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vTG9zc2xlc3NOdW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzSDs7QUFFdEg7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFRO0FBQ2pCLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQXFCOztBQUU5QztBQUNBLHVEQUF1RCx5REFBa0I7QUFDekU7QUFDQTs7QUFFQTtBQUNBLFFBQVEsb0RBQVM7QUFDakI7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRSxXQUFXLFVBQVUsY0FBYyxhQUFhLDhCQUE4QjtBQUNqSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLE1BQU0sbUVBQXdCO0FBQzlCLDhIQUE4SCxNQUFNO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vTG9zc2xlc3NOdW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVW5zYWZlTnVtYmVyUmVhc29uLCBleHRyYWN0U2lnbmlmaWNhbnREaWdpdHMsIGdldFVuc2FmZU51bWJlclJlYXNvbiwgaXNJbnRlZ2VyLCBpc051bWJlciB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgbG9zc2xlc3MgbnVtYmVyLiBTdG9yZXMgaXRzIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBMb3NzbGVzc051bWJlciB7XG4gIC8vIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXG5cbiAgLy8gdHlwZSBpbmZvcm1hdGlvblxuICBpc0xvc3NsZXNzTnVtYmVyID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciAodmFsdWU6IFwiJHt2YWx1ZX1cIilgKTtcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIExvc3NsZXNzTnVtYmVyIGFzIG51bWJlciBvciBiaWdpbnQuXG4gICAqXG4gICAqIC0gYSBudW1iZXIgaXMgcmV0dXJuZWQgZm9yIHNhZmUgbnVtYmVycyBhbmQgZGVjaW1hbCB2YWx1ZXMgdGhhdCBvbmx5IGxvc2Ugc29tZSBpbnNpZ25pZmljYW50IGRpZ2l0c1xuICAgKiAtIGEgYmlnaW50IGlzIHJldHVybmVkIGZvciBiaWcgaW50ZWdlciBudW1iZXJzXG4gICAqIC0gYW4gRXJyb3IgaXMgdGhyb3duIGZvciB2YWx1ZXMgdGhhdCB3aWxsIG92ZXJmbG93IG9yIHVuZGVyZmxvd1xuICAgKlxuICAgKiBOb3RlIHRoYXQgeW91IGNhbiBpbXBsZW1lbnQgeW91ciBvd24gc3RyYXRlZ3kgZm9yIGNvbnZlcnNpb24gYnkganVzdCBnZXR0aW5nIHRoZSB2YWx1ZSBhcyBzdHJpbmdcbiAgICogdmlhIC50b1N0cmluZygpLCBhbmQgdXNpbmcgdXRpbCBmdW5jdGlvbnMgbGlrZSBpc0ludGVnZXIsIGlzU2FmZU51bWJlciwgZ2V0VW5zYWZlTnVtYmVyUmVhc29uLFxuICAgKiBhbmQgdG9TYWZlTnVtYmVyT3JUaHJvdyB0byBjb252ZXJ0IGl0IHRvIGEgbnVtZXJpYyB2YWx1ZS5cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVhc29uID0gZ2V0VW5zYWZlTnVtYmVyUmVhc29uKHRoaXMudmFsdWUpO1xuXG4gICAgLy8gc2FmZSBvciB0cnVuY2F0ZV9mbG9hdFxuICAgIGlmICh1bnNhZmVSZWFzb24gPT09IHVuZGVmaW5lZCB8fCB1bnNhZmVSZWFzb24gPT09IFVuc2FmZU51bWJlclJlYXNvbi50cnVuY2F0ZV9mbG9hdCkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIHRydW5jYXRlX2ludGVnZXJcbiAgICBpZiAoaXNJbnRlZ2VyKHRoaXMudmFsdWUpKSB7XG4gICAgICByZXR1cm4gQmlnSW50KHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIG92ZXJmbG93IG9yIHVuZGVyZmxvd1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNhZmVseSBjb252ZXJ0IHRvIG51bWJlcjogdGhlIHZhbHVlICcke3RoaXMudmFsdWV9JyB3b3VsZCAke3Vuc2FmZVJlYXNvbn0gYW5kIGJlY29tZSAke051bWJlci5wYXJzZUZsb2F0KHRoaXMudmFsdWUpfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIExvc3NsZXNzTnVtYmVyIGFzIHN0cmluZy5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgLy8gTm90ZTogd2UgZG8gTk9UIGltcGxlbWVudCBhIC50b0pTT04oKSBtZXRob2QsIGFuZCB5b3Ugc2hvdWxkIG5vdCBpbXBsZW1lbnRcbiAgLy8gb3IgdXNlIHRoYXQsIGl0IGNhbm5vdCBzYWZlbHkgdHVybiB0aGUgbnVtZXJpYyB2YWx1ZSBpbiB0aGUgc3RyaW5nIGludG9cbiAgLy8gc3RyaW5naWZpZWQgSlNPTiBzaW5jZSBpdCBoYXMgdG8gYmUgcGFyc2VkIGludG8gYSBudW1iZXIgZmlyc3QuXG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYSBMb3NzbGVzc051bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb3NzbGVzc051bWJlcih2YWx1ZSkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmlzTG9zc2xlc3NOdW1iZXIgPT09IHRydWUgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQ29udmVydCBhIG51bWJlciBpbnRvIGEgTG9zc2xlc3NOdW1iZXIgaWYgdGhpcyBpcyBwb3NzaWJsZSBpbiBhIHNhZmUgd2F5XG4gKiBJZiB0aGUgdmFsdWUgaGFzIHRvbyBtYW55IGRpZ2l0cywgb3IgaXMgTmFOIG9yIEluZmluaXR5LCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Mb3NzbGVzc051bWJlcih2YWx1ZSkge1xuICBpZiAoZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKFN0cmluZyh2YWx1ZSkpLmxlbmd0aCA+IDE1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlcjogY29udGFpbnMgbW9yZSB0aGFuIDE1IGRpZ2l0cyBhbmQgaXMgbW9zdCBsaWtlbHkgdHJ1bmNhdGVkIGFuZCB1bnNhZmUgYnkgaXRzZWxmICh2YWx1ZTogJHt2YWx1ZX0pYCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyOiBOYU4nKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyOiAke3ZhbHVlfWApO1xuICB9XG4gIHJldHVybiBuZXcgTG9zc2xlc3NOdW1iZXIoU3RyaW5nKHZhbHVlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb3NzbGVzc051bWJlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/config.js":
/*!******************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/config.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config)\n/* harmony export */ });\n/**\n * Get and/or set configuration options\n * @deprecated There is no config anymore\n */\nfunction config(_options) {\n  // Backward compatibility warning for v1.x\n  throw new Error('config is deprecated, support for circularRefs is removed from the library. ' + 'If you encounter circular references in your data structures, ' + 'please rethink your datastructures: ' + 'better prevent circular references in the first place.');\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL2NvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdldCBhbmQvb3Igc2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQGRlcHJlY2F0ZWQgVGhlcmUgaXMgbm8gY29uZmlnIGFueW1vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZyhfb3B0aW9ucykge1xuICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdhcm5pbmcgZm9yIHYxLnhcbiAgdGhyb3cgbmV3IEVycm9yKCdjb25maWcgaXMgZGVwcmVjYXRlZCwgc3VwcG9ydCBmb3IgY2lyY3VsYXJSZWZzIGlzIHJlbW92ZWQgZnJvbSB0aGUgbGlicmFyeS4gJyArICdJZiB5b3UgZW5jb3VudGVyIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4geW91ciBkYXRhIHN0cnVjdHVyZXMsICcgKyAncGxlYXNlIHJldGhpbmsgeW91ciBkYXRhc3RydWN0dXJlczogJyArICdiZXR0ZXIgcHJldmVudCBjaXJjdWxhciByZWZlcmVuY2VzIGluIHRoZSBmaXJzdCBwbGFjZS4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.LosslessNumber),\n/* harmony export */   UnsafeNumberReason: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.UnsafeNumberReason),\n/* harmony export */   config: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_0__.config),\n/* harmony export */   getUnsafeNumberReason: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.getUnsafeNumberReason),\n/* harmony export */   isInteger: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isInteger),\n/* harmony export */   isLosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.isLosslessNumber),\n/* harmony export */   isNumber: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isNumber),\n/* harmony export */   isSafeNumber: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isSafeNumber),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_1__.parse),\n/* harmony export */   parseLosslessNumber: () => (/* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseLosslessNumber),\n/* harmony export */   parseNumberAndBigInt: () => (/* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt),\n/* harmony export */   reviveDate: () => (/* reexport safe */ _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__.reviveDate),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify),\n/* harmony export */   toLosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.toLosslessNumber),\n/* harmony export */   toSafeNumberOrThrow: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.toSafeNumberOrThrow)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/config.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/stringify.js\");\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reviveDate.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/reviveDate.js\");\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./numberParsers.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/types.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRjtBQUNRO0FBQzhDO0FBQzVDO0FBQ2tDO0FBQ2dEO0FBQ3BHO0FBQzNCIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZy5qcyc7XG5leHBvcnQgeyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnO1xuZXhwb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgTG9zc2xlc3NOdW1iZXIsIGlzTG9zc2xlc3NOdW1iZXIsIHRvTG9zc2xlc3NOdW1iZXIgfSBmcm9tICcuL0xvc3NsZXNzTnVtYmVyLmpzJztcbmV4cG9ydCB7IHJldml2ZURhdGUgfSBmcm9tICcuL3Jldml2ZURhdGUuanMnO1xuZXhwb3J0IHsgcGFyc2VMb3NzbGVzc051bWJlciwgcGFyc2VOdW1iZXJBbmRCaWdJbnQgfSBmcm9tICcuL251bWJlclBhcnNlcnMuanMnO1xuZXhwb3J0IHsgVW5zYWZlTnVtYmVyUmVhc29uLCBpc0ludGVnZXIsIGlzTnVtYmVyLCBpc1NhZmVOdW1iZXIsIHRvU2FmZU51bWJlck9yVGhyb3csIGdldFVuc2FmZU51bWJlclJlYXNvbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js":
/*!*************************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/numberParsers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseLosslessNumber: () => (/* binding */ parseLosslessNumber),\n/* harmony export */   parseNumberAndBigInt: () => (/* binding */ parseNumberAndBigInt)\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n\n\nfunction parseLosslessNumber(value) {\n  return new _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.LosslessNumber(value);\n}\nfunction parseNumberAndBigInt(value) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(value) ? BigInt(value) : Number.parseFloat(value);\n}\n//# sourceMappingURL=numberParsers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vbnVtYmVyUGFyc2Vycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFEO0FBQ2Q7QUFDaEM7QUFDUCxhQUFhLDhEQUFjO0FBQzNCO0FBQ087QUFDUCxTQUFTLG9EQUFTO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL251bWJlclBhcnNlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9zc2xlc3NOdW1iZXIgfSBmcm9tICcuL0xvc3NsZXNzTnVtYmVyLmpzJztcbmltcG9ydCB7IGlzSW50ZWdlciB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTG9zc2xlc3NOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBMb3NzbGVzc051bWJlcih2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VOdW1iZXJBbmRCaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgPyBCaWdJbnQodmFsdWUpIDogTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyUGFyc2Vycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeLowercaseA: () => (/* binding */ codeLowercaseA),\n/* harmony export */   codeLowercaseE: () => (/* binding */ codeLowercaseE),\n/* harmony export */   codeLowercaseF: () => (/* binding */ codeLowercaseF),\n/* harmony export */   codeUppercaseA: () => (/* binding */ codeUppercaseA),\n/* harmony export */   codeUppercaseE: () => (/* binding */ codeUppercaseE),\n/* harmony export */   codeUppercaseF: () => (/* binding */ codeUppercaseF),\n/* harmony export */   isDeepEqual: () => (/* binding */ isDeepEqual),\n/* harmony export */   isValidStringCharacter: () => (/* binding */ isValidStringCharacter),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberParsers.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _revive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./revive.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/revive.js\");\n\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nfunction parse(text, reviver) {\n  let parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__.parseLosslessNumber;\n  let i = 0;\n  const value = parseValue();\n  expectValue(value);\n  expectEndOfInput();\n  return reviver ? (0,_revive_js__WEBPACK_IMPORTED_MODULE_1__.revive)(value, reviver) : value;\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++;\n      skipWhitespace();\n      const object = {};\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma();\n          skipWhitespace();\n        } else {\n          initial = false;\n        }\n        const start = i;\n        const key = parseString();\n        if (key === undefined) {\n          throwObjectKeyExpected();\n          return; // To make TS happy\n        }\n        skipWhitespace();\n        eatColon();\n        const value = parseValue();\n        if (value === undefined) {\n          throwObjectValueExpected();\n          return; // To make TS happy\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1);\n        }\n        object[key] = value;\n      }\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected();\n      }\n      i++;\n      return object;\n    }\n  }\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++;\n      skipWhitespace();\n      const array = [];\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma();\n        } else {\n          initial = false;\n        }\n        const value = parseValue();\n        expectArrayItem(value);\n        array.push(value);\n      }\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected();\n      }\n      i++;\n      return array;\n    }\n  }\n  function parseValue() {\n    skipWhitespace();\n    const value = parseString() ?? parseNumeric() ?? parseObject() ?? parseArray() ?? parseKeyword('true', true) ?? parseKeyword('false', false) ?? parseKeyword('null', null);\n    skipWhitespace();\n    return value;\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length;\n      return value;\n    }\n  }\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++;\n    }\n  }\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++;\n      let result = '';\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1];\n          const escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            result += escapeChar;\n            i++;\n          } else if (char === 'u') {\n            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n              result += String.fromCharCode(Number.parseInt(text.slice(i + 2, i + 6), 16));\n              i += 5;\n            } else {\n              throwInvalidUnicodeCharacter(i);\n            }\n          } else {\n            throwInvalidEscapeCharacter(i);\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i];\n          } else {\n            throwInvalidCharacter(text[i]);\n          }\n        }\n        i++;\n      }\n      expectEndOfString();\n      i++;\n      return result;\n    }\n  }\n  function parseNumeric() {\n    const start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      expectDigit(start);\n    }\n    if (text.charCodeAt(i) === codeZero) {\n      i++;\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++;\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (i > start) {\n      return parseNumber(text.slice(start, i));\n    }\n  }\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`);\n    }\n    i++;\n  }\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`);\n    }\n    i++;\n  }\n  function expectValue(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`);\n    }\n  }\n  function expectArrayItem(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`);\n    }\n  }\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`);\n    }\n  }\n  function expectDigit(start) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i);\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`);\n    }\n  }\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`);\n    }\n  }\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`);\n  }\n  function throwDuplicateKey(key, pos) {\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`);\n  }\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`);\n  }\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`);\n  }\n  function throwInvalidCharacter(char) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`);\n  }\n  function throwInvalidEscapeCharacter(start) {\n    const chars = text.slice(start, start + 2);\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`);\n  }\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`);\n  }\n  function throwInvalidUnicodeCharacter(start) {\n    const chars = text.slice(start, start + 6);\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`);\n  }\n\n  // zero based character position\n  function pos() {\n    return `at position ${i}`;\n  }\n  function got() {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input';\n  }\n  function gotAt() {\n    return `${got()} ${pos()}`;\n  }\n}\nfunction isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n  return code >= codeOne && code <= codeNine;\n}\nfunction isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nfunction isDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]));\n  }\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])];\n    return keys.every(key => isDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\n// map with all escape characters\nconst escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\nconst codeBackslash = 0x5c; // \"\\\"\nconst codeOpeningBrace = 0x7b; // \"{\"\nconst codeClosingBrace = 0x7d; // \"}\"\nconst codeOpeningBracket = 0x5b; // \"[\"\nconst codeClosingBracket = 0x5d; // \"]\"\nconst codeSpace = 0x20; // \" \"\nconst codeNewline = 0xa; // \"\\n\"\nconst codeTab = 0x9; // \"\\t\"\nconst codeReturn = 0xd; // \"\\r\"\nconst codeDoubleQuote = 0x0022; // \"\nconst codePlus = 0x2b; // \"+\"\nconst codeMinus = 0x2d; // \"-\"\nconst codeZero = 0x30;\nconst codeOne = 0x31;\nconst codeNine = 0x39;\nconst codeComma = 0x2c; // \",\"\nconst codeDot = 0x2e; // \".\" (dot, period)\nconst codeColon = 0x3a; // \":\"\nconst codeUppercaseA = 0x41; // \"A\"\nconst codeLowercaseA = 0x61; // \"a\"\nconst codeUppercaseE = 0x45; // \"E\"\nconst codeLowercaseE = 0x65; // \"e\"\nconst codeUppercaseF = 0x46; // \"F\"\nconst codeLowercaseF = 0x66; // \"f\"\n//# sourceMappingURL=parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDcEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdGQUF3RixrRUFBbUI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEUsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFFBQVE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVMsdUJBQXVCLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0EsNENBQTRDLElBQUksNEJBQTRCLElBQUk7QUFDaEY7QUFDQTtBQUNBLGdFQUFnRSxhQUFhLFFBQVE7QUFDckY7QUFDQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSyxJQUFJLE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE1BQU0sSUFBSSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTSxJQUFJLE1BQU07QUFDeEU7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0EsY0FBYyxPQUFPLEVBQUUsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLCtCQUErQixLQUFLO0FBQ3BDLCtCQUErQixLQUFLO0FBQ3BDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ2pCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQ3BDIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZUxvc3NsZXNzTnVtYmVyIH0gZnJvbSAnLi9udW1iZXJQYXJzZXJzLmpzJztcbmltcG9ydCB7IHJldml2ZSB9IGZyb20gJy4vcmV2aXZlLmpzJztcbi8qKlxuICogVGhlIExvc3NsZXNzSlNPTi5wYXJzZSgpIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXMgSlNPTiwgb3B0aW9uYWxseSB0cmFuc2Zvcm1pbmdcbiAqIHRoZSB2YWx1ZSBwcm9kdWNlZCBieSBwYXJzaW5nLlxuICpcbiAqIFRoZSBwYXJzZXIgaXMgYmFzZWQgb24gdGhlIHBhcnNlciBvZiBUYW4gTGkgSG91IHNoYXJlZCBpblxuICogaHR0cHM6Ly9saWhhdXRhbi5jb20vanNvbi1wYXJzZXItd2l0aC1qYXZhc2NyaXB0L1xuICpcbiAqIEBwYXJhbSB0ZXh0XG4gKiBUaGUgc3RyaW5nIHRvIHBhcnNlIGFzIEpTT04uIFNlZSB0aGUgSlNPTiBvYmplY3QgZm9yIGEgZGVzY3JpcHRpb24gb2YgSlNPTiBzeW50YXguXG4gKlxuICogQHBhcmFtIFtyZXZpdmVyXVxuICogSWYgYSBmdW5jdGlvbiwgcHJlc2NyaWJlcyBob3cgdGhlIHZhbHVlIG9yaWdpbmFsbHkgcHJvZHVjZWQgYnkgcGFyc2luZyBpc1xuICogdHJhbnNmb3JtZWQsIGJlZm9yZSBiZWluZyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gW3BhcnNlTnVtYmVyPXBhcnNlTG9zc2xlc3NOdW1iZXJdXG4gKiBQYXNzIGEgY3VzdG9tIG51bWJlciBwYXJzZXIuIElucHV0IGlzIGEgc3RyaW5nLCBhbmQgdGhlIG91dHB1dCBjYW4gYmUgdW5rbm93blxuICogbnVtZXJpYyB2YWx1ZTogbnVtYmVyLCBiaWdpbnQsIExvc3NsZXNzTnVtYmVyLCBvciBhIGN1c3RvbSBCaWdOdW1iZXIgbGlicmFyeS5cbiAqXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBPYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gSlNPTiB0ZXh0LlxuICpcbiAqIEB0aHJvd3MgVGhyb3dzIGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uIGlmIHRoZSBzdHJpbmcgdG8gcGFyc2UgaXMgbm90IHZhbGlkIEpTT04uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0LCByZXZpdmVyKSB7XG4gIGxldCBwYXJzZU51bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcGFyc2VMb3NzbGVzc051bWJlcjtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlVmFsdWUoKTtcbiAgZXhwZWN0VmFsdWUodmFsdWUpO1xuICBleHBlY3RFbmRPZklucHV0KCk7XG4gIHJldHVybiByZXZpdmVyID8gcmV2aXZlKHZhbHVlLCByZXZpdmVyKSA6IHZhbHVlO1xuICBmdW5jdGlvbiBwYXJzZU9iamVjdCgpIHtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlT3BlbmluZ0JyYWNlKSB7XG4gICAgICBpKys7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICBsZXQgaW5pdGlhbCA9IHRydWU7XG4gICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFjZSkge1xuICAgICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgICBlYXRDb21tYSgpO1xuICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VTdHJpbmcoKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3dPYmplY3RLZXlFeHBlY3RlZCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gVG8gbWFrZSBUUyBoYXBweVxuICAgICAgICB9XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIGVhdENvbG9uKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VWYWx1ZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93T2JqZWN0VmFsdWVFeHBlY3RlZCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gVG8gbWFrZSBUUyBoYXBweVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGVzdCBkZWVwIGVxdWFsIGluc3RlYWQgb2Ygc3RyaWN0IGVxdWFsXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmICFpc0RlZXBFcXVhbCh2YWx1ZSwgb2JqZWN0W2tleV0pKSB7XG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNvdWxkIGFsc28gdGVzdCBgaWYoa2V5IGluIG9iamVjdCkgey4uLn1gXG4gICAgICAgICAgLy8gb3IgYGlmIChvYmplY3Rba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHsuLi59YCwgYnV0IHRoYXQgaXMgc2xvd2VyLlxuICAgICAgICAgIHRocm93RHVwbGljYXRlS2V5KGtleSwgc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFjZSkge1xuICAgICAgICB0aHJvd09iamVjdEtleU9yRW5kRXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZU9wZW5pbmdCcmFja2V0KSB7XG4gICAgICBpKys7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgIGxldCBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlQ2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgICAgZWF0Q29tbWEoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZVZhbHVlKCk7XG4gICAgICAgIGV4cGVjdEFycmF5SXRlbSh2YWx1ZSk7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFja2V0KSB7XG4gICAgICAgIHRocm93QXJyYXlJdGVtT3JFbmRFeHBlY3RlZCgpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXJzZVZhbHVlKCkge1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZVN0cmluZygpID8/IHBhcnNlTnVtZXJpYygpID8/IHBhcnNlT2JqZWN0KCkgPz8gcGFyc2VBcnJheSgpID8/IHBhcnNlS2V5d29yZCgndHJ1ZScsIHRydWUpID8/IHBhcnNlS2V5d29yZCgnZmFsc2UnLCBmYWxzZSkgPz8gcGFyc2VLZXl3b3JkKCdudWxsJywgbnVsbCk7XG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VLZXl3b3JkKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRleHQuc2xpY2UoaSwgaSArIG5hbWUubGVuZ3RoKSA9PT0gbmFtZSkge1xuICAgICAgaSArPSBuYW1lLmxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgaSsrO1xuICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgd2hpbGUgKGkgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlQmFja3NsYXNoKSB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgICAgIGNvbnN0IGVzY2FwZUNoYXIgPSBlc2NhcGVDaGFyYWN0ZXJzW2NoYXJdO1xuICAgICAgICAgIGlmIChlc2NhcGVDaGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3UnKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyAyKSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyAzKSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyA0KSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyA1KSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoTnVtYmVyLnBhcnNlSW50KHRleHQuc2xpY2UoaSArIDIsIGkgKyA2KSwgMTYpKTtcbiAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3dJbnZhbGlkVW5pY29kZUNoYXJhY3RlcihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZFN0cmluZ0NoYXJhY3Rlcih0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGV4dFtpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dJbnZhbGlkQ2hhcmFjdGVyKHRleHRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBleHBlY3RFbmRPZlN0cmluZygpO1xuICAgICAgaSsrO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VOdW1lcmljKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlTWludXMpIHtcbiAgICAgIGkrKztcbiAgICAgIGV4cGVjdERpZ2l0KHN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZVplcm8pIHtcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKGlzTm9uWmVyb0RpZ2l0KHRleHQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlRG90KSB7XG4gICAgICBpKys7XG4gICAgICBleHBlY3REaWdpdChzdGFydCk7XG4gICAgICB3aGlsZSAoaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZUxvd2VyY2FzZUUgfHwgdGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlVXBwZXJjYXNlRSkge1xuICAgICAgaSsrO1xuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZU1pbnVzIHx8IHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZVBsdXMpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgZXhwZWN0RGlnaXQoc3RhcnQpO1xuICAgICAgd2hpbGUgKGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gc3RhcnQpIHtcbiAgICAgIHJldHVybiBwYXJzZU51bWJlcih0ZXh0LnNsaWNlKHN0YXJ0LCBpKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVhdENvbW1hKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVDb21tYSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBDb21tYSAnLCcgZXhwZWN0ZWQgYWZ0ZXIgdmFsdWUgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZnVuY3Rpb24gZWF0Q29sb24oKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNvbG9uKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENvbG9uICc6JyBleHBlY3RlZCBhZnRlciBwcm9wZXJ0eSBuYW1lICR7Z290QXQoKX1gKTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIGZ1bmN0aW9uIGV4cGVjdFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSlNPTiB2YWx1ZSBleHBlY3RlZCAke2dvdEF0KCl9YCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4cGVjdEFycmF5SXRlbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEFycmF5IGl0ZW0gZXhwZWN0ZWQgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHBlY3RFbmRPZklucHV0KCkge1xuICAgIGlmIChpIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgZW5kIG9mIGlucHV0ICR7Z290QXQoKX1gKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0RGlnaXQoc3RhcnQpIHtcbiAgICBpZiAoIWlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgY29uc3QgbnVtU29GYXIgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBudW1iZXIgJyR7bnVtU29GYXJ9JywgZXhwZWN0aW5nIGEgZGlnaXQgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHBlY3RFbmRPZlN0cmluZygpIHtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlRG91YmxlUXVvdGUpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRW5kIG9mIHN0cmluZyAnXCInIGV4cGVjdGVkICR7Z290QXQoKX1gKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdGhyb3dPYmplY3RLZXlFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFF1b3RlZCBvYmplY3Qga2V5IGV4cGVjdGVkICR7Z290QXQoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0R1cGxpY2F0ZUtleShrZXksIHBvcykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRHVwbGljYXRlIGtleSAnJHtrZXl9JyBlbmNvdW50ZXJlZCBhdCBwb3NpdGlvbiAke3Bvc31gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd09iamVjdEtleU9yRW5kRXhwZWN0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBRdW90ZWQgb2JqZWN0IGtleSBvciBlbmQgb2Ygb2JqZWN0ICd9JyBleHBlY3RlZCAke2dvdEF0KCl9YCk7XG4gIH1cbiAgZnVuY3Rpb24gdGhyb3dBcnJheUl0ZW1PckVuZEV4cGVjdGVkKCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgQXJyYXkgaXRlbSBvciBlbmQgb2YgYXJyYXkgJ10nIGV4cGVjdGVkICR7Z290QXQoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0ludmFsaWRDaGFyYWN0ZXIoY2hhcikge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgJyR7Y2hhcn0nICR7cG9zKCl9YCk7XG4gIH1cbiAgZnVuY3Rpb24gdGhyb3dJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyKHN0YXJ0KSB7XG4gICAgY29uc3QgY2hhcnMgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIDIpO1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBlc2NhcGUgY2hhcmFjdGVyICcke2NoYXJzfScgJHtwb3MoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd09iamVjdFZhbHVlRXhwZWN0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBPYmplY3QgdmFsdWUgZXhwZWN0ZWQgYWZ0ZXIgJzonICR7cG9zKCl9YCk7XG4gIH1cbiAgZnVuY3Rpb24gdGhyb3dJbnZhbGlkVW5pY29kZUNoYXJhY3RlcihzdGFydCkge1xuICAgIGNvbnN0IGNoYXJzID0gdGV4dC5zbGljZShzdGFydCwgc3RhcnQgKyA2KTtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdW5pY29kZSBjaGFyYWN0ZXIgJyR7Y2hhcnN9JyAke3BvcygpfWApO1xuICB9XG5cbiAgLy8gemVybyBiYXNlZCBjaGFyYWN0ZXIgcG9zaXRpb25cbiAgZnVuY3Rpb24gcG9zKCkge1xuICAgIHJldHVybiBgYXQgcG9zaXRpb24gJHtpfWA7XG4gIH1cbiAgZnVuY3Rpb24gZ290KCkge1xuICAgIHJldHVybiBpIDwgdGV4dC5sZW5ndGggPyBgYnV0IGdvdCAnJHt0ZXh0W2ldfSdgIDogJ2J1dCByZWFjaGVkIGVuZCBvZiBpbnB1dCc7XG4gIH1cbiAgZnVuY3Rpb24gZ290QXQoKSB7XG4gICAgcmV0dXJuIGAke2dvdCgpfSAke3BvcygpfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSBjb2RlU3BhY2UgfHwgY29kZSA9PT0gY29kZU5ld2xpbmUgfHwgY29kZSA9PT0gY29kZVRhYiB8fCBjb2RlID09PSBjb2RlUmV0dXJuO1xufVxuZnVuY3Rpb24gaXNIZXgoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSBjb2RlWmVybyAmJiBjb2RlIDw9IGNvZGVOaW5lIHx8IGNvZGUgPj0gY29kZVVwcGVyY2FzZUEgJiYgY29kZSA8PSBjb2RlVXBwZXJjYXNlRiB8fCBjb2RlID49IGNvZGVMb3dlcmNhc2VBICYmIGNvZGUgPD0gY29kZUxvd2VyY2FzZUY7XG59XG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gY29kZVplcm8gJiYgY29kZSA8PSBjb2RlTmluZTtcbn1cbmZ1bmN0aW9uIGlzTm9uWmVyb0RpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gY29kZU9uZSAmJiBjb2RlIDw9IGNvZGVOaW5lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRTdHJpbmdDaGFyYWN0ZXIoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAweDIwICYmIGNvZGUgPD0gMHgxMGZmZmY7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGl0ZW0sIGluZGV4KSA9PiBpc0RlZXBFcXVhbChpdGVtLCBiW2luZGV4XSkpO1xuICB9XG4gIGlmIChpc09iamVjdChhKSAmJiBpc09iamVjdChiKSkge1xuICAgIGNvbnN0IGtleXMgPSBbLi4ubmV3IFNldChbLi4uT2JqZWN0LmtleXMoYSksIC4uLk9iamVjdC5rZXlzKGIpXSldO1xuICAgIHJldHVybiBrZXlzLmV2ZXJ5KGtleSA9PiBpc0RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG4vLyBtYXAgd2l0aCBhbGwgZXNjYXBlIGNoYXJhY3RlcnNcbmNvbnN0IGVzY2FwZUNoYXJhY3RlcnMgPSB7XG4gICdcIic6ICdcIicsXG4gICdcXFxcJzogJ1xcXFwnLFxuICAnLyc6ICcvJyxcbiAgYjogJ1xcYicsXG4gIGY6ICdcXGYnLFxuICBuOiAnXFxuJyxcbiAgcjogJ1xccicsXG4gIHQ6ICdcXHQnXG4gIC8vIG5vdGUgdGhhdCBcXHUgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGluIHBhcnNlU3RyaW5nKClcbn07XG5jb25zdCBjb2RlQmFja3NsYXNoID0gMHg1YzsgLy8gXCJcXFwiXG5jb25zdCBjb2RlT3BlbmluZ0JyYWNlID0gMHg3YjsgLy8gXCJ7XCJcbmNvbnN0IGNvZGVDbG9zaW5nQnJhY2UgPSAweDdkOyAvLyBcIn1cIlxuY29uc3QgY29kZU9wZW5pbmdCcmFja2V0ID0gMHg1YjsgLy8gXCJbXCJcbmNvbnN0IGNvZGVDbG9zaW5nQnJhY2tldCA9IDB4NWQ7IC8vIFwiXVwiXG5jb25zdCBjb2RlU3BhY2UgPSAweDIwOyAvLyBcIiBcIlxuY29uc3QgY29kZU5ld2xpbmUgPSAweGE7IC8vIFwiXFxuXCJcbmNvbnN0IGNvZGVUYWIgPSAweDk7IC8vIFwiXFx0XCJcbmNvbnN0IGNvZGVSZXR1cm4gPSAweGQ7IC8vIFwiXFxyXCJcbmNvbnN0IGNvZGVEb3VibGVRdW90ZSA9IDB4MDAyMjsgLy8gXCJcbmNvbnN0IGNvZGVQbHVzID0gMHgyYjsgLy8gXCIrXCJcbmNvbnN0IGNvZGVNaW51cyA9IDB4MmQ7IC8vIFwiLVwiXG5jb25zdCBjb2RlWmVybyA9IDB4MzA7XG5jb25zdCBjb2RlT25lID0gMHgzMTtcbmNvbnN0IGNvZGVOaW5lID0gMHgzOTtcbmNvbnN0IGNvZGVDb21tYSA9IDB4MmM7IC8vIFwiLFwiXG5jb25zdCBjb2RlRG90ID0gMHgyZTsgLy8gXCIuXCIgKGRvdCwgcGVyaW9kKVxuY29uc3QgY29kZUNvbG9uID0gMHgzYTsgLy8gXCI6XCJcbmV4cG9ydCBjb25zdCBjb2RlVXBwZXJjYXNlQSA9IDB4NDE7IC8vIFwiQVwiXG5leHBvcnQgY29uc3QgY29kZUxvd2VyY2FzZUEgPSAweDYxOyAvLyBcImFcIlxuZXhwb3J0IGNvbnN0IGNvZGVVcHBlcmNhc2VFID0gMHg0NTsgLy8gXCJFXCJcbmV4cG9ydCBjb25zdCBjb2RlTG93ZXJjYXNlRSA9IDB4NjU7IC8vIFwiZVwiXG5leHBvcnQgY29uc3QgY29kZVVwcGVyY2FzZUYgPSAweDQ2OyAvLyBcIkZcIlxuZXhwb3J0IGNvbnN0IGNvZGVMb3dlcmNhc2VGID0gMHg2NjsgLy8gXCJmXCJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/parse.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/revive.js":
/*!******************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/revive.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   revive: () => (/* binding */ revive)\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nfunction revive(json, reviver) {\n  return reviveValue({\n    '': json\n  }, '', json, reviver);\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  }\n  if (value && typeof value === 'object' && !(0,_LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.isLosslessNumber)(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver));\n  }\n  return reviver.call(context, key, value);\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object, reviver) {\n  for (const key of Object.keys(object)) {\n    const value = reviveValue(object, key, object[key], reviver);\n    if (value !== undefined) {\n      object[key] = value;\n    } else {\n      delete object[key];\n    }\n  }\n  return object;\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array, reviver) {\n  for (let i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, String(i), array[i], reviver);\n  }\n  return array;\n}\n//# sourceMappingURL=revive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcmV2aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9FQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNMb3NzbGVzc051bWJlciB9IGZyb20gJy4vTG9zc2xlc3NOdW1iZXIuanMnO1xuLyoqXG4gKiBSZXZpdmUgYSBqc29uIG9iamVjdC5cbiAqIEFwcGxpZXMgdGhlIHJldml2ZXIgZnVuY3Rpb24gcmVjdXJzaXZlbHkgb24gYWxsIHZhbHVlcyBpbiB0aGUgSlNPTiBvYmplY3QuXG4gKiBAcGFyYW0ganNvbiAgIEEgSlNPTiBPYmplY3QsIEFycmF5LCBvciB2YWx1ZVxuICogQHBhcmFtIHJldml2ZXJcbiAqICAgICAgICAgICAgICBBIHJldml2ZXIgZnVuY3Rpb24gaW52b2tlZCB3aXRoIGFyZ3VtZW50cyBga2V5YCBhbmQgYHZhbHVlYCxcbiAqICAgICAgICAgICAgICB3aGljaCBtdXN0IHJldHVybiBhIHJlcGxhY2VtZW50IHZhbHVlLiBUaGUgZnVuY3Rpb24gY29udGV4dFxuICogICAgICAgICAgICAgIChgdGhpc2ApIGlzIHRoZSBPYmplY3Qgb3IgQXJyYXkgdGhhdCBjb250YWlucyB0aGUgY3VycmVudGx5XG4gKiAgICAgICAgICAgICAgaGFuZGxlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldml2ZShqc29uLCByZXZpdmVyKSB7XG4gIHJldHVybiByZXZpdmVWYWx1ZSh7XG4gICAgJyc6IGpzb25cbiAgfSwgJycsIGpzb24sIHJldml2ZXIpO1xufVxuXG4vKipcbiAqIFJldml2ZSBhIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHJldml2ZVZhbHVlKGNvbnRleHQsIGtleSwgdmFsdWUsIHJldml2ZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChjb250ZXh0LCBrZXksIHJldml2ZUFycmF5KHZhbHVlLCByZXZpdmVyKSk7XG4gIH1cbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIWlzTG9zc2xlc3NOdW1iZXIodmFsdWUpKSB7XG4gICAgLy8gbm90ZSB0aGUgc3BlY2lhbCBjYXNlIGZvciBMb3NzbGVzc051bWJlcixcbiAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGl0ZXJhdGUgb3ZlciB0aGUgaW50ZXJuYWxzIG9mIGEgTG9zc2xlc3NOdW1iZXJcbiAgICByZXR1cm4gcmV2aXZlci5jYWxsKGNvbnRleHQsIGtleSwgcmV2aXZlT2JqZWN0KHZhbHVlLCByZXZpdmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJldml2ZXIuY2FsbChjb250ZXh0LCBrZXksIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZXZpdmUgdGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHJldml2ZU9iamVjdChvYmplY3QsIHJldml2ZXIpIHtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqZWN0KSkge1xuICAgIGNvbnN0IHZhbHVlID0gcmV2aXZlVmFsdWUob2JqZWN0LCBrZXksIG9iamVjdFtrZXldLCByZXZpdmVyKTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIFJldml2ZSB0aGUgcHJvcGVydGllcyBvZiBhbiBBcnJheVxuICovXG5mdW5jdGlvbiByZXZpdmVBcnJheShhcnJheSwgcmV2aXZlcikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSByZXZpdmVWYWx1ZShhcnJheSwgU3RyaW5nKGkpLCBhcnJheVtpXSwgcmV2aXZlcik7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV2aXZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/revive.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/reviveDate.js":
/*!**********************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/reviveDate.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reviveDate: () => (/* binding */ reviveDate)\n/* harmony export */ });\n/**\n * Revive a string containing an ISO 8601 date string into a JavaScript `Date` object\n */\nfunction reviveDate(key, value) {\n  return typeof value === 'string' && isoDateRegex.test(value) ? new Date(value) : value;\n}\n\n// Matches strings like \"2022-08-25T09:39:19.288Z\"\nconst isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;\n//# sourceMappingURL=reviveDate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcmV2aXZlRGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDakUiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL3Jldml2ZURhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXZpdmUgYSBzdHJpbmcgY29udGFpbmluZyBhbiBJU08gODYwMSBkYXRlIHN0cmluZyBpbnRvIGEgSmF2YVNjcmlwdCBgRGF0ZWAgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZpdmVEYXRlKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgaXNvRGF0ZVJlZ2V4LnRlc3QodmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogdmFsdWU7XG59XG5cbi8vIE1hdGNoZXMgc3RyaW5ncyBsaWtlIFwiMjAyMi0wOC0yNVQwOTozOToxOS4yODhaXCJcbmNvbnN0IGlzb0RhdGVSZWdleCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn1cXC5cXGR7M31aJC87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZpdmVEYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/reviveDate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */\nfunction stringify(value, replacer, space, numberStringifiers) {\n  const resolvedSpace = resolveSpace(space);\n  const replacedValue = typeof replacer === 'function' ? replacer.call({\n    '': value\n  }, '', value) : value;\n  return stringifyValue(replacedValue, '');\n\n  /**\n   * Stringify a value\n   */\n  function stringifyValue(value, indent) {\n    if (Array.isArray(numberStringifiers)) {\n      const stringifier = numberStringifiers.find(item => item.test(value));\n      if (stringifier) {\n        const str = stringifier.stringify(value);\n        if (typeof str !== 'string' || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(str)) {\n          throw new Error(`Invalid JSON number: output of a number stringifier must be a string containing a JSON number (output: ${str})`);\n        }\n        return str;\n      }\n    }\n\n    // boolean, null, number, string, or date\n    if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value === null || value instanceof Date || value instanceof Boolean || value instanceof Number || value instanceof String) {\n      return JSON.stringify(value);\n    }\n\n    // lossless number, the secret ingredient :)\n    // @ts-ignore\n    if (value?.isLosslessNumber) {\n      return value.toString();\n    }\n\n    // BigInt\n    if (typeof value === 'bigint') {\n      return value.toString();\n    }\n\n    // Array\n    if (Array.isArray(value)) {\n      return stringifyArray(value, indent);\n    }\n\n    // Object (test lastly!)\n    if (value && typeof value === 'object') {\n      return stringifyObject(value, indent);\n    }\n    return undefined;\n  }\n\n  /**\n   * Stringify an array\n   */\n  function stringifyArray(array, indent) {\n    if (array.length === 0) {\n      return '[]';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let str = resolvedSpace ? '[\\n' : '[';\n    for (let i = 0; i < array.length; i++) {\n      const item = typeof replacer === 'function' ? replacer.call(array, String(i), array[i]) : array[i];\n      if (resolvedSpace) {\n        str += childIndent;\n      }\n      if (typeof item !== 'undefined' && typeof item !== 'function') {\n        str += stringifyValue(item, childIndent);\n      } else {\n        str += 'null';\n      }\n      if (i < array.length - 1) {\n        str += resolvedSpace ? ',\\n' : ',';\n      }\n    }\n    str += resolvedSpace ? `\\n${indent}]` : ']';\n    return str;\n  }\n\n  /**\n   * Stringify an object\n   */\n  function stringifyObject(object, indent) {\n    if (typeof object.toJSON === 'function') {\n      return stringify(object.toJSON(), replacer, space, undefined);\n    }\n    const keys = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);\n    if (keys.length === 0) {\n      return '{}';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let first = true;\n    let str = resolvedSpace ? '{\\n' : '{';\n    for (const key of keys) {\n      const value = typeof replacer === 'function' ? replacer.call(object, key, object[key]) : object[key];\n      if (includeProperty(key, value)) {\n        if (first) {\n          first = false;\n        } else {\n          str += resolvedSpace ? ',\\n' : ',';\n        }\n        const keyStr = JSON.stringify(key);\n        str += resolvedSpace ? `${childIndent + keyStr}: ` : `${keyStr}:`;\n        str += stringifyValue(value, childIndent);\n      }\n    }\n    str += resolvedSpace ? `\\n${indent}}` : '}';\n    return str;\n  }\n\n  /**\n   * Test whether to include a property in a stringified object or not.\n   */\n  function includeProperty(_key, value) {\n    return typeof value !== 'undefined' && typeof value !== 'function' && typeof value !== 'symbol';\n  }\n}\n\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */\nfunction resolveSpace(space) {\n  if (typeof space === 'number') {\n    return ' '.repeat(space);\n  }\n  if (typeof space === 'string' && space !== '') {\n    return space;\n  }\n  return undefined;\n}\n//# sourceMappingURL=stringify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtREFBUTtBQUNoRCxvSUFBb0ksSUFBSTtBQUN4STtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUIsU0FBUyxPQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLE1BQU07QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9zdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBUaGUgTG9zc2xlc3NKU09OLnN0cmluZ2lmeSgpIG1ldGhvZCBjb252ZXJ0cyBhIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBKU09OIHN0cmluZyxcbiAqIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHZhbHVlcyBpZiBhIHJlcGxhY2VyIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgb3JcbiAqIG9wdGlvbmFsbHkgaW5jbHVkaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGlmIGEgcmVwbGFjZXIgYXJyYXkgaXMgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBKU09OIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gW3JlcGxhY2VyXVxuICogQSBmdW5jdGlvbiB0aGF0IGFsdGVycyB0aGUgYmVoYXZpb3Igb2YgdGhlIHN0cmluZ2lmaWNhdGlvbiBwcm9jZXNzLFxuICogb3IgYW4gYXJyYXkgb2YgU3RyaW5nIGFuZCBOdW1iZXIgb2JqZWN0cyB0aGF0IHNlcnZlIGFzIGEgd2hpdGVsaXN0IGZvclxuICogc2VsZWN0aW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2YWx1ZSBvYmplY3QgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIEpTT04gc3RyaW5nLlxuICogSWYgdGhpcyB2YWx1ZSBpcyBudWxsIG9yIG5vdCBwcm92aWRlZCwgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBhcmVcbiAqIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIFtzcGFjZV1cbiAqIEEgU3RyaW5nIG9yIE51bWJlciBvYmplY3QgdGhhdCdzIHVzZWQgdG8gaW5zZXJ0IHdoaXRlIHNwYWNlIGludG8gdGhlIG91dHB1dFxuICogSlNPTiBzdHJpbmcgZm9yIHJlYWRhYmlsaXR5IHB1cnBvc2VzLiBJZiB0aGlzIGlzIGEgTnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlXG4gKiBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycyB0byB1c2UgYXMgd2hpdGUgc3BhY2U7IHRoaXMgbnVtYmVyIGlzIGNhcHBlZCBhdCAxMFxuICogaWYgaXQncyBsYXJnZXIgdGhhbiB0aGF0LiBWYWx1ZXMgbGVzcyB0aGFuIDEgaW5kaWNhdGUgdGhhdCBubyBzcGFjZSBzaG91bGQgYmVcbiAqIHVzZWQuIElmIHRoaXMgaXMgYSBTdHJpbmcsIHRoZSBzdHJpbmcgKG9yIHRoZSBmaXJzdCAxMCBjaGFyYWN0ZXJzIG9mIHRoZSBzdHJpbmcsXG4gKiBpZiBpdCdzIGxvbmdlciB0aGFuIHRoYXQpIGlzIHVzZWQgYXMgd2hpdGUgc3BhY2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdFxuICogcHJvdmlkZWQgKG9yIGlzIG51bGwpLCBubyB3aGl0ZSBzcGFjZSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbbnVtYmVyU3RyaW5naWZpZXJzXVxuICogQW4gb3B0aW9uYWwgbGlzdCB3aXRoIGFkZGl0aW9uYWwgbnVtYmVyIHN0cmluZ2lmaWVycywgZm9yIGV4YW1wbGUgdG8gc2VyaWFsaXplXG4gKiBhIEJpZ051bWJlci4gVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gbXVzdCBiZSB2YWxpZCBzdHJpbmdpZmllZCBKU09OLlxuICogV2hlbiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCwgdGhlIHByb3BlcnR5IHdpbGwgYmUgZGVsZXRlZCBmcm9tIHRoZSBvYmplY3QuXG4gKiBUaGUgZGlmZmVyZW5jZSB3aXRoIHVzaW5nIGEgYHJlcGxhY2VyYCBpcyB0aGF0IHRoZSBvdXRwdXQgb2YgYSBgcmVwbGFjZXJgXG4gKiBtdXN0IGJlIEpTT04gYW5kIHdpbGwgYmUgc3RyaW5naWZpZWQgYWZ0ZXJ3YXJkcywgd2hlcmVhcyB0aGUgb3V0cHV0IG9mIHRoZVxuICogYG51bWJlclN0cmluZ2lmaWVyc2AgaXMgYWxyZWFkeSBzdHJpbmdpZmllZCBKU09OLlxuICpcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKSB7XG4gIGNvbnN0IHJlc29sdmVkU3BhY2UgPSByZXNvbHZlU3BhY2Uoc3BhY2UpO1xuICBjb25zdCByZXBsYWNlZFZhbHVlID0gdHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZXIuY2FsbCh7XG4gICAgJyc6IHZhbHVlXG4gIH0sICcnLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgcmV0dXJuIHN0cmluZ2lmeVZhbHVlKHJlcGxhY2VkVmFsdWUsICcnKTtcblxuICAvKipcbiAgICogU3RyaW5naWZ5IGEgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHZhbHVlLCBpbmRlbnQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShudW1iZXJTdHJpbmdpZmllcnMpKSB7XG4gICAgICBjb25zdCBzdHJpbmdpZmllciA9IG51bWJlclN0cmluZ2lmaWVycy5maW5kKGl0ZW0gPT4gaXRlbS50ZXN0KHZhbHVlKSk7XG4gICAgICBpZiAoc3RyaW5naWZpZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gc3RyaW5naWZpZXIuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8ICFpc051bWJlcihzdHIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04gbnVtYmVyOiBvdXRwdXQgb2YgYSBudW1iZXIgc3RyaW5naWZpZXIgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIGEgSlNPTiBudW1iZXIgKG91dHB1dDogJHtzdHJ9KWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYm9vbGVhbiwgbnVsbCwgbnVtYmVyLCBzdHJpbmcsIG9yIGRhdGVcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gbG9zc2xlc3MgbnVtYmVyLCB0aGUgc2VjcmV0IGluZ3JlZGllbnQgOilcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHZhbHVlPy5pc0xvc3NsZXNzTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBCaWdJbnRcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gQXJyYXlcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSwgaW5kZW50KTtcbiAgICB9XG5cbiAgICAvLyBPYmplY3QgKHRlc3QgbGFzdGx5ISlcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSwgaW5kZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgYW4gYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFycmF5LCBpbmRlbnQpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1tdJztcbiAgICB9XG4gICAgY29uc3QgY2hpbGRJbmRlbnQgPSByZXNvbHZlZFNwYWNlID8gaW5kZW50ICsgcmVzb2x2ZWRTcGFjZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgc3RyID0gcmVzb2x2ZWRTcGFjZSA/ICdbXFxuJyA6ICdbJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZXIuY2FsbChhcnJheSwgU3RyaW5nKGkpLCBhcnJheVtpXSkgOiBhcnJheVtpXTtcbiAgICAgIGlmIChyZXNvbHZlZFNwYWNlKSB7XG4gICAgICAgIHN0ciArPSBjaGlsZEluZGVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGl0ZW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RyICs9IHN0cmluZ2lmeVZhbHVlKGl0ZW0sIGNoaWxkSW5kZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSAnbnVsbCc7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IGFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc3RyICs9IHJlc29sdmVkU3BhY2UgPyAnLFxcbicgOiAnLCc7XG4gICAgICB9XG4gICAgfVxuICAgIHN0ciArPSByZXNvbHZlZFNwYWNlID8gYFxcbiR7aW5kZW50fV1gIDogJ10nO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5naWZ5IGFuIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iamVjdCwgaW5kZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KG9iamVjdC50b0pTT04oKSwgcmVwbGFjZXIsIHNwYWNlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShyZXBsYWNlcikgPyByZXBsYWNlci5tYXAoU3RyaW5nKSA6IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICB9XG4gICAgY29uc3QgY2hpbGRJbmRlbnQgPSByZXNvbHZlZFNwYWNlID8gaW5kZW50ICsgcmVzb2x2ZWRTcGFjZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzdHIgPSByZXNvbHZlZFNwYWNlID8gJ3tcXG4nIDogJ3snO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZXIuY2FsbChvYmplY3QsIGtleSwgb2JqZWN0W2tleV0pIDogb2JqZWN0W2tleV07XG4gICAgICBpZiAoaW5jbHVkZVByb3BlcnR5KGtleSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9IHJlc29sdmVkU3BhY2UgPyAnLFxcbicgOiAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgc3RyICs9IHJlc29sdmVkU3BhY2UgPyBgJHtjaGlsZEluZGVudCArIGtleVN0cn06IGAgOiBgJHtrZXlTdHJ9OmA7XG4gICAgICAgIHN0ciArPSBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSwgY2hpbGRJbmRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/IGBcXG4ke2luZGVudH19YCA6ICd9JztcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0byBpbmNsdWRlIGEgcHJvcGVydHkgaW4gYSBzdHJpbmdpZmllZCBvYmplY3Qgb3Igbm90LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5jbHVkZVByb3BlcnR5KF9rZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgSlNPTiBzdHJpbmdpZnkgc3BhY2U6XG4gKiByZXBsYWNlIGEgbnVtYmVyIHdpdGggYSBzdHJpbmcgY29udGFpbmluZyB0aGF0IG51bWJlciBvZiBzcGFjZXNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNwYWNlKHNwYWNlKSB7XG4gIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcgJy5yZXBlYXQoc3BhY2UpO1xuICB9XG4gIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnICYmIHNwYWNlICE9PSAnJykge1xuICAgIHJldHVybiBzcGFjZTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5naWZ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/stringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/types.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnsafeNumberReason: () => (/* binding */ UnsafeNumberReason),\n/* harmony export */   extractSignificantDigits: () => (/* binding */ extractSignificantDigits),\n/* harmony export */   getUnsafeNumberReason: () => (/* binding */ getUnsafeNumberReason),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isSafeNumber: () => (/* binding */ isSafeNumber),\n/* harmony export */   toSafeNumberOrThrow: () => (/* binding */ toSafeNumberOrThrow)\n/* harmony export */ });\n/**\n * Test whether a string contains an integer number\n */\nfunction isInteger(value) {\n  return INTEGER_REGEX.test(value);\n}\nconst INTEGER_REGEX = /^-?[0-9]+$/;\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nfunction isNumber(value) {\n  return NUMBER_REGEX.test(value);\n}\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/;\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nfunction isSafeNumber(value, config) {\n  const num = Number.parseFloat(value);\n  const str = String(num);\n  const v = extractSignificantDigits(value);\n  const s = extractSignificantDigits(str);\n  if (v === s) {\n    return true;\n  }\n  if (config?.approx === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    const requiredDigits = 14;\n    if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {\n      return true;\n    }\n  }\n  return false;\n}\nlet UnsafeNumberReason = /*#__PURE__*/function (UnsafeNumberReason) {\n  UnsafeNumberReason[\"underflow\"] = \"underflow\";\n  UnsafeNumberReason[\"overflow\"] = \"overflow\";\n  UnsafeNumberReason[\"truncate_integer\"] = \"truncate_integer\";\n  UnsafeNumberReason[\"truncate_float\"] = \"truncate_float\";\n  return UnsafeNumberReason;\n}({});\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nfunction getUnsafeNumberReason(value) {\n  if (isSafeNumber(value, {\n    approx: false\n  })) {\n    return undefined;\n  }\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer;\n  }\n  const num = Number.parseFloat(value);\n  if (!Number.isFinite(num)) {\n    return UnsafeNumberReason.overflow;\n  }\n  if (num === 0) {\n    return UnsafeNumberReason.underflow;\n  }\n  return UnsafeNumberReason.truncate_float;\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nfunction toSafeNumberOrThrow(value, config) {\n  const number = Number.parseFloat(value);\n  const unsafeReason = getUnsafeNumberReason(value);\n  if (config?.approx === true ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float : unsafeReason) {\n    const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, '');\n    throw new Error(`Cannot safely convert to number: the value '${value}' would ${unsafeReasonText} and become ${number}`);\n  }\n  return number;\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nfunction extractSignificantDigits(value) {\n  return value\n  // from \"-0.250e+30\" to \"-0.250\"\n  .replace(EXPONENTIAL_PART_REGEX, '')\n\n  // from \"-0.250\" to \"-0250\"\n  .replace(DOT_REGEX, '')\n\n  // from \"-0250\" to \"-025\"\n  .replace(TRAILING_ZEROS_REGEX, '')\n\n  // from \"-025\" to \"25\"\n  .replace(LEADING_MINUS_AND_ZEROS_REGEX, '');\n}\nconst EXPONENTIAL_PART_REGEX = /[eE][+-]?\\d+$/;\nconst LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;\nconst DOT_REGEX = /\\./;\nconst TRAILING_ZEROS_REGEX = /0+$/;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxNQUFNLFVBQVUsa0JBQWtCLGFBQWEsT0FBTztBQUN6SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdCB3aGV0aGVyIGEgc3RyaW5nIGNvbnRhaW5zIGFuIGludGVnZXIgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIElOVEVHRVJfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5jb25zdCBJTlRFR0VSX1JFR0VYID0gL14tP1swLTldKyQvO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBjb250YWlucyBhIG51bWJlclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM0MDcxNy9qc29uLW51bWJlcnMtcmVndWxhci1leHByZXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gTlVNQkVSX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuY29uc3QgTlVNQkVSX1JFR0VYID0gL14tPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPyQvO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBjYW4gYmUgc2FmZWx5IHJlcHJlc2VudGVkIHdpdGggYSBudW1iZXJcbiAqIHdpdGhvdXQgaW5mb3JtYXRpb24gbG9zcy5cbiAqXG4gKiBXaGVuIGFwcHJveCBpcyB0cnVlLCBmbG9hdGluZyBwb2ludCBudW1iZXJzIHRoYXQgbG9zZSBhIGZldyBkaWdpdHMgYnV0XG4gKiBhcmUgc3RpbGwgYXBwcm94aW1hdGVseSBlcXVhbCBpbiB2YWx1ZSBhcmUgY29uc2lkZXJlZCBzYWZlIHRvby5cbiAqIEludGVnZXIgbnVtYmVycyBtdXN0IHN0aWxsIGJlIGV4YWN0bHkgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmVOdW1iZXIodmFsdWUsIGNvbmZpZykge1xuICBjb25zdCBudW0gPSBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSk7XG4gIGNvbnN0IHN0ciA9IFN0cmluZyhudW0pO1xuICBjb25zdCB2ID0gZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHZhbHVlKTtcbiAgY29uc3QgcyA9IGV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyhzdHIpO1xuICBpZiAodiA9PT0gcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb25maWc/LmFwcHJveCA9PT0gdHJ1ZSkge1xuICAgIC8vIEEgdmFsdWUgaXMgYXBwcm94aW1hdGVseSBlcXVhbCB3aGVuOlxuICAgIC8vIDEuIGl0IGlzIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCBub3QgYW4gaW50ZWdlclxuICAgIC8vIDIuIGl0IGhhcyBhdCBsZWFzdCAxNCBkaWdpdHNcbiAgICAvLyAzLiB0aGUgZmlyc3QgMTQgZGlnaXRzIGFyZSBlcXVhbFxuICAgIGNvbnN0IHJlcXVpcmVkRGlnaXRzID0gMTQ7XG4gICAgaWYgKCFpc0ludGVnZXIodmFsdWUpICYmIHMubGVuZ3RoID49IHJlcXVpcmVkRGlnaXRzICYmIHYuc3RhcnRzV2l0aChzLnN1YnN0cmluZygwLCByZXF1aXJlZERpZ2l0cykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGxldCBVbnNhZmVOdW1iZXJSZWFzb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFVuc2FmZU51bWJlclJlYXNvbikge1xuICBVbnNhZmVOdW1iZXJSZWFzb25bXCJ1bmRlcmZsb3dcIl0gPSBcInVuZGVyZmxvd1wiO1xuICBVbnNhZmVOdW1iZXJSZWFzb25bXCJvdmVyZmxvd1wiXSA9IFwib3ZlcmZsb3dcIjtcbiAgVW5zYWZlTnVtYmVyUmVhc29uW1widHJ1bmNhdGVfaW50ZWdlclwiXSA9IFwidHJ1bmNhdGVfaW50ZWdlclwiO1xuICBVbnNhZmVOdW1iZXJSZWFzb25bXCJ0cnVuY2F0ZV9mbG9hdFwiXSA9IFwidHJ1bmNhdGVfZmxvYXRcIjtcbiAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbjtcbn0oe30pO1xuXG4vKipcbiAqIFdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFuIHVuc2FmZSBudW1iZXIsIGRlc2NyaWJlIHdoYXQgdGhlIHJlYXNvbiBpczpcbiAqIG92ZXJmbG93LCB1bmRlcmZsb3csIHRydW5jYXRlX2ludGVnZXIsIG9yIHRydW5jYXRlX2Zsb2F0LlxuICogUmV0dXJucyB1bmRlZmluZWQgd2hlbiB0aGUgdmFsdWUgaXMgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuc2FmZU51bWJlclJlYXNvbih2YWx1ZSkge1xuICBpZiAoaXNTYWZlTnVtYmVyKHZhbHVlLCB7XG4gICAgYXBwcm94OiBmYWxzZVxuICB9KSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gVW5zYWZlTnVtYmVyUmVhc29uLnRydW5jYXRlX2ludGVnZXI7XG4gIH1cbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi5vdmVyZmxvdztcbiAgfVxuICBpZiAobnVtID09PSAwKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi51bmRlcmZsb3c7XG4gIH1cbiAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi50cnVuY2F0ZV9mbG9hdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludG8gYSBudW1iZXIgd2hlbiBpdCBpcyBzYWZlIHRvIGRvIHNvLlxuICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZSwgZXhwbGFpbmluZyB0aGUgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TYWZlTnVtYmVyT3JUaHJvdyh2YWx1ZSwgY29uZmlnKSB7XG4gIGNvbnN0IG51bWJlciA9IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKTtcbiAgY29uc3QgdW5zYWZlUmVhc29uID0gZ2V0VW5zYWZlTnVtYmVyUmVhc29uKHZhbHVlKTtcbiAgaWYgKGNvbmZpZz8uYXBwcm94ID09PSB0cnVlID8gdW5zYWZlUmVhc29uICYmIHVuc2FmZVJlYXNvbiAhPT0gVW5zYWZlTnVtYmVyUmVhc29uLnRydW5jYXRlX2Zsb2F0IDogdW5zYWZlUmVhc29uKSB7XG4gICAgY29uc3QgdW5zYWZlUmVhc29uVGV4dCA9IHVuc2FmZVJlYXNvbj8ucmVwbGFjZSgvX1xcdyskLywgJycpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNhZmVseSBjb252ZXJ0IHRvIG51bWJlcjogdGhlIHZhbHVlICcke3ZhbHVlfScgd291bGQgJHt1bnNhZmVSZWFzb25UZXh0fSBhbmQgYmVjb21lICR7bnVtYmVyfWApO1xuICB9XG4gIHJldHVybiBudW1iZXI7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaWduaWZpY2FudCBkaWdpdHMgb2YgYSBudW1iZXIuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKiAgICcyLjM0JyByZXR1cm5zICcyMzQnXG4gKiAgICctNzcnIHJldHVybnMgJzc3J1xuICogICAnMC4wMDM0MDAnIHJldHVybnMgJzM0J1xuICogICAnMTIwLjVlKzMwJyByZXR1cm5zICcxMjA1J1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVcbiAgLy8gZnJvbSBcIi0wLjI1MGUrMzBcIiB0byBcIi0wLjI1MFwiXG4gIC5yZXBsYWNlKEVYUE9ORU5USUFMX1BBUlRfUkVHRVgsICcnKVxuXG4gIC8vIGZyb20gXCItMC4yNTBcIiB0byBcIi0wMjUwXCJcbiAgLnJlcGxhY2UoRE9UX1JFR0VYLCAnJylcblxuICAvLyBmcm9tIFwiLTAyNTBcIiB0byBcIi0wMjVcIlxuICAucmVwbGFjZShUUkFJTElOR19aRVJPU19SRUdFWCwgJycpXG5cbiAgLy8gZnJvbSBcIi0wMjVcIiB0byBcIjI1XCJcbiAgLnJlcGxhY2UoTEVBRElOR19NSU5VU19BTkRfWkVST1NfUkVHRVgsICcnKTtcbn1cbmNvbnN0IEVYUE9ORU5USUFMX1BBUlRfUkVHRVggPSAvW2VFXVsrLV0/XFxkKyQvO1xuY29uc3QgTEVBRElOR19NSU5VU19BTkRfWkVST1NfUkVHRVggPSAvXi0/KDAqKT8vO1xuY29uc3QgRE9UX1JFR0VYID0gL1xcLi87XG5jb25zdCBUUkFJTElOR19aRVJPU19SRUdFWCA9IC8wKyQvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pako/dist/pako.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/pako/dist/pako.esm.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deflate: () => (/* binding */ Deflate_1),\n/* harmony export */   Inflate: () => (/* binding */ Inflate_1),\n/* harmony export */   constants: () => (/* binding */ constants_1),\n/* harmony export */   \"default\": () => (/* binding */ pako),\n/* harmony export */   deflate: () => (/* binding */ deflate_1),\n/* harmony export */   deflateRaw: () => (/* binding */ deflateRaw_1),\n/* harmony export */   gzip: () => (/* binding */ gzip_1),\n/* harmony export */   inflate: () => (/* binding */ inflate_1),\n/* harmony export */   inflateRaw: () => (/* binding */ inflateRaw_1),\n/* harmony export */   ungzip: () => (/* binding */ ungzip_1)\n/* harmony export */ });\n\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED$1               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN$1             = 2;\n\n/*============================================================================*/\n\n\nfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH$1    = 3;\nconst MAX_MATCH$1    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES$1  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS$1      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES$1       = 30;\n/* number of distance codes */\n\nconst BL_CODES$1      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n/* maximum heap size */\n\nconst MAX_BITS$1      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES$1);\nzero$1(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES$1);\nzero$1(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Tracev((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) => {\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n\n  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    code = (code + bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.sym_next = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) => {\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) => {\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let sx = 0;         /* running index in sym_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.sym_next !== 0) {\n    do {\n      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;\n      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;\n      lc = s.pending_buf[s.sym_buf + sx++];\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and sym_buf is ok: */\n      //Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n\n    } while (sx < s.sym_next);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) => {\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"block list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* block_mask is the bit mask of block-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let block_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"block-listed\") bytes. */\n  for (n = 0; n <= 31; n++, block_mask >>>= 1) {\n    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"allow-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"block-listed\" or \"allow-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init$1 = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  bi_windup(s);        /* align on byte boundary */\n  put_short(s, stored_len);\n  put_short(s, ~stored_len);\n  if (stored_len) {\n    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);\n  }\n  s.pending += stored_len;\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align$1 = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nconst _tr_flush_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN$1) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->sym_next / 3));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block$1(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally$1 = (s, dist, lc) => {\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist;\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;\n  s.pending_buf[s.sym_buf + s.sym_next++] = lc;\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n  return (s.sym_next === s.sym_end);\n};\n\nvar _tr_init_1  = _tr_init$1;\nvar _tr_stored_block_1 = _tr_stored_block$1;\nvar _tr_flush_block_1  = _tr_flush_block$1;\nvar _tr_tally_1 = _tr_tally$1;\nvar _tr_align_1 = _tr_align$1;\n\nvar trees = {\n\t_tr_init: _tr_init_1,\n\t_tr_stored_block: _tr_stored_block_1,\n\t_tr_flush_block: _tr_flush_block_1,\n\t_tr_tally: _tr_tally_1,\n\t_tr_align: _tr_align_1\n};\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nvar adler32_1 = adler32;\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nvar crc32_1 = crc32;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar constants$2 = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_UNKNOWN,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants$2;\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS$1 = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n//#ifdef GZIP\nconst GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n//#endif\nconst EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\nconst NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\nconst COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\nconst HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\nconst BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\nconst FINISH_STATE  = 666;    /* stream complete */\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) * 2) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\nconst slide_hash = (s) => {\n  let n, m;\n  let p;\n  let wsize = s.w_size;\n\n  n = s.hash_size;\n  p = n;\n  do {\n    m = s.head[--p];\n    s.head[p] = (m >= wsize ? m - wsize : 0);\n  } while (--n);\n  n = wsize;\n//#ifndef FASTEST\n  p = n;\n  do {\n    m = s.prev[--p];\n    s.prev[p] = (m >= wsize ? m - wsize : 0);\n    /* If n is not on any hash chain, prev[n] is garbage but\n     * its value will never be used.\n     */\n  } while (--n);\n//#endif\n};\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out  += len;\n  s.pending_out  += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending      -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let n, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n      slide_hash(s);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Smallest worthy block size when not flushing or finishing. By default\n   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n   * large input and output buffers, the stored block size will be larger.\n   */\n  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n  /* Copy as many min_block or larger stored blocks directly to next_out as\n   * possible. If flushing, copy the remaining available input to next_out as\n   * stored blocks, if there is enough space.\n   */\n  let len, left, have, last = 0;\n  let used = s.strm.avail_in;\n  do {\n    /* Set len to the maximum size block that we can copy directly with the\n     * available input data and output space. Set left to how much of that\n     * would be copied from what's left in the window.\n     */\n    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    if (s.strm.avail_out < have) {         /* need room for header */\n      break;\n    }\n      /* maximum stored block length that will fit in avail_out: */\n    have = s.strm.avail_out - have;\n    left = s.strstart - s.block_start;  /* bytes left in window */\n    if (len > left + s.strm.avail_in) {\n      len = left + s.strm.avail_in;   /* limit len to the input */\n    }\n    if (len > have) {\n      len = have;             /* limit len to the output */\n    }\n\n    /* If the stored block would be less than min_block in length, or if\n     * unable to copy all of the available input when flushing, then try\n     * copying to the window and the pending buffer instead. Also don't\n     * write an empty block when flushing -- deflate() does that.\n     */\n    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||\n                        flush === Z_NO_FLUSH$2 ||\n                        len !== left + s.strm.avail_in)) {\n      break;\n    }\n\n    /* Make a dummy stored block in pending to get the header bytes,\n     * including any pending bits. This also updates the debugging counts.\n     */\n    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;\n    _tr_stored_block(s, 0, 0, last);\n\n    /* Replace the lengths in the dummy stored block with len. */\n    s.pending_buf[s.pending - 4] = len;\n    s.pending_buf[s.pending - 3] = len >> 8;\n    s.pending_buf[s.pending - 2] = ~len;\n    s.pending_buf[s.pending - 1] = ~len >> 8;\n\n    /* Write the stored block header bytes. */\n    flush_pending(s.strm);\n\n//#ifdef ZLIB_DEBUG\n//    /* Update debugging counts for the data about to be copied. */\n//    s->compressed_len += len << 3;\n//    s->bits_sent += len << 3;\n//#endif\n\n    /* Copy uncompressed bytes from the window to next_out. */\n    if (left) {\n      if (left > len) {\n        left = len;\n      }\n      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n      s.strm.next_out += left;\n      s.strm.avail_out -= left;\n      s.strm.total_out += left;\n      s.block_start += left;\n      len -= left;\n    }\n\n    /* Copy uncompressed bytes directly from next_in to next_out, updating\n     * the check value.\n     */\n    if (len) {\n      read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n      s.strm.next_out += len;\n      s.strm.avail_out -= len;\n      s.strm.total_out += len;\n    }\n  } while (last === 0);\n\n  /* Update the sliding window with the last s->w_size bytes of the copied\n   * data, or append all of the copied data to the existing window if less\n   * than s->w_size bytes were copied. Also update the number of bytes to\n   * insert in the hash tables, in the event that deflateParams() switches to\n   * a non-zero compression level.\n   */\n  used -= s.strm.avail_in;    /* number of input bytes directly copied */\n  if (used) {\n    /* If any input was used, then no unused input remains in the window,\n     * therefore s->block_start == s->strstart.\n     */\n    if (used >= s.w_size) {  /* supplant the previous history */\n      s.matches = 2;     /* clear hash */\n      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n      s.strstart = s.w_size;\n      s.insert = s.strstart;\n    }\n    else {\n      if (s.window_size - s.strstart <= used) {\n        /* Slide the window down. */\n        s.strstart -= s.w_size;\n        //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n        if (s.matches < 2) {\n          s.matches++;   /* add a pending slide_hash() */\n        }\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n      }\n      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n      s.strstart += used;\n      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n    }\n    s.block_start = s.strstart;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* If the last block was written to next_out, then done. */\n  if (last) {\n    return BS_FINISH_DONE;\n  }\n\n  /* If flushing and all input has been consumed, then done. */\n  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&\n    s.strm.avail_in === 0 && s.strstart === s.block_start) {\n    return BS_BLOCK_DONE;\n  }\n\n  /* Fill the window with any remaining input. */\n  have = s.window_size - s.strstart;\n  if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n    /* Slide the window down. */\n    s.block_start -= s.w_size;\n    s.strstart -= s.w_size;\n    //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n    if (s.matches < 2) {\n      s.matches++;       /* add a pending slide_hash() */\n    }\n    have += s.w_size;      /* more space now */\n    if (s.insert > s.strstart) {\n      s.insert = s.strstart;\n    }\n  }\n  if (have > s.strm.avail_in) {\n    have = s.strm.avail_in;\n  }\n  if (have) {\n    read_buf(s.strm, s.window, s.strstart, have);\n    s.strstart += have;\n    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* There was not enough avail_out to write a complete worthy or flushed\n   * stored block to next_out. Write a stored block to pending instead, if we\n   * have enough input for a worthy block, or if flushing and there is enough\n   * room for the remaining input as a stored block in the pending buffer.\n   */\n  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    /* maximum stored block length that will fit in pending: */\n  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n  min_block = have > s.w_size ? s.w_size : have;\n  left = s.strstart - s.block_start;\n  if (left >= min_block ||\n     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&\n     s.strm.avail_in === 0 && left <= have)) {\n    len = left > have ? have : left;\n    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&\n         len === left ? 1 : 0;\n    _tr_stored_block(s, s.block_start, len, last);\n    s.block_start += len;\n    flush_pending(s.strm);\n  }\n\n  /* We've done all we can with the available input and output. */\n  return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n};\n\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$2) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.sym_next = 0;      /* running index in sym_buf */\n  this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nconst deflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const s = strm.state;\n  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n//#ifdef GZIP\n                                s.status !== GZIP_STATE &&\n//#endif\n                                s.status !== EXTRA_STATE &&\n                                s.status !== NAME_STATE &&\n                                s.status !== COMMENT_STATE &&\n                                s.status !== HCRC_STATE &&\n                                s.status !== BUSY_STATE &&\n                                s.status !== FINISH_STATE)) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status =\n//#ifdef GZIP\n    s.wrap === 2 ? GZIP_STATE :\n//#endif\n    s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = -2;\n  _tr_init(s);\n  return Z_OK$3;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK$3) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR$2;\n  }\n  strm.state.gzhead = head;\n  return Z_OK$3;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR$2;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n  s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  /* We overlay pending_buf and sym_buf. This works since the average size\n   * for length/distance pairs over any compressed block is assured to be 31\n   * bits or less.\n   *\n   * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n   * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n   * possible fixed-codes length/distance pair is then 31 bits total.\n   *\n   * sym_buf starts one-fourth of the way into pending_buf. So there are\n   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n   * in sym_buf is three bytes -- two for the distance and one for the\n   * literal/length. As each symbol is consumed, the pointer to the next\n   * sym_buf value to read moves forward three bytes. From that symbol, up to\n   * 31 bits are written to pending_buf. The closest the written pending_buf\n   * bits gets to the next sym_buf symbol to read is just before the last\n   * code is written. At that time, 31*(n-2) bits have been written, just\n   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n   * symbols are written.) The closest the writing gets to what is unread is\n   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n   * can range from 128 to 32768.\n   *\n   * Therefore, at a minimum, there are 142 bits of space between what is\n   * written and what is read in the overlain buffers, so the symbols cannot\n   * be overwritten by the compressed data. That space is actually 139 bits,\n   * due to the three-bit fixed-code block header.\n   *\n   * That covers the case where either Z_FIXED is specified, forcing fixed\n   * codes, or when the use of fixed codes is chosen, because that choice\n   * results in a smaller compressed block than dynamic codes. That latter\n   * condition then assures that the above analysis also covers all dynamic\n   * blocks. A dynamic-code block will only be chosen to be emitted if it has\n   * fewer bits than a fixed-code block would for the same set of symbols.\n   * Therefore its average symbol length is assured to be less than 31. So\n   * the compressed data for a dynamic block also cannot overwrite the\n   * symbols from which it is being constructed.\n   */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->sym_buf = s->pending_buf + s->lit_bufsize;\n  s.sym_buf = s.lit_bufsize;\n\n  //s->sym_end = (s->lit_bufsize - 1) * 3;\n  s.sym_end = (s.lit_bufsize - 1) * 3;\n  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n};\n\n\n/* ========================================================================= */\nconst deflate$2 = (strm, flush) => {\n\n  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (strm.avail_in !== 0 && !strm.input) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n  }\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH$3) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* Write the header */\n  if (s.status === INIT_STATE && s.wrap === 0) {\n    s.status = BUSY_STATE;\n  }\n  if (s.status === INIT_STATE) {\n    /* zlib header */\n    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n    let level_flags = -1;\n\n    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n      level_flags = 0;\n    } else if (s.level < 6) {\n      level_flags = 1;\n    } else if (s.level === 6) {\n      level_flags = 2;\n    } else {\n      level_flags = 3;\n    }\n    header |= (level_flags << 6);\n    if (s.strstart !== 0) { header |= PRESET_DICT; }\n    header += 31 - (header % 31);\n\n    putShortMSB(s, header);\n\n    /* Save the adler32 of the preset dictionary: */\n    if (s.strstart !== 0) {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#ifdef GZIP\n  if (s.status === GZIP_STATE) {\n    /* gzip header */\n    strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n    put_byte(s, 31);\n    put_byte(s, 139);\n    put_byte(s, 8);\n    if (!s.gzhead) { // s->gzhead == Z_NULL\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, OS_CODE);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$3;\n      }\n    }\n    else {\n      put_byte(s, (s.gzhead.text ? 1 : 0) +\n                  (s.gzhead.hcrc ? 2 : 0) +\n                  (!s.gzhead.extra ? 0 : 4) +\n                  (!s.gzhead.name ? 0 : 8) +\n                  (!s.gzhead.comment ? 0 : 16)\n      );\n      put_byte(s, s.gzhead.time & 0xff);\n      put_byte(s, (s.gzhead.time >> 8) & 0xff);\n      put_byte(s, (s.gzhead.time >> 16) & 0xff);\n      put_byte(s, (s.gzhead.time >> 24) & 0xff);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, s.gzhead.os & 0xff);\n      if (s.gzhead.extra && s.gzhead.extra.length) {\n        put_byte(s, s.gzhead.extra.length & 0xff);\n        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n      }\n      if (s.gzhead.hcrc) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n      }\n      s.gzindex = 0;\n      s.status = EXTRA_STATE;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n      while (s.pending + left > s.pending_buf_size) {\n        let copy = s.pending_buf_size - s.pending;\n        // zmemcpy(s.pending_buf + s.pending,\n        //    s.gzhead.extra + s.gzindex, copy);\n        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n        s.pending = s.pending_buf_size;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex += copy;\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n        beg = 0;\n        left -= copy;\n      }\n      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n      let gzhead_extra = new Uint8Array(s.gzhead.extra);\n      // zmemcpy(s->pending_buf + s->pending,\n      //     s->gzhead->extra + s->gzindex, left);\n      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n      s.pending += left;\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = NAME_STATE;\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = COMMENT_STATE;\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n    }\n    s.status = HCRC_STATE;\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n      }\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n    }\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#endif\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n    let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                 configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK$3;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH$1) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK$3;\n      }\n    }\n  }\n\n  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const status = strm.state.status;\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK$3;\n};\n\n\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2$1 = deflate$2;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateGetDictionary = deflateGetDictionary;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n\nvar deflate_1$2 = {\n\tdeflateInit: deflateInit_1,\n\tdeflateInit2: deflateInit2_1,\n\tdeflateReset: deflateReset_1,\n\tdeflateResetKeep: deflateResetKeep_1,\n\tdeflateSetHeader: deflateSetHeader_1,\n\tdeflate: deflate_2$1,\n\tdeflateEnd: deflateEnd_1,\n\tdeflateSetDictionary: deflateSetDictionary_1,\n\tdeflateInfo: deflateInfo\n};\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nvar flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n\nvar common = {\n\tassign: assign,\n\tflattenChunks: flattenChunks\n};\n\n// String encode/decode helpers\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nvar string2buf = (str) => {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nvar buf2string = (buf, max) => {\n  const len = max || buf.length;\n\n  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n\n  let i, out;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\nvar strings = {\n\tstring2buf: string2buf,\n\tbuf2string: buf2string,\n\tutf8border: utf8border\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nvar zstream = ZStream;\n\nconst toString$1 = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate$1(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  let status = deflate_1$2.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK$2) {\n    throw new Error(messages[status]);\n  }\n\n  if (opt.header) {\n    deflate_1$2.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = deflate_1$2.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK$2) {\n      throw new Error(messages[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = deflate_1$2.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END$2) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1$2.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$2;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$2) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate$1(input, options) {\n  const deflator = new Deflate$1(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate$1(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip$1(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate$1(input, options);\n}\n\n\nvar Deflate_1$1 = Deflate$1;\nvar deflate_2 = deflate$1;\nvar deflateRaw_1$1 = deflateRaw$1;\nvar gzip_1$1 = gzip$1;\nvar constants$1 = constants$2;\n\nvar deflate_1$1 = {\n\tDeflate: Deflate_1$1,\n\tdeflate: deflate_2,\n\tdeflateRaw: deflateRaw_1$1,\n\tgzip: gzip_1$1,\n\tconstants: constants$1\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD$1 = 16209;       /* got a data error -- remain here until reset */\nconst TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvar inffast = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD$1;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD$1;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE$1;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD$1;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS$1 = 852;\nconst ENOUGH_DISTS$1 = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES$1 = 0;\nconst LENS$1 = 1;\nconst DISTS$1 = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n//  let shoextra;    /* extra bits table to use */\n  let match;                  /* use base and extra for symbol >= match */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES$1) {\n    base = extra = work;    /* dummy value--not used */\n    match = 20;\n\n  } else if (type === LENS$1) {\n    base = lbase;\n    extra = lext;\n    match = 257;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    match = 0;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] + 1 < match) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] >= match) {\n      here_op = extra[work[sym] - match];\n      here_val = base[work[sym] - match];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nvar inftrees = inflate_table;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n\n\n\n\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n  Z_DEFLATED\n} = constants$2;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 16180;       /* i: waiting for magic header */\nconst    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 16182;       /* i: waiting for modification time (gzip) */\nconst    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 16184;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 16186;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 16188;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 16189;    /* i: waiting for dictionary check value */\nconst    DICT = 16190;      /* waiting for inflateSetDictionary() call */\nconst        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 16193;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 16196;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 16197;   /* i: waiting for code length code lengths */\nconst        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 16199;      /* i: same as LEN below, but only first time in */\nconst            LEN = 16200;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 16201;    /* i: waiting for length extra bits */\nconst            DIST = 16202;      /* i: waiting for distance code */\nconst            DISTEXT = 16203;   /* i: waiting for distance extra bits */\nconst            MATCH = 16204;     /* o: waiting for output space to copy string */\nconst            LIT = 16205;       /* o: waiting for output space to write literal */\nconst    CHECK = 16206;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 16208;      /* finished check, done -- remain here until reset */\nconst    BAD = 16209;       /* got a data error -- remain here until reset */\nconst    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.strm = null;           /* pointer back to this zlib stream */\n  this.mode = 0;              /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,\n                                 bit 2 true to validate check value */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib), or\n                                 -1 if raw or no header yet */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const state = strm.state;\n  if (!state || state.strm !== strm ||\n    state.mode < HEAD || state.mode > SYNC) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.flags = -1;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$1;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 5;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR$1; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.strm = strm;\n  state.window = null/*Z_NULL*/;\n  state.mode = HEAD;     /* to pass state test in inflateReset2() */\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate$2 = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (inflateStateCheck(strm) || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          if (state.wbits === 0) {\n            state.wbits = 15;\n          }\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        if (len > 15 || len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        state.flags = 0;               /* indicate zlib header */\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if ((state.flags & 0x0200) && (state.wrap & 4)) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT$1;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inffast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if ((state.wrap & 4) && _out) {\n            strm.adler = state.check =\n                /*UPDATE_CHECK(state.check, put - _out, _out);*/\n                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$1;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR$1;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH$1))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if ((state.wrap & 4) && _out) {\n    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (inflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK$1;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR$1;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK$1;\n};\n\n\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2$1 = inflate$2;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCodesUsed = inflateCodesUsed;\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\nmodule.exports.inflateValidate = inflateValidate;\n*/\n\nvar inflate_1$2 = {\n\tinflateReset: inflateReset_1,\n\tinflateReset2: inflateReset2_1,\n\tinflateResetKeep: inflateResetKeep_1,\n\tinflateInit: inflateInit_1,\n\tinflateInit2: inflateInit2_1,\n\tinflate: inflate_2$1,\n\tinflateEnd: inflateEnd_1,\n\tinflateGetHeader: inflateGetHeader_1,\n\tinflateSetDictionary: inflateSetDictionary_1,\n\tinflateInfo: inflateInfo\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nvar gzheader = GZheader;\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate$1(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  let status  = inflate_1$2.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(messages[status]);\n  }\n\n  this.header = new gzheader();\n\n  inflate_1$2.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = inflate_1$2.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT && dictionary) {\n      status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK) {\n        status = inflate_1$2.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      inflate_1$2.inflateReset(strm);\n      status = inflate_1$2.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END) {\n      status = inflate_1$2.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err) {\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate$1(input, options) {\n  const inflator = new Inflate$1(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || messages[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nvar Inflate_1$1 = Inflate$1;\nvar inflate_2 = inflate$1;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip$1 = inflate$1;\nvar constants = constants$2;\n\nvar inflate_1$1 = {\n\tInflate: Inflate_1$1,\n\tinflate: inflate_2,\n\tinflateRaw: inflateRaw_1$1,\n\tungzip: ungzip$1,\n\tconstants: constants\n};\n\nconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n\nconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n\n\n\nvar Deflate_1 = Deflate;\nvar deflate_1 = deflate;\nvar deflateRaw_1 = deflateRaw;\nvar gzip_1 = gzip;\nvar Inflate_1 = Inflate;\nvar inflate_1 = inflate;\nvar inflateRaw_1 = inflateRaw;\nvar ungzip_1 = ungzip;\nvar constants_1 = constants$2;\n\nvar pako = {\n\tDeflate: Deflate_1,\n\tdeflate: deflate_1,\n\tdeflateRaw: deflateRaw_1,\n\tgzip: gzip_1,\n\tInflate: Inflate_1,\n\tinflate: inflate_1,\n\tinflateRaw: inflateRaw_1,\n\tungzip: ungzip_1,\n\tconstants: constants_1\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYWtvL2Rpc3QvcGFrby5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTs7O0FBR0EsdUJBQXVCLHNCQUFzQixxQkFBcUI7O0FBRWxFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDOzs7O0FBSUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QixpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRCwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFlBQVk7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDOztBQUVqQywrQ0FBK0M7QUFDL0MsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBLGNBQWMsZ0JBQWdCLE9BQU87QUFDckMsY0FBYyxnQkFBZ0IsT0FBTztBQUNyQyxjQUFjLGdCQUFnQixPQUFPOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCOztBQUU1QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxPQUFPOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3Qix5Q0FBeUM7O0FBRXpDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUEsTUFBTTs7QUFFTixnQ0FBZ0M7QUFDaEM7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsMEJBQTBCOztBQUUxQiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0IseUNBQXlDOztBQUV6Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZUFBZTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOLFdBQVcsbUNBQW1DOztBQUU5QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxpQ0FBaUM7QUFDakMsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJLE1BQU0sR0FBRyxNQUFNLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQiw0REFBNEQ7QUFDNUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQiw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkMsSUFBSTtBQUNKO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsb0VBQW9FOzs7OztBQUs1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0Isc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEIsbUJBQW1COztBQUVuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qyx5QkFBeUI7QUFDekIsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHVDQUF1QztBQUN2QywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7O0FBRXpCOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0I7QUFDdEIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsMEJBQTBCOztBQUUxQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBOztBQUVBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDLGlEQUFpRDtBQUNqRDs7QUFFQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCOzs7QUFHMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkIsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLHNEQUFzRCxhQUFhOzs7QUFHekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsbUNBQW1DOzs7QUFHbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjs7QUFFekM7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEIsZ0JBQWdCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwwQkFBMEI7O0FBRS9DO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZTs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCOzs7QUFHQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0Isa0NBQWtDO0FBQ2xDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5Qiw4Q0FBOEMsa0JBQWtCO0FBQ2hFLDZDQUE2QyxtQkFBbUI7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdDQUF3Qyw2QkFBNkI7QUFDckUsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0Qjs7QUFFNUI7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUI7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixpQ0FBaUM7O0FBRWpDLG9DQUFvQztBQUNwQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxlQUFlO0FBQ2YsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7OztBQUdyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QixtRUFBbUUsU0FBUzs7QUFFNUU7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsbUVBQW1FLFNBQVM7O0FBRTVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixxQ0FBcUM7QUFDckM7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QiwwQkFBMEI7OztBQUd2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWU7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHFDQUFxQzs7QUFFN0MsUUFBUSx1Q0FBdUM7Ozs7QUFJL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlPIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3Bha28vZGlzdC9wYWtvLmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiEgcGFrbyAyLjEuMCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28gQGxpY2Vuc2UgKE1JVCBBTkQgWmxpYikgKi9cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vY29uc3QgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy9jb25zdCBaX1JMRSAgICAgICAgICAgICAgID0gMztcbmNvbnN0IFpfRklYRUQkMSAgICAgICAgICAgICAgID0gNDtcbi8vY29uc3QgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbmNvbnN0IFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG5jb25zdCBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbmNvbnN0IFpfVU5LTk9XTiQxICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvJDEoYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxuY29uc3QgU1RPUkVEX0JMT0NLID0gMDtcbmNvbnN0IFNUQVRJQ19UUkVFUyA9IDE7XG5jb25zdCBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxuY29uc3QgTUlOX01BVENIJDEgICAgPSAzO1xuY29uc3QgTUFYX01BVENIJDEgICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbmNvbnN0IExFTkdUSF9DT0RFUyQxICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IExJVEVSQUxTJDEgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG5jb25zdCBMX0NPREVTJDEgICAgICAgPSBMSVRFUkFMUyQxICsgMSArIExFTkdUSF9DT0RFUyQxO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IERfQ09ERVMkMSAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbmNvbnN0IEJMX0NPREVTJDEgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbmNvbnN0IEhFQVBfU0laRSQxICAgICA9IDIgKiBMX0NPREVTJDEgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxuY29uc3QgTUFYX0JJVFMkMSAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG5jb25zdCBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxuY29uc3QgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbmNvbnN0IGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTtcblxuY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pO1xuXG5jb25zdCBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKTtcblxuY29uc3QgYmxfb3JkZXIgPVxuICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxuY29uc3QgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG5jb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTJDEgKyAyKSAqIDIpO1xuemVybyQxKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbmNvbnN0IHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxICogMik7XG56ZXJvJDEoc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxuY29uc3QgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8kMShfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbmNvbnN0IF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIJDEgLSBNSU5fTUFUQ0gkMSArIDEpO1xuemVybyQxKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTJDEpO1xuemVybyQxKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxKTtcbnplcm8kMShiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxubGV0IHN0YXRpY19sX2Rlc2M7XG5sZXQgc3RhdGljX2RfZGVzYztcbmxldCBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5jb25zdCBkX2NvZGUgPSAoZGlzdCkgPT4ge1xuXG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuY29uc3QgcHV0X3Nob3J0ID0gKHMsIHcpID0+IHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuY29uc3Qgc2VuZF9iaXRzID0gKHMsIHZhbHVlLCBsZW5ndGgpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59O1xuXG5cbmNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7XG5cbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuY29uc3QgYmlfcmV2ZXJzZSA9IChjb2RlLCBsZW4pID0+IHtcblxuICBsZXQgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmNvbnN0IGJpX2ZsdXNoID0gKHMpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuY29uc3QgZ2VuX2JpdGxlbiA9IChzLCBkZXNjKSA9PiB7XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG5cbiAgY29uc3QgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3QgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgY29uc3Qgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgY29uc3QgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgY29uc3QgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgbGV0IGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIGxldCBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICBsZXQgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgbGV0IGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgbGV0IG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkUkMTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNldigoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuY29uc3QgZ2VuX2NvZGVzID0gKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgPT4ge1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xuXG4gIGNvbnN0IG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyQxICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIGxldCBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7XG4gICAgY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGU7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgbGV0IGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmNvbnN0IHRyX3N0YXRpY19pbml0ID0gKCkgPT4ge1xuXG4gIGxldCBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgbGV0IGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgbGV0IGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIGxldCBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgY29uc3QgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyQxIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTJDE7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMkMSArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMkMSArIDEsIExfQ09ERVMkMSwgTUFYX0JJVFMkMSk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUyQxLCBNQVhfQklUUyQxKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMkMSwgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuY29uc3QgaW5pdF9ibG9jayA9IChzKSA9PiB7XG5cbiAgbGV0IG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUyQxOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUyQxOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMuc3ltX25leHQgPSBzLm1hdGNoZXMgPSAwO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5jb25zdCBiaV93aW5kdXAgPSAocykgPT5cbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuY29uc3Qgc21hbGxlciA9ICh0cmVlLCBuLCBtLCBkZXB0aCkgPT4ge1xuXG4gIGNvbnN0IF9uMiA9IG4gKiAyO1xuICBjb25zdCBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmNvbnN0IHBxZG93bmhlYXAgPSAocywgdHJlZSwgaykgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xuXG4gIGNvbnN0IHYgPSBzLmhlYXBba107XG4gIGxldCBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn07XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gY29uc3QgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5jb25zdCBjb21wcmVzc19ibG9jayA9IChzLCBsdHJlZSwgZHRyZWUpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuXG4gIGxldCBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgbGV0IHN4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIHN5bV9idWYgKi9cbiAgbGV0IGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIGxldCBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLnN5bV9uZXh0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IHMucGVuZGluZ19idWZbcy5zeW1fYnVmICsgc3grK10gJiAweGZmO1xuICAgICAgZGlzdCArPSAocy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzeCsrXSAmIDB4ZmYpIDw8IDg7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5zeW1fYnVmICsgc3grK107XG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMkMSArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBzeW1fYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQocy0+cGVuZGluZyA8IHMtPmxpdF9idWZzaXplICsgc3gsIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKHN4IDwgcy5zeW1fbmV4dCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5jb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cblxuICBjb25zdCB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgbGV0IG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIGxldCBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgbGV0IG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkUkMTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmNvbnN0IHNjYW5fdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cblxuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuY29uc3Qgc2VuZF90cmVlID0gKHMsIHRyZWUsIG1heF9jb2RlKSA9PiB7XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cblxuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmNvbnN0IGJ1aWxkX2JsX3RyZWUgPSAocykgPT4ge1xuXG4gIGxldCBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyQxIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuY29uc3Qgc2VuZF9hbGxfdHJlZXMgPSAocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG5cbiAgbGV0IHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibG9jayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYWxsb3cgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuY29uc3QgZGV0ZWN0X2RhdGFfdHlwZSA9IChzKSA9PiB7XG4gIC8qIGJsb2NrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsb2NrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgbGV0IGJsb2NrX21hc2sgPSAweGYzZmZjMDdmO1xuICBsZXQgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxvY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsb2NrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibG9ja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJhbGxvdy1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUyQxOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsb2NrLWxpc3RlZFwiIG9yIFwiYWxsb3ctbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59O1xuXG5cbmxldCBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5jb25zdCBfdHJfaW5pdCQxID0gKHMpID0+XG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuY29uc3QgX3RyX3N0b3JlZF9ibG9jayQxID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT4ge1xuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG5cbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG4gIHB1dF9zaG9ydChzLCBzdG9yZWRfbGVuKTtcbiAgcHV0X3Nob3J0KHMsIH5zdG9yZWRfbGVuKTtcbiAgaWYgKHN0b3JlZF9sZW4pIHtcbiAgICBzLnBlbmRpbmdfYnVmLnNldChzLndpbmRvdy5zdWJhcnJheShidWYsIGJ1ZiArIHN0b3JlZF9sZW4pLCBzLnBlbmRpbmcpO1xuICB9XG4gIHMucGVuZGluZyArPSBzdG9yZWRfbGVuO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuY29uc3QgX3RyX2FsaWduJDEgPSAocykgPT4ge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgd3JpdGUgb3V0IHRoZSBlbmNvZGVkIGJsb2NrLlxuICovXG5jb25zdCBfdHJfZmx1c2hfYmxvY2skMSA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+IHtcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG5cbiAgbGV0IG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgbGV0IG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOJDEpIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zeW1fbmV4dCAvIDMpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayQxKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEJDEgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5jb25zdCBfdHJfdGFsbHkkMSA9IChzLCBkaXN0LCBsYykgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG5cbiAgcy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzLnN5bV9uZXh0KytdID0gZGlzdDtcbiAgcy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzLnN5bV9uZXh0KytdID0gZGlzdCA+PiA4O1xuICBzLnBlbmRpbmdfYnVmW3Muc3ltX2J1ZiArIHMuc3ltX25leHQrK10gPSBsYztcbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyQxICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuICByZXR1cm4gKHMuc3ltX25leHQgPT09IHMuc3ltX2VuZCk7XG59O1xuXG52YXIgX3RyX2luaXRfMSAgPSBfdHJfaW5pdCQxO1xudmFyIF90cl9zdG9yZWRfYmxvY2tfMSA9IF90cl9zdG9yZWRfYmxvY2skMTtcbnZhciBfdHJfZmx1c2hfYmxvY2tfMSAgPSBfdHJfZmx1c2hfYmxvY2skMTtcbnZhciBfdHJfdGFsbHlfMSA9IF90cl90YWxseSQxO1xudmFyIF90cl9hbGlnbl8xID0gX3RyX2FsaWduJDE7XG5cbnZhciB0cmVlcyA9IHtcblx0X3RyX2luaXQ6IF90cl9pbml0XzEsXG5cdF90cl9zdG9yZWRfYmxvY2s6IF90cl9zdG9yZWRfYmxvY2tfMSxcblx0X3RyX2ZsdXNoX2Jsb2NrOiBfdHJfZmx1c2hfYmxvY2tfMSxcblx0X3RyX3RhbGx5OiBfdHJfdGFsbHlfMSxcblx0X3RyX2FsaWduOiBfdHJfYWxpZ25fMVxufTtcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgYWRsZXIzMiA9IChhZGxlciwgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBsZXQgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufTtcblxuXG52YXIgYWRsZXIzMl8xID0gYWRsZXIzMjtcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5jb25zdCBtYWtlVGFibGUgPSAoKSA9PiB7XG4gIGxldCBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTtcblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KG1ha2VUYWJsZSgpKTtcblxuXG5jb25zdCBjcmMzMiA9IChjcmMsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgY29uc3QgdCA9IGNyY1RhYmxlO1xuICBjb25zdCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAobGV0IGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59O1xuXG5cbnZhciBjcmMzMl8xID0gY3JjMzI7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIG1lc3NhZ2VzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgY29uc3RhbnRzJDIgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgWl9NRU1fRVJST1I6ICAgICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IHsgX3RyX2luaXQsIF90cl9zdG9yZWRfYmxvY2ssIF90cl9mbHVzaF9ibG9jaywgX3RyX3RhbGx5LCBfdHJfYWxpZ24gfSA9IHRyZWVzO1xuXG5cblxuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDIsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNIOiBaX0ZVTExfRkxVU0gkMSwgWl9GSU5JU0g6IFpfRklOSVNIJDMsIFpfQkxPQ0s6IFpfQkxPQ0skMSxcbiAgWl9PSzogWl9PSyQzLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQzLCBaX1NUUkVBTV9FUlJPUjogWl9TVFJFQU1fRVJST1IkMiwgWl9EQVRBX0VSUk9SOiBaX0RBVEFfRVJST1IkMiwgWl9CVUZfRVJST1I6IFpfQlVGX0VSUk9SJDEsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogWl9ERUZBVUxUX0NPTVBSRVNTSU9OJDEsXG4gIFpfRklMVEVSRUQsIFpfSFVGRk1BTl9PTkxZLCBaX1JMRSwgWl9GSVhFRCwgWl9ERUZBVUxUX1NUUkFURUdZOiBaX0RFRkFVTFRfU1RSQVRFR1kkMSxcbiAgWl9VTktOT1dOLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDJcbn0gPSBjb25zdGFudHMkMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xuY29uc3QgTUFYX1dCSVRTJDEgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX01FTV9MRVZFTCA9IDg7XG5cblxuY29uc3QgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5jb25zdCBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbmNvbnN0IEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuY29uc3QgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5jb25zdCBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG5jb25zdCBNSU5fTUFUQ0ggPSAzO1xuY29uc3QgTUFYX01BVENIID0gMjU4O1xuY29uc3QgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxuY29uc3QgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG5jb25zdCBJTklUX1NUQVRFICAgID0gIDQyOyAgICAvKiB6bGliIGhlYWRlciAtPiBCVVNZX1NUQVRFICovXG4vLyNpZmRlZiBHWklQXG5jb25zdCBHWklQX1NUQVRFICAgID0gIDU3OyAgICAvKiBnemlwIGhlYWRlciAtPiBCVVNZX1NUQVRFIHwgRVhUUkFfU1RBVEUgKi9cbi8vI2VuZGlmXG5jb25zdCBFWFRSQV9TVEFURSAgID0gIDY5OyAgICAvKiBnemlwIGV4dHJhIGJsb2NrIC0+IE5BTUVfU1RBVEUgKi9cbmNvbnN0IE5BTUVfU1RBVEUgICAgPSAgNzM7ICAgIC8qIGd6aXAgZmlsZSBuYW1lIC0+IENPTU1FTlRfU1RBVEUgKi9cbmNvbnN0IENPTU1FTlRfU1RBVEUgPSAgOTE7ICAgIC8qIGd6aXAgY29tbWVudCAtPiBIQ1JDX1NUQVRFICovXG5jb25zdCBIQ1JDX1NUQVRFICAgID0gMTAzOyAgICAvKiBnemlwIGhlYWRlciBDUkMgLT4gQlVTWV9TVEFURSAqL1xuY29uc3QgQlVTWV9TVEFURSAgICA9IDExMzsgICAgLyogZGVmbGF0ZSAtPiBGSU5JU0hfU1RBVEUgKi9cbmNvbnN0IEZJTklTSF9TVEFURSAgPSA2NjY7ICAgIC8qIHN0cmVhbSBjb21wbGV0ZSAqL1xuXG5jb25zdCBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xuY29uc3QgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbmNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbmNvbnN0IEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG5jb25zdCBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuY29uc3QgZXJyID0gKHN0cm0sIGVycm9yQ29kZSkgPT4ge1xuICBzdHJtLm1zZyA9IG1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59O1xuXG5jb25zdCByYW5rID0gKGYpID0+IHtcbiAgcmV0dXJuICgoZikgKiAyKSAtICgoZikgPiA0ID8gOSA6IDApO1xufTtcblxuY29uc3QgemVybyA9IChidWYpID0+IHtcbiAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfVxufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSB3aGVuIHNsaWRpbmcgdGhlIHdpbmRvdyBkb3duIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzJcbiAqIGJpdCB2YWx1ZXMgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDAgdG9cbiAqIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDAgbGF0ZXIuXG4gKi9cbmNvbnN0IHNsaWRlX2hhc2ggPSAocykgPT4ge1xuICBsZXQgbiwgbTtcbiAgbGV0IHA7XG4gIGxldCB3c2l6ZSA9IHMud19zaXplO1xuXG4gIG4gPSBzLmhhc2hfc2l6ZTtcbiAgcCA9IG47XG4gIGRvIHtcbiAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgcy5oZWFkW3BdID0gKG0gPj0gd3NpemUgPyBtIC0gd3NpemUgOiAwKTtcbiAgfSB3aGlsZSAoLS1uKTtcbiAgbiA9IHdzaXplO1xuLy8jaWZuZGVmIEZBU1RFU1RcbiAgcCA9IG47XG4gIGRvIHtcbiAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgcy5wcmV2W3BdID0gKG0gPj0gd3NpemUgPyBtIC0gd3NpemUgOiAwKTtcbiAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICovXG4gIH0gd2hpbGUgKC0tbik7XG4vLyNlbmRpZlxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xubGV0IEhBU0hfWkxJQiA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgcy5oYXNoX3NoaWZ0KSBeIGRhdGEpICYgcy5oYXNoX21hc2s7XG4vLyBUaGlzIGhhc2ggY2F1c2VzIGxlc3MgY29sbGlzaW9ucywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL2lzc3Vlcy8xMzVcbi8vIEJ1dCBicmVha3MgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vbGV0IEhBU0hfRkFTVCA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgOCkgKyAocHJldiA+PiA4KSArIChkYXRhIDw8IDQpKSAmIHMuaGFzaF9tYXNrO1xubGV0IEhBU0ggPSBIQVNIX1pMSUI7XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQsIGV4Y2VwdCBmb3JcbiAqIHNvbWUgZGVmbGF0ZV9zdG9yZWQoKSBvdXRwdXQsIGdvZXMgdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWVcbiAqIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlXG4gKiBzdHJtLT5uZXh0X291dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC4gKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5jb25zdCBmbHVzaF9wZW5kaW5nID0gKHN0cm0pID0+IHtcbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgbGV0IGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICBzdHJtLm91dHB1dC5zZXQocy5wZW5kaW5nX2J1Zi5zdWJhcnJheShzLnBlbmRpbmdfb3V0LCBzLnBlbmRpbmdfb3V0ICsgbGVuKSwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCAgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nICAgICAgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn07XG5cblxuY29uc3QgZmx1c2hfYmxvY2tfb25seSA9IChzLCBsYXN0KSA9PiB7XG4gIF90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufTtcblxuXG5jb25zdCBwdXRfYnl0ZSA9IChzLCBiKSA9PiB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBwdXRTaG9ydE1TQiA9IChzLCBiKSA9PiB7XG5cbiAgLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmNvbnN0IHJlYWRfYnVmID0gKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpID0+IHtcblxuICBsZXQgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgYnVmLnNldChzdHJtLmlucHV0LnN1YmFycmF5KHN0cm0ubmV4dF9pbiwgc3RybS5uZXh0X2luICsgbGVuKSwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuY29uc3QgbG9uZ2VzdF9tYXRjaCA9IChzLCBjdXJfbWF0Y2gpID0+IHtcblxuICBsZXQgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICBsZXQgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIGxldCBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgbGV0IGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICBsZXQgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICBjb25zdCBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIGNvbnN0IF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICBjb25zdCB3bWFzayA9IHMud19tYXNrO1xuICBjb25zdCBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICBjb25zdCBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICBsZXQgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIGxldCBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5jb25zdCBmaWxsX3dpbmRvdyA9IChzKSA9PiB7XG5cbiAgY29uc3QgX3dfc2l6ZSA9IHMud19zaXplO1xuICBsZXQgbiwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkoX3dfc2l6ZSwgX3dfc2l6ZSArIF93X3NpemUgLSBtb3JlKSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuICAgICAgaWYgKHMuaW5zZXJ0ID4gcy5zdHJzdGFydCkge1xuICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQ7XG4gICAgICB9XG4gICAgICBzbGlkZV9oYXNoKHMpO1xuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgMV0pO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIGNvbnN0IGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICBsZXQgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICpcbiAqIEluIGNhc2UgZGVmbGF0ZVBhcmFtcygpIGlzIHVzZWQgdG8gbGF0ZXIgc3dpdGNoIHRvIGEgbm9uLXplcm8gY29tcHJlc3Npb25cbiAqIGxldmVsLCBzLT5tYXRjaGVzIChvdGhlcndpc2UgdW51c2VkIHdoZW4gc3RvcmluZykga2VlcHMgdHJhY2sgb2YgdGhlIG51bWJlclxuICogb2YgaGFzaCB0YWJsZSBzbGlkZXMgdG8gcGVyZm9ybS4gSWYgcy0+bWF0Y2hlcyBpcyAxLCB0aGVuIG9uZSBoYXNoIHRhYmxlXG4gKiBzbGlkZSB3aWxsIGJlIGRvbmUgd2hlbiBzd2l0Y2hpbmcuIElmIHMtPm1hdGNoZXMgaXMgMiwgdGhlIG1heGltdW0gdmFsdWVcbiAqIGFsbG93ZWQgaGVyZSwgdGhlbiB0aGUgaGFzaCB0YWJsZSB3aWxsIGJlIGNsZWFyZWQsIHNpbmNlIHR3byBvciBtb3JlIHNsaWRlc1xuICogaXMgdGhlIHNhbWUgYXMgYSBjbGVhci5cbiAqXG4gKiBkZWZsYXRlX3N0b3JlZCgpIGlzIHdyaXR0ZW4gdG8gbWluaW1pemUgdGhlIG51bWJlciBvZiB0aW1lcyBhbiBpbnB1dCBieXRlIGlzXG4gKiBjb3BpZWQuIEl0IGlzIG1vc3QgZWZmaWNpZW50IHdpdGggbGFyZ2UgaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzLCB3aGljaFxuICogbWF4aW1pemVzIHRoZSBvcHBvcnR1bml0ZXMgdG8gaGF2ZSBhIHNpbmdsZSBjb3B5IGZyb20gbmV4dF9pbiB0byBuZXh0X291dC5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zdG9yZWQgPSAocywgZmx1c2gpID0+IHtcblxuICAvKiBTbWFsbGVzdCB3b3J0aHkgYmxvY2sgc2l6ZSB3aGVuIG5vdCBmbHVzaGluZyBvciBmaW5pc2hpbmcuIEJ5IGRlZmF1bHRcbiAgICogdGhpcyBpcyAzMksuIFRoaXMgY2FuIGJlIGFzIHNtYWxsIGFzIDUwNyBieXRlcyBmb3IgbWVtTGV2ZWwgPT0gMS4gRm9yXG4gICAqIGxhcmdlIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycywgdGhlIHN0b3JlZCBibG9jayBzaXplIHdpbGwgYmUgbGFyZ2VyLlxuICAgKi9cbiAgbGV0IG1pbl9ibG9jayA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDUgPiBzLndfc2l6ZSA/IHMud19zaXplIDogcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcblxuICAvKiBDb3B5IGFzIG1hbnkgbWluX2Jsb2NrIG9yIGxhcmdlciBzdG9yZWQgYmxvY2tzIGRpcmVjdGx5IHRvIG5leHRfb3V0IGFzXG4gICAqIHBvc3NpYmxlLiBJZiBmbHVzaGluZywgY29weSB0aGUgcmVtYWluaW5nIGF2YWlsYWJsZSBpbnB1dCB0byBuZXh0X291dCBhc1xuICAgKiBzdG9yZWQgYmxvY2tzLCBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UuXG4gICAqL1xuICBsZXQgbGVuLCBsZWZ0LCBoYXZlLCBsYXN0ID0gMDtcbiAgbGV0IHVzZWQgPSBzLnN0cm0uYXZhaWxfaW47XG4gIGRvIHtcbiAgICAvKiBTZXQgbGVuIHRvIHRoZSBtYXhpbXVtIHNpemUgYmxvY2sgdGhhdCB3ZSBjYW4gY29weSBkaXJlY3RseSB3aXRoIHRoZVxuICAgICAqIGF2YWlsYWJsZSBpbnB1dCBkYXRhIGFuZCBvdXRwdXQgc3BhY2UuIFNldCBsZWZ0IHRvIGhvdyBtdWNoIG9mIHRoYXRcbiAgICAgKiB3b3VsZCBiZSBjb3BpZWQgZnJvbSB3aGF0J3MgbGVmdCBpbiB0aGUgd2luZG93LlxuICAgICAqL1xuICAgIGxlbiA9IDY1NTM1LyogTUFYX1NUT1JFRCAqLzsgICAgIC8qIG1heGltdW0gZGVmbGF0ZSBzdG9yZWQgYmxvY2sgbGVuZ3RoICovXG4gICAgaGF2ZSA9IChzLmJpX3ZhbGlkICsgNDIpID4+IDM7ICAgICAvKiBudW1iZXIgb2YgaGVhZGVyIGJ5dGVzICovXG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPCBoYXZlKSB7ICAgICAgICAgLyogbmVlZCByb29tIGZvciBoZWFkZXIgKi9cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAgIC8qIG1heGltdW0gc3RvcmVkIGJsb2NrIGxlbmd0aCB0aGF0IHdpbGwgZml0IGluIGF2YWlsX291dDogKi9cbiAgICBoYXZlID0gcy5zdHJtLmF2YWlsX291dCAtIGhhdmU7XG4gICAgbGVmdCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0OyAgLyogYnl0ZXMgbGVmdCBpbiB3aW5kb3cgKi9cbiAgICBpZiAobGVuID4gbGVmdCArIHMuc3RybS5hdmFpbF9pbikge1xuICAgICAgbGVuID0gbGVmdCArIHMuc3RybS5hdmFpbF9pbjsgICAvKiBsaW1pdCBsZW4gdG8gdGhlIGlucHV0ICovXG4gICAgfVxuICAgIGlmIChsZW4gPiBoYXZlKSB7XG4gICAgICBsZW4gPSBoYXZlOyAgICAgICAgICAgICAvKiBsaW1pdCBsZW4gdG8gdGhlIG91dHB1dCAqL1xuICAgIH1cblxuICAgIC8qIElmIHRoZSBzdG9yZWQgYmxvY2sgd291bGQgYmUgbGVzcyB0aGFuIG1pbl9ibG9jayBpbiBsZW5ndGgsIG9yIGlmXG4gICAgICogdW5hYmxlIHRvIGNvcHkgYWxsIG9mIHRoZSBhdmFpbGFibGUgaW5wdXQgd2hlbiBmbHVzaGluZywgdGhlbiB0cnlcbiAgICAgKiBjb3B5aW5nIHRvIHRoZSB3aW5kb3cgYW5kIHRoZSBwZW5kaW5nIGJ1ZmZlciBpbnN0ZWFkLiBBbHNvIGRvbid0XG4gICAgICogd3JpdGUgYW4gZW1wdHkgYmxvY2sgd2hlbiBmbHVzaGluZyAtLSBkZWZsYXRlKCkgZG9lcyB0aGF0LlxuICAgICAqL1xuICAgIGlmIChsZW4gPCBtaW5fYmxvY2sgJiYgKChsZW4gPT09IDAgJiYgZmx1c2ggIT09IFpfRklOSVNIJDMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCA9PT0gWl9OT19GTFVTSCQyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gIT09IGxlZnQgKyBzLnN0cm0uYXZhaWxfaW4pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBNYWtlIGEgZHVtbXkgc3RvcmVkIGJsb2NrIGluIHBlbmRpbmcgdG8gZ2V0IHRoZSBoZWFkZXIgYnl0ZXMsXG4gICAgICogaW5jbHVkaW5nIGFueSBwZW5kaW5nIGJpdHMuIFRoaXMgYWxzbyB1cGRhdGVzIHRoZSBkZWJ1Z2dpbmcgY291bnRzLlxuICAgICAqL1xuICAgIGxhc3QgPSBmbHVzaCA9PT0gWl9GSU5JU0gkMyAmJiBsZW4gPT09IGxlZnQgKyBzLnN0cm0uYXZhaWxfaW4gPyAxIDogMDtcbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGxhc3QpO1xuXG4gICAgLyogUmVwbGFjZSB0aGUgbGVuZ3RocyBpbiB0aGUgZHVtbXkgc3RvcmVkIGJsb2NrIHdpdGggbGVuLiAqL1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nIC0gNF0gPSBsZW47XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcgLSAzXSA9IGxlbiA+PiA4O1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nIC0gMl0gPSB+bGVuO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nIC0gMV0gPSB+bGVuID4+IDg7XG5cbiAgICAvKiBXcml0ZSB0aGUgc3RvcmVkIGJsb2NrIGhlYWRlciBieXRlcy4gKi9cbiAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG5cbi8vI2lmZGVmIFpMSUJfREVCVUdcbi8vICAgIC8qIFVwZGF0ZSBkZWJ1Z2dpbmcgY291bnRzIGZvciB0aGUgZGF0YSBhYm91dCB0byBiZSBjb3BpZWQuICovXG4vLyAgICBzLT5jb21wcmVzc2VkX2xlbiArPSBsZW4gPDwgMztcbi8vICAgIHMtPmJpdHNfc2VudCArPSBsZW4gPDwgMztcbi8vI2VuZGlmXG5cbiAgICAvKiBDb3B5IHVuY29tcHJlc3NlZCBieXRlcyBmcm9tIHRoZSB3aW5kb3cgdG8gbmV4dF9vdXQuICovXG4gICAgaWYgKGxlZnQpIHtcbiAgICAgIGlmIChsZWZ0ID4gbGVuKSB7XG4gICAgICAgIGxlZnQgPSBsZW47XG4gICAgICB9XG4gICAgICAvL3ptZW1jcHkocy0+c3RybS0+bmV4dF9vdXQsIHMtPndpbmRvdyArIHMtPmJsb2NrX3N0YXJ0LCBsZWZ0KTtcbiAgICAgIHMuc3RybS5vdXRwdXQuc2V0KHMud2luZG93LnN1YmFycmF5KHMuYmxvY2tfc3RhcnQsIHMuYmxvY2tfc3RhcnQgKyBsZWZ0KSwgcy5zdHJtLm5leHRfb3V0KTtcbiAgICAgIHMuc3RybS5uZXh0X291dCArPSBsZWZ0O1xuICAgICAgcy5zdHJtLmF2YWlsX291dCAtPSBsZWZ0O1xuICAgICAgcy5zdHJtLnRvdGFsX291dCArPSBsZWZ0O1xuICAgICAgcy5ibG9ja19zdGFydCArPSBsZWZ0O1xuICAgICAgbGVuIC09IGxlZnQ7XG4gICAgfVxuXG4gICAgLyogQ29weSB1bmNvbXByZXNzZWQgYnl0ZXMgZGlyZWN0bHkgZnJvbSBuZXh0X2luIHRvIG5leHRfb3V0LCB1cGRhdGluZ1xuICAgICAqIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgKi9cbiAgICBpZiAobGVuKSB7XG4gICAgICByZWFkX2J1ZihzLnN0cm0sIHMuc3RybS5vdXRwdXQsIHMuc3RybS5uZXh0X291dCwgbGVuKTtcbiAgICAgIHMuc3RybS5uZXh0X291dCArPSBsZW47XG4gICAgICBzLnN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgICAgIHMuc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICAgIH1cbiAgfSB3aGlsZSAobGFzdCA9PT0gMCk7XG5cbiAgLyogVXBkYXRlIHRoZSBzbGlkaW5nIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHMtPndfc2l6ZSBieXRlcyBvZiB0aGUgY29waWVkXG4gICAqIGRhdGEsIG9yIGFwcGVuZCBhbGwgb2YgdGhlIGNvcGllZCBkYXRhIHRvIHRoZSBleGlzdGluZyB3aW5kb3cgaWYgbGVzc1xuICAgKiB0aGFuIHMtPndfc2l6ZSBieXRlcyB3ZXJlIGNvcGllZC4gQWxzbyB1cGRhdGUgdGhlIG51bWJlciBvZiBieXRlcyB0b1xuICAgKiBpbnNlcnQgaW4gdGhlIGhhc2ggdGFibGVzLCBpbiB0aGUgZXZlbnQgdGhhdCBkZWZsYXRlUGFyYW1zKCkgc3dpdGNoZXMgdG9cbiAgICogYSBub24temVybyBjb21wcmVzc2lvbiBsZXZlbC5cbiAgICovXG4gIHVzZWQgLT0gcy5zdHJtLmF2YWlsX2luOyAgICAvKiBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgZGlyZWN0bHkgY29waWVkICovXG4gIGlmICh1c2VkKSB7XG4gICAgLyogSWYgYW55IGlucHV0IHdhcyB1c2VkLCB0aGVuIG5vIHVudXNlZCBpbnB1dCByZW1haW5zIGluIHRoZSB3aW5kb3csXG4gICAgICogdGhlcmVmb3JlIHMtPmJsb2NrX3N0YXJ0ID09IHMtPnN0cnN0YXJ0LlxuICAgICAqL1xuICAgIGlmICh1c2VkID49IHMud19zaXplKSB7ICAvKiBzdXBwbGFudCB0aGUgcHJldmlvdXMgaGlzdG9yeSAqL1xuICAgICAgcy5tYXRjaGVzID0gMjsgICAgIC8qIGNsZWFyIGhhc2ggKi9cbiAgICAgIC8vem1lbWNweShzLT53aW5kb3csIHMtPnN0cm0tPm5leHRfaW4gLSBzLT53X3NpemUsIHMtPndfc2l6ZSk7XG4gICAgICBzLndpbmRvdy5zZXQocy5zdHJtLmlucHV0LnN1YmFycmF5KHMuc3RybS5uZXh0X2luIC0gcy53X3NpemUsIHMuc3RybS5uZXh0X2luKSwgMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gcy53X3NpemU7XG4gICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHMud2luZG93X3NpemUgLSBzLnN0cnN0YXJ0IDw9IHVzZWQpIHtcbiAgICAgICAgLyogU2xpZGUgdGhlIHdpbmRvdyBkb3duLiAqL1xuICAgICAgICBzLnN0cnN0YXJ0IC09IHMud19zaXplO1xuICAgICAgICAvL3ptZW1jcHkocy0+d2luZG93LCBzLT53aW5kb3cgKyBzLT53X3NpemUsIHMtPnN0cnN0YXJ0KTtcbiAgICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHMud19zaXplLCBzLndfc2l6ZSArIHMuc3Ryc3RhcnQpLCAwKTtcbiAgICAgICAgaWYgKHMubWF0Y2hlcyA8IDIpIHtcbiAgICAgICAgICBzLm1hdGNoZXMrKzsgICAvKiBhZGQgYSBwZW5kaW5nIHNsaWRlX2hhc2goKSAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmluc2VydCA+IHMuc3Ryc3RhcnQpIHtcbiAgICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vem1lbWNweShzLT53aW5kb3cgKyBzLT5zdHJzdGFydCwgcy0+c3RybS0+bmV4dF9pbiAtIHVzZWQsIHVzZWQpO1xuICAgICAgcy53aW5kb3cuc2V0KHMuc3RybS5pbnB1dC5zdWJhcnJheShzLnN0cm0ubmV4dF9pbiAtIHVzZWQsIHMuc3RybS5uZXh0X2luKSwgcy5zdHJzdGFydCk7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHVzZWQ7XG4gICAgICBzLmluc2VydCArPSB1c2VkID4gcy53X3NpemUgLSBzLmluc2VydCA/IHMud19zaXplIC0gcy5pbnNlcnQgOiB1c2VkO1xuICAgIH1cbiAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgfVxuICBpZiAocy5oaWdoX3dhdGVyIDwgcy5zdHJzdGFydCkge1xuICAgIHMuaGlnaF93YXRlciA9IHMuc3Ryc3RhcnQ7XG4gIH1cblxuICAvKiBJZiB0aGUgbGFzdCBibG9jayB3YXMgd3JpdHRlbiB0byBuZXh0X291dCwgdGhlbiBkb25lLiAqL1xuICBpZiAobGFzdCkge1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIC8qIElmIGZsdXNoaW5nIGFuZCBhbGwgaW5wdXQgaGFzIGJlZW4gY29uc3VtZWQsIHRoZW4gZG9uZS4gKi9cbiAgaWYgKGZsdXNoICE9PSBaX05PX0ZMVVNIJDIgJiYgZmx1c2ggIT09IFpfRklOSVNIJDMgJiZcbiAgICBzLnN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcy5zdHJzdGFydCA9PT0gcy5ibG9ja19zdGFydCkge1xuICAgIHJldHVybiBCU19CTE9DS19ET05FO1xuICB9XG5cbiAgLyogRmlsbCB0aGUgd2luZG93IHdpdGggYW55IHJlbWFpbmluZyBpbnB1dC4gKi9cbiAgaGF2ZSA9IHMud2luZG93X3NpemUgLSBzLnN0cnN0YXJ0O1xuICBpZiAocy5zdHJtLmF2YWlsX2luID4gaGF2ZSAmJiBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSB7XG4gICAgLyogU2xpZGUgdGhlIHdpbmRvdyBkb3duLiAqL1xuICAgIHMuYmxvY2tfc3RhcnQgLT0gcy53X3NpemU7XG4gICAgcy5zdHJzdGFydCAtPSBzLndfc2l6ZTtcbiAgICAvL3ptZW1jcHkocy0+d2luZG93LCBzLT53aW5kb3cgKyBzLT53X3NpemUsIHMtPnN0cnN0YXJ0KTtcbiAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkocy53X3NpemUsIHMud19zaXplICsgcy5zdHJzdGFydCksIDApO1xuICAgIGlmIChzLm1hdGNoZXMgPCAyKSB7XG4gICAgICBzLm1hdGNoZXMrKzsgICAgICAgLyogYWRkIGEgcGVuZGluZyBzbGlkZV9oYXNoKCkgKi9cbiAgICB9XG4gICAgaGF2ZSArPSBzLndfc2l6ZTsgICAgICAvKiBtb3JlIHNwYWNlIG5vdyAqL1xuICAgIGlmIChzLmluc2VydCA+IHMuc3Ryc3RhcnQpIHtcbiAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydDtcbiAgICB9XG4gIH1cbiAgaWYgKGhhdmUgPiBzLnN0cm0uYXZhaWxfaW4pIHtcbiAgICBoYXZlID0gcy5zdHJtLmF2YWlsX2luO1xuICB9XG4gIGlmIChoYXZlKSB7XG4gICAgcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCwgaGF2ZSk7XG4gICAgcy5zdHJzdGFydCArPSBoYXZlO1xuICAgIHMuaW5zZXJ0ICs9IGhhdmUgPiBzLndfc2l6ZSAtIHMuaW5zZXJ0ID8gcy53X3NpemUgLSBzLmluc2VydCA6IGhhdmU7XG4gIH1cbiAgaWYgKHMuaGlnaF93YXRlciA8IHMuc3Ryc3RhcnQpIHtcbiAgICBzLmhpZ2hfd2F0ZXIgPSBzLnN0cnN0YXJ0O1xuICB9XG5cbiAgLyogVGhlcmUgd2FzIG5vdCBlbm91Z2ggYXZhaWxfb3V0IHRvIHdyaXRlIGEgY29tcGxldGUgd29ydGh5IG9yIGZsdXNoZWRcbiAgICogc3RvcmVkIGJsb2NrIHRvIG5leHRfb3V0LiBXcml0ZSBhIHN0b3JlZCBibG9jayB0byBwZW5kaW5nIGluc3RlYWQsIGlmIHdlXG4gICAqIGhhdmUgZW5vdWdoIGlucHV0IGZvciBhIHdvcnRoeSBibG9jaywgb3IgaWYgZmx1c2hpbmcgYW5kIHRoZXJlIGlzIGVub3VnaFxuICAgKiByb29tIGZvciB0aGUgcmVtYWluaW5nIGlucHV0IGFzIGEgc3RvcmVkIGJsb2NrIGluIHRoZSBwZW5kaW5nIGJ1ZmZlci5cbiAgICovXG4gIGhhdmUgPSAocy5iaV92YWxpZCArIDQyKSA+PiAzOyAgICAgLyogbnVtYmVyIG9mIGhlYWRlciBieXRlcyAqL1xuICAgIC8qIG1heGltdW0gc3RvcmVkIGJsb2NrIGxlbmd0aCB0aGF0IHdpbGwgZml0IGluIHBlbmRpbmc6ICovXG4gIGhhdmUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSBoYXZlID4gNjU1MzUvKiBNQVhfU1RPUkVEICovID8gNjU1MzUvKiBNQVhfU1RPUkVEICovIDogcy5wZW5kaW5nX2J1Zl9zaXplIC0gaGF2ZTtcbiAgbWluX2Jsb2NrID0gaGF2ZSA+IHMud19zaXplID8gcy53X3NpemUgOiBoYXZlO1xuICBsZWZ0ID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4gIGlmIChsZWZ0ID49IG1pbl9ibG9jayB8fFxuICAgICAoKGxlZnQgfHwgZmx1c2ggPT09IFpfRklOSVNIJDMpICYmIGZsdXNoICE9PSBaX05PX0ZMVVNIJDIgJiZcbiAgICAgcy5zdHJtLmF2YWlsX2luID09PSAwICYmIGxlZnQgPD0gaGF2ZSkpIHtcbiAgICBsZW4gPSBsZWZ0ID4gaGF2ZSA/IGhhdmUgOiBsZWZ0O1xuICAgIGxhc3QgPSBmbHVzaCA9PT0gWl9GSU5JU0gkMyAmJiBzLnN0cm0uYXZhaWxfaW4gPT09IDAgJiZcbiAgICAgICAgIGxlbiA9PT0gbGVmdCA/IDEgOiAwO1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgcy5ibG9ja19zdGFydCwgbGVuLCBsYXN0KTtcbiAgICBzLmJsb2NrX3N0YXJ0ICs9IGxlbjtcbiAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG4gIH1cblxuICAvKiBXZSd2ZSBkb25lIGFsbCB3ZSBjYW4gd2l0aCB0aGUgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQuICovXG4gIHJldHVybiBsYXN0ID8gQlNfRklOSVNIX1NUQVJURUQgOiBCU19ORUVEX01PUkU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5jb25zdCBkZWZsYXRlX2Zhc3QgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSk7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zbG93ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBsZXQgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfcmxlID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgbGV0IHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICBsZXQgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9odWZmID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuXG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG5jb25zdCBjb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmNvbnN0IGxtX2luaXQgPSAocykgPT4ge1xuXG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59O1xuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRCQyOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5zeW1fYnVmID0gMDsgICAgICAgIC8qIGJ1ZmZlciBmb3IgZGlzdGFuY2VzIGFuZCBsaXRlcmFscy9sZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMuc3ltX25leHQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gc3ltX2J1ZiAqL1xuICB0aGlzLnN5bV9lbmQgPSAwOyAgICAgICAvKiBzeW1ib2wgdGFibGUgZnVsbCB3aGVuIHN5bV9uZXh0IHJlYWNoZXMgdGhpcyAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBmb3IgYSB2YWxpZCBkZWZsYXRlIHN0cmVhbSBzdGF0ZS4gUmV0dXJuIDAgaWYgb2ssIDEgaWYgbm90LlxuICovXG5jb25zdCBkZWZsYXRlU3RhdGVDaGVjayA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGlmICghcyB8fCBzLnN0cm0gIT09IHN0cm0gfHwgKHMuc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4vLyNpZmRlZiBHWklQXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuc3RhdHVzICE9PSBHWklQX1NUQVRFICYmXG4vLyNlbmRpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKGRlZmxhdGVTdGF0ZUNoZWNrKHN0cm0pKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9XG4vLyNpZmRlZiBHWklQXG4gICAgcy53cmFwID09PSAyID8gR1pJUF9TVEFURSA6XG4vLyNlbmRpZlxuICAgIHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSAtMjtcbiAgX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LJDM7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVSZXNldCA9IChzdHJtKSA9PiB7XG5cbiAgY29uc3QgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSyQzKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkgfHwgc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG5jb25zdCBkZWZsYXRlSW5pdDIgPSAoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSkge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEJDIgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQgfHwgKHdpbmRvd0JpdHMgPT09IDggJiYgd3JhcCAhPT0gMSkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICBjb25zdCBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuICBzLnN0YXR1cyA9IElOSVRfU1RBVEU7ICAgICAvKiB0byBwYXNzIHN0YXRlIHRlc3QgaW4gZGVmbGF0ZVJlc2V0KCkgKi9cblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IFVpbnQxNkFycmF5KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IFVpbnQxNkFycmF5KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICAvKiBXZSBvdmVybGF5IHBlbmRpbmdfYnVmIGFuZCBzeW1fYnVmLiBUaGlzIHdvcmtzIHNpbmNlIHRoZSBhdmVyYWdlIHNpemVcbiAgICogZm9yIGxlbmd0aC9kaXN0YW5jZSBwYWlycyBvdmVyIGFueSBjb21wcmVzc2VkIGJsb2NrIGlzIGFzc3VyZWQgdG8gYmUgMzFcbiAgICogYml0cyBvciBsZXNzLlxuICAgKlxuICAgKiBBbmFseXNpczogVGhlIGxvbmdlc3QgZml4ZWQgY29kZXMgYXJlIGEgbGVuZ3RoIGNvZGUgb2YgOCBiaXRzIHBsdXMgNVxuICAgKiBleHRyYSBiaXRzLCBmb3IgbGVuZ3RocyAxMzEgdG8gMjU3LiBUaGUgbG9uZ2VzdCBmaXhlZCBkaXN0YW5jZSBjb2RlcyBhcmVcbiAgICogNSBiaXRzIHBsdXMgMTMgZXh0cmEgYml0cywgZm9yIGRpc3RhbmNlcyAxNjM4NSB0byAzMjc2OC4gVGhlIGxvbmdlc3RcbiAgICogcG9zc2libGUgZml4ZWQtY29kZXMgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgdGhlbiAzMSBiaXRzIHRvdGFsLlxuICAgKlxuICAgKiBzeW1fYnVmIHN0YXJ0cyBvbmUtZm91cnRoIG9mIHRoZSB3YXkgaW50byBwZW5kaW5nX2J1Zi4gU28gdGhlcmUgYXJlXG4gICAqIHRocmVlIGJ5dGVzIGluIHN5bV9idWYgZm9yIGV2ZXJ5IGZvdXIgYnl0ZXMgaW4gcGVuZGluZ19idWYuIEVhY2ggc3ltYm9sXG4gICAqIGluIHN5bV9idWYgaXMgdGhyZWUgYnl0ZXMgLS0gdHdvIGZvciB0aGUgZGlzdGFuY2UgYW5kIG9uZSBmb3IgdGhlXG4gICAqIGxpdGVyYWwvbGVuZ3RoLiBBcyBlYWNoIHN5bWJvbCBpcyBjb25zdW1lZCwgdGhlIHBvaW50ZXIgdG8gdGhlIG5leHRcbiAgICogc3ltX2J1ZiB2YWx1ZSB0byByZWFkIG1vdmVzIGZvcndhcmQgdGhyZWUgYnl0ZXMuIEZyb20gdGhhdCBzeW1ib2wsIHVwIHRvXG4gICAqIDMxIGJpdHMgYXJlIHdyaXR0ZW4gdG8gcGVuZGluZ19idWYuIFRoZSBjbG9zZXN0IHRoZSB3cml0dGVuIHBlbmRpbmdfYnVmXG4gICAqIGJpdHMgZ2V0cyB0byB0aGUgbmV4dCBzeW1fYnVmIHN5bWJvbCB0byByZWFkIGlzIGp1c3QgYmVmb3JlIHRoZSBsYXN0XG4gICAqIGNvZGUgaXMgd3JpdHRlbi4gQXQgdGhhdCB0aW1lLCAzMSoobi0yKSBiaXRzIGhhdmUgYmVlbiB3cml0dGVuLCBqdXN0XG4gICAqIGFmdGVyIDI0KihuLTIpIGJpdHMgaGF2ZSBiZWVuIGNvbnN1bWVkIGZyb20gc3ltX2J1Zi4gc3ltX2J1ZiBzdGFydHMgYXRcbiAgICogOCpuIGJpdHMgaW50byBwZW5kaW5nX2J1Zi4gKE5vdGUgdGhhdCB0aGUgc3ltYm9sIGJ1ZmZlciBmaWxscyB3aGVuIG4tMVxuICAgKiBzeW1ib2xzIGFyZSB3cml0dGVuLikgVGhlIGNsb3Nlc3QgdGhlIHdyaXRpbmcgZ2V0cyB0byB3aGF0IGlzIHVucmVhZCBpc1xuICAgKiB0aGVuIG4rMTQgYml0cy4gSGVyZSBuIGlzIGxpdF9idWZzaXplLCB3aGljaCBpcyAxNjM4NCBieSBkZWZhdWx0LCBhbmRcbiAgICogY2FuIHJhbmdlIGZyb20gMTI4IHRvIDMyNzY4LlxuICAgKlxuICAgKiBUaGVyZWZvcmUsIGF0IGEgbWluaW11bSwgdGhlcmUgYXJlIDE0MiBiaXRzIG9mIHNwYWNlIGJldHdlZW4gd2hhdCBpc1xuICAgKiB3cml0dGVuIGFuZCB3aGF0IGlzIHJlYWQgaW4gdGhlIG92ZXJsYWluIGJ1ZmZlcnMsIHNvIHRoZSBzeW1ib2xzIGNhbm5vdFxuICAgKiBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29tcHJlc3NlZCBkYXRhLiBUaGF0IHNwYWNlIGlzIGFjdHVhbGx5IDEzOSBiaXRzLFxuICAgKiBkdWUgdG8gdGhlIHRocmVlLWJpdCBmaXhlZC1jb2RlIGJsb2NrIGhlYWRlci5cbiAgICpcbiAgICogVGhhdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgZWl0aGVyIFpfRklYRUQgaXMgc3BlY2lmaWVkLCBmb3JjaW5nIGZpeGVkXG4gICAqIGNvZGVzLCBvciB3aGVuIHRoZSB1c2Ugb2YgZml4ZWQgY29kZXMgaXMgY2hvc2VuLCBiZWNhdXNlIHRoYXQgY2hvaWNlXG4gICAqIHJlc3VsdHMgaW4gYSBzbWFsbGVyIGNvbXByZXNzZWQgYmxvY2sgdGhhbiBkeW5hbWljIGNvZGVzLiBUaGF0IGxhdHRlclxuICAgKiBjb25kaXRpb24gdGhlbiBhc3N1cmVzIHRoYXQgdGhlIGFib3ZlIGFuYWx5c2lzIGFsc28gY292ZXJzIGFsbCBkeW5hbWljXG4gICAqIGJsb2Nrcy4gQSBkeW5hbWljLWNvZGUgYmxvY2sgd2lsbCBvbmx5IGJlIGNob3NlbiB0byBiZSBlbWl0dGVkIGlmIGl0IGhhc1xuICAgKiBmZXdlciBiaXRzIHRoYW4gYSBmaXhlZC1jb2RlIGJsb2NrIHdvdWxkIGZvciB0aGUgc2FtZSBzZXQgb2Ygc3ltYm9scy5cbiAgICogVGhlcmVmb3JlIGl0cyBhdmVyYWdlIHN5bWJvbCBsZW5ndGggaXMgYXNzdXJlZCB0byBiZSBsZXNzIHRoYW4gMzEuIFNvXG4gICAqIHRoZSBjb21wcmVzc2VkIGRhdGEgZm9yIGEgZHluYW1pYyBibG9jayBhbHNvIGNhbm5vdCBvdmVyd3JpdGUgdGhlXG4gICAqIHN5bWJvbHMgZnJvbSB3aGljaCBpdCBpcyBiZWluZyBjb25zdHJ1Y3RlZC5cbiAgICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPnN5bV9idWYgPSBzLT5wZW5kaW5nX2J1ZiArIHMtPmxpdF9idWZzaXplO1xuICBzLnN5bV9idWYgPSBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+c3ltX2VuZCA9IChzLT5saXRfYnVmc2l6ZSAtIDEpICogMztcbiAgcy5zeW1fZW5kID0gKHMubGl0X2J1ZnNpemUgLSAxKSAqIDM7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUqMyBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn07XG5cbmNvbnN0IGRlZmxhdGVJbml0ID0gKHN0cm0sIGxldmVsKSA9PiB7XG5cbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCQyLCBNQVhfV0JJVFMkMSwgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZJDEpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5jb25zdCBkZWZsYXRlJDIgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkgfHwgZmx1c2ggPiBaX0JMT0NLJDEgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMikgOiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKHN0cm0uYXZhaWxfaW4gIT09IDAgJiYgIXN0cm0uaW5wdXQpIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gkMykpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiQxIDogWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBjb25zdCBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LJDM7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gkMykge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IkMSk7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUiQxKTtcbiAgfVxuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFICYmIHMud3JhcCA9PT0gMCkge1xuICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcbiAgICAvKiB6bGliIGhlYWRlciAqL1xuICAgIGxldCBoZWFkZXIgPSAoWl9ERUZMQVRFRCQyICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgIGxldCBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICB9XG4gICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICB9XG4gICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuXG4gICAgLyogQ29tcHJlc3Npb24gbXVzdCBzdGFydCB3aXRoIGFuIGVtcHR5IHBlbmRpbmcgYnVmZmVyICovXG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LJDM7XG4gICAgfVxuICB9XG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gR1pJUF9TVEFURSkge1xuICAgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG5cbiAgICAgIC8qIENvbXByZXNzaW9uIG11c3Qgc3RhcnQgd2l0aCBhbiBlbXB0eSBwZW5kaW5nIGJ1ZmZlciAqL1xuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIHJldHVybiBaX09LJDM7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgKTtcbiAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgIH1cbiAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGxldCBiZWcgPSBzLnBlbmRpbmc7ICAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgbGV0IGxlZnQgPSAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSAtIHMuZ3ppbmRleDtcbiAgICAgIHdoaWxlIChzLnBlbmRpbmcgKyBsZWZ0ID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGxldCBjb3B5ID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gcy5wZW5kaW5nO1xuICAgICAgICAvLyB6bWVtY3B5KHMucGVuZGluZ19idWYgKyBzLnBlbmRpbmcsXG4gICAgICAgIC8vICAgIHMuZ3poZWFkLmV4dHJhICsgcy5nemluZGV4LCBjb3B5KTtcbiAgICAgICAgcy5wZW5kaW5nX2J1Zi5zZXQocy5nemhlYWQuZXh0cmEuc3ViYXJyYXkocy5nemluZGV4LCBzLmd6aW5kZXggKyBjb3B5KSwgcy5wZW5kaW5nKTtcbiAgICAgICAgcy5wZW5kaW5nID0gcy5wZW5kaW5nX2J1Zl9zaXplO1xuICAgICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHMuZ3ppbmRleCArPSBjb3B5O1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgICAgcmV0dXJuIFpfT0skMztcbiAgICAgICAgfVxuICAgICAgICBiZWcgPSAwO1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICB9XG4gICAgICAvLyBKUyBzcGVjaWZpYzogcy5nemhlYWQuZXh0cmEgbWF5IGJlIFR5cGVkQXJyYXkgb3IgQXJyYXkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vICAgICAgICAgICAgICBUeXBlZEFycmF5LnNsaWNlIGFuZCBUeXBlZEFycmF5LmZyb20gZG9uJ3QgZXhpc3QgaW4gSUUxMC1JRTExXG4gICAgICBsZXQgZ3poZWFkX2V4dHJhID0gbmV3IFVpbnQ4QXJyYXkocy5nemhlYWQuZXh0cmEpO1xuICAgICAgLy8gem1lbWNweShzLT5wZW5kaW5nX2J1ZiArIHMtPnBlbmRpbmcsXG4gICAgICAvLyAgICAgcy0+Z3poZWFkLT5leHRyYSArIHMtPmd6aW5kZXgsIGxlZnQpO1xuICAgICAgcy5wZW5kaW5nX2J1Zi5zZXQoZ3poZWFkX2V4dHJhLnN1YmFycmF5KHMuZ3ppbmRleCwgcy5nemluZGV4ICsgbGVmdCksIHMucGVuZGluZyk7XG4gICAgICBzLnBlbmRpbmcgKz0gbGVmdDtcbiAgICAgIC8vLS0tIEhDUkNfVVBEQVRFKGJlZykgLS0tLy9cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICAvLy0tLS8vXG4gICAgICBzLmd6aW5kZXggPSAwO1xuICAgIH1cbiAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgbGV0IGJlZyA9IHMucGVuZGluZzsgICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICBsZXQgdmFsO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAgICAgcmV0dXJuIFpfT0skMztcbiAgICAgICAgICB9XG4gICAgICAgICAgYmVnID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuICAgICAgLy8tLS0gSENSQ19VUERBVEUoYmVnKSAtLS0vL1xuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIC8vLS0tLy9cbiAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgfVxuICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBsZXQgYmVnID0gcy5wZW5kaW5nOyAgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIGxldCB2YWw7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIC8vLS0tIEhDUkNfVVBEQVRFKGJlZykgLS0tLy9cbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiZWcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG4gICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgLy8tLS0vL1xuICAgIH1cbiAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcblxuICAgIC8qIENvbXByZXNzaW9uIG11c3Qgc3RhcnQgd2l0aCBhbiBlbXB0eSBwZW5kaW5nIGJ1ZmZlciAqL1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSyQzO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCQyICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgbGV0IGJzdGF0ZSA9IHMubGV2ZWwgPT09IDAgPyBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkgOlxuICAgICAgICAgICAgICAgICBzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgICAgICAgICAgICBzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIF90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLJDEpIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCQxKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LJDM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCQzKSB7IHJldHVybiBaX09LJDM7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQkMzsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LJDMgOiBaX1NUUkVBTV9FTkQkMztcbn07XG5cblxuY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKGRlZmxhdGVTdGF0ZUNoZWNrKHN0cm0pKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUiQyKSA6IFpfT0skMztcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5jb25zdCBkZWZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG5cbiAgbGV0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBjb25zdCB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIGxldCB0bXBEaWN0ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUpO1xuICAgIHRtcERpY3Quc2V0KGRpY3Rpb25hcnkuc3ViYXJyYXkoZGljdExlbmd0aCAtIHMud19zaXplLCBkaWN0TGVuZ3RoKSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGNvbnN0IGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgY29uc3QgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgY29uc3QgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgbGV0IHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbGV0IG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0skMztcbn07XG5cblxudmFyIGRlZmxhdGVJbml0XzEgPSBkZWZsYXRlSW5pdDtcbnZhciBkZWZsYXRlSW5pdDJfMSA9IGRlZmxhdGVJbml0MjtcbnZhciBkZWZsYXRlUmVzZXRfMSA9IGRlZmxhdGVSZXNldDtcbnZhciBkZWZsYXRlUmVzZXRLZWVwXzEgPSBkZWZsYXRlUmVzZXRLZWVwO1xudmFyIGRlZmxhdGVTZXRIZWFkZXJfMSA9IGRlZmxhdGVTZXRIZWFkZXI7XG52YXIgZGVmbGF0ZV8yJDEgPSBkZWZsYXRlJDI7XG52YXIgZGVmbGF0ZUVuZF8xID0gZGVmbGF0ZUVuZDtcbnZhciBkZWZsYXRlU2V0RGljdGlvbmFyeV8xID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVHZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZUdldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cblxudmFyIGRlZmxhdGVfMSQyID0ge1xuXHRkZWZsYXRlSW5pdDogZGVmbGF0ZUluaXRfMSxcblx0ZGVmbGF0ZUluaXQyOiBkZWZsYXRlSW5pdDJfMSxcblx0ZGVmbGF0ZVJlc2V0OiBkZWZsYXRlUmVzZXRfMSxcblx0ZGVmbGF0ZVJlc2V0S2VlcDogZGVmbGF0ZVJlc2V0S2VlcF8xLFxuXHRkZWZsYXRlU2V0SGVhZGVyOiBkZWZsYXRlU2V0SGVhZGVyXzEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMiQxLFxuXHRkZWZsYXRlRW5kOiBkZWZsYXRlRW5kXzEsXG5cdGRlZmxhdGVTZXREaWN0aW9uYXJ5OiBkZWZsYXRlU2V0RGljdGlvbmFyeV8xLFxuXHRkZWZsYXRlSW5mbzogZGVmbGF0ZUluZm9cbn07XG5cbmNvbnN0IF9oYXMgPSAob2JqLCBrZXkpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxudmFyIGZsYXR0ZW5DaHVua3MgPSAoY2h1bmtzKSA9PiB7XG4gIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICBsZXQgbGVuID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGpvaW4gY2h1bmtzXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY29tbW9uID0ge1xuXHRhc3NpZ246IGFzc2lnbixcblx0ZmxhdHRlbkNodW5rczogZmxhdHRlbkNodW5rc1xufTtcblxuLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbmxldCBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxuY29uc3QgX3V0ZjhsZW4gPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbnZhciBzdHJpbmcyYnVmID0gKHN0cikgPT4ge1xuICBpZiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nICYmIFRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG4gIH1cblxuICBsZXQgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlclxuY29uc3QgYnVmMmJpbnN0cmluZyA9IChidWYsIGxlbikgPT4ge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmLmxlbmd0aCA9PT0gbGVuID8gYnVmIDogYnVmLnN1YmFycmF5KDAsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gKGJ1ZiwgbWF4KSA9PiB7XG4gIGNvbnN0IGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgJiYgVGV4dERlY29kZXIucHJvdG90eXBlLmRlY29kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmLnN1YmFycmF5KDAsIG1heCkpO1xuICB9XG5cbiAgbGV0IGksIG91dDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICBjb25zdCB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgbGV0IGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgbGV0IHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG5cbnZhciBzdHJpbmdzID0ge1xuXHRzdHJpbmcyYnVmOiBzdHJpbmcyYnVmLFxuXHRidWYyc3RyaW5nOiBidWYyc3RyaW5nLFxuXHR1dGY4Ym9yZGVyOiB1dGY4Ym9yZGVyXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbnZhciB6c3RyZWFtID0gWlN0cmVhbTtcblxuY29uc3QgdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMSwgWl9TWU5DX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNIOiBaX0ZJTklTSCQyLFxuICBaX09LOiBaX09LJDIsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDIsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDFcbn0gPSBjb25zdGFudHMkMjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gbmV3IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogY29uc3QgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUkMShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGNvbW1vbi5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVEJDEsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGxldCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IHpzdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0skMikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgZGVmbGF0ZV8xJDIuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgbGV0IGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0skMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3RcbiAqIGhhdmUgYGZsdXNoX21vZGVgIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZ1xuICogYnVmZmVycyBhbmQgY2FsbCBbW0RlZmxhdGUjb25FbmRdXS5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZSQxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIJDIgOiBaX05PX0ZMVVNIJDE7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nJDEuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhdmFpbF9vdXQgPiA2IHRvIGF2b2lkIHJlcGVhdGluZyBtYXJrZXJzXG4gICAgaWYgKChfZmx1c2hfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIIHx8IF9mbHVzaF9tb2RlID09PSBaX0ZVTExfRkxVU0gpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgLy8gRW5kZWQgPT4gZmx1c2ggYW5kIGZpbmlzaFxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCQyKSB7XG4gICAgICBpZiAoc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LJDI7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgb3V0IGJ1ZmZlciBmdWxsXG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiByZXF1ZXN0ZWQgYW5kIGhhcyBkYXRhXG4gICAgaWYgKF9mbHVzaF9tb2RlID4gMCAmJiBzdHJtLm5leHRfb3V0ID4gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXkpOiBvdXRwdXQgZGF0YS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUkMS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlJDEucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LJDIpIHtcbiAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmxhdG9yID0gbmV3IERlZmxhdGUkMShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtZXNzYWdlc1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXckMShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcCQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG52YXIgRGVmbGF0ZV8xJDEgPSBEZWZsYXRlJDE7XG52YXIgZGVmbGF0ZV8yID0gZGVmbGF0ZSQxO1xudmFyIGRlZmxhdGVSYXdfMSQxID0gZGVmbGF0ZVJhdyQxO1xudmFyIGd6aXBfMSQxID0gZ3ppcCQxO1xudmFyIGNvbnN0YW50cyQxID0gY29uc3RhbnRzJDI7XG5cbnZhciBkZWZsYXRlXzEkMSA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xJDEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMixcblx0ZGVmbGF0ZVJhdzogZGVmbGF0ZVJhd18xJDEsXG5cdGd6aXA6IGd6aXBfMSQxLFxuXHRjb25zdGFudHM6IGNvbnN0YW50cyQxXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xuY29uc3QgQkFEJDEgPSAxNjIwOTsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgVFlQRSQxID0gMTYxOTE7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG52YXIgaW5mZmFzdCA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICBsZXQgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICBsZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIGxldCBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBsZXQgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICBsZXQgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIGxldCB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIGxldCB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgbGV0IHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICBsZXQgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgbGV0IGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICBsZXQgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICBsZXQgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIGxldCBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICBsZXQgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIGxldCBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICBsZXQgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICBsZXQgZnJvbV9zb3VyY2U7XG5cblxuICBsZXQgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBNQVhCSVRTID0gMTU7XG5jb25zdCBFTk9VR0hfTEVOUyQxID0gODUyO1xuY29uc3QgRU5PVUdIX0RJU1RTJDEgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBDT0RFUyQxID0gMDtcbmNvbnN0IExFTlMkMSA9IDE7XG5jb25zdCBESVNUUyQxID0gMjtcblxuY29uc3QgbGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXSk7XG5cbmNvbnN0IGxleHQgPSBuZXcgVWludDhBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXSk7XG5cbmNvbnN0IGRiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXSk7XG5cbmNvbnN0IGRleHQgPSBuZXcgVWludDhBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXSk7XG5cbmNvbnN0IGluZmxhdGVfdGFibGUgPSAodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykgPT5cbntcbiAgY29uc3QgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgbGV0IGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgbGV0IHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIGxldCBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICBsZXQgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICBsZXQgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICBsZXQgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIGxldCBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgbGV0IHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgbGV0IGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIGxldCBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICBsZXQgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIGxldCBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICBsZXQgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgbGV0IG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIGxldCBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4vLyAgbGV0IHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgbWF0Y2g7ICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPj0gbWF0Y2ggKi9cbiAgY29uc3QgY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgY29uc3Qgb2ZmcyA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICBsZXQgZXh0cmEgPSBudWxsO1xuXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyQxIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUyQxKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgbWF0Y2ggPSAyMDtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMkMSkge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgbWF0Y2ggPSAyNTc7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBtYXRjaCA9IDA7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyQxICYmIHVzZWQgPiBFTk9VR0hfTEVOUyQxKSB8fFxuICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSArIDEgPCBtYXRjaCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID49IG1hdGNoKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbd29ya1tzeW1dIC0gbWF0Y2hdO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW3dvcmtbc3ltXSAtIG1hdGNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMkMSAmJiB1c2VkID4gRU5PVUdIX0xFTlMkMSkgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTJDEgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUyQxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcblxuXG52YXIgaW5mdHJlZXMgPSBpbmZsYXRlX3RhYmxlO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cblxuXG5cblxuXG5jb25zdCBDT0RFUyA9IDA7XG5jb25zdCBMRU5TID0gMTtcbmNvbnN0IERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9GSU5JU0g6IFpfRklOSVNIJDEsIFpfQkxPQ0ssIFpfVFJFRVMsXG4gIFpfT0s6IFpfT0skMSwgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMSwgWl9ORUVEX0RJQ1Q6IFpfTkVFRF9ESUNUJDEsIFpfU1RSRUFNX0VSUk9SOiBaX1NUUkVBTV9FUlJPUiQxLCBaX0RBVEFfRVJST1I6IFpfREFUQV9FUlJPUiQxLCBaX01FTV9FUlJPUjogWl9NRU1fRVJST1IkMSwgWl9CVUZfRVJST1IsXG4gIFpfREVGTEFURURcbn0gPSBjb25zdGFudHMkMjtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCAgICBIRUFEID0gMTYxODA7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAxNjE4MTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xuY29uc3QgICAgVElNRSA9IDE2MTgyOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIE9TID0gMTYxODM7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDE2MTg0OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYVFJBID0gMTYxODU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG5jb25zdCAgICBOQU1FID0gMTYxODY7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gMTYxODc7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xuY29uc3QgICAgSENSQyA9IDE2MTg4OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xuY29uc3QgICAgRElDVElEID0gMTYxODk7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIERJQ1QgPSAxNjE5MDsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbmNvbnN0ICAgICAgICBUWVBFID0gMTYxOTE7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuY29uc3QgICAgICAgIFRZUEVETyA9IDE2MTkyOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG5jb25zdCAgICAgICAgU1RPUkVEID0gMTYxOTM7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG5jb25zdCAgICAgICAgQ09QWV8gPSAxNjE5NDsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgQ09QWSA9IDE2MTk1OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG5jb25zdCAgICAgICAgVEFCTEUgPSAxNjE5NjsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIExFTkxFTlMgPSAxNjE5NzsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE2MTk4OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgICAgIExFTl8gPSAxNjE5OTsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgICAgICBMRU4gPSAxNjIwMDsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAxNjIwMTsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVCA9IDE2MjAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVEVYVCA9IDE2MjAzOyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAxNjIwNDsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xuY29uc3QgICAgICAgICAgICBMSVQgPSAxNjIwNTsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbmNvbnN0ICAgIENIRUNLID0gMTYyMDY7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIExFTkdUSCA9IDE2MjA3OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRE9ORSA9IDE2MjA4OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBCQUQgPSAxNjIwOTsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgTUVNID0gMTYyMTA7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBTWU5DID0gMTYyMTE7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG5jb25zdCBFTk9VR0hfTEVOUyA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmNvbnN0IHpzd2FwMzIgPSAocSkgPT4ge1xuXG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufTtcblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0IDIgdHJ1ZSB0byB2YWxpZGF0ZSBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpLCBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgaWYgcmF3IG9yIG5vIGhlYWRlciB5ZXQgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyBVaW50MTZBcnJheSgzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgSW50MzJBcnJheShFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5cbmNvbnN0IGluZmxhdGVTdGF0ZUNoZWNrID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0pIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICghc3RhdGUgfHwgc3RhdGUuc3RybSAhPT0gc3RybSB8fFxuICAgIHN0YXRlLm1vZGUgPCBIRUFEIHx8IHN0YXRlLm1vZGUgPiBTWU5DKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5mbGFncyA9IC0xO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBpZiAoaW5mbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcbiAgbGV0IHdyYXA7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoaW5mbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDU7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUuc3RybSA9IHN0cm07XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5tb2RlID0gSEVBRDsgICAgIC8qIHRvIHBhc3Mgc3RhdGUgdGVzdCBpbiBpbmZsYXRlUmVzZXQyKCkgKi9cbiAgY29uc3QgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSyQxKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0ID0gKHN0cm0pID0+IHtcblxuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59O1xuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbmxldCB2aXJnaW4gPSB0cnVlO1xuXG5sZXQgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5cbmNvbnN0IGZpeGVkdGFibGVzID0gKHN0YXRlKSA9PiB7XG5cbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIGxlbmZpeCA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyBJbnQzMkFycmF5KDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgbGV0IHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZnRyZWVzKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mdHJlZXMoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59O1xuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5jb25zdCB1cGRhdGV3aW5kb3cgPSAoc3RybSwgc3JjLCBlbmQsIGNvcHkpID0+IHtcblxuICBsZXQgZGlzdDtcbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gc3RhdGUud3NpemUsIGVuZCksIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQgLSBjb3B5ICsgZGlzdCksIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGUkMiA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LJDE7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUud2JpdHMgPSAxNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gMTUgfHwgbGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gISEhIHBha28gcGF0Y2guIEZvcmNlIHVzZSBgb3B0aW9ucy53aW5kb3dCaXRzYCBpZiBwYXNzZWQuXG4gICAgICAgIC8vIFJlcXVpcmVkIHRvIGFsd2F5cyB1c2UgbWF4IHdpbmRvdyBzaXplIGJ5IGRlZmF1bHQuXG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgICAgICAvL3N0YXRlLmRtYXggPSAxIDw8IGxlbjtcblxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAgICAgLyogaW5kaWNhdGUgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEuc2V0KFxuICAgICAgICAgICAgICAgIGlucHV0LnN1YmFycmF5KFxuICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgICBuZXh0ICsgY29weVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweDAyMDApICYmIChzdGF0ZS53cmFwICYgNCkpIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweDAyMDApICYmIChzdGF0ZS53cmFwICYgNCkpIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDQpICYmIGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUJDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KG5leHQsIG5leHQgKyBjb3B5KSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmZhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgNCkgJiYgX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURV9DSEVDSyhzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDQpICYmIChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiA0KSAmJiBob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQkMTtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUiQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQxKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSA7XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoKHN0YXRlLndyYXAgJiA0KSAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEVfQ0hFQ0soc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCQxKSAmJiByZXQgPT09IFpfT0skMSkge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LJDE7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVHZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuICBjb25zdCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgZGljdGlkO1xuICBsZXQgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzJfMShkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SJDE7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxudmFyIGluZmxhdGVSZXNldF8xID0gaW5mbGF0ZVJlc2V0O1xudmFyIGluZmxhdGVSZXNldDJfMSA9IGluZmxhdGVSZXNldDI7XG52YXIgaW5mbGF0ZVJlc2V0S2VlcF8xID0gaW5mbGF0ZVJlc2V0S2VlcDtcbnZhciBpbmZsYXRlSW5pdF8xID0gaW5mbGF0ZUluaXQ7XG52YXIgaW5mbGF0ZUluaXQyXzEgPSBpbmZsYXRlSW5pdDI7XG52YXIgaW5mbGF0ZV8yJDEgPSBpbmZsYXRlJDI7XG52YXIgaW5mbGF0ZUVuZF8xID0gaW5mbGF0ZUVuZDtcbnZhciBpbmZsYXRlR2V0SGVhZGVyXzEgPSBpbmZsYXRlR2V0SGVhZGVyO1xudmFyIGluZmxhdGVTZXREaWN0aW9uYXJ5XzEgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbnZhciBpbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlQ29kZXNVc2VkID0gaW5mbGF0ZUNvZGVzVXNlZDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVZhbGlkYXRlID0gaW5mbGF0ZVZhbGlkYXRlO1xuKi9cblxudmFyIGluZmxhdGVfMSQyID0ge1xuXHRpbmZsYXRlUmVzZXQ6IGluZmxhdGVSZXNldF8xLFxuXHRpbmZsYXRlUmVzZXQyOiBpbmZsYXRlUmVzZXQyXzEsXG5cdGluZmxhdGVSZXNldEtlZXA6IGluZmxhdGVSZXNldEtlZXBfMSxcblx0aW5mbGF0ZUluaXQ6IGluZmxhdGVJbml0XzEsXG5cdGluZmxhdGVJbml0MjogaW5mbGF0ZUluaXQyXzEsXG5cdGluZmxhdGU6IGluZmxhdGVfMiQxLFxuXHRpbmZsYXRlRW5kOiBpbmZsYXRlRW5kXzEsXG5cdGluZmxhdGVHZXRIZWFkZXI6IGluZmxhdGVHZXRIZWFkZXJfMSxcblx0aW5mbGF0ZVNldERpY3Rpb25hcnk6IGluZmxhdGVTZXREaWN0aW9uYXJ5XzEsXG5cdGluZmxhdGVJbmZvOiBpbmZsYXRlSW5mb1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxudmFyIGd6aGVhZGVyID0gR1poZWFkZXI7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9GSU5JU0gsXG4gIFpfT0ssIFpfU1RSRUFNX0VORCwgWl9ORUVEX0RJQ1QsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfTUVNX0VSUk9SXG59ID0gY29uc3RhbnRzJDI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqIGNvbnN0IGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiBjb25zdCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZSQxKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxMDI0ICogNjQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBnemhlYWRlcigpO1xuXG4gIGluZmxhdGVfMSQyLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUVcbiAqICAgZmx1c2ggbW9kZXMuIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILFxuICogICBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBJZiBlbmQgb2Ygc3RyZWFtIGRldGVjdGVkLFxuICogW1tJbmZsYXRlI29uRW5kXV0gd2lsbCBiZSBjYWxsZWQuXG4gKlxuICogYGZsdXNoX21vZGVgIGlzIG5vdCBuZWVkZWQgZm9yIG5vcm1hbCBvcGVyYXRpb24sIGJlY2F1c2UgZW5kIG9mIHN0cmVhbVxuICogZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gWW91IG1heSB0cnkgdG8gdXNlIGl0IGZvciBhZHZhbmNlZCB0aGluZ3MsIGJ1dFxuICogdGhpcyBmdW5jdGlvbmFsaXR5IHdhcyBub3QgdGVzdGVkLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlJDEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBjb25zdCBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlLCBsYXN0X2F2YWlsX291dDtcblxuICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSk7XG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gWl9EQVRBX0VSUk9SKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgY29kZSB3aXRoIG1vcmUgdmVyYm9zZVxuICAgICAgICBzdGF0dXMgPSBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTa2lwIHNueWMgbWFya2VycyBpZiBtb3JlIGRhdGEgZm9sbG93cyBhbmQgbm90IHJhdyBtb2RlXG4gICAgd2hpbGUgKHN0cm0uYXZhaWxfaW4gPiAwICYmXG4gICAgICAgICAgIHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EICYmXG4gICAgICAgICAgIHN0cm0uc3RhdGUud3JhcCA+IDAgJiZcbiAgICAgICAgICAgZGF0YVtzdHJtLm5leHRfaW5dICE9PSAwKVxuICAgIHtcbiAgICAgIGluZmxhdGVfMSQyLmluZmxhdGVSZXNldChzdHJtKTtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFpfU1RSRUFNX0VSUk9SOlxuICAgICAgY2FzZSBaX0RBVEFfRVJST1I6XG4gICAgICBjYXNlIFpfTkVFRF9ESUNUOlxuICAgICAgY2FzZSBaX01FTV9FUlJPUjpcbiAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbWVtYmVyIHJlYWwgYGF2YWlsX291dGAgdmFsdWUsIGJlY2F1c2Ugd2UgbWF5IHBhdGNoIG91dCBidWZmZXIgY29udGVudFxuICAgIC8vIHRvIGFsaWduIHV0Zjggc3RyaW5ncyBib3VuZGFyaWVzLlxuICAgIGxhc3RfYXZhaWxfb3V0ID0gc3RybS5hdmFpbF9vdXQ7XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIGxldCBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIGxldCB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgbGV0IHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsICYgcmVhbGlnbiBjb3VudGVyc1xuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgc3RybS5vdXRwdXQuc2V0KHN0cm0ub3V0cHV0LnN1YmFycmF5KG5leHRfb3V0X3V0ZjgsIG5leHRfb3V0X3V0ZjggKyB0YWlsKSwgMCk7XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0Lmxlbmd0aCA9PT0gc3RybS5uZXh0X291dCA/IHN0cm0ub3V0cHV0IDogc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTXVzdCByZXBlYXQgaXRlcmF0aW9uIGlmIG91dCBidWZmZXIgaXMgZnVsbFxuICAgIGlmIChzdGF0dXMgPT09IFpfT0sgJiYgbGFzdF9hdmFpbF9vdXQgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluYWxpemUgaWYgZW5kIG9mIHN0cmVhbSByZWFjaGVkLlxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgZWFjaCBjaHVuayB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xuICogY29uc3QgaW5wdXQgPSBwYWtvLmRlZmxhdGUobmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSkpO1xuICogbGV0IG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBpbmZsYXRvciA9IG5ldyBJbmZsYXRlJDEob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2luZmxhdG9yLmVycl07XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcik6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG52YXIgSW5mbGF0ZV8xJDEgPSBJbmZsYXRlJDE7XG52YXIgaW5mbGF0ZV8yID0gaW5mbGF0ZSQxO1xudmFyIGluZmxhdGVSYXdfMSQxID0gaW5mbGF0ZVJhdyQxO1xudmFyIHVuZ3ppcCQxID0gaW5mbGF0ZSQxO1xudmFyIGNvbnN0YW50cyA9IGNvbnN0YW50cyQyO1xuXG52YXIgaW5mbGF0ZV8xJDEgPSB7XG5cdEluZmxhdGU6IEluZmxhdGVfMSQxLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzIsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSQxLFxuXHR1bmd6aXA6IHVuZ3ppcCQxLFxuXHRjb25zdGFudHM6IGNvbnN0YW50c1xufTtcblxuY29uc3QgeyBEZWZsYXRlLCBkZWZsYXRlLCBkZWZsYXRlUmF3LCBnemlwIH0gPSBkZWZsYXRlXzEkMTtcblxuY29uc3QgeyBJbmZsYXRlLCBpbmZsYXRlLCBpbmZsYXRlUmF3LCB1bmd6aXAgfSA9IGluZmxhdGVfMSQxO1xuXG5cblxudmFyIERlZmxhdGVfMSA9IERlZmxhdGU7XG52YXIgZGVmbGF0ZV8xID0gZGVmbGF0ZTtcbnZhciBkZWZsYXRlUmF3XzEgPSBkZWZsYXRlUmF3O1xudmFyIGd6aXBfMSA9IGd6aXA7XG52YXIgSW5mbGF0ZV8xID0gSW5mbGF0ZTtcbnZhciBpbmZsYXRlXzEgPSBpbmZsYXRlO1xudmFyIGluZmxhdGVSYXdfMSA9IGluZmxhdGVSYXc7XG52YXIgdW5nemlwXzEgPSB1bmd6aXA7XG52YXIgY29uc3RhbnRzXzEgPSBjb25zdGFudHMkMjtcblxudmFyIHBha28gPSB7XG5cdERlZmxhdGU6IERlZmxhdGVfMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8xLFxuXHRkZWZsYXRlUmF3OiBkZWZsYXRlUmF3XzEsXG5cdGd6aXA6IGd6aXBfMSxcblx0SW5mbGF0ZTogSW5mbGF0ZV8xLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzEsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSxcblx0dW5nemlwOiB1bmd6aXBfMSxcblx0Y29uc3RhbnRzOiBjb25zdGFudHNfMVxufTtcblxuZXhwb3J0IHsgRGVmbGF0ZV8xIGFzIERlZmxhdGUsIEluZmxhdGVfMSBhcyBJbmZsYXRlLCBjb25zdGFudHNfMSBhcyBjb25zdGFudHMsIHBha28gYXMgZGVmYXVsdCwgZGVmbGF0ZV8xIGFzIGRlZmxhdGUsIGRlZmxhdGVSYXdfMSBhcyBkZWZsYXRlUmF3LCBnemlwXzEgYXMgZ3ppcCwgaW5mbGF0ZV8xIGFzIGluZmxhdGUsIGluZmxhdGVSYXdfMSBhcyBpbmZsYXRlUmF3LCB1bmd6aXBfMSBhcyB1bmd6aXAgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pako/dist/pako.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/components.js":
/*!*******************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/components.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// TODO: To be completed in future revisions\n// This is in API SPEC extracted from starknetjs RPC 0.7 components.ts\n\n//# sourceMappingURL=components.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvY29tcG9uZW50cy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNVO0FBQ1YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvc3RhcmtuZXQtdHlwZXMtMDcvZGlzdC9lc20vYXBpL2NvbXBvbmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogVG8gYmUgY29tcGxldGVkIGluIGZ1dHVyZSByZXZpc2lvbnNcbi8vIFRoaXMgaXMgaW4gQVBJIFNQRUMgZXh0cmFjdGVkIGZyb20gc3RhcmtuZXRqcyBSUEMgMC43IGNvbXBvbmVudHMudHNcbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/components.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/errors.js":
/*!***************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/errors.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3N0YXJrbmV0LXR5cGVzLTA3L2Rpc3QvZXNtL2FwaS9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EBlockTag: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.EBlockTag),\n/* harmony export */   EDAMode: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.EDAMode),\n/* harmony export */   EDataAvailabilityMode: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.EDataAvailabilityMode),\n/* harmony export */   ESimulationFlag: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ESimulationFlag),\n/* harmony export */   ETransactionExecutionStatus: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionExecutionStatus),\n/* harmony export */   ETransactionFinalityStatus: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionFinalityStatus),\n/* harmony export */   ETransactionStatus: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionStatus),\n/* harmony export */   ETransactionType: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionType),\n/* harmony export */   ETransactionVersion: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionVersion),\n/* harmony export */   ETransactionVersion2: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionVersion2),\n/* harmony export */   ETransactionVersion3: () => (/* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionVersion3),\n/* harmony export */   Errors: () => (/* reexport module object */ _errors_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   SPEC: () => (/* reexport module object */ _components_js__WEBPACK_IMPORTED_MODULE_1__)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/errors.js\");\n/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/components.js\");\n/* harmony import */ var _nonspec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonspec.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNVO0FBQ1Y7QUFDWTtBQUNoQjtBQUNHO0FBQzdCIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3N0YXJrbmV0LXR5cGVzLTA3L2Rpc3QvZXNtL2FwaS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NvbnRyYWN0LmpzJztcbmltcG9ydCAqIGFzIEVycm9yc18xIGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCB7IEVycm9yc18xIGFzIEVycm9ycyB9O1xuaW1wb3J0ICogYXMgU1BFQ18xIGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5leHBvcnQgeyBTUEVDXzEgYXMgU1BFQyB9O1xuZXhwb3J0ICogZnJvbSAnLi9ub25zcGVjLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js":
/*!****************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/nonspec.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EBlockTag: () => (/* binding */ EBlockTag),\n/* harmony export */   EDAMode: () => (/* binding */ EDAMode),\n/* harmony export */   EDataAvailabilityMode: () => (/* binding */ EDataAvailabilityMode),\n/* harmony export */   ESimulationFlag: () => (/* binding */ ESimulationFlag),\n/* harmony export */   ETransactionExecutionStatus: () => (/* binding */ ETransactionExecutionStatus),\n/* harmony export */   ETransactionFinalityStatus: () => (/* binding */ ETransactionFinalityStatus),\n/* harmony export */   ETransactionStatus: () => (/* binding */ ETransactionStatus),\n/* harmony export */   ETransactionType: () => (/* binding */ ETransactionType),\n/* harmony export */   ETransactionVersion: () => (/* binding */ ETransactionVersion),\n/* harmony export */   ETransactionVersion2: () => (/* binding */ ETransactionVersion2),\n/* harmony export */   ETransactionVersion3: () => (/* binding */ ETransactionVersion3)\n/* harmony export */ });\n// Enums Derived From Spec Types (require manual check for changes)\nconst ETransactionType = {\n    DECLARE: 'DECLARE',\n    DEPLOY: 'DEPLOY',\n    DEPLOY_ACCOUNT: 'DEPLOY_ACCOUNT',\n    INVOKE: 'INVOKE',\n    L1_HANDLER: 'L1_HANDLER',\n};\nconst ESimulationFlag = {\n    SKIP_VALIDATE: 'SKIP_VALIDATE',\n    SKIP_FEE_CHARGE: 'SKIP_FEE_CHARGE',\n};\nconst ETransactionStatus = {\n    RECEIVED: 'RECEIVED',\n    REJECTED: 'REJECTED',\n    ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n    ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n};\nconst ETransactionFinalityStatus = {\n    ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n    ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n};\nconst ETransactionExecutionStatus = {\n    SUCCEEDED: 'SUCCEEDED',\n    REVERTED: 'REVERTED',\n};\nconst EBlockTag = {\n    LATEST: 'latest',\n    PENDING: 'pending',\n};\n// 'L1' | 'L2'\nconst EDataAvailabilityMode = {\n    L1: 'L1',\n    L2: 'L2',\n};\n// 0 | 1\nconst EDAMode = {\n    L1: 0,\n    L2: 1,\n};\n/**\n * V_ Transaction versions HexString\n * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)\n */\nconst ETransactionVersion = {\n    V0: '0x0',\n    V1: '0x1',\n    V2: '0x2',\n    V3: '0x3',\n    F0: '0x100000000000000000000000000000000',\n    F1: '0x100000000000000000000000000000001',\n    F2: '0x100000000000000000000000000000002',\n    F3: '0x100000000000000000000000000000003',\n};\n/**\n * Old Transaction Versions\n */\nconst ETransactionVersion2 = {\n    V0: '0x0',\n    V1: '0x1',\n    V2: '0x2',\n    F0: '0x100000000000000000000000000000000',\n    F1: '0x100000000000000000000000000000001',\n    F2: '0x100000000000000000000000000000002',\n};\n/**\n * V3 Transaction Versions\n */\nconst ETransactionVersion3 = {\n    V3: '0x3',\n    F3: '0x100000000000000000000000000000003',\n};\n//# sourceMappingURL=nonspec.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvbm9uc3BlYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS93aWxmcmlkLWsvcHJvamVjdHMvb25seWR1c3QvY2hhaW5ldmVudHMtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3N0YXJrbmV0LXR5cGVzLTA3L2Rpc3QvZXNtL2FwaS9ub25zcGVjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudW1zIERlcml2ZWQgRnJvbSBTcGVjIFR5cGVzIChyZXF1aXJlIG1hbnVhbCBjaGVjayBmb3IgY2hhbmdlcylcbmV4cG9ydCBjb25zdCBFVHJhbnNhY3Rpb25UeXBlID0ge1xuICAgIERFQ0xBUkU6ICdERUNMQVJFJyxcbiAgICBERVBMT1k6ICdERVBMT1knLFxuICAgIERFUExPWV9BQ0NPVU5UOiAnREVQTE9ZX0FDQ09VTlQnLFxuICAgIElOVk9LRTogJ0lOVk9LRScsXG4gICAgTDFfSEFORExFUjogJ0wxX0hBTkRMRVInLFxufTtcbmV4cG9ydCBjb25zdCBFU2ltdWxhdGlvbkZsYWcgPSB7XG4gICAgU0tJUF9WQUxJREFURTogJ1NLSVBfVkFMSURBVEUnLFxuICAgIFNLSVBfRkVFX0NIQVJHRTogJ1NLSVBfRkVFX0NIQVJHRScsXG59O1xuZXhwb3J0IGNvbnN0IEVUcmFuc2FjdGlvblN0YXR1cyA9IHtcbiAgICBSRUNFSVZFRDogJ1JFQ0VJVkVEJyxcbiAgICBSRUpFQ1RFRDogJ1JFSkVDVEVEJyxcbiAgICBBQ0NFUFRFRF9PTl9MMjogJ0FDQ0VQVEVEX09OX0wyJyxcbiAgICBBQ0NFUFRFRF9PTl9MMTogJ0FDQ0VQVEVEX09OX0wxJyxcbn07XG5leHBvcnQgY29uc3QgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSB7XG4gICAgQUNDRVBURURfT05fTDI6ICdBQ0NFUFRFRF9PTl9MMicsXG4gICAgQUNDRVBURURfT05fTDE6ICdBQ0NFUFRFRF9PTl9MMScsXG59O1xuZXhwb3J0IGNvbnN0IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IHtcbiAgICBTVUNDRUVERUQ6ICdTVUNDRUVERUQnLFxuICAgIFJFVkVSVEVEOiAnUkVWRVJURUQnLFxufTtcbmV4cG9ydCBjb25zdCBFQmxvY2tUYWcgPSB7XG4gICAgTEFURVNUOiAnbGF0ZXN0JyxcbiAgICBQRU5ESU5HOiAncGVuZGluZycsXG59O1xuLy8gJ0wxJyB8ICdMMidcbmV4cG9ydCBjb25zdCBFRGF0YUF2YWlsYWJpbGl0eU1vZGUgPSB7XG4gICAgTDE6ICdMMScsXG4gICAgTDI6ICdMMicsXG59O1xuLy8gMCB8IDFcbmV4cG9ydCBjb25zdCBFREFNb2RlID0ge1xuICAgIEwxOiAwLFxuICAgIEwyOiAxLFxufTtcbi8qKlxuICogVl8gVHJhbnNhY3Rpb24gdmVyc2lvbnMgSGV4U3RyaW5nXG4gKiBGXyBGZWUgVHJhbnNhY3Rpb24gVmVyc2lvbnMgSGV4U3RyaW5nICgyICoqIDEyOCArIFRSQU5TQUNUSU9OX1ZFUlNJT04pXG4gKi9cbmV4cG9ydCBjb25zdCBFVHJhbnNhY3Rpb25WZXJzaW9uID0ge1xuICAgIFYwOiAnMHgwJyxcbiAgICBWMTogJzB4MScsXG4gICAgVjI6ICcweDInLFxuICAgIFYzOiAnMHgzJyxcbiAgICBGMDogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICBGMTogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAgICBGMjogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyJyxcbiAgICBGMzogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzJyxcbn07XG4vKipcbiAqIE9sZCBUcmFuc2FjdGlvbiBWZXJzaW9uc1xuICovXG5leHBvcnQgY29uc3QgRVRyYW5zYWN0aW9uVmVyc2lvbjIgPSB7XG4gICAgVjA6ICcweDAnLFxuICAgIFYxOiAnMHgxJyxcbiAgICBWMjogJzB4MicsXG4gICAgRjA6ICcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgRjE6ICcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gICAgRjI6ICcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMicsXG59O1xuLyoqXG4gKiBWMyBUcmFuc2FjdGlvbiBWZXJzaW9uc1xuICovXG5leHBvcnQgY29uc3QgRVRyYW5zYWN0aW9uVmVyc2lvbjMgPSB7XG4gICAgVjM6ICcweDMnLFxuICAgIEYzOiAnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDMnLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbnNwZWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API: () => (/* reexport module object */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   EBlockTag: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.EBlockTag),\n/* harmony export */   EDAMode: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.EDAMode),\n/* harmony export */   EDataAvailabilityMode: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.EDataAvailabilityMode),\n/* harmony export */   ESimulationFlag: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ESimulationFlag),\n/* harmony export */   ETransactionExecutionStatus: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionExecutionStatus),\n/* harmony export */   ETransactionFinalityStatus: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionFinalityStatus),\n/* harmony export */   ETransactionStatus: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionStatus),\n/* harmony export */   ETransactionType: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionType),\n/* harmony export */   ETransactionVersion: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionVersion),\n/* harmony export */   ETransactionVersion2: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionVersion2),\n/* harmony export */   ETransactionVersion3: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionVersion3),\n/* harmony export */   Errors: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.Errors),\n/* harmony export */   Permission: () => (/* reexport safe */ _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__.Permission),\n/* harmony export */   SPEC: () => (/* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.SPEC),\n/* harmony export */   TypedDataRevision: () => (/* reexport safe */ _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__.TypedDataRevision),\n/* harmony export */   WALLET_API: () => (/* reexport module object */ _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__)\n/* harmony export */ });\n/* harmony import */ var _api_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api/index.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/index.js\");\n/* harmony import */ var _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallet-api/index.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/index.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ1M7QUFDaEI7QUFDYztBQUNnQjtBQUNoQjtBQUN0QyIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FwaS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBBUElfMSBmcm9tICcuL2FwaS9pbmRleC5qcyc7XG5leHBvcnQgeyBBUElfMSBhcyBBUEkgfTtcbmV4cG9ydCAqIGZyb20gJy4vd2FsbGV0LWFwaS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBXQUxMRVRfQVBJXzEgZnJvbSAnLi93YWxsZXQtYXBpL2luZGV4LmpzJztcbmV4cG9ydCB7IFdBTExFVF9BUElfMSBhcyBXQUxMRVRfQVBJIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Permission: () => (/* binding */ Permission)\n/* harmony export */ });\nconst Permission = {\n    ACCOUNTS: 'accounts',\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS93YWxsZXQtYXBpL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvc3RhcmtuZXQtdHlwZXMtMDcvZGlzdC9lc20vd2FsbGV0LWFwaS9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFBlcm1pc3Npb24gPSB7XG4gICAgQUNDT1VOVFM6ICdhY2NvdW50cycsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/wallet-api/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Permission: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.Permission),\n/* harmony export */   TypedDataRevision: () => (/* reexport safe */ _typedData_js__WEBPACK_IMPORTED_MODULE_1__.TypedDataRevision)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js\");\n/* harmony import */ var _typedData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typedData.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS93YWxsZXQtYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNXO0FBQ1Y7QUFDSDtBQUNEO0FBQ0E7QUFDNUIiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvc3RhcmtuZXQtdHlwZXMtMDcvZGlzdC9lc20vd2FsbGV0LWFwaS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVkRGF0YS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1N0YXJrbmV0V2luZG93T2JqZWN0LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL21ldGhvZHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ldmVudHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js":
/*!*************************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataRevision: () => (/* binding */ TypedDataRevision)\n/* harmony export */ });\nconst TypedDataRevision = {\n    ACTIVE: '1',\n    LEGACY: '0',\n};\n//# sourceMappingURL=typedData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS93YWxsZXQtYXBpL3R5cGVkRGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvd2lsZnJpZC1rL3Byb2plY3RzL29ubHlkdXN0L2NoYWluZXZlbnRzLWZyb250ZW5kL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS93YWxsZXQtYXBpL3R5cGVkRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVHlwZWREYXRhUmV2aXNpb24gPSB7XG4gICAgQUNUSVZFOiAnMScsXG4gICAgTEVHQUNZOiAnMCcsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWREYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CairoUint256: () => (/* binding */ CairoUint256),\n/* harmony export */   CairoUint512: () => (/* binding */ CairoUint512),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   EthSigner: () => (/* binding */ EthSigner),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   Provider: () => (/* binding */ RpcProvider2),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ api_exports),\n/* harmony export */   RPC06: () => (/* binding */ rpc_0_6_exports),\n/* harmony export */   RPC07: () => (/* binding */ rpc_0_7_exports),\n/* harmony export */   RPCResponseParser: () => (/* binding */ RPCResponseParser),\n/* harmony export */   ReceiptTx: () => (/* binding */ ReceiptTx),\n/* harmony export */   ResponseParser: () => (/* binding */ ResponseParser),\n/* harmony export */   RpcChannel: () => (/* binding */ RpcChannel2),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider2),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   TypedDataRevision: () => (/* reexport safe */ starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision),\n/* harmony export */   UINT_128_MAX: () => (/* binding */ UINT_128_MAX),\n/* harmony export */   UINT_128_MIN: () => (/* binding */ UINT_128_MIN),\n/* harmony export */   UINT_256_HIGH_MAX: () => (/* binding */ UINT_256_HIGH_MAX),\n/* harmony export */   UINT_256_HIGH_MIN: () => (/* binding */ UINT_256_HIGH_MIN),\n/* harmony export */   UINT_256_LOW_MAX: () => (/* binding */ UINT_256_LOW_MAX),\n/* harmony export */   UINT_256_LOW_MIN: () => (/* binding */ UINT_256_LOW_MIN),\n/* harmony export */   UINT_256_MAX: () => (/* binding */ UINT_256_MAX),\n/* harmony export */   UINT_256_MIN: () => (/* binding */ UINT_256_MIN),\n/* harmony export */   UINT_512_MAX: () => (/* binding */ UINT_512_MAX),\n/* harmony export */   UINT_512_MIN: () => (/* binding */ UINT_512_MIN),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   WalletAccount: () => (/* binding */ WalletAccount),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   byteArray: () => (/* binding */ byteArray_exports),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   eth: () => (/* binding */ eth_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseCalldataField: () => (/* binding */ parseCalldataField),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   v2hash: () => (/* binding */ v2_exports),\n/* harmony export */   v3hash: () => (/* binding */ v3_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress),\n/* harmony export */   wallet: () => (/* binding */ connect_exports)\n/* harmony export */ });\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet-types-07 */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! starknet-types-07 */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! starknet-types-07 */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @scure/starknet */ \"(app-pages-browser)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lossless-json */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pako */ \"(app-pages-browser)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var fetch_cookie__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! fetch-cookie */ \"(app-pages-browser)/./node_modules/fetch-cookie/esm/index.js\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! isomorphic-fetch */ \"(app-pages-browser)/./node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\n/* harmony import */ var ts_mixer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ts-mixer */ \"(app-pages-browser)/./node_modules/ts-mixer/dist/esm/index.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! url-join */ \"(app-pages-browser)/./node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  ADDR_BOUND: () => ADDR_BOUND,\n  API_VERSION: () => API_VERSION,\n  BaseUrl: () => BaseUrl,\n  FeeMarginPercentage: () => FeeMarginPercentage,\n  IS_BROWSER: () => IS_BROWSER,\n  MASK_250: () => MASK_250,\n  MAX_STORAGE_ITEM_SIZE: () => MAX_STORAGE_ITEM_SIZE,\n  NetworkName: () => NetworkName,\n  PRIME: () => PRIME,\n  RANGE_FELT: () => RANGE_FELT,\n  RANGE_I128: () => RANGE_I128,\n  RANGE_U128: () => RANGE_U128,\n  RPC_DEFAULT_VERSION: () => RPC_DEFAULT_VERSION,\n  RPC_NODES: () => RPC_NODES,\n  StarknetChainId: () => StarknetChainId,\n  TEXT_TO_FELT_MAX_LEN: () => TEXT_TO_FELT_MAX_LEN,\n  TRANSACTION_VERSION: () => api_exports.ETransactionVersion,\n  TransactionHashPrefix: () => TransactionHashPrefix,\n  UDC: () => UDC,\n  ZERO: () => ZERO\n});\n\n// src/types/api/index.ts\nvar api_exports = {};\n__export(api_exports, {\n  JRPC: () => jsonrpc_exports,\n  RPCSPEC06: () => rpcspec_0_6_exports,\n  RPCSPEC07: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_0__\n});\n\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n\n// src/types/api/rpcspec_0_6/index.ts\nvar rpcspec_0_6_exports = {};\n__export(rpcspec_0_6_exports, {\n  EBlockTag: () => EBlockTag,\n  EDAMode: () => EDAMode,\n  EDataAvailabilityMode: () => EDataAvailabilityMode,\n  ESimulationFlag: () => ESimulationFlag,\n  ETransactionExecutionStatus: () => ETransactionExecutionStatus,\n  ETransactionFinalityStatus: () => ETransactionFinalityStatus,\n  ETransactionStatus: () => ETransactionStatus,\n  ETransactionType: () => ETransactionType,\n  ETransactionVersion: () => ETransactionVersion,\n  ETransactionVersion2: () => ETransactionVersion2,\n  ETransactionVersion3: () => ETransactionVersion3,\n  Errors: () => errors_exports,\n  SPEC: () => components_exports\n});\n\n// src/types/api/rpcspec_0_6/errors.ts\nvar errors_exports = {};\n\n// src/types/api/rpcspec_0_6/components.ts\nvar components_exports = {};\n\n// src/types/api/rpcspec_0_6/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2) => {\n  ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n  ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n  ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2) => {\n  ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n  ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n  return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2) => {\n  ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2) => {\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2) => {\n  ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2) => {\n  EBlockTag2[\"PENDING\"] = \"pending\";\n  EBlockTag2[\"LATEST\"] = \"latest\";\n  return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode3) => {\n  EDataAvailabilityMode3[\"L1\"] = \"L1\";\n  EDataAvailabilityMode3[\"L2\"] = \"L2\";\n  return EDataAvailabilityMode3;\n})(EDataAvailabilityMode || {});\nvar EDAMode = /* @__PURE__ */ ((EDAMode4) => {\n  EDAMode4[EDAMode4[\"L1\"] = 0] = \"L1\";\n  EDAMode4[EDAMode4[\"L2\"] = 1] = \"L2\";\n  return EDAMode4;\n})(EDAMode || {});\nvar ETransactionVersion = /* @__PURE__ */ ((ETransactionVersion10) => {\n  ETransactionVersion10[\"V0\"] = \"0x0\";\n  ETransactionVersion10[\"V1\"] = \"0x1\";\n  ETransactionVersion10[\"V2\"] = \"0x2\";\n  ETransactionVersion10[\"V3\"] = \"0x3\";\n  ETransactionVersion10[\"F0\"] = \"0x100000000000000000000000000000000\";\n  ETransactionVersion10[\"F1\"] = \"0x100000000000000000000000000000001\";\n  ETransactionVersion10[\"F2\"] = \"0x100000000000000000000000000000002\";\n  ETransactionVersion10[\"F3\"] = \"0x100000000000000000000000000000003\";\n  return ETransactionVersion10;\n})(ETransactionVersion || {});\nvar ETransactionVersion2 = /* @__PURE__ */ ((ETransactionVersion25) => {\n  ETransactionVersion25[\"V0\"] = \"0x0\";\n  ETransactionVersion25[\"V1\"] = \"0x1\";\n  ETransactionVersion25[\"V2\"] = \"0x2\";\n  ETransactionVersion25[\"F0\"] = \"0x100000000000000000000000000000000\";\n  ETransactionVersion25[\"F1\"] = \"0x100000000000000000000000000000001\";\n  ETransactionVersion25[\"F2\"] = \"0x100000000000000000000000000000002\";\n  return ETransactionVersion25;\n})(ETransactionVersion2 || {});\nvar ETransactionVersion3 = /* @__PURE__ */ ((ETransactionVersion36) => {\n  ETransactionVersion36[\"V3\"] = \"0x3\";\n  ETransactionVersion36[\"F3\"] = \"0x100000000000000000000000000000003\";\n  return ETransactionVersion36;\n})(ETransactionVersion3 || {});\n\n// src/types/api/index.ts\n__reExport(api_exports, starknet_types_07__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n  IS_BROWSER: () => IS_BROWSER,\n  addHexPrefix: () => addHexPrefix,\n  arrayBufferToString: () => arrayBufferToString,\n  atobUniversal: () => atobUniversal,\n  btoaUniversal: () => btoaUniversal,\n  buf2hex: () => buf2hex,\n  calcByteLength: () => calcByteLength,\n  padLeft: () => padLeft,\n  pascalToSnake: () => pascalToSnake,\n  removeHexPrefix: () => removeHexPrefix,\n  sanitizeBytes: () => sanitizeBytes,\n  sanitizeHex: () => sanitizeHex,\n  stringToArrayBuffer: () => stringToArrayBuffer,\n  utf8ToArray: () => utf8ToArray\n});\n\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n  return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n  return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n  return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n  return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n  return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n  return hex;\n}\nvar pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar API_VERSION = ZERO;\nvar PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar range = (min, max) => ({ min, max });\nvar RANGE_FELT = range(ZERO, PRIME - 1n);\nvar RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\nvar RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2) => {\n  BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n  BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n  return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n  NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n  return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId6) => {\n  StarknetChainId6[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n  StarknetChainId6[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n  return StarknetChainId6;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2) => {\n  TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n  TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n  TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n  TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n  TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n  return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar FeeMarginPercentage = /* @__PURE__ */ ((FeeMarginPercentage2) => {\n  FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_AMOUNT\"] = 50] = \"L1_BOUND_MAX_AMOUNT\";\n  FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_PRICE_PER_UNIT\"] = 50] = \"L1_BOUND_MAX_PRICE_PER_UNIT\";\n  FeeMarginPercentage2[FeeMarginPercentage2[\"MAX_FEE\"] = 50] = \"MAX_FEE\";\n  return FeeMarginPercentage2;\n})(FeeMarginPercentage || {});\nvar UDC = {\n  ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n  ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_7\";\nvar RPC_NODES = {\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`\n  ]\n};\n\n// src/provider/rpc.ts\n\n\n\n// src/channel/rpc_0_6.ts\nvar rpc_0_6_exports = {};\n__export(rpc_0_6_exports, {\n  RpcChannel: () => RpcChannel\n});\n\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n  const { captureStackTrace } = Error;\n  captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n  const { setPrototypeOf } = Object;\n  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n  name;\n  constructor(message) {\n    super(message);\n    Object.defineProperty(this, \"name\", {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n    fixProto(this, new.target.prototype);\n    fixStack(this);\n  }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\nvar HttpError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\n\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n  BlockStatus: () => BlockStatus,\n  BlockTag: () => BlockTag,\n  EntryPointType: () => EntryPointType,\n  Literal: () => Literal,\n  RPC: () => api_exports,\n  TransactionExecutionStatus: () => TransactionExecutionStatus,\n  TransactionFinalityStatus: () => TransactionFinalityStatus,\n  TransactionStatus: () => TransactionStatus,\n  TransactionType: () => TransactionType,\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n  Uint: () => Uint,\n  ValidateType: () => ValidateType\n});\n\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2) => {\n  ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n  ValidateType2[\"CALL\"] = \"CALL\";\n  ValidateType2[\"INVOKE\"] = \"INVOKE\";\n  return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2) => {\n  Uint2[\"u8\"] = \"core::integer::u8\";\n  Uint2[\"u16\"] = \"core::integer::u16\";\n  Uint2[\"u32\"] = \"core::integer::u32\";\n  Uint2[\"u64\"] = \"core::integer::u64\";\n  Uint2[\"u128\"] = \"core::integer::u128\";\n  Uint2[\"u256\"] = \"core::integer::u256\";\n  Uint2[\"u512\"] = \"core::integer::u512\";\n  return Uint2;\n})(Uint || {});\nvar Literal = /* @__PURE__ */ ((Literal2) => {\n  Literal2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n  Literal2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n  Literal2[\"Secp256k1Point\"] = \"core::starknet::secp256k1::Secp256k1Point\";\n  return Literal2;\n})(Literal || {});\n\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2) => {\n  EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n  EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n  return EntryPointType2;\n})(EntryPointType || {});\n\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2) => {\n  TransactionType2[\"DECLARE\"] = \"DECLARE\";\n  TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n  return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {\n  TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2) => {\n  TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2) => {\n  TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2) => {\n  BlockStatus2[\"PENDING\"] = \"PENDING\";\n  BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n  return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2) => {\n  BlockTag2[\"PENDING\"] = \"pending\";\n  BlockTag2[\"LATEST\"] = \"latest\";\n  return BlockTag2;\n})(BlockTag || {});\n\n// src/types/typedData.ts\n\n\n// src/utils/assert.ts\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failure\");\n  }\n}\n\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n  addPercent: () => addPercent,\n  assertInRange: () => assertInRange,\n  bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,\n  cleanHex: () => cleanHex,\n  getDecimalString: () => getDecimalString,\n  getHexString: () => getHexString,\n  getHexStringArray: () => getHexStringArray,\n  hexToBytes: () => hexToBytes,\n  hexToDecimalString: () => hexToDecimalString,\n  isBigInt: () => isBigInt,\n  isBoolean: () => isBoolean,\n  isHex: () => isHex,\n  isNumber: () => isNumber,\n  isStringWholeNumber: () => isStringWholeNumber,\n  toBigInt: () => toBigInt,\n  toCairoBool: () => toCairoBool,\n  toHex: () => toHex,\n  toHexString: () => toHexString,\n  toStorageKey: () => toStorageKey\n});\n\nfunction isHex(hex) {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n  return BigInt(value);\n}\nfunction isBigInt(value) {\n  return typeof value === \"bigint\";\n}\nfunction toHex(value) {\n  return addHexPrefix(toBigInt(value).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n  return addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n}\nfunction hexToDecimalString(hex) {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\nfunction cleanHex(hex) {\n  return hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\n}\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n  const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\nfunction bigNumberishArrayToDecimalStringArray(data) {\n  return data.map((x) => toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(data) {\n  return data.map((x) => toHex(x));\n}\nfunction isStringWholeNumber(str) {\n  return /^\\d+$/.test(str);\n}\nfunction getDecimalString(str) {\n  if (isHex(str)) {\n    return hexToDecimalString(str);\n  }\n  if (isStringWholeNumber(str)) {\n    return str;\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexString(str) {\n  if (isHex(str)) {\n    return str;\n  }\n  if (isStringWholeNumber(str)) {\n    return toHexString(str);\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexStringArray(array) {\n  return array.map(getHexString);\n}\nfunction toCairoBool(value) {\n  return (+value).toString();\n}\nfunction hexToBytes(str) {\n  if (!isHex(str))\n    throw new Error(`${str} needs to be a hex-string`);\n  let adaptedValue = removeHexPrefix(str);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(adaptedValue);\n}\nfunction addPercent(number2, percent) {\n  const bigIntNum = BigInt(number2);\n  return bigIntNum + bigIntNum * BigInt(percent) / 100n;\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\n\n// src/utils/hash/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  keccakBn: () => keccakBn,\n  starknetKeccak: () => starknetKeccak\n});\n\nfunction keccakBn(value) {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n  const hash = BigInt(keccakHex(str));\n  return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n  return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  return getSelectorFromName(value);\n}\n\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n  decodeShortString: () => decodeShortString,\n  encodeShortString: () => encodeShortString,\n  isASCII: () => isASCII,\n  isDecimalString: () => isDecimalString,\n  isLongText: () => isLongText,\n  isShortString: () => isShortString,\n  isShortText: () => isShortText,\n  isString: () => isString,\n  isText: () => isText,\n  splitLongString: () => splitLongString\n});\nfunction isASCII(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n  return /^[0-9]*$/i.test(str);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isText(val) {\n  return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val) => isText(val) && isShortString(val);\nvar isLongText = (val) => isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n  return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n  if (!isASCII(str))\n    throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str))\n    throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n  if (!isASCII(str))\n    throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n\n// src/utils/calldata/byteArray.ts\nvar byteArray_exports = {};\n__export(byteArray_exports, {\n  byteArrayFromString: () => byteArrayFromString,\n  stringFromByteArray: () => stringFromByteArray\n});\nfunction stringFromByteArray(myByteArray) {\n  const pending_word = BigInt(myByteArray.pending_word) === 0n ? \"\" : decodeShortString(toHex(myByteArray.pending_word));\n  return myByteArray.data.reduce((cumuledString, encodedString) => {\n    const add = BigInt(encodedString) === 0n ? \"\" : decodeShortString(toHex(encodedString));\n    return cumuledString + add;\n  }, \"\") + pending_word;\n}\nfunction byteArrayFromString(targetString) {\n  const shortStrings = splitLongString(targetString);\n  const remainder = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded = shortStrings.map(encodeShortString);\n  const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\"0x00\", 0] : [shortStringsEncoded.pop(), remainder.length];\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength\n  };\n}\n\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n  felt: () => felt,\n  getAbiContractVersion: () => getAbiContractVersion,\n  getArrayType: () => getArrayType,\n  isCairo1Abi: () => isCairo1Abi,\n  isCairo1Type: () => isCairo1Type,\n  isLen: () => isLen,\n  isTypeArray: () => isTypeArray,\n  isTypeBool: () => isTypeBool,\n  isTypeByteArray: () => isTypeByteArray,\n  isTypeBytes31: () => isTypeBytes31,\n  isTypeContractAddress: () => isTypeContractAddress,\n  isTypeEnum: () => isTypeEnum,\n  isTypeEthAddress: () => isTypeEthAddress,\n  isTypeFelt: () => isTypeFelt,\n  isTypeLiteral: () => isTypeLiteral,\n  isTypeNamedTuple: () => isTypeNamedTuple,\n  isTypeNonZero: () => isTypeNonZero,\n  isTypeOption: () => isTypeOption,\n  isTypeResult: () => isTypeResult,\n  isTypeSecp256k1Point: () => isTypeSecp256k1Point,\n  isTypeStruct: () => isTypeStruct,\n  isTypeTuple: () => isTypeTuple,\n  isTypeUint: () => isTypeUint,\n  isTypeUint256: () => isTypeUint256,\n  tuple: () => tuple,\n  uint256: () => uint256,\n  uint512: () => uint512\n});\n\n// src/utils/cairoDataTypes/felt.ts\nfunction CairoFelt(it) {\n  if (isBigInt(it) || Number.isInteger(it)) {\n    return it.toString();\n  }\n  if (isString(it)) {\n    if (isHex(it)) {\n      return BigInt(it).toString();\n    }\n    if (isText(it)) {\n      if (!isShortString(it)) {\n        throw new Error(\n          `${it} is a long string > 31 chars. Please split it into an array of short strings.`\n        );\n      }\n      return BigInt(encodeShortString(it)).toString();\n    }\n    if (isStringWholeNumber(it)) {\n      return it;\n    }\n  }\n  if (isBoolean(it)) {\n    return `${+it}`;\n  }\n  throw new Error(`${it} can't be computed by felt()`);\n}\n\n// src/utils/cairoDataTypes/uint256.ts\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nvar UINT_256_MIN = 0n;\nvar UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_LOW_MIN = 0n;\nvar UINT_256_HIGH_MIN = 0n;\nvar CairoUint256 = class _CairoUint256 {\n  low;\n  high;\n  static abiSelector = \"core::integer::u256\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"low\" in arr[0] && \"high\" in arr[0]) {\n      const props = _CairoUint256.validateProps(arr[0].low, arr[0].high);\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = _CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error(\"Incorrect constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_256_MIN)\n      throw Error(\"bigNumberish is smaller than UINT_256_MIN\");\n    if (bigInt > UINT_256_MAX)\n      throw new Error(\"bigNumberish is bigger than UINT_256_MAX\");\n    return bigInt;\n  }\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low, high) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n      throw new Error(\"low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX\");\n    }\n    if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n      throw new Error(\"high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX\");\n    }\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint256.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16))\n    };\n  }\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n};\n\n// src/utils/cairoDataTypes/uint512.ts\nvar UINT_512_MAX = (1n << 512n) - 1n;\nvar UINT_512_MIN = 0n;\nvar UINT_128_MIN = 0n;\nvar CairoUint512 = class _CairoUint512 {\n  limb0;\n  limb1;\n  limb2;\n  limb3;\n  static abiSelector = \"core::integer::u512\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"limb0\" in arr[0] && \"limb1\" in arr[0] && \"limb2\" in arr[0] && \"limb3\" in arr[0]) {\n      const props = _CairoUint512.validateProps(\n        arr[0].limb0,\n        arr[0].limb1,\n        arr[0].limb2,\n        arr[0].limb3\n      );\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint512.validate(arr[0]);\n      this.limb0 = bigInt & UINT_128_MAX;\n      this.limb1 = (bigInt & UINT_128_MAX << 128n) >> 128n;\n      this.limb2 = (bigInt & UINT_128_MAX << 256n) >> 256n;\n      this.limb3 = bigInt >> 384n;\n    } else if (arr.length === 4) {\n      const props = _CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else {\n      throw Error(\"Incorrect Uint512 constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Uint512\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_512_MIN)\n      throw Error(\"bigNumberish is smaller than UINT_512_MIN.\");\n    if (bigInt > UINT_512_MAX)\n      throw Error(\"bigNumberish is bigger than UINT_512_MAX.\");\n    return bigInt;\n  }\n  /**\n   * Validate if limbs can be represented as Uint512\n   */\n  static validateProps(limb0, limb1, limb2, limb3) {\n    const l0 = BigInt(limb0);\n    const l1 = BigInt(limb1);\n    const l2 = BigInt(limb2);\n    const l3 = BigInt(limb3);\n    [l0, l1, l2, l3].forEach((value, index) => {\n      if (value < UINT_128_MIN || value > UINT_128_MAX) {\n        throw Error(`limb${index} is not in the range of a u128 number`);\n      }\n    });\n    return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };\n  }\n  /**\n   * Check if BigNumberish can be represented as Uint512\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint512.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint512.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n  }\n  /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */\n  toUint512HexString() {\n    return {\n      limb0: addHexPrefix(this.limb0.toString(16)),\n      limb1: addHexPrefix(this.limb1.toString(16)),\n      limb2: addHexPrefix(this.limb2.toString(16)),\n      limb3: addHexPrefix(this.limb3.toString(16))\n    };\n  }\n  /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */\n  toUint512DecimalString() {\n    return {\n      limb0: this.limb0.toString(10),\n      limb1: this.limb1.toString(10),\n      limb2: this.limb2.toString(10),\n      limb3: this.limb3.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [\n      CairoFelt(this.limb0),\n      CairoFelt(this.limb1),\n      CairoFelt(this.limb2),\n      CairoFelt(this.limb3)\n    ];\n  }\n};\n\n// src/utils/calldata/cairo.ts\nvar isLen = (name) => /_len$/.test(name);\nvar isTypeFelt = (type) => type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type) => /\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type) => /^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type) => /\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs) => type in structs;\nvar isTypeEnum = (type, enums) => type in enums;\nvar isTypeOption = (type) => type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type) => type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type) => Object.values(Uint).includes(type);\nvar isTypeUint256 = (type) => CairoUint256.isAbiType(type);\nvar isTypeLiteral = (type) => Object.values(Literal).includes(type);\nvar isTypeBool = (type) => type === \"core::bool\";\nvar isTypeContractAddress = (type) => type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type) => type === \"core::starknet::eth_address::EthAddress\";\nvar isTypeBytes31 = (type) => type === \"core::bytes_31::bytes31\";\nvar isTypeByteArray = (type) => type === \"core::byte_array::ByteArray\";\nvar isTypeSecp256k1Point = (type) => type === \"core::starknet::secp256k1::Secp256k1Point\";\nvar isCairo1Type = (type) => type.includes(\"::\");\nvar getArrayType = (type) => {\n  if (isCairo1Type(type)) {\n    return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n  }\n  return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === void 0) {\n    throw Error(\"Unable to determine Cairo version\");\n  }\n  return cairo === \"1\";\n}\nfunction isTypeNonZero(type) {\n  return type.startsWith(\"core::zeroable::NonZero::\");\n}\nfunction getAbiContractVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\")) {\n    return { cairo: \"1\", compiler: \"2\" };\n  }\n  const testFunction = abi.find(\n    (it) => it.type === \"function\" && (it.inputs.length || it.outputs.length)\n  );\n  if (!testFunction) {\n    return { cairo: void 0, compiler: void 0 };\n  }\n  const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: \"1\", compiler: \"1\" };\n  }\n  return { cairo: \"0\", compiler: \"0\" };\n}\nvar uint256 = (it) => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\nvar uint512 = (it) => {\n  return new CairoUint512(it).toUint512DecimalString();\n};\nvar tuple = (...args) => ({ ...args });\nfunction felt(it) {\n  return CairoFelt(it);\n}\n\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  variant;\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error(\"This Enum must have at least 1 variant\");\n    }\n    const nbActiveVariants = variantsList.filter(\n      (content) => typeof content !== \"undefined\"\n    ).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error(\"This Enum must have exactly one active variant\");\n    }\n    this.variant = enumContent;\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  unwrap() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return void 0;\n    }\n    return activeVariant[1];\n  }\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  activeVariant() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return \"\";\n    }\n    return activeVariant[0];\n  }\n};\n\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2) => {\n  CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n  CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n  return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n  Some;\n  None;\n  constructor(variant, someContent) {\n    if (!(variant in CairoOptionVariant)) {\n      throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n    }\n    if (variant === 0 /* Some */) {\n      if (typeof someContent === \"undefined\") {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = someContent;\n      this.None = void 0;\n    } else {\n      this.Some = void 0;\n      this.None = true;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  unwrap() {\n    if (this.None) {\n      return void 0;\n    }\n    return this.Some;\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  isSome() {\n    return !(typeof this.Some === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  isNone() {\n    return this.None === true;\n  }\n};\n\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2) => {\n  CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n  CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n  return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n  Ok;\n  Err;\n  constructor(variant, resultContent) {\n    if (!(variant in CairoResultVariant)) {\n      throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n    }\n    if (variant === 0 /* Ok */) {\n      this.Ok = resultContent;\n      this.Err = void 0;\n    } else {\n      this.Ok = void 0;\n      this.Err = resultContent;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  unwrap() {\n    if (typeof this.Ok !== \"undefined\") {\n      return this.Ok;\n    }\n    if (typeof this.Err !== \"undefined\") {\n      return this.Err;\n    }\n    throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  isOk() {\n    return !(typeof this.Ok === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  isErr() {\n    return !(typeof this.Err === \"undefined\");\n  }\n};\n\n// src/utils/calldata/formatter.ts\nvar guard = {\n  isBN: (data, type, key) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  unknown: (data, type, key) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  }\n};\nfunction formatter(data, type, sameType) {\n  return Object.entries(data).reduce(\n    (acc, [key, value]) => {\n      const elType = sameType ?? type[key];\n      if (!(key in type) && !sameType) {\n        acc[key] = value;\n        return acc;\n      }\n      if (elType === \"string\") {\n        if (Array.isArray(data[key])) {\n          const arrayStr = formatter(\n            data[key],\n            data[key].map((_) => elType)\n          );\n          acc[key] = Object.values(arrayStr).join(\"\");\n          return acc;\n        }\n        guard.isBN(data, type, key);\n        acc[key] = decodeShortString(value);\n        return acc;\n      }\n      if (elType === \"number\") {\n        guard.isBN(data, type, key);\n        acc[key] = Number(value);\n        return acc;\n      }\n      if (typeof elType === \"function\") {\n        acc[key] = elType(value);\n        return acc;\n      }\n      if (Array.isArray(elType)) {\n        const arrayObj = formatter(data[key], elType, elType[0]);\n        acc[key] = Object.values(arrayObj);\n        return acc;\n      }\n      if (typeof elType === \"object\") {\n        acc[key] = formatter(data[key], elType);\n        return acc;\n      }\n      guard.unknown(data, type, key);\n      return acc;\n    },\n    {}\n  );\n}\n\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    return this.abi.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi;\n  }\n};\n\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.length;\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    const intf = this.abi.find(\n      (it) => it.type === \"interface\"\n    );\n    return intf.items.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi.flatMap((e) => {\n      if (e.type === \"interface\") {\n        return e.items;\n      }\n      return e;\n    });\n  }\n};\n\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\"))\n    return 2;\n  if (isCairo1Abi(abi))\n    return 1;\n  return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n  return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n  const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n  const type = namedTuple.substring(name.length + \":\".length);\n  return { name, type };\n}\nfunction parseSubTuple(s) {\n  if (!s.includes(\"(\"))\n    return { subTuple: [], result: s };\n  const subTuple = [];\n  let result = \"\";\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === \"(\") {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === \")\")\n          counter--;\n        if (s[i] === \"(\")\n          counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += \" \";\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n  return {\n    subTuple,\n    result\n  };\n}\nfunction extractCairo0Tuple(type) {\n  const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n  const { subTuple, result } = parseSubTuple(cleanType);\n  let recomposed = result.split(\",\").map((it) => {\n    return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n  });\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n  return recomposed;\n}\nfunction getClosureOffset(input, open, close) {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\nfunction extractCairo1Tuple(type) {\n  const input = type.slice(1, -1);\n  const result = [];\n  let currentIndex = 0;\n  let limitIndex;\n  while (currentIndex < input.length) {\n    switch (true) {\n      case input[currentIndex] === \"(\": {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"(\", \")\") + 1;\n        break;\n      }\n      case (input.startsWith(\"core::result::Result::<\", currentIndex) || input.startsWith(\"core::array::Array::<\", currentIndex) || input.startsWith(\"core::option::Option::<\", currentIndex)): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"<\", \">\") + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(\",\", currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2;\n  }\n  return result;\n}\nfunction extractTupleMemberTypes(type) {\n  if (isCairo1Type(type)) {\n    return extractCairo1Tuple(type);\n  }\n  return extractCairo0Tuple(type);\n}\n\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\nfunction errorU512(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`\n  );\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n  const orderInput = (unorderedItem, abiType) => {\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeNonZero(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeByteArray(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeSecp256k1Point(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== \"object\") {\n        return u256;\n      }\n      if (!(\"low\" in u256 && \"high\" in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (CairoUint512.isAbiType(abiType)) {\n      const u512 = unorderedItem;\n      if (typeof u512 !== \"object\") {\n        return u512;\n      }\n      if (![\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in u512)) {\n        throw errorU512(abiType);\n      }\n      return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    return unorderedItem;\n  };\n  const orderStruct = (unorderedObject2, abiObject) => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value: value ?? unorderedObject2[abiParam.name]\n      });\n      if (unorderedObject2[abiParam.name] === \"undefined\") {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n  function orderArray(myArray, abiParam) {\n    const typeInArray = getArrayType(abiParam);\n    if (isString(myArray)) {\n      return myArray;\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n  function orderTuple(unorderedObject2, abiParam) {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index) => {\n      const myObjKeys = Object.keys(unorderedObject2);\n      const setProperty = (value) => Object.defineProperty(orderedObject, index.toString(), {\n        enumerable: true,\n        value: value ?? unorderedObject2[myObjKeys[index]]\n      });\n      const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n  const orderEnum = (unorderedObject2, abiObject) => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2;\n      const resultOkType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\",\")\n      );\n      const resultErrType = abiObject.name.substring(\n        abiObject.name.indexOf(\",\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult(\n          0 /* Ok */,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult(\n        1 /* Err */,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2;\n      const resultSomeType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption(\n          0 /* Some */,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      return new CairoOption(1 /* None */, {});\n    }\n    const unorderedCustomEnum = unorderedObject2;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (typeof variant[1] === \"undefined\") {\n        return variant;\n      }\n      const variantType = abiObject.type.substring(\n        abiObject.type.lastIndexOf(\"<\") + 1,\n        abiObject.type.lastIndexOf(\">\")\n      );\n      if (variantType === \"()\") {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n      enumerable: true,\n      value\n    });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return new CairoUint256(val).toApiRequest();\n    case CairoUint512.isAbiType(type):\n      return new CairoUint512(val).toApiRequest();\n    case isTypeBytes31(type):\n      return encodeShortString(val.toString());\n    case isTypeSecp256k1Point(type): {\n      const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, \"0\");\n      const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n      const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n      return [\n        felt(pubKeyETHx.low),\n        felt(pubKeyETHx.high),\n        felt(pubKeyETHy.low),\n        felt(pubKeyETHy.high)\n      ];\n    }\n    default:\n      return felt(val);\n  }\n}\nfunction parseTuple(element, typeStr) {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`\n    );\n  }\n  return memberTypes.map((it, dx) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it\n    };\n  });\n}\nfunction parseByteArray(element) {\n  const myByteArray = byteArrayFromString(element);\n  return [\n    myByteArray.data.length.toString(),\n    ...myByteArray.data.map((bn) => bn.toString()),\n    myByteArray.pending_word.toString(),\n    myByteArray.pending_word_len.toString()\n  ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n  if (element === void 0) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n  if (Array.isArray(element)) {\n    const result = [];\n    result.push(felt(element.length));\n    const arrayType = getArrayType(type);\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n  if (structs[type] && structs[type].members.length) {\n    if (CairoUint256.isAbiType(type)) {\n      return new CairoUint256(element).toApiRequest();\n    }\n    if (CairoUint512.isAbiType(type)) {\n      return new CairoUint512(element).toApiRequest();\n    }\n    if (type === \"core::starknet::eth_address::EthAddress\")\n      return parseBaseTypes(type, element);\n    if (type === \"core::byte_array::ByteArray\")\n      return parseByteArray(element);\n    const { members } = structs[type];\n    const subElement = element;\n    return members.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, []);\n  }\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element, type);\n    return tupled.reduce((acc, it) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, []);\n  }\n  if (CairoUint256.isAbiType(type)) {\n    return new CairoUint256(element).toApiRequest();\n  }\n  if (CairoUint512.isAbiType(type)) {\n    return new CairoUint512(element).toApiRequest();\n  }\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    if (isTypeOption(type)) {\n      const myOption = element;\n      if (myOption.isSome()) {\n        const listTypeVariant2 = variants.find((variant) => variant.name === \"Some\");\n        if (typeof listTypeVariant2 === \"undefined\") {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant2.type;\n        if (typeVariantSome === \"()\") {\n          return 0 /* Some */.toString();\n        }\n        const parsedParameter2 = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter2)) {\n          return [0 /* Some */.toString(), ...parsedParameter2];\n        }\n        return [0 /* Some */.toString(), parsedParameter2];\n      }\n      return 1 /* None */.toString();\n    }\n    if (isTypeResult(type)) {\n      const myResult = element;\n      if (myResult.isOk()) {\n        const listTypeVariant3 = variants.find((variant) => variant.name === \"Ok\");\n        if (typeof listTypeVariant3 === \"undefined\") {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant3.type;\n        if (typeVariantOk === \"()\") {\n          return 0 /* Ok */.toString();\n        }\n        const parsedParameter3 = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter3)) {\n          return [0 /* Ok */.toString(), ...parsedParameter3];\n        }\n        return [0 /* Ok */.toString(), parsedParameter3];\n      }\n      const listTypeVariant2 = variants.find((variant) => variant.name === \"Err\");\n      if (typeof listTypeVariant2 === \"undefined\") {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant2.type;\n      if (typeVariantErr === \"()\") {\n        return 1 /* Err */.toString();\n      }\n      const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter2)) {\n        return [1 /* Err */.toString(), ...parsedParameter2];\n      }\n      return [1 /* Err */.toString(), parsedParameter2];\n    }\n    const myEnum = element;\n    const activeVariant = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (typeof listTypeVariant === \"undefined\") {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);\n    if (typeActiveVariant === \"()\") {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n  if (isTypeNonZero(type)) {\n    return parseBaseTypes(getArrayType(type), element);\n  }\n  if (typeof element === \"object\") {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n  switch (true) {\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (isString(value)) {\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    case isTypeNonZero(type):\n      return parseBaseTypes(getArrayType(type), value);\n    case type === \"core::starknet::eth_address::EthAddress\":\n      return parseBaseTypes(type, value);\n    case (isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type) || CairoUint256.isAbiType(type)):\n      return parseCalldataValue(value, type, structs, enums);\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value,\n        type,\n        structs,\n        enums\n      );\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return new CairoUint256(low, high).toBigInt();\n    case CairoUint512.isAbiType(type):\n      const limb0 = it.next().value;\n      const limb1 = it.next().value;\n      const limb2 = it.next().value;\n      const limb3 = it.next().value;\n      return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n    case type === \"core::starknet::eth_address::EthAddress\":\n      temp = it.next().value;\n      return BigInt(temp);\n    case type === \"core::bytes_31::bytes31\":\n      temp = it.next().value;\n      return decodeShortString(temp);\n    case isTypeSecp256k1Point(type):\n      const xLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const xHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n      return pubK;\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n  if (element.type === \"()\") {\n    return {};\n  }\n  if (CairoUint256.isAbiType(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return new CairoUint256(low, high).toBigInt();\n  }\n  if (CairoUint512.isAbiType(element.type)) {\n    const limb0 = responseIterator.next().value;\n    const limb1 = responseIterator.next().value;\n    const limb2 = responseIterator.next().value;\n    const limb3 = responseIterator.next().value;\n    return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n  }\n  if (isTypeByteArray(element.type)) {\n    const parsedBytes31Arr = [];\n    const bytes31ArrLen = BigInt(responseIterator.next().value);\n    while (parsedBytes31Arr.length < bytes31ArrLen) {\n      parsedBytes31Arr.push(toHex(responseIterator.next().value));\n    }\n    const pending_word = toHex(responseIterator.next().value);\n    const pending_word_len = BigInt(responseIterator.next().value);\n    const myByteArray = {\n      data: parsedBytes31Arr,\n      pending_word,\n      pending_word_len\n    };\n    return stringFromByteArray(myByteArray);\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  if (isTypeNonZero(element.type)) {\n    const el = { name: \"\", type: getArrayType(element.type) };\n    return parseResponseValue(responseIterator, el, structs, enums);\n  }\n  if (structs && element.type in structs && structs[element.type]) {\n    if (element.type === \"core::starknet::eth_address::EthAddress\") {\n      return parseBaseTypes2(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum = Number(responseIterator.next().value);\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: \"\", type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = void 0;\n      return acc;\n    }, {});\n    if (element.type.startsWith(\"core::option::Option\")) {\n      const content = variantNum === 0 /* Some */ ? rawEnum.Some : void 0;\n      return new CairoOption(variantNum, content);\n    }\n    if (element.type.startsWith(\"core::result::Result\")) {\n      let content;\n      if (variantNum === 0 /* Ok */) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult(variantNum, content);\n    }\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n  const { name, type } = output;\n  let temp;\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n    case (structs && type in structs || isTypeTuple(type)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case (enums && isTypeEnum(type, enums)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case isTypeArray(type):\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      const parsedDataArr = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`];\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace(\"*\", \"\") },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n    case isTypeNonZero(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    default:\n      return parseBaseTypes2(type, responseIterator);\n  }\n}\n\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input) => {\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter),\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (isString(parameter) && !isHex(parameter))\n    return;\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\nvar validateBytes31 = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n  assert(\n    parameter.length < 32,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`\n  );\n};\nvar validateByteArray = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n};\nvar validateUint = (parameter, input) => {\n  if (isNumber(parameter)) {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      `Validation: Parameter is to large to be typed as Number use (BigInt or String)`\n    );\n  }\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter) || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter || typeof parameter === \"object\" && [\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  let param;\n  switch (input.type) {\n    case \"core::integer::u256\" /* u256 */:\n      param = new CairoUint256(parameter).toBigInt();\n      break;\n    case \"core::integer::u512\" /* u512 */:\n      param = new CairoUint512(parameter).toBigInt();\n      break;\n    default:\n      param = toBigInt(parameter);\n  }\n  switch (input.type) {\n    case \"core::integer::u8\" /* u8 */:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n    case \"core::integer::u16\" /* u16 */:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n    case \"core::integer::u32\" /* u32 */:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n    case \"core::integer::u64\" /* u64 */:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n    case \"core::integer::u128\" /* u128 */:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n    case \"core::integer::u256\" /* u256 */:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`\n      );\n      break;\n    case \"core::integer::u512\" /* u512 */:\n      assert(CairoUint512.is(param), `Validate: arg ${input.name} is ${input.type} 0 - 2^512-1`);\n      break;\n    case \"core::starknet::class_hash::ClassHash\" /* ClassHash */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case \"core::starknet::secp256k1::Secp256k1Point\" /* Secp256k1Point */: {\n      assert(\n        param >= 0n && param <= 2n ** 512n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`\n      );\n      break;\n    }\n    default:\n      break;\n  }\n};\nvar validateBool = (parameter, input) => {\n  assert(\n    isBoolean(parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\nvar validateStruct = (parameter, input, structs) => {\n  if (input.type === \"core::integer::u256\" /* u256 */ || input.type === \"core::integer::u512\" /* u512 */) {\n    validateUint(parameter, input);\n    return;\n  }\n  if (input.type === \"core::starknet::eth_address::EthAddress\") {\n    assert(\n      typeof parameter !== \"object\",\n      `EthAddress type is waiting a BigNumberish. Got ${parameter}`\n    );\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`\n  );\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\nvar validateEnum = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`\n  );\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n    return;\n  }\n  if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n    return;\n  }\n  if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n    return;\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`\n  );\n};\nvar validateTuple = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} should be a tuple (defined as object)`\n  );\n};\nvar validateArray = (parameter, input, structs, enums) => {\n  const baseType = getArrayType(input.type);\n  if (isTypeFelt(baseType) && isLongText(parameter)) {\n    return;\n  }\n  assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeArray(baseType):\n      parameter.forEach(\n        (param) => validateArray(param, { name: \"\", type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach(\n        (it) => validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case (isTypeUint(baseType) || isTypeLiteral(baseType)):\n      parameter.forEach((param) => validateUint(param, { name: \"\", type: baseType }));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\nvar validateNonZero = (parameter, input) => {\n  const baseType = getArrayType(input.type);\n  assert(\n    isTypeUint(baseType) && baseType !== CairoUint512.abiSelector || isTypeFelt(baseType),\n    `Validate: ${input.name} type is not authorized for NonZero type.`\n  );\n  switch (true) {\n    case isTypeFelt(baseType):\n      validateFelt(parameter, input);\n      assert(\n        BigInt(parameter.toString(10)) > 0,\n        \"Validate: value 0 is not authorized in NonZero felt252 type.\"\n      );\n      break;\n    case isTypeUint(baseType):\n      validateUint(parameter, { name: \"\", type: baseType });\n      switch (input.type) {\n        case \"core::integer::u256\" /* u256 */:\n          assert(\n            new CairoUint256(parameter).toBigInt() > 0,\n            \"Validate: value 0 is not authorized in NonZero uint256 type.\"\n          );\n          break;\n        default:\n          assert(\n            toBigInt(parameter) > 0,\n            \"Validate: value 0 is not authorized in NonZero uint type.\"\n          );\n      }\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case isTypeBytes31(input.type):\n        validateBytes31(parameter, input);\n        break;\n      case (isTypeUint(input.type) || isTypeLiteral(input.type)):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeByteArray(input.type):\n        validateByteArray(parameter, input);\n        break;\n      case isTypeArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      case isTypeNonZero(input.type):\n        validateNonZero(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n    return acc + 1;\n  }, 0);\n}\n\n// src/utils/calldata/index.ts\nvar CallData = class _CallData {\n  abi;\n  parser;\n  structs;\n  enums;\n  constructor(abi) {\n    this.structs = _CallData.getAbiStruct(abi);\n    this.enums = _CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  validate(type, method, args = []) {\n    if (type !== \"DEPLOY\" /* DEPLOY */) {\n      const invocableFunctionNames = this.abi.filter((abi) => {\n        if (abi.type !== \"function\")\n          return false;\n        const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n        return type === \"INVOKE\" /* INVOKE */ ? !isView : isView;\n      }).map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === \"INVOKE\" /* INVOKE */ ? \"invocable\" : \"viewable\"} method not found in abi`\n      );\n    }\n    const abiMethod = this.abi.find(\n      (abi) => type === \"DEPLOY\" /* DEPLOY */ ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\"\n    );\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  compile(method, argsCalldata) {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n    let args;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    const argsIterator = args[Symbol.iterator]();\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) => isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      []\n    );\n    Object.defineProperty(callArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callArray;\n  }\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs) {\n    const createTree = (obj) => {\n      const getEntries = (o, prefix = \".\") => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === \"entrypoint\")\n            value = getSelectorFromName(value);\n          else if (isLongText(value))\n            value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n          if (isBigInt(value))\n            return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n              const myOption = value;\n              const variantNb = myOption.isSome() ? 0 /* Some */ : 1 /* None */;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n              const myResult = value;\n              const variantNb = myResult.isOk() ? 0 /* Ok */ : 1 /* Err */;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n              const myEnum = value;\n              const activeVariant = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant) => variant === activeVariant\n              );\n              if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      const callTree = createTree(rawArgs);\n      callTreeArray = Object.values(callTree);\n    } else {\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n    Object.defineProperty(callTreeArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callTreeArray;\n  }\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  parse(method, response) {\n    const { outputs } = this.abi.find((abi) => abi.name === method);\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {});\n    return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n  }\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  format(method, response, format) {\n    const parsed = this.parse(method, response);\n    return formatter(parsed, format);\n  }\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi) {\n    return abi.filter((abiEntry) => abiEntry.type === \"struct\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n  }\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi) {\n    const fullEnumList = abi.filter((abiEntry) => abiEntry.type === \"enum\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n    delete fullEnumList[\"core::bool\"];\n    return fullEnumList;\n  }\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata = []) {\n    return _CallData.compile(rawCalldata);\n  }\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw = []) {\n    const calldata = _CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  decodeParameters(typeCairo, response) {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) => responseParser(\n        responseIterator,\n        { name: \"\", type: typeParam },\n        this.structs,\n        this.enums\n      )\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n};\n\n// src/utils/hash/index.ts\nvar hash_exports = {};\n__export(hash_exports, {\n  calculateContractAddressFromHash: () => calculateContractAddressFromHash,\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash3,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash3,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash2,\n  computeCompiledClassHash: () => computeCompiledClassHash,\n  computeContractClassHash: () => computeContractClassHash,\n  computeHashOnElements: () => computeHashOnElements2,\n  computeHintedClassHash: () => computeHintedClassHash,\n  computeLegacyContractClassHash: () => computeLegacyContractClassHash,\n  computePedersenHash: () => computePedersenHash,\n  computePedersenHashOnElements: () => computePedersenHashOnElements,\n  computePoseidonHash: () => computePoseidonHash,\n  computePoseidonHashOnElements: () => computePoseidonHashOnElements,\n  computeSierraContractClassHash: () => computeSierraContractClassHash,\n  formatSpaces: () => formatSpaces,\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  hashByteCodeSegments: () => hashByteCodeSegments,\n  keccakBn: () => keccakBn,\n  poseidon: () => _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_5__,\n  starknetKeccak: () => starknetKeccak\n});\n\n\n// src/utils/hash/transactionHash/v2.ts\nvar v2_exports = {};\n__export(v2_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,\n  calculateTransactionHash: () => calculateTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon,\n  computeHashOnElements: () => computeHashOnElements\n});\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n  starkCurve: () => _scure_starknet__WEBPACK_IMPORTED_MODULE_4__,\n  weierstrass: () => _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_6__\n});\n\n\n\n// src/utils/hash/transactionHash/v2.ts\nfunction computeHashOnElements(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData\n  ];\n  return computeHashOnElements(dataToHash);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n  return calculateTransactionHashCommon(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...compiledClassHash ? [compiledClassHash] : []]\n  );\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n  return calculateTransactionHashCommon(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n  return calculateTransactionHashCommon(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n// src/utils/hash/transactionHash/v3.ts\nvar v3_exports = {};\n__export(v3_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash2,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash2,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon2,\n  hashDAMode: () => hashDAMode,\n  hashFeeField: () => hashFeeField\n});\n\nvar AToBI = (array) => array.map((it) => BigInt(it));\nvar DATA_AVAILABILITY_MODE_BITS = 32n;\nvar MAX_AMOUNT_BITS = 64n;\nvar MAX_PRICE_PER_UNIT_BITS = 128n;\nvar RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nvar L1_GAS_NAME = BigInt(encodeShortString(\"L1_GAS\"));\nvar L2_GAS_NAME = BigInt(encodeShortString(\"L2_GAS\"));\nfunction hashDAMode(nonceDAMode, feeDAMode) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\nfunction hashFeeField(tip, bounds) {\n  const L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);\n  const L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([BigInt(tip), L1Bound, L2Bound]);\n}\nfunction calculateTransactionHashCommon2(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {\n  const feeFieldHash = hashFeeField(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData)\n  ]);\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(dataToHash));\n}\nfunction calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\nfunction calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\nfunction calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(accountDeploymentData)), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(compiledCalldata))]\n  );\n}\n\n// src/utils/hash/transactionHash/index.ts\nfunction isV3InvokeTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateInvokeTransactionHash2(args) {\n  if (isV3InvokeTx(args)) {\n    return calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateTransactionHash(\n    args.senderAddress,\n    args.version,\n    args.compiledCalldata,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\nfunction isV3DeclareTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateDeclareTransactionHash3(args) {\n  if (isV3DeclareTx(args)) {\n    return calculateDeclareTransactionHash2(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeclareTransactionHash(\n    args.classHash,\n    args.senderAddress,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce,\n    args.compiledClassHash\n  );\n}\nfunction isV3DeployAccountTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateDeployAccountTransactionHash3(args) {\n  if (isV3DeployAccountTx(args)) {\n    return calculateDeployAccountTransactionHash2(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeployAccountTransactionHash(\n    args.contractAddress,\n    args.classHash,\n    args.constructorCalldata,\n    args.salt,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n\n// src/utils/hash/classHash.ts\n\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n  parse: () => parse2,\n  parseAlwaysAsBig: () => parseAlwaysAsBig,\n  stringify: () => stringify2,\n  stringifyAlwaysAsBig: () => stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (str) => {\n  if (!lossless_json__WEBPACK_IMPORTED_MODULE_7__.isInteger(str))\n    return parseFloat(str);\n  const num = parseInt(str, 10);\n  return Number.isSafeInteger(num) ? num : BigInt(str);\n};\nvar parse2 = (str) => lossless_json__WEBPACK_IMPORTED_MODULE_7__.parse(String(str), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (str) => lossless_json__WEBPACK_IMPORTED_MODULE_7__.parse(String(str), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_7__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers) => lossless_json__WEBPACK_IMPORTED_MODULE_7__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n\n// src/utils/hash/classHash.ts\nfunction computePedersenHash(a, b) {\n  return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n  return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements2(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements2;\nfunction computePoseidonHashOnElements(data) {\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(data.map((x) => BigInt(x))));\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements2(compiledCalldata);\n  const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n  const hash = computeHashOnElements2([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n  if (key === \"attributes\" || key === \"accessible_scopes\") {\n    return Array.isArray(value) && value.length === 0 ? void 0 : value;\n  }\n  if (key === \"debug_info\") {\n    return null;\n  }\n  return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n  let insideQuotes = false;\n  const newString = [];\n  for (const char of json2) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n    }\n  }\n  return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n  return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  const apiVersion = toHex(API_VERSION);\n  const externalEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n  const l1HandlerEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n  const constructorEntryPointHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n  const builtinsHash = computeHashOnElements2(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n  const dataHash = computeHashOnElements2(compiledContract.program.data);\n  return computeHashOnElements2([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash\n  ]);\n}\nfunction hashBuiltins(builtins) {\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(\n    builtins.flatMap((it) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\nfunction hashEntryPoint(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(base);\n}\nfunction hashByteCodeSegments(casm) {\n  const byteCode = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths = casm.bytecode_segment_lengths ?? [];\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, segmentStart += len);\n    return [BigInt(len), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(segment)];\n  });\n  return 1n + (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(hashLeaves);\n}\nfunction computeCompiledClassHash(casm) {\n  const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n  const bytecode = casm.bytecode_segment_lengths ? hashByteCodeSegments(casm) : (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode\n    ])\n  );\n}\nfunction hashEntryPointSierra(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n  const indentString = formatSpaces(stringify2(sierra.abi, null));\n  return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n  const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n  const abiHash = hashAbi(sierra);\n  const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram\n    ])\n  );\n}\nfunction computeContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  if (\"sierra_program\" in compiledContract) {\n    return computeSierraContractClassHash(compiledContract);\n  }\n  return computeLegacyContractClassHash(compiledContract);\n}\n\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n  compressProgram: () => compressProgram,\n  decompressProgram: () => decompressProgram,\n  estimateFeeToBounds: () => estimateFeeToBounds,\n  estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,\n  formatSignature: () => formatSignature,\n  intDAM: () => intDAM,\n  makeAddress: () => makeAddress,\n  randomAddress: () => randomAddress,\n  reduceV2: () => reduceV2,\n  signatureToDecimalArray: () => signatureToDecimalArray,\n  signatureToHexArray: () => signatureToHexArray,\n  toFeeVersion: () => toFeeVersion,\n  toTransactionVersion: () => toTransactionVersion,\n  v3Details: () => v3Details\n});\n\n\nfunction compressProgram(jsonProgram) {\n  const stringified = isString(jsonProgram) ? jsonProgram : stringify2(jsonProgram);\n  const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_8__.gzip)(stringified);\n  return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n  if (Array.isArray(base642))\n    return base642;\n  const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_8__.ungzip)(atobUniversal(base642)));\n  return parse2(decompressed);\n}\nfunction randomAddress() {\n  const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.utils.randomPrivateKey();\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n  return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n  if (!sig)\n    throw Error(\"formatSignature: provided signature is undefined\");\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n  }\n}\nfunction signatureToDecimalArray(sig) {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 50 /* MAX_FEE */) {\n  return addPercent(estimatedFee, overhead);\n}\nfunction estimateFeeToBounds(estimate, amountOverhead = 50 /* L1_BOUND_MAX_AMOUNT */, priceOverhead = 50 /* L1_BOUND_MAX_PRICE_PER_UNIT */) {\n  if (isBigInt(estimate)) {\n    return {\n      l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n      l1_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" }\n    };\n  }\n  if (typeof estimate.gas_consumed === \"undefined\" || typeof estimate.gas_price === \"undefined\") {\n    throw Error(\"estimateFeeToBounds: estimate is undefined\");\n  }\n  const maxUnits = estimate.data_gas_consumed !== void 0 && estimate.data_gas_price !== void 0 ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead)) : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n  return {\n    l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice }\n  };\n}\nfunction intDAM(dam) {\n  if (dam === api_exports.EDataAvailabilityMode.L1)\n    return api_exports.EDAMode.L1;\n  if (dam === api_exports.EDataAvailabilityMode.L2)\n    return api_exports.EDAMode.L2;\n  throw Error(\"EDAM conversion\");\n}\nfunction toTransactionVersion(defaultVersion, providedVersion) {\n  const providedVersion0xs = providedVersion ? toHex(providedVersion) : void 0;\n  const defaultVersion0xs = toHex(defaultVersion);\n  if (providedVersion && !Object.values(api_exports.ETransactionVersion).includes(providedVersion0xs)) {\n    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n  }\n  if (!Object.values(api_exports.ETransactionVersion).includes(defaultVersion0xs)) {\n    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n  }\n  return providedVersion ? providedVersion0xs : defaultVersion0xs;\n}\nfunction toFeeVersion(providedVersion) {\n  if (!providedVersion)\n    return void 0;\n  const version = toHex(providedVersion);\n  if (version === api_exports.ETransactionVersion.V0)\n    return api_exports.ETransactionVersion.F0;\n  if (version === api_exports.ETransactionVersion.V1)\n    return api_exports.ETransactionVersion.F1;\n  if (version === api_exports.ETransactionVersion.V2)\n    return api_exports.ETransactionVersion.F2;\n  if (version === api_exports.ETransactionVersion.V3)\n    return api_exports.ETransactionVersion.F3;\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\nfunction v3Details(details) {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO)\n  };\n}\nfunction reduceV2(providedVersion) {\n  if (providedVersion === api_exports.ETransactionVersion.F2)\n    return api_exports.ETransactionVersion.F1;\n  if (providedVersion === api_exports.ETransactionVersion.V2)\n    return api_exports.ETransactionVersion.V1;\n  return providedVersion;\n}\n\n// src/utils/contract.ts\nfunction isSierra(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n  const response = { ...payload };\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        \"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\"\n      );\n  }\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n  return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n  if (isSierra(ccr)) {\n    throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n  }\n  const contract = ccr;\n  return { ...contract, program: decompressProgram(contract.program) };\n}\n\n// src/utils/eth.ts\nvar eth_exports = {};\n__export(eth_exports, {\n  ethRandomPrivateKey: () => ethRandomPrivateKey,\n  validateAndParseEthAddress: () => validateAndParseEthAddress\n});\n\nfunction ethRandomPrivateKey() {\n  return sanitizeHex(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.utils.randomPrivateKey()));\n}\nfunction validateAndParseEthAddress(address) {\n  assertInRange(address, ZERO, 2n ** 160n - 1n, \"Ethereum Address \");\n  const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, \"0\"));\n  assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), \"Invalid Ethereum Address Format\");\n  return result;\n}\n\n// src/utils/fetchPonyfill.ts\n\n\nvar fetchPonyfill_default = typeof window !== \"undefined\" && window.fetch || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && (0,fetch_cookie__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(global.fetch) || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_11__;\n\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n  Block: () => Block,\n  createSierraContractClass: () => createSierraContractClass,\n  getDefaultNodeUrl: () => getDefaultNodeUrl,\n  isPendingBlock: () => isPendingBlock,\n  isPendingStateUpdate: () => isPendingStateUpdate,\n  isPendingTransaction: () => isPendingTransaction,\n  isV3Tx: () => isV3Tx,\n  isVersion: () => isVersion,\n  parseContract: () => parseContract,\n  validBlockTags: () => validBlockTags,\n  wait: () => wait\n});\nfunction wait(delay) {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\nfunction createSierraContractClass(contract) {\n  const result = { ...contract };\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify2(contract.abi));\n  result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\nfunction parseContract(contract) {\n  const parsedContract = isString(contract) ? parse2(contract) : contract;\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...\"program\" in parsedContract && { program: compressProgram(parsedContract.program) }\n    };\n  }\n  return createSierraContractClass(parsedContract);\n}\nvar getDefaultNodeUrl = (networkName, mute = false) => {\n  if (!mute) {\n    console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n  }\n  const nodes = RPC_NODES[networkName ?? \"SN_SEPOLIA\" /* SN_SEPOLIA */];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n  /**\n   * @param {BlockIdentifier} hash if not null, contains the block hash\n   */\n  hash = null;\n  /**\n   * @param {BlockIdentifier} number if not null, contains the block number\n   */\n  number = null;\n  /**\n   * @param {BlockIdentifier} tag if not null, contains \"pending\" or \"latest\"\n   */\n  tag = null;\n  setIdentifier(__identifier) {\n    if (isString(__identifier)) {\n      if (isDecimalString(__identifier)) {\n        this.number = parseInt(__identifier, 10);\n      } else if (isHex(__identifier)) {\n        this.hash = __identifier;\n      } else if (validBlockTags.includes(__identifier)) {\n        this.tag = __identifier;\n      } else {\n        throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n      }\n    } else if (isBigInt(__identifier)) {\n      this.hash = toHex(__identifier);\n    } else if (isNumber(__identifier)) {\n      this.number = __identifier;\n    } else {\n      this.tag = \"pending\" /* PENDING */;\n    }\n    if (isNumber(this.number) && this.number < 0) {\n      throw TypeError(`Block number (${this.number}) can't be negative`);\n    }\n  }\n  /**\n   * Create a Block instance\n   * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.\n   * decimal string and number are detected as block numbers.\n   * text string are detected as block tag.\n   * null is considered as a 'pending' block tag.\n   */\n  constructor(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as a string\n   * @example\n   * ```typescript\n   * const result = new provider.Block(123456n).queryIdentifier;\n   * // result = \"blockHash=0x1e240\"\n   * ```\n   */\n  get queryIdentifier() {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n    return `blockNumber=${this.tag}`;\n  }\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as an object\n   * @example\n   * ```typescript\n   * const result = new provider.Block(56789).identifier;\n   * // result = { block_number: 56789 }\n   * ```\n   */\n  get identifier() {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n    return this.tag;\n  }\n  /**\n   * change the identifier of an existing Block instance\n   * @example\n   * ```typescript\n   * const myBlock = new provider.Block(\"latest\");\n   * myBlock.identifier =\"0x3456789abc\";\n   * const result = myBlock.identifier;\n   * // result = { block_hash: '0x3456789abc' }\n   * ```\n   */\n  set identifier(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  valueOf = () => this.number;\n  toString = () => this.hash;\n};\nfunction isV3Tx(details) {\n  const version = details.version ? toHex(details.version) : api_exports.ETransactionVersion.V3;\n  return version === api_exports.ETransactionVersion.V3 || version === api_exports.ETransactionVersion.F3;\n}\nfunction isVersion(version, response) {\n  const [majorS, minorS] = version.split(\".\");\n  const [majorR, minorR] = response.split(\".\");\n  return majorS === majorR && minorS === minorR;\n}\nfunction isPendingBlock(response) {\n  return response.status === \"PENDING\";\n}\nfunction isPendingTransaction(response) {\n  return !(\"block_hash\" in response);\n}\nfunction isPendingStateUpdate(response) {\n  return !(\"block_hash\" in response);\n}\n\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n  buildUDCCall: () => buildUDCCall,\n  fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,\n  fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,\n  fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,\n  getExecuteCalldata: () => getExecuteCalldata,\n  getVersionsByType: () => getVersionsByType,\n  transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,\n  transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls) => {\n  const callArray = [];\n  const calldata = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString()\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata })\n  };\n};\nvar fromCallsToExecuteCalldata = (calls) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls) => {\n  const callArray = calls.map((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || [])\n  }));\n  return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls) => {\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n    // RawArgsObject | RawArgsArray type\n  }));\n  return CallData.compile({ orderCalls });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\") => {\n  if (cairoVersion === \"1\") {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\nfunction buildUDCCall(payload, address) {\n  const params = [].concat(payload).map((it) => {\n    const {\n      classHash,\n      salt,\n      unique = true,\n      constructorCalldata = []\n    } = it;\n    const compiledConstructorCallData = CallData.compile(constructorCalldata);\n    const deploySalt = salt ?? randomAddress();\n    return {\n      call: {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          deploySalt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      },\n      address: calculateContractAddressFromHash(\n        unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(address, deploySalt) : deploySalt,\n        classHash,\n        compiledConstructorCallData,\n        unique ? UDC.ADDRESS : 0\n      )\n    };\n  });\n  return {\n    calls: params.map((it) => it.call),\n    addresses: params.map((it) => it.address)\n  };\n}\nfunction getVersionsByType(versionType) {\n  return versionType === \"fee\" ? {\n    v1: api_exports.ETransactionVersion.F1,\n    v2: api_exports.ETransactionVersion.F2,\n    v3: api_exports.ETransactionVersion.F3\n  } : { v1: api_exports.ETransactionVersion.V1, v2: api_exports.ETransactionVersion.V2, v3: api_exports.ETransactionVersion.V3 };\n}\n\n// src/channel/rpc_0_6.ts\nvar defaultOptions = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: \"pending\" /* PENDING */,\n  retries: 200\n};\nvar RpcChannel = class {\n  nodeUrl;\n  headers;\n  retries;\n  requestId;\n  blockIdentifier;\n  chainId;\n  specVersion;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  constructor(optionsOrProvider) {\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return fetchPonyfill_default(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify2(params, null, 2)}\n\n        ${code}: ${message}: ${stringify2(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, simulateTransactionOptions = {}) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate)\n      simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge)\n      simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5e3;\n    const errorStates = options?.errorStates ?? [\n      rpcspec_0_6_exports.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      rpcspec_0_6_exports.ETransactionExecutionStatus.SUCCEEDED,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L2,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        // v0 v1 v3\n        type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/channel/rpc_0_7.ts\nvar rpc_0_7_exports = {};\n__export(rpc_0_7_exports, {\n  RpcChannel: () => RpcChannel2\n});\nvar defaultOptions2 = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: \"pending\" /* PENDING */,\n  retries: 200\n};\nvar RpcChannel2 = class {\n  nodeUrl;\n  headers;\n  retries;\n  requestId;\n  blockIdentifier;\n  chainId;\n  specVersion;\n  transactionRetryIntervalFallback;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  constructor(optionsOrProvider) {\n    const {\n      nodeUrl,\n      retries,\n      headers,\n      blockIdentifier,\n      chainId,\n      specVersion,\n      waitMode,\n      transactionRetryIntervalFallback\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions2.retries;\n    this.headers = { ...defaultOptions2.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions2.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n  }\n  get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5e3;\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return fetchPonyfill_default(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify2(params, null, 2)}\n \n        ${code}: ${message}: ${stringify2(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockWithReceipts(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithReceipts\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, simulateTransactionOptions = {}) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate)\n      simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge)\n      simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates = options?.errorStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionExecutionStatus.SUCCEEDED,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.ACCEPTED_ON_L2,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DEPLOY_ACCOUNT,\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        // v0 v1 v3\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n  margin;\n  constructor(margin) {\n    this.margin = margin;\n  }\n  estimatedFeeToMaxFee(estimatedFee) {\n    return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n  }\n  estimateFeeToBounds(estimate) {\n    return estimateFeeToBounds(\n      estimate,\n      this.margin?.l1BoundMaxAmount,\n      this.margin?.l1BoundMaxPricePerUnit\n    );\n  }\n  parseGetBlockResponse(res) {\n    return { status: \"PENDING\", ...res };\n  }\n  parseTransactionReceipt(res) {\n    if (\"actual_fee\" in res && isString(res.actual_fee)) {\n      return {\n        ...res,\n        actual_fee: {\n          amount: res.actual_fee,\n          unit: \"FRI\"\n        }\n      };\n    }\n    return res;\n  }\n  parseFeeEstimateResponse(res) {\n    const val = res[0];\n    return {\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    };\n  }\n  parseFeeEstimateBulkResponse(res) {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    }));\n  }\n  parseSimulateTransactionResponse(res) {\n    return res.map((it) => {\n      return {\n        ...it,\n        suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n        resourceBounds: this.estimateFeeToBounds(it.fee_estimation)\n      };\n    });\n  }\n  parseContractClassResponse(res) {\n    return {\n      ...res,\n      abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi\n    };\n  }\n  parseL1GasPriceResponse(res) {\n    return res.l1_gas_price.price_in_wei;\n  }\n};\n\n// src/utils/transactionReceipt.ts\nvar ReceiptTx = class _ReceiptTx {\n  statusReceipt;\n  value;\n  constructor(receipt) {\n    [this.statusReceipt, this.value] = _ReceiptTx.isSuccess(receipt) ? [\"success\", receipt] : _ReceiptTx.isReverted(receipt) ? [\"reverted\", receipt] : _ReceiptTx.isRejected(receipt) ? [\"rejected\", receipt] : [\"error\", new Error(\"Unknown response type\")];\n    for (const [key] of Object.entries(this)) {\n      Object.defineProperty(this, key, {\n        enumerable: false\n      });\n    }\n    for (const [key, value] of Object.entries(receipt)) {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        writable: false,\n        value\n      });\n    }\n  }\n  match(callbacks) {\n    if (this.statusReceipt in callbacks) {\n      return callbacks[this.statusReceipt](this.value);\n    }\n    return callbacks._();\n  }\n  isSuccess() {\n    return this.statusReceipt === \"success\";\n  }\n  isReverted() {\n    return this.statusReceipt === \"reverted\";\n  }\n  isRejected() {\n    return this.statusReceipt === \"rejected\";\n  }\n  isError() {\n    return this.statusReceipt === \"error\";\n  }\n  static isSuccess(transactionReceipt) {\n    return transactionReceipt.execution_status === \"SUCCEEDED\" /* SUCCEEDED */;\n  }\n  static isReverted(transactionReceipt) {\n    return transactionReceipt.execution_status === \"REVERTED\" /* REVERTED */;\n  }\n  static isRejected(transactionReceipt) {\n    return transactionReceipt.status === \"REJECTED\" /* REJECTED */;\n  }\n};\n\n// src/provider/rpc.ts\nvar RpcProvider = class {\n  responseParser;\n  channel;\n  constructor(optionsOrProvider) {\n    if (optionsOrProvider && \"channel\" in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser = \"responseParser\" in optionsOrProvider ? optionsOrProvider.responseParser : new RPCResponseParser();\n    } else {\n      this.channel = new RpcChannel2({ ...optionsOrProvider, waitMode: false });\n      this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n    }\n  }\n  fetch(method, params, id = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n  async getChainId() {\n    return this.channel.getChainId();\n  }\n  async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n  async getNonceForAddress(contractAddress, blockIdentifier) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n  async getBlock(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n  async getBlockWithTxHashes(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n  async getBlockWithTxs(blockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n  /**\n   * Pause the execution of the script until a specified block is created.\n   * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberisk) or 'pending' or 'latest'.\n   * Use of 'latest\" or of a block already created will generate no pause.\n   * @param {number} [retryInterval] number of milliseconds between 2 requests to the node\n   * @example\n   * ```typescript\n   * await myProvider.waitForBlock();\n   * // wait the creation of the pending block\n   * ```\n   */\n  async waitForBlock(blockIdentifier = \"pending\", retryInterval = 5e3) {\n    if (blockIdentifier === \"latest\" /* LATEST */)\n      return;\n    const currentBlock = await this.getBlockNumber();\n    const targetBlock = blockIdentifier === \"pending\" /* PENDING */ ? currentBlock + 1 : Number(toHex(blockIdentifier));\n    if (targetBlock <= currentBlock)\n      return;\n    const { retries } = this.channel;\n    let retriesCount = retries;\n    let isTargetBlock = false;\n    while (!isTargetBlock) {\n      const currBlock = await this.getBlockNumber();\n      if (currBlock === targetBlock) {\n        isTargetBlock = true;\n      } else {\n        await wait(retryInterval);\n      }\n      retriesCount -= 1;\n      if (retriesCount <= 0) {\n        throw new Error(`waitForBlock() timed-out after ${retries} tries.`);\n      }\n    }\n  }\n  async getL1GasPrice(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse);\n  }\n  async getL1MessageHash(l2TxHash) {\n    const transaction = await this.channel.getTransactionByHash(l2TxHash);\n    assert(transaction.type === \"L1_HANDLER\", \"This L2 transaction is not a L1 message.\");\n    const { calldata, contract_address, entry_point_selector, nonce } = transaction;\n    const params = [\n      calldata[0],\n      contract_address,\n      nonce,\n      entry_point_selector,\n      calldata.length - 1,\n      ...calldata.slice(1)\n    ];\n    const myEncode = addHexPrefix(\n      params.reduce(\n        (res, par) => res + removeHexPrefix(toHex(par)).padStart(64, \"0\"),\n        \"\"\n      )\n    );\n    return addHexPrefix((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.bytesToHex)((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_13__.keccak_256)(hexToBytes(myEncode))));\n  }\n  async getBlockWithReceipts(blockIdentifier) {\n    if (this.channel instanceof rpc_0_6_exports.RpcChannel)\n      throw new LibraryError(\"Unsupported method for RPC version\");\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n  getStateUpdate = this.getBlockStateUpdate;\n  async getBlockStateUpdate(blockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n  async getBlockTransactionsTraces(blockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n  async getBlockTransactionCount(blockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */\n  async getPendingTransactions() {\n    const { transactions } = await this.getBlockWithTxHashes(\"pending\" /* PENDING */).then(\n      this.responseParser.parseGetBlockResponse\n    );\n    return Promise.all(transactions.map((it) => this.getTransactionByHash(it)));\n  }\n  async getTransaction(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByHash(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n  async getTransactionReceipt(txHash) {\n    const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n    const txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n    return new ReceiptTx(txReceiptWoHelperModified);\n  }\n  async getTransactionTrace(txHash) {\n    return this.channel.getTransactionTrace(txHash);\n  }\n  /**\n   * Get the status of a transaction\n   */\n  async getTransactionStatus(transactionHash) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param options blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  async getSimulateTransaction(invocations, options) {\n    return this.channel.simulateTransaction(invocations, options).then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n  async waitForTransaction(txHash, options) {\n    const receiptWoHelper = await this.channel.waitForTransaction(\n      txHash,\n      options\n    );\n    return new ReceiptTx(receiptWoHelper);\n  }\n  async getStorageAt(contractAddress, key, blockIdentifier) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n  async getClassHashAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n  async getClassByHash(classHash) {\n    return this.getClass(classHash);\n  }\n  async getClass(classHash, blockIdentifier) {\n    return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getClassAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getContractVersion(contractAddress, classHash, {\n    blockIdentifier = this.channel.blockIdentifier,\n    compiler = true\n  } = {}) {\n    let contractClass;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error(\"getContractVersion require contractAddress or classHash\");\n    }\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: \"1\", compiler: abiTest.compiler };\n      }\n      return { cairo: \"1\", compiler: void 0 };\n    }\n    return { cairo: \"0\", compiler: \"0\" };\n  }\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n  async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"INVOKE_FUNCTION\" /* INVOKE */,\n          ...invocation,\n          ...invocationDetails\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"DECLARE\" /* DECLARE */,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getEstimateFeeBulk(invocations, options) {\n    return this.channel.getEstimateFee(invocations, options).then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n  async invokeFunction(functionInvocation, details) {\n    return this.channel.invoke(functionInvocation, details);\n  }\n  async declareContract(transaction, details) {\n    return this.channel.declare(transaction, details);\n  }\n  async deployAccountContract(transaction, details) {\n    return this.channel.deployAccount(\n      transaction,\n      details\n    );\n  }\n  async callContract(call, blockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  async estimateMessageFee(message, blockIdentifier) {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  async getEvents(eventFilter) {\n    return this.channel.getEvents(eventFilter);\n  }\n};\n\n// src/provider/extensions/default.ts\n\n\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n  StarknetIdContract: () => StarknetIdContract,\n  StarknetIdIdentityContract: () => StarknetIdIdentityContract,\n  StarknetIdMulticallContract: () => StarknetIdMulticallContract,\n  StarknetIdPfpContract: () => StarknetIdPfpContract,\n  StarknetIdPopContract: () => StarknetIdPopContract,\n  StarknetIdVerifierContract: () => StarknetIdVerifierContract,\n  dynamicCallData: () => dynamicCallData,\n  dynamicFelt: () => dynamicFelt,\n  execution: () => execution,\n  getStarknetIdContract: () => getStarknetIdContract,\n  getStarknetIdIdentityContract: () => getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract: () => getStarknetIdMulticallContract,\n  getStarknetIdPfpContract: () => getStarknetIdPfpContract,\n  getStarknetIdPopContract: () => getStarknetIdPopContract,\n  getStarknetIdVerifierContract: () => getStarknetIdVerifierContract,\n  useDecoded: () => useDecoded,\n  useEncoded: () => useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"\\u8FD9\\u6765\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\nfunction useDecoded(encoded) {\n  let decoded = \"\";\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO)\n            decoded += basicAlphabet[0];\n          else\n            decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else\n        decoded += basicAlphabet[Number(code)];\n    }\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += \".\";\n  });\n  if (!decoded) {\n    return decoded;\n  }\n  return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n    if (index !== -1) {\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n  return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2) => {\n  StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n  StarknetIdContract2[\"TESTNET_SEPOLIA\"] = \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\";\n  return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id is not yet deployed on this network\");\n  }\n}\nvar StarknetIdIdentityContract = /* @__PURE__ */ ((StarknetIdIdentityContract2) => {\n  StarknetIdIdentityContract2[\"MAINNET\"] = \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\";\n  StarknetIdIdentityContract2[\"TESTNET_SEPOLIA\"] = \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\";\n  return StarknetIdIdentityContract2;\n})(StarknetIdIdentityContract || {});\nfunction getStarknetIdIdentityContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdMulticallContract = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\";\nfunction getStarknetIdMulticallContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdMulticallContract;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdMulticallContract;\n    default:\n      throw new Error(\"Starknet.id multicall contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdVerifierContract = /* @__PURE__ */ ((StarknetIdVerifierContract2) => {\n  StarknetIdVerifierContract2[\"MAINNET\"] = \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\";\n  StarknetIdVerifierContract2[\"TESTNET_SEPOLIA\"] = \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\";\n  return StarknetIdVerifierContract2;\n})(StarknetIdVerifierContract || {});\nfunction getStarknetIdVerifierContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdPfpContract = /* @__PURE__ */ ((StarknetIdPfpContract2) => {\n  StarknetIdPfpContract2[\"MAINNET\"] = \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\";\n  StarknetIdPfpContract2[\"TESTNET_SEPOLIA\"] = \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\";\n  return StarknetIdPfpContract2;\n})(StarknetIdPfpContract || {});\nfunction getStarknetIdPfpContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\n        \"Starknet.id profile picture verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nvar StarknetIdPopContract = /* @__PURE__ */ ((StarknetIdPopContract2) => {\n  StarknetIdPopContract2[\"MAINNET\"] = \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\";\n  StarknetIdPopContract2[\"TESTNET_SEPOLIA\"] = \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\";\n  return StarknetIdPopContract2;\n})(StarknetIdPopContract || {});\nfunction getStarknetIdPopContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\n        \"Starknet.id proof of personhood verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nfunction execution(staticEx, ifEqual = void 0, ifNotEqual = void 0) {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : void 0,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : void 0\n  });\n}\nfunction dynamicFelt(hardcoded, reference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0\n  });\n}\nfunction dynamicCallData(hardcoded, reference = void 0, arrayReference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : void 0\n  });\n}\n\n// src/provider/extensions/starknetId.ts\nvar StarknetId = class _StarknetId {\n  async getStarkName(address, StarknetIdContract2) {\n    return _StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2\n    );\n  }\n  async getAddressFromStarkName(name, StarknetIdContract2) {\n    return _StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      name,\n      StarknetIdContract2\n    );\n  }\n  async getStarkProfile(address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    return _StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2,\n      StarknetIdIdentityContract2,\n      StarknetIdVerifierContract2,\n      StarknetIdPfpContract2,\n      StarknetIdPopContract2,\n      StarknetIdMulticallContract2\n    );\n  }\n  static async getStarkName(provider, address, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"address_to_domain\",\n        calldata: CallData.compile({\n          address,\n          hint: []\n        })\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n      const stringDomain = useDecoded(decimalDomain);\n      if (!stringDomain) {\n        throw Error(\"Starkname not found\");\n      }\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === \"Starkname not found\") {\n        throw e;\n      }\n      throw Error(\"Could not get stark name\");\n    }\n  }\n  static async getAddressFromStarkName(provider, name, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const encodedDomain = name.replace(\".stark\", \"\").split(\".\").map((part) => useEncoded(part).toString(10));\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"domain_to_address\",\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] })\n      });\n      return addressData[0];\n    } catch {\n      throw Error(\"Could not get address from stark name\");\n    }\n  }\n  static async getStarkProfile(provider, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract2 ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract2 ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract2 ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract2 ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract2 ?? getStarknetIdMulticallContract(chainId);\n    try {\n      const calls = [\n        {\n          execution: execution({}),\n          to: dynamicCallData(contract),\n          selector: dynamicCallData(getSelectorFromName(\"address_to_domain\")),\n          calldata: [dynamicCallData(address), dynamicCallData(\"0\")]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(contract),\n          selector: dynamicFelt(getSelectorFromName(\"domain_to_id\")),\n          calldata: [dynamicCallData(void 0, void 0, [0, 0])]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"twitter\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"github\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"discord\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"proof_of_personhood\")),\n            dynamicCallData(popContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        // PFP\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"nft_pp_contract\")),\n            dynamicCallData(pfpContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_extended_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"nft_pp_id\")),\n            dynamicCallData(\"2\"),\n            dynamicCallData(pfpContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution(void 0, void 0, [6, 0, 0]),\n          to: dynamicFelt(void 0, [6, 0]),\n          selector: dynamicFelt(getSelectorFromName(\"tokenURI\")),\n          calldata: [dynamicCallData(void 0, [7, 1]), dynamicCallData(void 0, [7, 2])]\n        }\n      ];\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: \"aggregate\",\n        calldata: CallData.compile({\n          calls\n        })\n      });\n      if (Array.isArray(data)) {\n        const size = parseInt(data[0], 16);\n        const finalArray = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n        const twitter = finalArray[2][0] !== \"0x0\" ? BigInt(finalArray[2][0]).toString() : void 0;\n        const github = finalArray[3][0] !== \"0x0\" ? BigInt(finalArray[3][0]).toString() : void 0;\n        const discord = finalArray[4][0] !== \"0x0\" ? BigInt(finalArray[4][0]).toString() : void 0;\n        const proofOfPersonhood = finalArray[5][0] === \"0x1\";\n        const profilePictureMetadata = data[0] === \"0x9\" ? finalArray[8].slice(1).map((val) => decodeShortString(val)).join(\"\") : void 0;\n        const profilePicture = profilePictureMetadata || `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture\n        };\n      }\n      throw Error(\"Error while calling aggregate function\");\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error(\"Could not get user stark profile data from address\");\n    }\n  }\n};\n\n// src/provider/extensions/default.ts\nvar RpcProvider2 = class extends (0,ts_mixer__WEBPACK_IMPORTED_MODULE_14__.Mixin)(RpcProvider, StarknetId) {\n};\n\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n\n// src/provider/index.ts\nvar defaultProvider = new RpcProvider({ default: true });\n\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n  encodeData: () => encodeData,\n  encodeType: () => encodeType,\n  encodeValue: () => encodeValue,\n  getDependencies: () => getDependencies,\n  getMessageHash: () => getMessageHash,\n  getStructHash: () => getStructHash,\n  getTypeHash: () => getTypeHash,\n  isMerkleTreeType: () => isMerkleTreeType,\n  prepareSelector: () => prepareSelector\n});\n\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n  MerkleTree: () => MerkleTree,\n  proofMerklePath: () => proofMerklePath\n});\nvar MerkleTree = class _MerkleTree {\n  leaves;\n  branches = [];\n  root;\n  hashMethod;\n  /**\n   * Create a Merkle tree\n   *\n   * @param leafHashes hex-string array\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns created Merkle tree\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * // tree = {\n   * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],\n   * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],\n   * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',\n   * //   hashMethod: [Function computePedersenHash],\n   * // }\n   * ```\n   */\n  constructor(leafHashes, hashMethod = computePedersenHash) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n  /** @ignore */\n  build(leaves) {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(_MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n      } else {\n        newLeaves.push(_MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n  /**\n   * Calculate hash from ordered a and b, Pedersen hash default\n   *\n   * @param a first value\n   * @param b second value\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns result of the hash function\n   * @example\n   * ```typescript\n   * const result1 = MerkleTree.hash('0xabc', '0xdef');\n   * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'\n   *\n   * const customHashMethod = (a, b) => `custom_${a}_${b}`;\n   * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);\n   * // result2 = 'custom_2748_3567'\n   * ```\n   */\n  static hash(a, b, hashMethod = computePedersenHash) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => x >= y ? 1 : -1);\n    return hashMethod(aSorted, bSorted);\n  }\n  /**\n   * Calculates the merkle membership proof path\n   *\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns collection of merkle proof hex-string hashes\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * const result = tree.getProof('0x3');\n   * // result = [\n   * //   '0x4',\n   * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n   * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n   * // ]\n   * ```\n   */\n  getProof(leaf, branch = this.leaves, hashPath = []) {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error(\"leaf not found\");\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      _MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n\n// src/utils/typedData.ts\nvar presetTypes = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  )\n};\nvar revisionConfiguration = {\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE]: {\n    domain: \"StarknetDomain\",\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes\n  },\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY]: {\n    domain: \"StarkNetDomain\",\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {}\n  }\n};\nfunction assertRange(data, type, { min, max }) {\n  const value = BigInt(data);\n  assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\nfunction identifyRevision({ types, domain }) {\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE].domain in types && domain.revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE;\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY].domain in types && (domain.revision ?? starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY;\n  return void 0;\n}\nfunction getHex(value) {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (isString(value)) {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\nfunction validateTypedData(data) {\n  const typedData = data;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\nfunction prepareSelector(selector) {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n  return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  if (type[type.length - 1] === \"*\") {\n    type = type.slice(0, -1);\n  } else if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n    if (type === \"enum\") {\n      type = contains;\n    } else if (type.match(/^\\(.*\\)$/)) {\n      type = type.slice(1, -1);\n    }\n  }\n  if (dependencies.includes(type) || !types[type]) {\n    return dependencies;\n  }\n  return [\n    type,\n    ...types[type].reduce(\n      (previous, t) => [\n        ...previous,\n        ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n          (dependency) => !previous.includes(dependency)\n        )\n      ],\n      []\n    )\n  ];\n}\nfunction getMerkleTreeType(types, ctx) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key);\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith(\"*\")) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return \"raw\";\n}\nfunction encodeType(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  const allTypes = revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE ? { ...types, ...revisionConfiguration[revision].presetTypes } : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    void 0,\n    void 0,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n  const esc = revisionConfiguration[revision].escapeTypeString;\n  return newTypes.map((dependency) => {\n    const dependencyElements = allTypes[dependency].map((t) => {\n      const targetType = t.type === \"enum\" && revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE ? t.contains : t.type;\n      const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e) => e ? esc(e) : e).join(\",\")})` : esc(targetType);\n      return `${esc(t.name)}:${typeString}`;\n    });\n    return `${esc(dependency)}(${dependencyElements})`;\n  }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data, revision)];\n  }\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data,\n        revision\n      )\n    ];\n  }\n  if (type.endsWith(\"*\")) {\n    const hashes = data.map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n  switch (type) {\n    case \"enum\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        const [variantKey, variantData] = Object.entries(data)[0];\n        const parentType = types[ctx.parent][0];\n        const enumType = types[parentType.contains];\n        const variantType = enumType.find((t) => t.name === variantKey);\n        const variantIndex = enumType.indexOf(variantType);\n        const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index) => {\n          if (!subtype)\n            return subtype;\n          const subtypeData = variantData[index];\n          return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n        });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes])\n        ];\n      }\n      return [type, getHex(data)];\n    }\n    case \"merkletree\": {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes = data.map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes,\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return [\"felt\", root];\n    }\n    case \"selector\": {\n      return [\"felt\", prepareSelector(data)];\n    }\n    case \"string\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        const byteArray = byteArrayFromString(data);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"i128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        const value = BigInt(data);\n        assertRange(value, type, RANGE_I128);\n        return [type, getHex(value < 0n ? PRIME + value : value)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"timestamp\":\n    case \"u128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assertRange(data, type, RANGE_U128);\n      }\n      return [type, getHex(data)];\n    }\n    case \"felt\":\n    case \"shortstring\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assertRange(getHex(data), type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"ClassHash\":\n    case \"ContractAddress\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assertRange(data, type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"bool\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assert(typeof data === \"boolean\", `Type mismatch for ${type} ${data}`);\n      }\n      return [type, getHex(data)];\n    }\n    default: {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data)];\n    }\n  }\n}\nfunction encodeData(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce(\n    ([ts, vs], field) => {\n      if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n      const value = data[field.name];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n      return [\n        [...ts, t],\n        [...vs, encodedValue]\n      ];\n    },\n    [[\"felt\"], [getTypeHash(types, type, revision)]]\n  );\n  return [returnTypes, values];\n}\nfunction getStructHash(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n  if (!validateTypedData(typedData)) {\n    throw new Error(\"Typed data does not match JSON schema\");\n  }\n  const revision = identifyRevision(typedData);\n  const { domain, hashMethod } = revisionConfiguration[revision];\n  const message = [\n    encodeShortString(\"StarkNet Message\"),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n  ];\n  return hashMethod(message);\n}\n\n// src/signer/default.ts\nvar Signer = class {\n  pk;\n  constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n  async getPubKey() {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.getStarkKey(this.pk);\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signRaw(msgHash) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.sign(msgHash, this.pk);\n  }\n};\n\n// src/signer/ethSigner.ts\n\n\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n  UINT_128_MAX: () => UINT_128_MAX,\n  UINT_256_MAX: () => UINT_256_MAX,\n  bnToUint256: () => bnToUint256,\n  isUint256: () => isUint256,\n  uint256ToBN: () => uint256ToBN\n});\nfunction uint256ToBN(uint2562) {\n  return new CairoUint256(uint2562).toBigInt();\n}\nfunction isUint256(bn) {\n  return CairoUint256.is(bn);\n}\nfunction bnToUint256(bn) {\n  return new CairoUint256(bn).toUint256HexString();\n}\n\n// src/signer/ethSigner.ts\nvar EthSigner = class {\n  pk;\n  // hex string without 0x and with an odd number of characters\n  constructor(pk = ethRandomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk).padStart(64, \"0\") : removeHexPrefix(toHex(pk)).padStart(64, \"0\");\n  }\n  /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  async getPubKey() {\n    return addHexPrefix(\n      buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.getPublicKey(this.pk, false)).padStart(130, \"0\").slice(2)\n    );\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */\n  formatEthSignature(ethSignature) {\n    const r = bnToUint256(ethSignature.r);\n    const s = bnToUint256(ethSignature.s);\n    return [\n      toHex(r.low),\n      toHex(r.high),\n      toHex(s.low),\n      toHex(s.high),\n      toHex(ethSignature.recovery)\n    ];\n  }\n};\n\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n  getAbiEvents: () => getAbiEvents,\n  isAbiEvent: () => isAbiEvent,\n  isObject: () => isObject,\n  parseEvents: () => parseEvents,\n  parseUDCEvent: () => parseUDCEvent\n});\nfunction isAbiEvent(object) {\n  return object.type === \"event\";\n}\nfunction getCairo0AbiEvents(abi) {\n  return abi.filter((abiEntry) => abiEntry.type === \"event\").reduce((acc, abiEntry) => {\n    const entryName = abiEntry.name;\n    const abiEntryMod = { ...abiEntry };\n    abiEntryMod.name = entryName;\n    return {\n      ...acc,\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n    };\n  }, {});\n}\nfunction getCairo1AbiEvents(abi) {\n  const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === \"struct\");\n  const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === \"enum\");\n  const abiEventsData = abiEventsStructs.reduce((acc, event) => {\n    let nameList = [];\n    let { name } = event;\n    let flat = false;\n    const findName = (variant) => variant.type === name;\n    while (true) {\n      const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));\n      if (typeof eventEnum === \"undefined\")\n        break;\n      const variant = eventEnum.variants.find(findName);\n      nameList.unshift(variant.name);\n      if (variant.kind === \"flat\")\n        flat = true;\n      name = eventEnum.name;\n    }\n    if (nameList.length === 0) {\n      throw new Error(\"inconsistency in ABI events definition.\");\n    }\n    if (flat)\n      nameList = [nameList[nameList.length - 1]];\n    const final = nameList.pop();\n    let result = {\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(final)).toString(16))]: event\n    };\n    while (nameList.length > 0) {\n      result = {\n        [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(nameList.pop())).toString(16))]: result\n      };\n    }\n    result = { ...result };\n    return mergeAbiEvents(acc, result);\n  }, {});\n  return abiEventsData;\n}\nfunction getAbiEvents(abi) {\n  return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);\n}\nfunction isObject(item) {\n  return item && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction mergeAbiEvents(target, source) {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target))\n          Object.assign(output, { [key]: source[key] });\n        else\n          output[key] = mergeAbiEvents(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n  const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {\n    let abiEvent = abiEvents[recEvent.keys.shift() ?? 0];\n    if (!abiEvent) {\n      return acc;\n    }\n    while (!abiEvent.name) {\n      const hashName = recEvent.keys.shift();\n      assert(!!hashName, 'Not enough data in \"key\" property of this event.');\n      abiEvent = abiEvent[hashName];\n    }\n    const parsedEvent = {};\n    parsedEvent[abiEvent.name] = {};\n    const keysIter = recEvent.keys[Symbol.iterator]();\n    const dataIter = recEvent.data[Symbol.iterator]();\n    const abiEventKeys = abiEvent.members?.filter((it) => it.kind === \"key\") || abiEvent.keys;\n    const abiEventData = abiEvent.members?.filter((it) => it.kind === \"data\") || abiEvent.data;\n    abiEventKeys.forEach((key) => {\n      parsedEvent[abiEvent.name][key.name] = responseParser(\n        keysIter,\n        key,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    abiEventData.forEach((data) => {\n      parsedEvent[abiEvent.name][data.name] = responseParser(\n        dataIter,\n        data,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    acc.push(parsedEvent);\n    return acc;\n  }, []);\n  return ret;\n}\nfunction parseUDCEvent(txReceipt) {\n  if (!txReceipt.events) {\n    throw new Error(\"UDC emitted event is empty\");\n  }\n  const event = txReceipt.events.find(\n    (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: []\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1]\n  };\n}\n\n// src/account/default.ts\nvar Account = class extends RpcProvider2 {\n  signer;\n  address;\n  cairoVersion;\n  transactionVersion;\n  constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = api_exports.ETransactionVersion.V2) {\n    super(providerOrOptions);\n    this.address = address.toLowerCase();\n    this.signer = isString(pkOrSigner) || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString();\n    }\n    this.transactionVersion = transactionVersion;\n  }\n  // provided version or contract based preferred transactionVersion\n  getPreferredVersion(type12, type3) {\n    if (this.transactionVersion === api_exports.ETransactionVersion.V3)\n      return type3;\n    if (this.transactionVersion === api_exports.ETransactionVersion.V2)\n      return type12;\n    return api_exports.ETransactionVersion.V3;\n  }\n  async getNonce(blockIdentifier) {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n  async getNonceSafe(nonce) {\n    try {\n      return toBigInt(nonce ?? await this.getNonce());\n    } catch (error) {\n      return 0n;\n    }\n  }\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  async getCairoVersion(classHash) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n  async estimateFee(calls, estimateFeeDetails = {}) {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n  async estimateInvokeFee(calls, details = {}) {\n    const {\n      nonce: providedNonce,\n      blockIdentifier,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n      skipValidate\n    };\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    return super.getInvokeEstimateFee(\n      { ...invocation },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeclareFee(payload, details = {}) {\n    const {\n      blockIdentifier,\n      nonce: providedNonce,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.F1 : this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const declareContractTransaction = await this.buildDeclarePayload(payload, {\n      ...v3Details(details),\n      nonce,\n      chainId,\n      version,\n      walletAddress: this.address,\n      maxFee: ZERO,\n      cairoVersion: void 0,\n      // unused parameter\n      skipValidate\n    });\n    return super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateAccountDeployFee({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress\n  }, details = {}) {\n    const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress },\n      {\n        ...v3Details(details),\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address,\n        // unused parameter\n        maxFee: ZERO,\n        cairoVersion: void 0,\n        // unused parameter,\n        skipValidate\n      }\n    );\n    return super.getDeployAccountEstimateFee(\n      { ...payload },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeployFee(payload, details = {}) {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, details);\n  }\n  async estimateFeeBulk(invocations, details = {}) {\n    const { nonce, blockIdentifier, version, skipValidate } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.F1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n          version\n        )\n        // sierra\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate\n    });\n  }\n  async simulateTransaction(invocations, details = {}) {\n    const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.V1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n          version\n        )\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute\n    });\n  }\n  async execute(transactions, arg2, transactionsDetail = {}) {\n    const details = arg2 === void 0 || Array.isArray(arg2) ? transactionsDetail : arg2;\n    const calls = Array.isArray(transactions) ? transactions : [transactions];\n    const nonce = toBigInt(details.nonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      // TODO: does this depend on cairo version ?\n      details.version\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      { type: \"INVOKE_FUNCTION\" /* INVOKE */, payload: transactions },\n      {\n        ...details,\n        version\n      }\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      walletAddress: this.address,\n      nonce,\n      maxFee: estimate.maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion()\n    };\n    const signature = await this.signer.signTransaction(calls, signerDetails);\n    const calldata = getExecuteCalldata(calls, await this.getCairoVersion());\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        ...v3Details(details),\n        resourceBounds: estimate.resourceBounds,\n        nonce,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  async declareIfNot(payload, transactionsDetail = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: \"\",\n      class_hash: declareContractPayload.classHash\n    };\n  }\n  async declare(payload, details = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    const { nonce, version: providedVersion } = details;\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.V1 : this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n      providedVersion\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: \"DECLARE\" /* DECLARE */,\n        payload: declareContractPayload\n      },\n      {\n        ...details,\n        version\n      }\n    );\n    const declareDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      nonce: toBigInt(nonce ?? await this.getNonce()),\n      version,\n      chainId: await this.getChainId(),\n      walletAddress: this.address,\n      cairoVersion: void 0\n    };\n    const declareContractTransaction = await this.buildDeclarePayload(\n      declareContractPayload,\n      declareDetails\n    );\n    return this.declareContract(declareContractTransaction, declareDetails);\n  }\n  async deploy(payload, details = {}) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls, void 0, details);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  async deployContract(payload, details = {}) {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt);\n  }\n  async declareAndDeploy(payload, details = {}) {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== \"\") {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n  deploySelf = this.deployAccount;\n  async deployAccount({\n    classHash,\n    constructorCalldata = [],\n    addressSalt = 0,\n    contractAddress: providedContractAddress\n  }, details = {}) {\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      details.version\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress\n        }\n      },\n      details\n    );\n    const signature = await this.signer.signDeployAccountTransaction({\n      ...v3Details(details),\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      version,\n      nonce\n    });\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        ...v3Details(details),\n        nonce,\n        resourceBounds: estimate.resourceBounds,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  async signMessage(typedData) {\n    return this.signer.signMessage(typedData, this.address);\n  }\n  async hashMessage(typedData) {\n    return getMessageHash(typedData, this.address);\n  }\n  async verifyMessageHash(hash, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n    const knownSigVerificationFName = signatureVerificationFunctionName ? [signatureVerificationFunctionName] : [\"isValidSignature\", \"is_valid_signature\"];\n    const knownSignatureResponse = signatureVerificationResponse || {\n      okResponse: [\n        // any non-nok response is true\n      ],\n      nokResponse: [\n        \"0x0\",\n        // Devnet\n        \"0x00\"\n        // OpenZeppelin 0.7.0 to 0.9.0 invalid signature\n      ],\n      error: [\n        \"argent/invalid-signature\",\n        // ArgentX 0.3.0 to 0.3.1\n        \"is invalid, with respect to the public key\",\n        // OpenZeppelin until 0.6.1, Braavos 0.0.11\n        \"INVALID_SIG\"\n        // Braavos 1.0.0\n      ]\n    };\n    let error;\n    for (const SigVerificationFName of knownSigVerificationFName) {\n      try {\n        const resp = await this.callContract({\n          contractAddress: this.address,\n          entrypoint: SigVerificationFName,\n          calldata: CallData.compile({\n            hash: toBigInt(hash).toString(),\n            signature: formatSignature(signature)\n          })\n        });\n        if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {\n          return false;\n        }\n        if (knownSignatureResponse.okResponse.length === 0 || knownSignatureResponse.okResponse.includes(resp[0].toString())) {\n          return true;\n        }\n        throw Error(\"signatureVerificationResponse Error: response is not part of known responses\");\n      } catch (err) {\n        if (knownSignatureResponse.error.some(\n          (errMessage) => err.message.includes(errMessage)\n        )) {\n          return false;\n        }\n        error = err;\n      }\n    }\n    throw Error(`Signature verification Error: ${error}`);\n  }\n  async verifyMessage(typedData, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n    const hash = await this.hashMessage(typedData);\n    return this.verifyMessageHash(\n      hash,\n      signature,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n  /*\n   * Support methods\n   */\n  async getUniversalSuggestedFee(version, { type, payload }, details) {\n    let maxFee = 0;\n    let resourceBounds = estimateFeeToBounds(ZERO);\n    if (version === api_exports.ETransactionVersion.V3) {\n      resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({ type, payload }, details)).resourceBounds;\n    } else {\n      maxFee = details.maxFee ?? (await this.getSuggestedFee({ type, payload }, details)).suggestedMaxFee;\n    }\n    return {\n      maxFee,\n      resourceBounds\n    };\n  }\n  async getSuggestedFee({ type, payload }, details) {\n    let feeEstimate;\n    switch (type) {\n      case \"INVOKE_FUNCTION\" /* INVOKE */:\n        feeEstimate = await this.estimateInvokeFee(payload, details);\n        break;\n      case \"DECLARE\" /* DECLARE */:\n        feeEstimate = await this.estimateDeclareFee(payload, details);\n        break;\n      case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */:\n        feeEstimate = await this.estimateAccountDeployFee(payload, details);\n        break;\n      case \"DEPLOY\" /* DEPLOY */:\n        feeEstimate = await this.estimateDeployFee(payload, details);\n        break;\n      default:\n        feeEstimate = {\n          gas_consumed: 0n,\n          gas_price: 0n,\n          overall_fee: ZERO,\n          unit: \"FRI\",\n          suggestedMaxFee: ZERO,\n          resourceBounds: estimateFeeToBounds(ZERO),\n          data_gas_consumed: 0n,\n          data_gas_price: 0n\n        };\n        break;\n    }\n    return feeEstimate;\n  }\n  async buildInvocation(call, details) {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature\n    };\n  }\n  async buildDeclarePayload(payload, details) {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n    if (typeof compiledClassHash === \"undefined\" && (details.version === api_exports.ETransactionVersion3.F3 || details.version === api_exports.ETransactionVersion3.V3)) {\n      throw Error(\"V3 Transaction work with Cairo1 Contracts and require compiledClassHash\");\n    }\n    const signature = !details.skipValidate ? await this.signer.signDeclareTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      compiledClassHash,\n      // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n      senderAddress: details.walletAddress\n    }) : [];\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash\n    };\n  }\n  async buildAccountDeployPayload({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress: providedContractAddress\n  }, details) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const signature = !details.skipValidate ? await this.signer.signDeployAccountTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      contractAddress,\n      addressSalt,\n      constructorCalldata: compiledCalldata\n    }) : [];\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature\n    };\n  }\n  buildUDCContractPayload(payload) {\n    const calls = [].concat(payload).map((it) => {\n      const {\n        classHash,\n        salt = \"0\",\n        unique = true,\n        constructorCalldata = []\n      } = it;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      };\n    });\n    return calls;\n  }\n  async accountInvocationsFactory(invocations, details) {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n    const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n    return Promise.all(\n      [].concat(invocations).map(async (transaction, index) => {\n        const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          chainId,\n          cairoVersion,\n          version: \"\",\n          skipValidate\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: \"\"\n        };\n        if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildInvocation(\n            [].concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DEPLOY\" /* DEPLOY */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            type: \"INVOKE_FUNCTION\" /* INVOKE */\n          };\n        }\n        if (transaction.type === \"DECLARE\" /* DECLARE */) {\n          const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    );\n  }\n  async getStarkName(address = this.address, StarknetIdContract2) {\n    return super.getStarkName(address, StarknetIdContract2);\n  }\n};\n\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n\n// src/wallet/connect.ts\nvar connect_exports = {};\n__export(connect_exports, {\n  addDeclareTransaction: () => addDeclareTransaction,\n  addInvokeTransaction: () => addInvokeTransaction,\n  addStarknetChain: () => addStarknetChain,\n  deploymentData: () => deploymentData,\n  getPermissions: () => getPermissions,\n  onAccountChange: () => onAccountChange,\n  onNetworkChanged: () => onNetworkChanged,\n  requestAccounts: () => requestAccounts,\n  requestChainId: () => requestChainId,\n  signMessage: () => signMessage,\n  supportedSpecs: () => supportedSpecs,\n  switchStarknetChain: () => switchStarknetChain,\n  watchAsset: () => watchAsset\n});\nfunction requestAccounts(swo, silent_mode = false) {\n  return swo.request({\n    type: \"wallet_requestAccounts\",\n    params: {\n      silent_mode\n    }\n  });\n}\nfunction getPermissions(swo) {\n  return swo.request({ type: \"wallet_getPermissions\" });\n}\nfunction watchAsset(swo, asset) {\n  return swo.request({\n    type: \"wallet_watchAsset\",\n    params: asset\n  });\n}\nfunction addStarknetChain(swo, chain) {\n  return swo.request({\n    type: \"wallet_addStarknetChain\",\n    params: chain\n  });\n}\nfunction switchStarknetChain(swo, chainId) {\n  return swo.request({\n    type: \"wallet_switchStarknetChain\",\n    params: {\n      chainId\n    }\n  });\n}\nfunction requestChainId(swo) {\n  return swo.request({ type: \"wallet_requestChainId\" });\n}\nfunction deploymentData(swo) {\n  return swo.request({ type: \"wallet_deploymentData\" });\n}\nfunction addInvokeTransaction(swo, params) {\n  return swo.request({\n    type: \"wallet_addInvokeTransaction\",\n    params\n  });\n}\nfunction addDeclareTransaction(swo, params) {\n  return swo.request({\n    type: \"wallet_addDeclareTransaction\",\n    params\n  });\n}\nfunction signMessage(swo, typedData) {\n  return swo.request({\n    type: \"wallet_signTypedData\",\n    params: typedData\n  });\n}\nfunction supportedSpecs(swo) {\n  return swo.request({ type: \"wallet_supportedSpecs\" });\n}\nfunction onAccountChange(swo, callback) {\n  swo.on(\"accountsChanged\", callback);\n}\nfunction onNetworkChanged(swo, callback) {\n  swo.on(\"networkChanged\", callback);\n}\n\n// src/wallet/account.ts\nvar WalletAccount = class extends Account {\n  address = \"\";\n  walletProvider;\n  constructor(providerOrOptions, walletProvider, cairoVersion) {\n    super(providerOrOptions, \"\", \"\", cairoVersion);\n    this.walletProvider = walletProvider;\n    this.walletProvider.on(\"accountsChanged\", (res) => {\n      if (!res)\n        return;\n      this.address = res[0].toLowerCase();\n    });\n    this.walletProvider.on(\"networkChanged\", (res) => {\n      if (!res)\n        return;\n      this.channel.setChainId(res);\n    });\n    walletProvider.request({\n      type: \"wallet_requestAccounts\",\n      params: {\n        silent_mode: false\n      }\n    }).then((res) => {\n      this.address = res[0].toLowerCase();\n    });\n  }\n  /**\n   * WALLET EVENTS\n   */\n  onAccountChange(callback) {\n    onAccountChange(this.walletProvider, callback);\n  }\n  onNetworkChanged(callback) {\n    onNetworkChanged(this.walletProvider, callback);\n  }\n  /**\n   * WALLET SPECIFIC METHODS\n   */\n  requestAccounts(silentMode = false) {\n    return requestAccounts(this.walletProvider, silentMode);\n  }\n  getPermissions() {\n    return getPermissions(this.walletProvider);\n  }\n  switchStarknetChain(chainId) {\n    return switchStarknetChain(this.walletProvider, chainId);\n  }\n  watchAsset(asset) {\n    return watchAsset(this.walletProvider, asset);\n  }\n  addStarknetChain(chain) {\n    return addStarknetChain(this.walletProvider, chain);\n  }\n  /**\n   * ACCOUNT METHODS\n   */\n  execute(calls) {\n    const txCalls = [].concat(calls).map((it) => {\n      const { contractAddress, entrypoint, calldata } = it;\n      return {\n        contract_address: contractAddress,\n        entry_point: entrypoint,\n        calldata\n      };\n    });\n    const params = {\n      calls: txCalls\n    };\n    return addInvokeTransaction(this.walletProvider, params);\n  }\n  declare(payload) {\n    const declareContractPayload = extractContractHashes(payload);\n    const pContract = payload.contract;\n    const cairo1Contract = {\n      ...pContract,\n      abi: stringify2(pContract.abi)\n    };\n    if (!declareContractPayload.compiledClassHash) {\n      throw Error(\"compiledClassHash is required\");\n    }\n    const params = {\n      compiled_class_hash: declareContractPayload.compiledClassHash,\n      contract_class: cairo1Contract\n    };\n    return addDeclareTransaction(this.walletProvider, params);\n  }\n  async deploy(payload) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  signMessage(typedData) {\n    return signMessage(this.walletProvider, typedData);\n  }\n  // TODO: MISSING ESTIMATES\n};\n\n// src/contract/default.ts\nvar splitArgsAndOptions = (args) => {\n  const options = [\n    \"blockIdentifier\",\n    \"parseRequest\",\n    \"parseResponse\",\n    \"formatResponse\",\n    \"maxFee\",\n    \"nonce\",\n    \"signature\",\n    \"addressSalt\"\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === \"object\" && options.some((x) => x in lastArg)) {\n    return { args, options: args.pop() };\n  }\n  return { args };\n};\nfunction buildCall(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options\n    });\n  };\n}\nfunction buildInvoke(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options\n    });\n  };\n}\nfunction buildDefault(contract, functionAbi) {\n  if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n  return function(...args) {\n    return contract.populate(functionAbi.name, args);\n  };\n}\nfunction buildEstimate(contract, functionAbi) {\n  return function(...args) {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\nfunction getCalldata(args, callback) {\n  if (Array.isArray(args) && \"__compiled__\" in args)\n    return args;\n  if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0])\n    return args[0];\n  return callback();\n}\nvar Contract = class {\n  abi;\n  address;\n  providerOrAccount;\n  deployTransactionHash;\n  structs;\n  events;\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n  callData;\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(abi, address, providerOrAccount = defaultProvider) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false }\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== \"function\")\n        return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement)\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement)\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement)\n        });\n      }\n    });\n  }\n  attach(address) {\n    this.address = address;\n  }\n  connect(providerOrAccount) {\n    this.providerOrAccount = providerOrAccount;\n  }\n  async deployed() {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = void 0;\n    }\n    return this;\n  }\n  async call(method, args = [], {\n    parseRequest = true,\n    parseResponse = true,\n    formatResponse = void 0,\n    blockIdentifier = void 0\n  } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"CALL\" /* CALL */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    return this.providerOrAccount.callContract(\n      {\n        contractAddress: this.address,\n        calldata,\n        entrypoint: method\n      },\n      blockIdentifier\n    ).then((it) => {\n      if (!parseResponse) {\n        return it;\n      }\n      if (formatResponse) {\n        return this.callData.format(method, it, formatResponse);\n      }\n      return this.callData.parse(method, it);\n    });\n  }\n  invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method\n    };\n    if (\"execute\" in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, void 0, {\n        maxFee,\n        nonce\n      });\n    }\n    if (!nonce)\n      throw new Error(`Nonce is required when invoking a function without an account`);\n    console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature\n      },\n      {\n        nonce\n      }\n    );\n  }\n  async estimate(method, args = []) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n    }\n    const invocation = this.populate(method, args);\n    if (\"estimateInvokeFee\" in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error(\"Contract must be connected to the account contract to estimate\");\n  }\n  populate(method, args = []) {\n    const calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata\n    };\n  }\n  parseEvents(receipt) {\n    return parseEvents(\n      receipt.events?.filter(\n        (event) => cleanHex(event.from_address) === cleanHex(this.address),\n        []\n      ) || [],\n      this.events,\n      this.structs,\n      CallData.getAbiEnum(this.abi)\n    );\n  }\n  isCairo1() {\n    return cairo_exports.isCairo1Abi(this.abi);\n  }\n  async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n  typedv2(tAbi) {\n    return this;\n  }\n};\n\n// src/contract/interface.ts\nvar ContractInterface = class {\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n};\n\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n  compiledContract;\n  account;\n  abi;\n  classHash;\n  casm;\n  compiledClassHash;\n  CallData;\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  async deploy(...args) {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(\"DEPLOY\" /* DEPLOY */, \"constructor\", param);\n        return this.CallData.compile(\"constructor\", param);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return param;\n    });\n    const {\n      deploy: { contract_address, transaction_hash }\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt\n    });\n    assert(Boolean(contract_address), \"Deployment of the contract failed\");\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n    return contractInstance;\n  }\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account) {\n    this.account = account;\n    return this;\n  }\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address) {\n    return new Contract(this.abi, address, this.account);\n  }\n  // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n};\n\n// src/utils/responseParser/interface.ts\nvar ResponseParser = class {\n};\n\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n  const hex = toHex(addHexPrefix(address.toString()));\n  const padded = removeHexPrefix(hex).padStart(64, \"0\");\n  return addHexPrefix(padded);\n}\nfunction validateAndParseAddress(address) {\n  const result = addAddressPadding(address);\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error(\"Invalid Address Format\");\n  }\n  assertInRange(result, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n  return result;\n}\nfunction getChecksumAddress(address) {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(hex.padStart(64, \"0\"));\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 15) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n  return getChecksumAddress(address) === address;\n}\n\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n  if (!s) {\n    return false;\n  }\n  if (typeof s !== \"string\") {\n    return false;\n  }\n  const match = s.match(protocolAndDomainRE);\n  if (!match) {\n    return false;\n  }\n  const everythingAfterProtocol = match[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n    return true;\n  }\n  return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n  return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_15__(baseUrl, urlOrPath ?? defaultPath);\n}\n\n// src/index.ts\nvar number = num_exports;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBUztBQUM1QixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQ0FBbUM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0Esd0JBQXdCLDhDQUFzQjtBQUNDO0FBQ2E7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ29DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0NBQU07QUFDZjtBQUNBO0FBQ0EsU0FBUywrQ0FBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9CQUFvQjtBQUMzRSxtREFBbUQsb0JBQW9CO0FBQ3ZFO0FBQ0E7QUFDQSx1REFBdUQsb0JBQW9CO0FBQzNFLG1EQUFtRCxvQkFBb0I7QUFDdkU7QUFDQTs7QUFFQTtBQUMwRDtBQUNWOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0VBQWlCO0FBQzVDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsWUFBWTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlDQUFpQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjs7QUFFakI7QUFHMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFdBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQSxTQUFTLHdFQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3dDO0FBQ3pDO0FBQ0E7QUFDQSw2RUFBNkUsaUJBQWlCO0FBQzlGLHNCQUFzQix1REFBTTtBQUM1QjtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUksc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJLEdBQUcsVUFBVSwyQkFBMkIsSUFBSSxHQUFHLFdBQVcseUJBQXlCLGlCQUFpQjtBQUNsSjtBQUNBLEdBQUc7QUFDSDtBQUNBLG1EQUFtRCxJQUFJLEdBQUcsV0FBVyxXQUFXLElBQUksR0FBRyxVQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUyxrQ0FBa0MsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QixRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sa0NBQWtDLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVksY0FBYyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxjQUFjLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxnQkFBZ0IsWUFBWSxvREFBb0Qsa0JBQWtCLEVBQUUsVUFBVTtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLGNBQWMsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVksY0FBYyxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxjQUFjLFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLGNBQWMsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVksY0FBYyxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxLQUFLLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVksS0FBSyxZQUFZO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxjQUFjLFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVksY0FBYyxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxVQUFVLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxnQkFBZ0IsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWSxjQUFjLFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZLHdCQUF3QixXQUFXO0FBQ3BFO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBLHVCQUF1QixZQUFZLHlCQUF5QixLQUFLO0FBQ2pFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVksc0JBQXNCLFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxTQUFTLFdBQVcsbUJBQW1CLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQ0FBa0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQ0FBa0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQztBQUNyRjtBQUNBO0FBQ0EseURBQXlELDBCQUEwQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxTQUFTLFdBQVcsVUFBVSxVQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVcsU0FBUyxXQUFXLFVBQVUsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVcsU0FBUyxXQUFXLFVBQVUsVUFBVTtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsMkRBQTJEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYyxxQkFBcUIsWUFBWTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkJBQTZCLEdBQUc7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sRUFBRSxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQyxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ3pGLDBCQUEwQixPQUFPLEVBQUUsR0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0MsS0FBSyxPQUFPLEVBQUUsR0FBRztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxFQUFFLEdBQUc7QUFDeEM7QUFDQSxrQ0FBa0Msd0NBQXdDLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDM0Y7QUFDQSx3Q0FBd0MsT0FBTyxFQUFFLEdBQUc7QUFDcEQ7QUFDQSxzQkFBc0IsT0FBTyxFQUFFLEdBQUc7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFRO0FBQzFCO0FBQ0EsQ0FBQztBQUMyRDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFVO0FBQzlCLHFCQUFxQiwrREFBVztBQUNoQyxDQUFDO0FBQzZDO0FBQ29COztBQUVsRTtBQUNBO0FBQ0EsaURBQWlELHFEQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2tEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpRUFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpRUFBZ0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUVBQWdCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlFQUFnQixnQ0FBZ0MsaUVBQWdCO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3dFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUM7QUFDdEM7QUFDQSxPQUFPLG9EQUFjO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFVO0FBQ2hDLGdDQUFnQyxnREFBVSxzQkFBc0IsK0RBQXlCO0FBQ3pGLGlFQUFpRSxvREFBYztBQUMvRTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxxREFBbUI7QUFDNUI7QUFDQTtBQUNBLGVBQWUseURBQXVCO0FBQ3RDO0FBQ0E7QUFDQSxpREFBaUQscURBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLDBCQUEwQjtBQUMxQjtBQUNBLHNCQUFzQixtREFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUVBQWlCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLGlFQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpRUFBaUI7QUFDMUMsR0FBRztBQUNILGNBQWMsaUVBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGlFQUFpQjtBQUNqRztBQUNBLElBQUksaUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyxpRUFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1EQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFpQjtBQUN6QztBQUNBLElBQUksaUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ29EO0FBQ2pCO0FBQ3BDO0FBQ0E7QUFDQSw0QkFBNEIsMENBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0Q0FBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQUs7QUFDN0IsU0FBUyw0REFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBOEM7QUFDOUQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDbUQ7QUFDcEQ7QUFDQSw2QkFBNkIsOERBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBOztBQUVBO0FBQzJDO0FBQ0k7QUFDL0M7QUFDQSxpQ0FBaUMseURBQWU7QUFDaEQsOENBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUix1REFBdUQsYUFBYTtBQUNwRTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEMsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLHFEQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZFQUE2RTtBQUN6RjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQSxnQkFBZ0IsUUFBUSxjQUFjOztBQUV0QyxVQUFVLEtBQUssSUFBSSxRQUFRLElBQUksaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsVUFBVTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxpQkFBaUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxrQkFBa0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsSUFBSSxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDLDZEQUE2RDtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdURBQXVEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBd0Q7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUEwRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQSxnQkFBZ0IsUUFBUSxjQUFjO0FBQ3RDO0FBQ0EsVUFBVSxLQUFLLElBQUksUUFBUSxJQUFJLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsaUJBQWlCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0JBQWtCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUF5QjtBQUNwRDtBQUNBLDJCQUEyQiwrREFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkVBQXFDO0FBQzNDLE1BQU0sa0VBQTRCO0FBQ2xDLE1BQU0sa0VBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQixJQUFJLGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0MsNkRBQTZEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtEQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRUFBMEI7QUFDMUM7QUFDQSxtQkFBbUIsbUVBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGdCQUFnQixnRUFBMEI7QUFDMUM7QUFDQTtBQUNBLG1CQUFtQixtRUFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1REFBdUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLG1CQUFtQixtRUFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGdCQUFnQixnRUFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLG1CQUFtQixtRUFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGdCQUFnQixnRUFBMEI7QUFDMUM7QUFDQTtBQUNBLG1CQUFtQixtRUFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUF3RDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRUFBMEI7QUFDMUM7QUFDQSxtQkFBbUIsbUVBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGdCQUFnQixnRUFBMEI7QUFDMUMsbUJBQW1CLG1FQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnRUFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0VBQVUsQ0FBQywrREFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEUsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysb0NBQW9DO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGdEQUFLO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxlQUFlOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLEdBQUcsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0IsSUFBSSxnQ0FBZ0M7QUFDMUY7QUFDQSxRQUFRLG9EQUFvRCxJQUFJLGtDQUFrQztBQUNsRztBQUNBO0FBQ0EsUUFBUSx5REFBeUQsSUFBSSxvQ0FBb0M7QUFDekc7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnRUFBaUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEVBQUU7QUFDbkM7QUFDQSxHQUFHO0FBQ0gsR0FBRyxnRUFBaUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBLDBDQUEwQyxPQUFPLEdBQUcsS0FBSyxzQkFBc0IsSUFBSSxJQUFJLElBQUk7QUFDM0Y7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQyw0QkFBNEIsZ0VBQWlCLGdEQUFnRCxnRUFBaUI7QUFDOUcsV0FBVyxnRUFBaUI7QUFDNUIsNEJBQTRCLGdFQUFpQixnREFBZ0QsZ0VBQWlCLGFBQWEsZ0VBQWlCO0FBQzVJLFdBQVcsZ0VBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixnRUFBaUI7QUFDcEc7QUFDQTtBQUNBLElBQUksc0JBQXNCLGdFQUFpQjtBQUMzQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBLHlGQUF5RixRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0VBQWlCO0FBQzdELGdDQUFnQyxnRUFBaUIsWUFBWSwyREFBMkQ7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnRUFBaUI7QUFDNUUsNERBQTRELHdFQUF3RTtBQUNwSSxnQkFBZ0IsWUFBWSxHQUFHLFdBQVc7QUFDMUMsS0FBSztBQUNMLGNBQWMsZ0JBQWdCLEdBQUcsbUJBQW1CO0FBQ3BELEdBQUc7QUFDSDtBQUNBLDZDQUE2QyxnRUFBaUI7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxhQUFhLGdFQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFpQjtBQUN4QywrREFBK0QsTUFBTSxFQUFFLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0VBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdFQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQWU7QUFDMUI7QUFDQTs7QUFFQTtBQUNrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQiw4REFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsOERBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsOERBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFpQjtBQUNyQztBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFpQjtBQUN2QztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlO0FBQ3ZCLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsY0FBYztBQUNqQixZQUFZLGlFQUFpRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQThEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVk7QUFDcEIsUUFBUSx1Q0FBdUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFlBQVksZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscURBQXFEO0FBQ3JELFlBQVksb0VBQW9FO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2REFBNkQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFvRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRLGtFQUFrRTtBQUMxRTtBQUNBO0FBQ0EsYUFBYSxXQUFXLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGNBQWM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSx3REFBd0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RixNQUFNO0FBQ04sK0RBQStELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsWUFBWTtBQUM1RixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQSxtQkFBbUIsMkJBQTJCLG1CQUFtQjtBQUNqRSxvQkFBb0IsMkJBQTJCLG1CQUFtQjtBQUNsRSw2QkFBNkIsMkJBQTJCLG1CQUFtQjtBQUMzRSxxQkFBcUIsMkJBQTJCO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLGdEQUFnRCxJQUFJO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5Qix1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUN5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0VBQVc7QUFDNUIsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDL0I7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQ0FBTztBQUMvQzs7QUFFQTtBQUNBO0FBNkZFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZCwgc2Vjb25kVGFyZ2V0KSA9PiAoX19jb3B5UHJvcHModGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSwgc2Vjb25kVGFyZ2V0ICYmIF9fY29weVByb3BzKHNlY29uZFRhcmdldCwgbW9kLCBcImRlZmF1bHRcIikpO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgY29uc3RhbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnN0YW50c19leHBvcnRzLCB7XG4gIEFERFJfQk9VTkQ6ICgpID0+IEFERFJfQk9VTkQsXG4gIEFQSV9WRVJTSU9OOiAoKSA9PiBBUElfVkVSU0lPTixcbiAgQmFzZVVybDogKCkgPT4gQmFzZVVybCxcbiAgRmVlTWFyZ2luUGVyY2VudGFnZTogKCkgPT4gRmVlTWFyZ2luUGVyY2VudGFnZSxcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgTUFTS18yNTA6ICgpID0+IE1BU0tfMjUwLFxuICBNQVhfU1RPUkFHRV9JVEVNX1NJWkU6ICgpID0+IE1BWF9TVE9SQUdFX0lURU1fU0laRSxcbiAgTmV0d29ya05hbWU6ICgpID0+IE5ldHdvcmtOYW1lLFxuICBQUklNRTogKCkgPT4gUFJJTUUsXG4gIFJBTkdFX0ZFTFQ6ICgpID0+IFJBTkdFX0ZFTFQsXG4gIFJBTkdFX0kxMjg6ICgpID0+IFJBTkdFX0kxMjgsXG4gIFJBTkdFX1UxMjg6ICgpID0+IFJBTkdFX1UxMjgsXG4gIFJQQ19ERUZBVUxUX1ZFUlNJT046ICgpID0+IFJQQ19ERUZBVUxUX1ZFUlNJT04sXG4gIFJQQ19OT0RFUzogKCkgPT4gUlBDX05PREVTLFxuICBTdGFya25ldENoYWluSWQ6ICgpID0+IFN0YXJrbmV0Q2hhaW5JZCxcbiAgVEVYVF9UT19GRUxUX01BWF9MRU46ICgpID0+IFRFWFRfVE9fRkVMVF9NQVhfTEVOLFxuICBUUkFOU0FDVElPTl9WRVJTSU9OOiAoKSA9PiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXg6ICgpID0+IFRyYW5zYWN0aW9uSGFzaFByZWZpeCxcbiAgVURDOiAoKSA9PiBVREMsXG4gIFpFUk86ICgpID0+IFpFUk9cbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL2luZGV4LnRzXG52YXIgYXBpX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGFwaV9leHBvcnRzLCB7XG4gIEpSUEM6ICgpID0+IGpzb25ycGNfZXhwb3J0cyxcbiAgUlBDU1BFQzA2OiAoKSA9PiBycGNzcGVjXzBfNl9leHBvcnRzLFxuICBSUENTUEVDMDc6ICgpID0+IFJQQ1NQRUMwN1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvanNvbnJwYy9pbmRleC50c1xudmFyIGpzb25ycGNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWNfMF82L2luZGV4LnRzXG52YXIgcnBjc3BlY18wXzZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjc3BlY18wXzZfZXhwb3J0cywge1xuICBFQmxvY2tUYWc6ICgpID0+IEVCbG9ja1RhZyxcbiAgRURBTW9kZTogKCkgPT4gRURBTW9kZSxcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlOiAoKSA9PiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gIEVTaW11bGF0aW9uRmxhZzogKCkgPT4gRVNpbXVsYXRpb25GbGFnLFxuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBFVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uVHlwZTogKCkgPT4gRVRyYW5zYWN0aW9uVHlwZSxcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI6ICgpID0+IEVUcmFuc2FjdGlvblZlcnNpb24yLFxuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbjMsXG4gIEVycm9yczogKCkgPT4gZXJyb3JzX2V4cG9ydHMsXG4gIFNQRUM6ICgpID0+IGNvbXBvbmVudHNfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvZXJyb3JzLnRzXG52YXIgZXJyb3JzX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjXzBfNi9jb21wb25lbnRzLnRzXG52YXIgY29tcG9uZW50c19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvbm9uc3BlYy50c1xudmFyIEVUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVHlwZTI7XG59KShFVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBFU2ltdWxhdGlvbkZsYWcgPSAvKiBAX19QVVJFX18gKi8gKChFU2ltdWxhdGlvbkZsYWcyKSA9PiB7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX0ZFRV9DSEFSR0VcIl0gPSBcIlNLSVBfRkVFX0NIQVJHRVwiO1xuICByZXR1cm4gRVNpbXVsYXRpb25GbGFnMjtcbn0pKEVTaW11bGF0aW9uRmxhZyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRUJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoRUJsb2NrVGFnMikgPT4ge1xuICBFQmxvY2tUYWcyW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICBFQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgcmV0dXJuIEVCbG9ja1RhZzI7XG59KShFQmxvY2tUYWcgfHwge30pO1xudmFyIEVEYXRhQXZhaWxhYmlsaXR5TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVEYXRhQXZhaWxhYmlsaXR5TW9kZTMpID0+IHtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlM1tcIkwxXCJdID0gXCJMMVwiO1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUzW1wiTDJcIl0gPSBcIkwyXCI7XG4gIHJldHVybiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUzO1xufSkoRURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IHt9KTtcbnZhciBFREFNb2RlID0gLyogQF9fUFVSRV9fICovICgoRURBTW9kZTQpID0+IHtcbiAgRURBTW9kZTRbRURBTW9kZTRbXCJMMVwiXSA9IDBdID0gXCJMMVwiO1xuICBFREFNb2RlNFtFREFNb2RlNFtcIkwyXCJdID0gMV0gPSBcIkwyXCI7XG4gIHJldHVybiBFREFNb2RlNDtcbn0pKEVEQU1vZGUgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uMTApID0+IHtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiVjBcIl0gPSBcIjB4MFwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJWMVwiXSA9IFwiMHgxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIlYyXCJdID0gXCIweDJcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiVjNcIl0gPSBcIjB4M1wiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJGMFwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiRjFcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIkYyXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMlwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJGM1wiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb24xMDtcbn0pKEVUcmFuc2FjdGlvblZlcnNpb24gfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24yID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uVmVyc2lvbjI1KSA9PiB7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIlYwXCJdID0gXCIweDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiVjFcIl0gPSBcIjB4MVwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJWMlwiXSA9IFwiMHgyXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIkYwXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJGMVwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiRjJcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25WZXJzaW9uMjU7XG59KShFVHJhbnNhY3Rpb25WZXJzaW9uMiB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uVmVyc2lvbjMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uMzYpID0+IHtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjM2W1wiVjNcIl0gPSBcIjB4M1wiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzZbXCJGM1wiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb24zNjtcbn0pKEVUcmFuc2FjdGlvblZlcnNpb24zIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9pbmRleC50c1xuX19yZUV4cG9ydChhcGlfZXhwb3J0cywgc3RhcmtuZXRfdHlwZXNfMDdfc3Rhcik7XG5pbXBvcnQgKiBhcyBSUENTUEVDMDcgZnJvbSBcInN0YXJrbmV0LXR5cGVzLTA3XCI7XG5pbXBvcnQgKiBhcyBzdGFya25ldF90eXBlc18wN19zdGFyIGZyb20gXCJzdGFya25ldC10eXBlcy0wN1wiO1xuXG4vLyBzcmMvdXRpbHMvZW5jb2RlLnRzXG52YXIgZW5jb2RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVuY29kZV9leHBvcnRzLCB7XG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIGFkZEhleFByZWZpeDogKCkgPT4gYWRkSGV4UHJlZml4LFxuICBhcnJheUJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBhcnJheUJ1ZmZlclRvU3RyaW5nLFxuICBhdG9iVW5pdmVyc2FsOiAoKSA9PiBhdG9iVW5pdmVyc2FsLFxuICBidG9hVW5pdmVyc2FsOiAoKSA9PiBidG9hVW5pdmVyc2FsLFxuICBidWYyaGV4OiAoKSA9PiBidWYyaGV4LFxuICBjYWxjQnl0ZUxlbmd0aDogKCkgPT4gY2FsY0J5dGVMZW5ndGgsXG4gIHBhZExlZnQ6ICgpID0+IHBhZExlZnQsXG4gIHBhc2NhbFRvU25ha2U6ICgpID0+IHBhc2NhbFRvU25ha2UsXG4gIHJlbW92ZUhleFByZWZpeDogKCkgPT4gcmVtb3ZlSGV4UHJlZml4LFxuICBzYW5pdGl6ZUJ5dGVzOiAoKSA9PiBzYW5pdGl6ZUJ5dGVzLFxuICBzYW5pdGl6ZUhleDogKCkgPT4gc2FuaXRpemVIZXgsXG4gIHN0cmluZ1RvQXJyYXlCdWZmZXI6ICgpID0+IHN0cmluZ1RvQXJyYXlCdWZmZXIsXG4gIHV0ZjhUb0FycmF5OiAoKSA9PiB1dGY4VG9BcnJheVxufSk7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBTVFJJTkdfWkVSTyA9IFwiMFwiO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb1N0cmluZyhhcnJheSkge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpLnJlZHVjZSgoZGF0YSwgYnl0ZSkgPT4gZGF0YSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gdXRmOFRvQXJyYXkoc3RyKSB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiB1dGY4VG9BcnJheShzdHIpO1xufVxuZnVuY3Rpb24gYXRvYlVuaXZlcnNhbChhKSB7XG4gIHJldHVybiBiYXNlNjQuZGVjb2RlKGEpO1xufVxuZnVuY3Rpb24gYnRvYVVuaXZlcnNhbChiKSB7XG4gIHJldHVybiBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGIpKTtcbn1cbmZ1bmN0aW9uIGJ1ZjJoZXgoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIucmVkdWNlKChyLCB4KSA9PiByICsgeC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhleFByZWZpeChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKC9eMHgvaSwgXCJcIik7XG59XG5mdW5jdGlvbiBhZGRIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBgMHgke3JlbW92ZUhleFByZWZpeChoZXgpfWA7XG59XG5mdW5jdGlvbiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIGxlZnQsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICBjb25zdCBkaWZmID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgaWYgKGRpZmYgPiAwKSB7XG4gICAgY29uc3QgcGFkID0gcGFkZGluZy5yZXBlYXQoZGlmZik7XG4gICAgcmVzdWx0ID0gbGVmdCA/IHBhZCArIHN0ciA6IHN0ciArIHBhZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFkTGVmdChzdHIsIGxlbmd0aCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIHJldHVybiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIHRydWUsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gY2FsY0J5dGVMZW5ndGgoc3RyLCBieXRlU2l6ZSA9IDgpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IHN0cjtcbiAgY29uc3QgcmVtYWluZGVyID0gbGVuZ3RoICUgYnl0ZVNpemU7XG4gIHJldHVybiByZW1haW5kZXIgPyAobGVuZ3RoIC0gcmVtYWluZGVyKSAvIGJ5dGVTaXplICogYnl0ZVNpemUgKyBieXRlU2l6ZSA6IGxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNhbml0aXplQnl0ZXMoc3RyLCBieXRlU2l6ZSA9IDgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkTGVmdChzdHIsIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUpLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplSGV4KGhleCkge1xuICBoZXggPSByZW1vdmVIZXhQcmVmaXgoaGV4KTtcbiAgaGV4ID0gc2FuaXRpemVCeXRlcyhoZXgsIDIpO1xuICBpZiAoaGV4KSB7XG4gICAgaGV4ID0gYWRkSGV4UHJlZml4KGhleCk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cbnZhciBwYXNjYWxUb1NuYWtlID0gKHRleHQpID0+IC9bYS16XS8udGVzdCh0ZXh0KSA/IHRleHQuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oXCJfXCIpLnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgVEVYVF9UT19GRUxUX01BWF9MRU4gPSAzMTtcbnZhciBaRVJPID0gMG47XG52YXIgTUFTS18yNTAgPSAybiAqKiAyNTBuIC0gMW47XG52YXIgQVBJX1ZFUlNJT04gPSBaRVJPO1xudmFyIFBSSU1FID0gMm4gKiogMjUxbiArIDE3biAqIDJuICoqIDE5Mm4gKyAxbjtcbnZhciBNQVhfU1RPUkFHRV9JVEVNX1NJWkUgPSAyNTZuO1xudmFyIEFERFJfQk9VTkQgPSAybiAqKiAyNTFuIC0gTUFYX1NUT1JBR0VfSVRFTV9TSVpFO1xudmFyIHJhbmdlID0gKG1pbiwgbWF4KSA9PiAoeyBtaW4sIG1heCB9KTtcbnZhciBSQU5HRV9GRUxUID0gcmFuZ2UoWkVSTywgUFJJTUUgLSAxbik7XG52YXIgUkFOR0VfSTEyOCA9IHJhbmdlKC0oMm4gKiogMTI3biksIDJuICoqIDEyN24gLSAxbik7XG52YXIgUkFOR0VfVTEyOCA9IHJhbmdlKFpFUk8sIDJuICoqIDEyOG4gLSAxbik7XG52YXIgQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyAoKEJhc2VVcmwyKSA9PiB7XG4gIEJhc2VVcmwyW1wiU05fTUFJTlwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1tYWlubmV0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fU0VQT0xJQVwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1zZXBvbGlhLnN0YXJrbmV0LmlvXCI7XG4gIHJldHVybiBCYXNlVXJsMjtcbn0pKEJhc2VVcmwgfHwge30pO1xudmFyIE5ldHdvcmtOYW1lID0gLyogQF9fUFVSRV9fICovICgoTmV0d29ya05hbWUyKSA9PiB7XG4gIE5ldHdvcmtOYW1lMltcIlNOX01BSU5cIl0gPSBcIlNOX01BSU5cIjtcbiAgTmV0d29ya05hbWUyW1wiU05fU0VQT0xJQVwiXSA9IFwiU05fU0VQT0xJQVwiO1xuICByZXR1cm4gTmV0d29ya05hbWUyO1xufSkoTmV0d29ya05hbWUgfHwge30pO1xudmFyIFN0YXJrbmV0Q2hhaW5JZCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0Q2hhaW5JZDYpID0+IHtcbiAgU3RhcmtuZXRDaGFpbklkNltcIlNOX01BSU5cIl0gPSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIjtcbiAgU3RhcmtuZXRDaGFpbklkNltcIlNOX1NFUE9MSUFcIl0gPSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIjtcbiAgcmV0dXJuIFN0YXJrbmV0Q2hhaW5JZDY7XG59KShTdGFya25ldENoYWluSWQgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uSGFzaFByZWZpeCA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uSGFzaFByZWZpeDIpID0+IHtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFQ0xBUkVcIl0gPSBcIjB4NjQ2NTYzNmM2MTcyNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWVwiXSA9IFwiMHg2NDY1NzA2YzZmNzlcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIklOVk9LRVwiXSA9IFwiMHg2OTZlNzY2ZjZiNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkwxX0hBTkRMRVJcIl0gPSBcIjB4NmMzMTVmNjg2MTZlNjQ2YzY1NzJcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uSGFzaFByZWZpeDI7XG59KShUcmFuc2FjdGlvbkhhc2hQcmVmaXggfHwge30pO1xudmFyIEZlZU1hcmdpblBlcmNlbnRhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChGZWVNYXJnaW5QZXJjZW50YWdlMikgPT4ge1xuICBGZWVNYXJnaW5QZXJjZW50YWdlMltGZWVNYXJnaW5QZXJjZW50YWdlMltcIkwxX0JPVU5EX01BWF9BTU9VTlRcIl0gPSA1MF0gPSBcIkwxX0JPVU5EX01BWF9BTU9VTlRcIjtcbiAgRmVlTWFyZ2luUGVyY2VudGFnZTJbRmVlTWFyZ2luUGVyY2VudGFnZTJbXCJMMV9CT1VORF9NQVhfUFJJQ0VfUEVSX1VOSVRcIl0gPSA1MF0gPSBcIkwxX0JPVU5EX01BWF9QUklDRV9QRVJfVU5JVFwiO1xuICBGZWVNYXJnaW5QZXJjZW50YWdlMltGZWVNYXJnaW5QZXJjZW50YWdlMltcIk1BWF9GRUVcIl0gPSA1MF0gPSBcIk1BWF9GRUVcIjtcbiAgcmV0dXJuIEZlZU1hcmdpblBlcmNlbnRhZ2UyO1xufSkoRmVlTWFyZ2luUGVyY2VudGFnZSB8fCB7fSk7XG52YXIgVURDID0ge1xuICBBRERSRVNTOiBcIjB4MDQxYTc4ZTc0MWU1YWYyZmVjMzRiNjk1Njc5YmM2ODkxNzQyNDM5ZjdhZmI4NDg0ZWNkNzc2NjY2MWFkMDJiZlwiLFxuICBFTlRSWVBPSU5UOiBcImRlcGxveUNvbnRyYWN0XCJcbn07XG52YXIgUlBDX0RFRkFVTFRfVkVSU0lPTiA9IFwidjBfN1wiO1xudmFyIFJQQ19OT0RFUyA9IHtcbiAgU05fTUFJTjogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL21haW5uZXQtanVuby8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YFxuICBdLFxuICBTTl9TRVBPTElBOiBbXG4gICAgYGh0dHBzOi8vc3RhcmtuZXQtc2Vwb2xpYS5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gLFxuICAgIGBodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vc2Vwb2xpYS1qdW5vLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gXG4gIF1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9ycGMudHNcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcblxuLy8gc3JjL2NoYW5uZWwvcnBjXzBfNi50c1xudmFyIHJwY18wXzZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjXzBfNl9leHBvcnRzLCB7XG4gIFJwY0NoYW5uZWw6ICgpID0+IFJwY0NoYW5uZWxcbn0pO1xuXG4vLyBzcmMvcHJvdmlkZXIvZXJyb3JzLnRzXG5mdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XG4gIGNvbnN0IHsgY2FwdHVyZVN0YWNrVHJhY2UgfSA9IEVycm9yO1xuICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcbn1cbmZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7XG4gIGNvbnN0IHsgc2V0UHJvdG90eXBlT2YgfSA9IE9iamVjdDtcbiAgc2V0UHJvdG90eXBlT2YgPyBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvdHlwZSkgOiB0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlO1xufVxudmFyIEN1c3RvbUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIHZhbHVlOiBuZXcudGFyZ2V0Lm5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGZpeFByb3RvKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICBmaXhTdGFjayh0aGlzKTtcbiAgfVxufTtcbnZhciBMaWJyYXJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEN1c3RvbUVycm9yIHtcbn07XG52YXIgR2F0ZXdheUVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcbnZhciBIdHRwRXJyb3IgPSBjbGFzcyBleHRlbmRzIExpYnJhcnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yQ29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvaW5kZXgudHNcbnZhciB0eXBlc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlc19leHBvcnRzLCB7XG4gIEJsb2NrU3RhdHVzOiAoKSA9PiBCbG9ja1N0YXR1cyxcbiAgQmxvY2tUYWc6ICgpID0+IEJsb2NrVGFnLFxuICBFbnRyeVBvaW50VHlwZTogKCkgPT4gRW50cnlQb2ludFR5cGUsXG4gIExpdGVyYWw6ICgpID0+IExpdGVyYWwsXG4gIFJQQzogKCkgPT4gYXBpX2V4cG9ydHMsXG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGU6ICgpID0+IFRyYW5zYWN0aW9uVHlwZSxcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBVaW50OiAoKSA9PiBVaW50LFxuICBWYWxpZGF0ZVR5cGU6ICgpID0+IFZhbGlkYXRlVHlwZVxufSk7XG5cbi8vIHNyYy90eXBlcy9jYWxsZGF0YS50c1xudmFyIFZhbGlkYXRlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFZhbGlkYXRlVHlwZTIpID0+IHtcbiAgVmFsaWRhdGVUeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJDQUxMXCJdID0gXCJDQUxMXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRVwiO1xuICByZXR1cm4gVmFsaWRhdGVUeXBlMjtcbn0pKFZhbGlkYXRlVHlwZSB8fCB7fSk7XG52YXIgVWludCA9IC8qIEBfX1BVUkVfXyAqLyAoKFVpbnQyKSA9PiB7XG4gIFVpbnQyW1widThcIl0gPSBcImNvcmU6OmludGVnZXI6OnU4XCI7XG4gIFVpbnQyW1widTE2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MTZcIjtcbiAgVWludDJbXCJ1MzJcIl0gPSBcImNvcmU6OmludGVnZXI6OnUzMlwiO1xuICBVaW50MltcInU2NFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTY0XCI7XG4gIFVpbnQyW1widTEyOFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiO1xuICBVaW50MltcInUyNTZcIl0gPSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbiAgVWludDJbXCJ1NTEyXCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1NTEyXCI7XG4gIHJldHVybiBVaW50Mjtcbn0pKFVpbnQgfHwge30pO1xudmFyIExpdGVyYWwgPSAvKiBAX19QVVJFX18gKi8gKChMaXRlcmFsMikgPT4ge1xuICBMaXRlcmFsMltcIkNsYXNzSGFzaFwiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiO1xuICBMaXRlcmFsMltcIkNvbnRyYWN0QWRkcmVzc1wiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xuICBMaXRlcmFsMltcIlNlY3AyNTZrMVBvaW50XCJdID0gXCJjb3JlOjpzdGFya25ldDo6c2VjcDI1NmsxOjpTZWNwMjU2azFQb2ludFwiO1xuICByZXR1cm4gTGl0ZXJhbDI7XG59KShMaXRlcmFsIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2xpYi9jb250cmFjdC9pbmRleC50c1xudmFyIEVudHJ5UG9pbnRUeXBlID0gLyogQF9fUFVSRV9fICovICgoRW50cnlQb2ludFR5cGUyKSA9PiB7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkVYVEVSTkFMXCJdID0gXCJFWFRFUk5BTFwiO1xuICBFbnRyeVBvaW50VHlwZTJbXCJMMV9IQU5ETEVSXCJdID0gXCJMMV9IQU5ETEVSXCI7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkNPTlNUUlVDVE9SXCJdID0gXCJDT05TVFJVQ1RPUlwiO1xuICByZXR1cm4gRW50cnlQb2ludFR5cGUyO1xufSkoRW50cnlQb2ludFR5cGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbGliL2luZGV4LnRzXG52YXIgVHJhbnNhY3Rpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVDTEFSRVwiXSA9IFwiREVDTEFSRVwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZXCJdID0gXCJERVBMT1lcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VfRlVOQ1RJT05cIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZTI7XG59KShUcmFuc2FjdGlvblR5cGUgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25TdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIk5PVF9SRUNFSVZFRFwiXSA9IFwiTk9UX1JFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJOT1RfUkVDRUlWRURcIl0gPSBcIk5PVF9SRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlNVQ0NFRURFRFwiXSA9IFwiU1VDQ0VFREVEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czI7XG59KShUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgQmxvY2tTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChCbG9ja1N0YXR1czIpID0+IHtcbiAgQmxvY2tTdGF0dXMyW1wiUEVORElOR1wiXSA9IFwiUEVORElOR1wiO1xuICBCbG9ja1N0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgQmxvY2tTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEJsb2NrU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICByZXR1cm4gQmxvY2tTdGF0dXMyO1xufSkoQmxvY2tTdGF0dXMgfHwge30pO1xudmFyIEJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tUYWcyKSA9PiB7XG4gIEJsb2NrVGFnMltcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgcmV0dXJuIEJsb2NrVGFnMjtcbn0pKEJsb2NrVGFnIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL3R5cGVkRGF0YS50c1xuaW1wb3J0IHtcbiAgVHlwZWREYXRhUmV2aXNpb25cbn0gZnJvbSBcInN0YXJrbmV0LXR5cGVzLTA3XCI7XG5cbi8vIHNyYy91dGlscy9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIkFzc2VydGlvbiBmYWlsdXJlXCIpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9udW0udHNcbnZhciBudW1fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobnVtX2V4cG9ydHMsIHtcbiAgYWRkUGVyY2VudDogKCkgPT4gYWRkUGVyY2VudCxcbiAgYXNzZXJ0SW5SYW5nZTogKCkgPT4gYXNzZXJ0SW5SYW5nZSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheTogKCkgPT4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5LFxuICBjbGVhbkhleDogKCkgPT4gY2xlYW5IZXgsXG4gIGdldERlY2ltYWxTdHJpbmc6ICgpID0+IGdldERlY2ltYWxTdHJpbmcsXG4gIGdldEhleFN0cmluZzogKCkgPT4gZ2V0SGV4U3RyaW5nLFxuICBnZXRIZXhTdHJpbmdBcnJheTogKCkgPT4gZ2V0SGV4U3RyaW5nQXJyYXksXG4gIGhleFRvQnl0ZXM6ICgpID0+IGhleFRvQnl0ZXMsXG4gIGhleFRvRGVjaW1hbFN0cmluZzogKCkgPT4gaGV4VG9EZWNpbWFsU3RyaW5nLFxuICBpc0JpZ0ludDogKCkgPT4gaXNCaWdJbnQsXG4gIGlzQm9vbGVhbjogKCkgPT4gaXNCb29sZWFuLFxuICBpc0hleDogKCkgPT4gaXNIZXgsXG4gIGlzTnVtYmVyOiAoKSA9PiBpc051bWJlcixcbiAgaXNTdHJpbmdXaG9sZU51bWJlcjogKCkgPT4gaXNTdHJpbmdXaG9sZU51bWJlcixcbiAgdG9CaWdJbnQ6ICgpID0+IHRvQmlnSW50LFxuICB0b0NhaXJvQm9vbDogKCkgPT4gdG9DYWlyb0Jvb2wsXG4gIHRvSGV4OiAoKSA9PiB0b0hleCxcbiAgdG9IZXhTdHJpbmc6ICgpID0+IHRvSGV4U3RyaW5nLFxuICB0b1N0b3JhZ2VLZXk6ICgpID0+IHRvU3RvcmFnZUtleVxufSk7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNOb2JsZSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBpc0hleChoZXgpIHtcbiAgcmV0dXJuIC9eMHhbMC05YS1mXSokL2kudGVzdChoZXgpO1xufVxuZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xufVxuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludCh2YWx1ZSkudG9TdHJpbmcoMTYpKTtcbn1cbnZhciB0b0hleFN0cmluZyA9IHRvSGV4O1xuZnVuY3Rpb24gdG9TdG9yYWdlS2V5KG51bWJlcjIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG59XG5mdW5jdGlvbiBoZXhUb0RlY2ltYWxTdHJpbmcoaGV4KSB7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KGhleCkpLnRvU3RyaW5nKDEwKTtcbn1cbmZ1bmN0aW9uIGNsZWFuSGV4KGhleCkge1xuICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXigweCkwKy8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRJblJhbmdlKGlucHV0LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBpbnB1dE5hbWUgPSBcIlwiKSB7XG4gIGNvbnN0IG1lc3NhZ2VTdWZmaXggPSBpbnB1dE5hbWUgPT09IFwiXCIgPyBcImludmFsaWQgbGVuZ3RoXCIgOiBgaW52YWxpZCAke2lucHV0TmFtZX0gbGVuZ3RoYDtcbiAgY29uc3QgaW5wdXRCaWdJbnQgPSBCaWdJbnQoaW5wdXQpO1xuICBjb25zdCBsb3dlckJvdW5kQmlnSW50ID0gQmlnSW50KGxvd2VyQm91bmQpO1xuICBjb25zdCB1cHBlckJvdW5kQmlnSW50ID0gQmlnSW50KHVwcGVyQm91bmQpO1xuICBhc3NlcnQoXG4gICAgaW5wdXRCaWdJbnQgPj0gbG93ZXJCb3VuZEJpZ0ludCAmJiBpbnB1dEJpZ0ludCA8PSB1cHBlckJvdW5kQmlnSW50LFxuICAgIGBNZXNzYWdlIG5vdCBzaWduYWJsZSwgJHttZXNzYWdlU3VmZml4fS5gXG4gICk7XG59XG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEubWFwKCh4KSA9PiB0b0JpZ0ludCh4KS50b1N0cmluZygxMCkpO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZGF0YSkge1xuICByZXR1cm4gZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSB7XG4gIHJldHVybiAvXlxcZCskLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBnZXREZWNpbWFsU3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcoc3RyKTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBuZWVkcyB0byBiZSBhIGhleC1zdHJpbmcgb3Igd2hvbGUtbnVtYmVyLXN0cmluZ2ApO1xufVxuZnVuY3Rpb24gZ2V0SGV4U3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyhzdHIpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IG5lZWRzIHRvIGJlIGEgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmdBcnJheShhcnJheSkge1xuICByZXR1cm4gYXJyYXkubWFwKGdldEhleFN0cmluZyk7XG59XG5mdW5jdGlvbiB0b0NhaXJvQm9vbCh2YWx1ZSkge1xuICByZXR1cm4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoc3RyKSB7XG4gIGlmICghaXNIZXgoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBuZWVkcyB0byBiZSBhIGhleC1zdHJpbmdgKTtcbiAgbGV0IGFkYXB0ZWRWYWx1ZSA9IHJlbW92ZUhleFByZWZpeChzdHIpO1xuICBpZiAoYWRhcHRlZFZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICBhZGFwdGVkVmFsdWUgPSBgMCR7YWRhcHRlZFZhbHVlfWA7XG4gIH1cbiAgcmV0dXJuIGhleFRvQnl0ZXNOb2JsZShhZGFwdGVkVmFsdWUpO1xufVxuZnVuY3Rpb24gYWRkUGVyY2VudChudW1iZXIyLCBwZXJjZW50KSB7XG4gIGNvbnN0IGJpZ0ludE51bSA9IEJpZ0ludChudW1iZXIyKTtcbiAgcmV0dXJuIGJpZ0ludE51bSArIGJpZ0ludE51bSAqIEJpZ0ludChwZXJjZW50KSAvIDEwMG47XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFzaC9zZWxlY3Rvci50c1xudmFyIHNlbGVjdG9yX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNlbGVjdG9yX2V4cG9ydHMsIHtcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBrZWNjYWtCbjogKCkgPT4ga2VjY2FrQm4sXG4gIHN0YXJrbmV0S2VjY2FrOiAoKSA9PiBzdGFya25ldEtlY2Nha1xufSk7XG5pbXBvcnQgeyBrZWNjYWsgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5mdW5jdGlvbiBrZWNjYWtCbih2YWx1ZSkge1xuICBjb25zdCBoZXhXaXRob3V0UHJlZml4ID0gcmVtb3ZlSGV4UHJlZml4KHRvSGV4KEJpZ0ludCh2YWx1ZSkpKTtcbiAgY29uc3QgZXZlbkhleCA9IGhleFdpdGhvdXRQcmVmaXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleFdpdGhvdXRQcmVmaXggOiBgMCR7aGV4V2l0aG91dFByZWZpeH1gO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGtlY2NhayhoZXhUb0J5dGVzKGFkZEhleFByZWZpeChldmVuSGV4KSkpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBrZWNjYWtIZXgoc3RyKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoa2VjY2FrKHV0ZjhUb0FycmF5KHN0cikpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBzdGFya25ldEtlY2NhayhzdHIpIHtcbiAgY29uc3QgaGFzaCA9IEJpZ0ludChrZWNjYWtIZXgoc3RyKSk7XG4gIHJldHVybiBoYXNoICYgTUFTS18yNTA7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvckZyb21OYW1lKGZ1bmNOYW1lKSB7XG4gIHJldHVybiB0b0hleChzdGFya25ldEtlY2NhayhmdW5jTmFtZSkpO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUpO1xuICB9XG4gIHJldHVybiBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3Nob3J0U3RyaW5nLnRzXG52YXIgc2hvcnRTdHJpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2hvcnRTdHJpbmdfZXhwb3J0cywge1xuICBkZWNvZGVTaG9ydFN0cmluZzogKCkgPT4gZGVjb2RlU2hvcnRTdHJpbmcsXG4gIGVuY29kZVNob3J0U3RyaW5nOiAoKSA9PiBlbmNvZGVTaG9ydFN0cmluZyxcbiAgaXNBU0NJSTogKCkgPT4gaXNBU0NJSSxcbiAgaXNEZWNpbWFsU3RyaW5nOiAoKSA9PiBpc0RlY2ltYWxTdHJpbmcsXG4gIGlzTG9uZ1RleHQ6ICgpID0+IGlzTG9uZ1RleHQsXG4gIGlzU2hvcnRTdHJpbmc6ICgpID0+IGlzU2hvcnRTdHJpbmcsXG4gIGlzU2hvcnRUZXh0OiAoKSA9PiBpc1Nob3J0VGV4dCxcbiAgaXNTdHJpbmc6ICgpID0+IGlzU3RyaW5nLFxuICBpc1RleHQ6ICgpID0+IGlzVGV4dCxcbiAgc3BsaXRMb25nU3RyaW5nOiAoKSA9PiBzcGxpdExvbmdTdHJpbmdcbn0pO1xuZnVuY3Rpb24gaXNBU0NJSShzdHIpIHtcbiAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc1Nob3J0U3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCA8PSBURVhUX1RPX0ZFTFRfTUFYX0xFTjtcbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOV0qJC9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc1RleHQodmFsKSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpICYmICFpc0hleCh2YWwpICYmICFpc1N0cmluZ1dob2xlTnVtYmVyKHZhbCk7XG59XG52YXIgaXNTaG9ydFRleHQgPSAodmFsKSA9PiBpc1RleHQodmFsKSAmJiBpc1Nob3J0U3RyaW5nKHZhbCk7XG52YXIgaXNMb25nVGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmICFpc1Nob3J0U3RyaW5nKHZhbCk7XG5mdW5jdGlvbiBzcGxpdExvbmdTdHJpbmcobG9uZ1N0cikge1xuICBjb25zdCByZWdleCA9IFJlZ0V4cChgW15dezEsJHtURVhUX1RPX0ZFTFRfTUFYX0xFTn19YCwgXCJnXCIpO1xuICByZXR1cm4gbG9uZ1N0ci5tYXRjaChyZWdleCkgfHwgW107XG59XG5mdW5jdGlvbiBlbmNvZGVTaG9ydFN0cmluZyhzdHIpIHtcbiAgaWYgKCFpc0FTQ0lJKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoIWlzU2hvcnRTdHJpbmcoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyB0b28gbG9uZ2ApO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHN0ci5yZXBsYWNlKC8uL2csIChjaGFyKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVTaG9ydFN0cmluZyhzdHIpIHtcbiAgaWYgKCFpc0FTQ0lJKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiByZW1vdmVIZXhQcmVmaXgoc3RyKS5yZXBsYWNlKC8uezJ9L2csIChoZXgpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpKTtcbiAgfVxuICBpZiAoaXNEZWNpbWFsU3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gZGVjb2RlU2hvcnRTdHJpbmcoXCIwWFwiLmNvbmNhdChCaWdJbnQoc3RyKS50b1N0cmluZygxNikpKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgSGV4IG9yIGRlY2ltYWxgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2J5dGVBcnJheS50c1xudmFyIGJ5dGVBcnJheV9leHBvcnRzID0ge307XG5fX2V4cG9ydChieXRlQXJyYXlfZXhwb3J0cywge1xuICBieXRlQXJyYXlGcm9tU3RyaW5nOiAoKSA9PiBieXRlQXJyYXlGcm9tU3RyaW5nLFxuICBzdHJpbmdGcm9tQnl0ZUFycmF5OiAoKSA9PiBzdHJpbmdGcm9tQnl0ZUFycmF5XG59KTtcbmZ1bmN0aW9uIHN0cmluZ0Zyb21CeXRlQXJyYXkobXlCeXRlQXJyYXkpIHtcbiAgY29uc3QgcGVuZGluZ193b3JkID0gQmlnSW50KG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZCkgPT09IDBuID8gXCJcIiA6IGRlY29kZVNob3J0U3RyaW5nKHRvSGV4KG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZCkpO1xuICByZXR1cm4gbXlCeXRlQXJyYXkuZGF0YS5yZWR1Y2UoKGN1bXVsZWRTdHJpbmcsIGVuY29kZWRTdHJpbmcpID0+IHtcbiAgICBjb25zdCBhZGQgPSBCaWdJbnQoZW5jb2RlZFN0cmluZykgPT09IDBuID8gXCJcIiA6IGRlY29kZVNob3J0U3RyaW5nKHRvSGV4KGVuY29kZWRTdHJpbmcpKTtcbiAgICByZXR1cm4gY3VtdWxlZFN0cmluZyArIGFkZDtcbiAgfSwgXCJcIikgKyBwZW5kaW5nX3dvcmQ7XG59XG5mdW5jdGlvbiBieXRlQXJyYXlGcm9tU3RyaW5nKHRhcmdldFN0cmluZykge1xuICBjb25zdCBzaG9ydFN0cmluZ3MgPSBzcGxpdExvbmdTdHJpbmcodGFyZ2V0U3RyaW5nKTtcbiAgY29uc3QgcmVtYWluZGVyID0gc2hvcnRTdHJpbmdzW3Nob3J0U3RyaW5ncy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgc2hvcnRTdHJpbmdzRW5jb2RlZCA9IHNob3J0U3RyaW5ncy5tYXAoZW5jb2RlU2hvcnRTdHJpbmcpO1xuICBjb25zdCBbcGVuZGluZ1dvcmQsIHBlbmRpbmdXb3JkTGVuZ3RoXSA9IHJlbWFpbmRlciA9PT0gdm9pZCAwIHx8IHJlbWFpbmRlci5sZW5ndGggPT09IDMxID8gW1wiMHgwMFwiLCAwXSA6IFtzaG9ydFN0cmluZ3NFbmNvZGVkLnBvcCgpLCByZW1haW5kZXIubGVuZ3RoXTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBzaG9ydFN0cmluZ3NFbmNvZGVkLmxlbmd0aCA9PT0gMCA/IFtdIDogc2hvcnRTdHJpbmdzRW5jb2RlZCxcbiAgICBwZW5kaW5nX3dvcmQ6IHBlbmRpbmdXb3JkLFxuICAgIHBlbmRpbmdfd29yZF9sZW46IHBlbmRpbmdXb3JkTGVuZ3RoXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGNhaXJvX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNhaXJvX2V4cG9ydHMsIHtcbiAgZmVsdDogKCkgPT4gZmVsdCxcbiAgZ2V0QWJpQ29udHJhY3RWZXJzaW9uOiAoKSA9PiBnZXRBYmlDb250cmFjdFZlcnNpb24sXG4gIGdldEFycmF5VHlwZTogKCkgPT4gZ2V0QXJyYXlUeXBlLFxuICBpc0NhaXJvMUFiaTogKCkgPT4gaXNDYWlybzFBYmksXG4gIGlzQ2Fpcm8xVHlwZTogKCkgPT4gaXNDYWlybzFUeXBlLFxuICBpc0xlbjogKCkgPT4gaXNMZW4sXG4gIGlzVHlwZUFycmF5OiAoKSA9PiBpc1R5cGVBcnJheSxcbiAgaXNUeXBlQm9vbDogKCkgPT4gaXNUeXBlQm9vbCxcbiAgaXNUeXBlQnl0ZUFycmF5OiAoKSA9PiBpc1R5cGVCeXRlQXJyYXksXG4gIGlzVHlwZUJ5dGVzMzE6ICgpID0+IGlzVHlwZUJ5dGVzMzEsXG4gIGlzVHlwZUNvbnRyYWN0QWRkcmVzczogKCkgPT4gaXNUeXBlQ29udHJhY3RBZGRyZXNzLFxuICBpc1R5cGVFbnVtOiAoKSA9PiBpc1R5cGVFbnVtLFxuICBpc1R5cGVFdGhBZGRyZXNzOiAoKSA9PiBpc1R5cGVFdGhBZGRyZXNzLFxuICBpc1R5cGVGZWx0OiAoKSA9PiBpc1R5cGVGZWx0LFxuICBpc1R5cGVMaXRlcmFsOiAoKSA9PiBpc1R5cGVMaXRlcmFsLFxuICBpc1R5cGVOYW1lZFR1cGxlOiAoKSA9PiBpc1R5cGVOYW1lZFR1cGxlLFxuICBpc1R5cGVOb25aZXJvOiAoKSA9PiBpc1R5cGVOb25aZXJvLFxuICBpc1R5cGVPcHRpb246ICgpID0+IGlzVHlwZU9wdGlvbixcbiAgaXNUeXBlUmVzdWx0OiAoKSA9PiBpc1R5cGVSZXN1bHQsXG4gIGlzVHlwZVNlY3AyNTZrMVBvaW50OiAoKSA9PiBpc1R5cGVTZWNwMjU2azFQb2ludCxcbiAgaXNUeXBlU3RydWN0OiAoKSA9PiBpc1R5cGVTdHJ1Y3QsXG4gIGlzVHlwZVR1cGxlOiAoKSA9PiBpc1R5cGVUdXBsZSxcbiAgaXNUeXBlVWludDogKCkgPT4gaXNUeXBlVWludCxcbiAgaXNUeXBlVWludDI1NjogKCkgPT4gaXNUeXBlVWludDI1NixcbiAgdHVwbGU6ICgpID0+IHR1cGxlLFxuICB1aW50MjU2OiAoKSA9PiB1aW50MjU2LFxuICB1aW50NTEyOiAoKSA9PiB1aW50NTEyXG59KTtcblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL2ZlbHQudHNcbmZ1bmN0aW9uIENhaXJvRmVsdChpdCkge1xuICBpZiAoaXNCaWdJbnQoaXQpIHx8IE51bWJlci5pc0ludGVnZXIoaXQpKSB7XG4gICAgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nKGl0KSkge1xuICAgIGlmIChpc0hleChpdCkpIHtcbiAgICAgIHJldHVybiBCaWdJbnQoaXQpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1RleHQoaXQpKSB7XG4gICAgICBpZiAoIWlzU2hvcnRTdHJpbmcoaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtpdH0gaXMgYSBsb25nIHN0cmluZyA+IDMxIGNoYXJzLiBQbGVhc2Ugc3BsaXQgaXQgaW50byBhbiBhcnJheSBvZiBzaG9ydCBzdHJpbmdzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihpdCkpIHtcbiAgICAgIHJldHVybiBpdDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQm9vbGVhbihpdCkpIHtcbiAgICByZXR1cm4gYCR7K2l0fWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke2l0fSBjYW4ndCBiZSBjb21wdXRlZCBieSBmZWx0KClgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL3VpbnQyNTYudHNcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NSU4gPSAwbjtcbnZhciBVSU5UXzI1Nl9MT1dfTUFYID0gMzQwMjgyMzY2OTIwOTM4NDYzNDYzMzc0NjA3NDMxNzY4MjExNDU1bjtcbnZhciBVSU5UXzI1Nl9ISUdIX01BWCA9IDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NW47XG52YXIgVUlOVF8yNTZfTE9XX01JTiA9IDBuO1xudmFyIFVJTlRfMjU2X0hJR0hfTUlOID0gMG47XG52YXIgQ2Fpcm9VaW50MjU2ID0gY2xhc3MgX0NhaXJvVWludDI1NiB7XG4gIGxvdztcbiAgaGlnaDtcbiAgc3RhdGljIGFiaVNlbGVjdG9yID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIGNvbnN0cnVjdG9yKC4uLmFycikge1xuICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm9iamVjdFwiICYmIGFyci5sZW5ndGggPT09IDEgJiYgXCJsb3dcIiBpbiBhcnJbMF0gJiYgXCJoaWdoXCIgaW4gYXJyWzBdKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQyNTYudmFsaWRhdGVQcm9wcyhhcnJbMF0ubG93LCBhcnJbMF0uaGlnaCk7XG4gICAgICB0aGlzLmxvdyA9IHByb3BzLmxvdztcbiAgICAgIHRoaXMuaGlnaCA9IHByb3BzLmhpZ2g7XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBiaWdJbnQgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlKGFyclswXSk7XG4gICAgICB0aGlzLmxvdyA9IGJpZ0ludCAmIFVJTlRfMTI4X01BWDtcbiAgICAgIHRoaXMuaGlnaCA9IGJpZ0ludCA+PiAxMjhuO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlUHJvcHMoYXJyWzBdLCBhcnJbMV0pO1xuICAgICAgdGhpcy5sb3cgPSBwcm9wcy5sb3c7XG4gICAgICB0aGlzLmhpZ2ggPSBwcm9wcy5oaWdoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkluY29ycmVjdCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUoYmlnTnVtYmVyaXNoKSB7XG4gICAgY29uc3QgYmlnSW50ID0gQmlnSW50KGJpZ051bWJlcmlzaCk7XG4gICAgaWYgKGJpZ0ludCA8IFVJTlRfMjU2X01JTilcbiAgICAgIHRocm93IEVycm9yKFwiYmlnTnVtYmVyaXNoIGlzIHNtYWxsZXIgdGhhbiBVSU5UXzI1Nl9NSU5cIik7XG4gICAgaWYgKGJpZ0ludCA+IFVJTlRfMjU2X01BWClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJpZ051bWJlcmlzaCBpcyBiaWdnZXIgdGhhbiBVSU5UXzI1Nl9NQVhcIik7XG4gICAgcmV0dXJuIGJpZ0ludDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgbG93IGFuZCBoaWdoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVQcm9wcyhsb3csIGhpZ2gpIHtcbiAgICBjb25zdCBiaWdJbnRMb3cgPSBCaWdJbnQobG93KTtcbiAgICBjb25zdCBiaWdJbnRIaWdoID0gQmlnSW50KGhpZ2gpO1xuICAgIGlmIChiaWdJbnRMb3cgPCBVSU5UXzI1Nl9MT1dfTUlOIHx8IGJpZ0ludExvdyA+IFVJTlRfMjU2X0xPV19NQVgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxvdyBpcyBvdXQgb2YgcmFuZ2UgVUlOVF8yNTZfTE9XX01JTiAtIFVJTlRfMjU2X0xPV19NQVhcIik7XG4gICAgfVxuICAgIGlmIChiaWdJbnRIaWdoIDwgVUlOVF8yNTZfSElHSF9NSU4gfHwgYmlnSW50SGlnaCA+IFVJTlRfMjU2X0hJR0hfTUFYKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoaWdoIGlzIG91dCBvZiByYW5nZSBVSU5UXzI1Nl9ISUdIX01JTiAtIFVJTlRfMjU2X0hJR0hfTUFYXCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBsb3c6IGJpZ0ludExvdywgaGlnaDogYmlnSW50SGlnaCB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVuaXQyNTZcbiAgICovXG4gIHN0YXRpYyBpcyhiaWdOdW1iZXJpc2gpIHtcbiAgICB0cnkge1xuICAgICAgX0NhaXJvVWludDI1Ni52YWxpZGF0ZShiaWdOdW1iZXJpc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwcm92aWRlZCBhYmkgdHlwZSBpcyB0aGlzIGRhdGEgdHlwZVxuICAgKi9cbiAgc3RhdGljIGlzQWJpVHlwZShhYmlUeXBlKSB7XG4gICAgcmV0dXJuIGFiaVR5cGUgPT09IF9DYWlyb1VpbnQyNTYuYWJpU2VsZWN0b3I7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBiaWdpbnQgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIHRvQmlnSW50KCkge1xuICAgIHJldHVybiAodGhpcy5oaWdoIDw8IDEyOG4pICsgdGhpcy5sb3c7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBVaW50MjU2IHN0cnVjdHVyZSB3aXRoIEhleFN0cmluZyBwcm9wc1xuICAgKiB7bG93OiBIZXhTdHJpbmcsIGhpZ2g6IEhleFN0cmluZ31cbiAgICovXG4gIHRvVWludDI1NkhleFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG93OiBhZGRIZXhQcmVmaXgodGhpcy5sb3cudG9TdHJpbmcoMTYpKSxcbiAgICAgIGhpZ2g6IGFkZEhleFByZWZpeCh0aGlzLmhpZ2gudG9TdHJpbmcoMTYpKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBVaW50MjU2IHN0cnVjdHVyZSB3aXRoIERlY2ltYWxTdHJpbmcgcHJvcHNcbiAgICoge2xvdzogRGVjU3RyaW5nLCBoaWdoOiBEZWNTdHJpbmd9XG4gICAqL1xuICB0b1VpbnQyNTZEZWNpbWFsU3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb3c6IHRoaXMubG93LnRvU3RyaW5nKDEwKSxcbiAgICAgIGhpZ2g6IHRoaXMuaGlnaC50b1N0cmluZygxMClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXBpIHJlcXVlc3RzIHJlcHJlc2VudGF0aW9uIHdpdGNoIGlzIGZlbHQgYXJyYXlcbiAgICovXG4gIHRvQXBpUmVxdWVzdCgpIHtcbiAgICByZXR1cm4gW0NhaXJvRmVsdCh0aGlzLmxvdyksIENhaXJvRmVsdCh0aGlzLmhpZ2gpXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL3VpbnQ1MTIudHNcbnZhciBVSU5UXzUxMl9NQVggPSAoMW4gPDwgNTEybikgLSAxbjtcbnZhciBVSU5UXzUxMl9NSU4gPSAwbjtcbnZhciBVSU5UXzEyOF9NSU4gPSAwbjtcbnZhciBDYWlyb1VpbnQ1MTIgPSBjbGFzcyBfQ2Fpcm9VaW50NTEyIHtcbiAgbGltYjA7XG4gIGxpbWIxO1xuICBsaW1iMjtcbiAgbGltYjM7XG4gIHN0YXRpYyBhYmlTZWxlY3RvciA9IFwiY29yZTo6aW50ZWdlcjo6dTUxMlwiO1xuICBjb25zdHJ1Y3RvciguLi5hcnIpIHtcbiAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJvYmplY3RcIiAmJiBhcnIubGVuZ3RoID09PSAxICYmIFwibGltYjBcIiBpbiBhcnJbMF0gJiYgXCJsaW1iMVwiIGluIGFyclswXSAmJiBcImxpbWIyXCIgaW4gYXJyWzBdICYmIFwibGltYjNcIiBpbiBhcnJbMF0pIHtcbiAgICAgIGNvbnN0IHByb3BzID0gX0NhaXJvVWludDUxMi52YWxpZGF0ZVByb3BzKFxuICAgICAgICBhcnJbMF0ubGltYjAsXG4gICAgICAgIGFyclswXS5saW1iMSxcbiAgICAgICAgYXJyWzBdLmxpbWIyLFxuICAgICAgICBhcnJbMF0ubGltYjNcbiAgICAgICk7XG4gICAgICB0aGlzLmxpbWIwID0gcHJvcHMubGltYjA7XG4gICAgICB0aGlzLmxpbWIxID0gcHJvcHMubGltYjE7XG4gICAgICB0aGlzLmxpbWIyID0gcHJvcHMubGltYjI7XG4gICAgICB0aGlzLmxpbWIzID0gcHJvcHMubGltYjM7XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBiaWdJbnQgPSBfQ2Fpcm9VaW50NTEyLnZhbGlkYXRlKGFyclswXSk7XG4gICAgICB0aGlzLmxpbWIwID0gYmlnSW50ICYgVUlOVF8xMjhfTUFYO1xuICAgICAgdGhpcy5saW1iMSA9IChiaWdJbnQgJiBVSU5UXzEyOF9NQVggPDwgMTI4bikgPj4gMTI4bjtcbiAgICAgIHRoaXMubGltYjIgPSAoYmlnSW50ICYgVUlOVF8xMjhfTUFYIDw8IDI1Nm4pID4+IDI1Nm47XG4gICAgICB0aGlzLmxpbWIzID0gYmlnSW50ID4+IDM4NG47XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQ1MTIudmFsaWRhdGVQcm9wcyhhcnJbMF0sIGFyclsxXSwgYXJyWzJdLCBhcnJbM10pO1xuICAgICAgdGhpcy5saW1iMCA9IHByb3BzLmxpbWIwO1xuICAgICAgdGhpcy5saW1iMSA9IHByb3BzLmxpbWIxO1xuICAgICAgdGhpcy5saW1iMiA9IHByb3BzLmxpbWIyO1xuICAgICAgdGhpcy5saW1iMyA9IHByb3BzLmxpbWIzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkluY29ycmVjdCBVaW50NTEyIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnNcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVpbnQ1MTJcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZShiaWdOdW1iZXJpc2gpIHtcbiAgICBjb25zdCBiaWdJbnQgPSBCaWdJbnQoYmlnTnVtYmVyaXNoKTtcbiAgICBpZiAoYmlnSW50IDwgVUlOVF81MTJfTUlOKVxuICAgICAgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgc21hbGxlciB0aGFuIFVJTlRfNTEyX01JTi5cIik7XG4gICAgaWYgKGJpZ0ludCA+IFVJTlRfNTEyX01BWClcbiAgICAgIHRocm93IEVycm9yKFwiYmlnTnVtYmVyaXNoIGlzIGJpZ2dlciB0aGFuIFVJTlRfNTEyX01BWC5cIik7XG4gICAgcmV0dXJuIGJpZ0ludDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgbGltYnMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVpbnQ1MTJcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVByb3BzKGxpbWIwLCBsaW1iMSwgbGltYjIsIGxpbWIzKSB7XG4gICAgY29uc3QgbDAgPSBCaWdJbnQobGltYjApO1xuICAgIGNvbnN0IGwxID0gQmlnSW50KGxpbWIxKTtcbiAgICBjb25zdCBsMiA9IEJpZ0ludChsaW1iMik7XG4gICAgY29uc3QgbDMgPSBCaWdJbnQobGltYjMpO1xuICAgIFtsMCwgbDEsIGwyLCBsM10uZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAodmFsdWUgPCBVSU5UXzEyOF9NSU4gfHwgdmFsdWUgPiBVSU5UXzEyOF9NQVgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGxpbWIke2luZGV4fSBpcyBub3QgaW4gdGhlIHJhbmdlIG9mIGEgdTEyOCBudW1iZXJgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBsaW1iMDogbDAsIGxpbWIxOiBsMSwgbGltYjI6IGwyLCBsaW1iMzogbDMgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVaW50NTEyXG4gICAqL1xuICBzdGF0aWMgaXMoYmlnTnVtYmVyaXNoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9DYWlyb1VpbnQ1MTIudmFsaWRhdGUoYmlnTnVtYmVyaXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcHJvdmlkZWQgYWJpIHR5cGUgaXMgdGhpcyBkYXRhIHR5cGVcbiAgICovXG4gIHN0YXRpYyBpc0FiaVR5cGUoYWJpVHlwZSkge1xuICAgIHJldHVybiBhYmlUeXBlID09PSBfQ2Fpcm9VaW50NTEyLmFiaVNlbGVjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYmlnaW50IHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICB0b0JpZ0ludCgpIHtcbiAgICByZXR1cm4gKHRoaXMubGltYjMgPDwgMzg0bikgKyAodGhpcy5saW1iMiA8PCAyNTZuKSArICh0aGlzLmxpbWIxIDw8IDEyOG4pICsgdGhpcy5saW1iMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFVpbnQ1MTIgc3RydWN0dXJlIHdpdGggSGV4U3RyaW5nIHByb3BzXG4gICAqIGxpbWJ4OiBIZXhTdHJpbmdcbiAgICovXG4gIHRvVWludDUxMkhleFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGltYjA6IGFkZEhleFByZWZpeCh0aGlzLmxpbWIwLnRvU3RyaW5nKDE2KSksXG4gICAgICBsaW1iMTogYWRkSGV4UHJlZml4KHRoaXMubGltYjEudG9TdHJpbmcoMTYpKSxcbiAgICAgIGxpbWIyOiBhZGRIZXhQcmVmaXgodGhpcy5saW1iMi50b1N0cmluZygxNikpLFxuICAgICAgbGltYjM6IGFkZEhleFByZWZpeCh0aGlzLmxpbWIzLnRvU3RyaW5nKDE2KSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDUxMiBzdHJ1Y3R1cmUgd2l0aCBEZWNpbWFsU3RyaW5nIHByb3BzXG4gICAqIGxpbWJ4IERlY1N0cmluZ1xuICAgKi9cbiAgdG9VaW50NTEyRGVjaW1hbFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGltYjA6IHRoaXMubGltYjAudG9TdHJpbmcoMTApLFxuICAgICAgbGltYjE6IHRoaXMubGltYjEudG9TdHJpbmcoMTApLFxuICAgICAgbGltYjI6IHRoaXMubGltYjIudG9TdHJpbmcoMTApLFxuICAgICAgbGltYjM6IHRoaXMubGltYjMudG9TdHJpbmcoMTApXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFwaSByZXF1ZXN0cyByZXByZXNlbnRhdGlvbiB3aXRjaCBpcyBmZWx0IGFycmF5XG4gICAqL1xuICB0b0FwaVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIwKSxcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIxKSxcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIyKSxcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIzKVxuICAgIF07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGlzTGVuID0gKG5hbWUpID0+IC9fbGVuJC8udGVzdChuYW1lKTtcbnZhciBpc1R5cGVGZWx0ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiZmVsdFwiIHx8IHR5cGUgPT09IFwiY29yZTo6ZmVsdDI1MlwiO1xudmFyIGlzVHlwZUFycmF5ID0gKHR5cGUpID0+IC9cXCovLnRlc3QodHlwZSkgfHwgdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6YXJyYXk6OkFycmF5OjpcIikgfHwgdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6YXJyYXk6OlNwYW46OlwiKTtcbnZhciBpc1R5cGVUdXBsZSA9ICh0eXBlKSA9PiAvXlxcKC4qXFwpJC9pLnRlc3QodHlwZSk7XG52YXIgaXNUeXBlTmFtZWRUdXBsZSA9ICh0eXBlKSA9PiAvXFwoLipcXCkvaS50ZXN0KHR5cGUpICYmIHR5cGUuaW5jbHVkZXMoXCI6XCIpO1xudmFyIGlzVHlwZVN0cnVjdCA9ICh0eXBlLCBzdHJ1Y3RzKSA9PiB0eXBlIGluIHN0cnVjdHM7XG52YXIgaXNUeXBlRW51bSA9ICh0eXBlLCBlbnVtcykgPT4gdHlwZSBpbiBlbnVtcztcbnZhciBpc1R5cGVPcHRpb24gPSAodHlwZSkgPT4gdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb246OlwiKTtcbnZhciBpc1R5cGVSZXN1bHQgPSAodHlwZSkgPT4gdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHQ6OlwiKTtcbnZhciBpc1R5cGVVaW50ID0gKHR5cGUpID0+IE9iamVjdC52YWx1ZXMoVWludCkuaW5jbHVkZXModHlwZSk7XG52YXIgaXNUeXBlVWludDI1NiA9ICh0eXBlKSA9PiBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpO1xudmFyIGlzVHlwZUxpdGVyYWwgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhMaXRlcmFsKS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVCb29sID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ym9vbFwiO1xudmFyIGlzVHlwZUNvbnRyYWN0QWRkcmVzcyA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbnZhciBpc1R5cGVFdGhBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI7XG52YXIgaXNUeXBlQnl0ZXMzMSA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OmJ5dGVzXzMxOjpieXRlczMxXCI7XG52YXIgaXNUeXBlQnl0ZUFycmF5ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ynl0ZV9hcnJheTo6Qnl0ZUFycmF5XCI7XG52YXIgaXNUeXBlU2VjcDI1NmsxUG9pbnQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6c2VjcDI1NmsxOjpTZWNwMjU2azFQb2ludFwiO1xudmFyIGlzQ2Fpcm8xVHlwZSA9ICh0eXBlKSA9PiB0eXBlLmluY2x1ZGVzKFwiOjpcIik7XG52YXIgZ2V0QXJyYXlUeXBlID0gKHR5cGUpID0+IHtcbiAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiB0eXBlLnN1YnN0cmluZyh0eXBlLmluZGV4T2YoXCI8XCIpICsgMSwgdHlwZS5sYXN0SW5kZXhPZihcIj5cIikpO1xuICB9XG4gIHJldHVybiB0eXBlLnJlcGxhY2UoXCIqXCIsIFwiXCIpO1xufTtcbmZ1bmN0aW9uIGlzQ2Fpcm8xQWJpKGFiaSkge1xuICBjb25zdCB7IGNhaXJvIH0gPSBnZXRBYmlDb250cmFjdFZlcnNpb24oYWJpKTtcbiAgaWYgKGNhaXJvID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBkZXRlcm1pbmUgQ2Fpcm8gdmVyc2lvblwiKTtcbiAgfVxuICByZXR1cm4gY2Fpcm8gPT09IFwiMVwiO1xufVxuZnVuY3Rpb24gaXNUeXBlTm9uWmVybyh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjp6ZXJvYWJsZTo6Tm9uWmVybzo6XCIpO1xufVxuZnVuY3Rpb24gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSkge1xuICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IFwiMlwiIH07XG4gIH1cbiAgY29uc3QgdGVzdEZ1bmN0aW9uID0gYWJpLmZpbmQoXG4gICAgKGl0KSA9PiBpdC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgKGl0LmlucHV0cy5sZW5ndGggfHwgaXQub3V0cHV0cy5sZW5ndGgpXG4gICk7XG4gIGlmICghdGVzdEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IHZvaWQgMCwgY29tcGlsZXI6IHZvaWQgMCB9O1xuICB9XG4gIGNvbnN0IGlvID0gdGVzdEZ1bmN0aW9uLmlucHV0cy5sZW5ndGggPyB0ZXN0RnVuY3Rpb24uaW5wdXRzIDogdGVzdEZ1bmN0aW9uLm91dHB1dHM7XG4gIGlmIChpc0NhaXJvMVR5cGUoaW9bMF0udHlwZSkpIHtcbiAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBcIjFcIiB9O1xuICB9XG4gIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG59XG52YXIgdWludDI1NiA9IChpdCkgPT4ge1xuICByZXR1cm4gbmV3IENhaXJvVWludDI1NihpdCkudG9VaW50MjU2RGVjaW1hbFN0cmluZygpO1xufTtcbnZhciB1aW50NTEyID0gKGl0KSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGl0KS50b1VpbnQ1MTJEZWNpbWFsU3RyaW5nKCk7XG59O1xudmFyIHR1cGxlID0gKC4uLmFyZ3MpID0+ICh7IC4uLmFyZ3MgfSk7XG5mdW5jdGlvbiBmZWx0KGl0KSB7XG4gIHJldHVybiBDYWlyb0ZlbHQoaXQpO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb0N1c3RvbUVudW0udHNcbnZhciBDYWlyb0N1c3RvbUVudW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBkaXJlY3QgcmVhZG9ubHkgYWNjZXNzIHRvIHZhcmlhbnRzIG9mIHRoZSBDYWlybyBDdXN0b20gRW51bS5cbiAgICogQHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGFueVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1Y2Nlc3NWYWx1ZSA9IG15Q2Fpcm9FbnVtLnZhcmlhbnQuU3VjY2VzcztcbiAgICovXG4gIHZhcmlhbnQ7XG4gIC8qKlxuICAgKiBAcGFyYW0gZW51bUNvbnRlbnQgYW4gb2JqZWN0IHdpdGggdGhlIHZhcmlhbnRzIGFzIGtleXMgYW5kIHRoZSBjb250ZW50IGFzIHZhbHVlLiBPbmx5IG9uZSBjb250ZW50IHNoYWxsIGJlIGRlZmluZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnVtQ29udGVudCkge1xuICAgIGNvbnN0IHZhcmlhbnRzTGlzdCA9IE9iamVjdC52YWx1ZXMoZW51bUNvbnRlbnQpO1xuICAgIGlmICh2YXJpYW50c0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmJBY3RpdmVWYXJpYW50cyA9IHZhcmlhbnRzTGlzdC5maWx0ZXIoXG4gICAgICAoY29udGVudCkgPT4gdHlwZW9mIGNvbnRlbnQgIT09IFwidW5kZWZpbmVkXCJcbiAgICApLmxlbmd0aDtcbiAgICBpZiAobmJBY3RpdmVWYXJpYW50cyAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBFbnVtIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBhY3RpdmUgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYW50ID0gZW51bUNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFsxXTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIGFjdGl2ZVZhcmlhbnQoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVZhcmlhbnRbMF07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvT3B0aW9uLnRzXG52YXIgQ2Fpcm9PcHRpb25WYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9PcHRpb25WYXJpYW50MikgPT4ge1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJTb21lXCJdID0gMF0gPSBcIlNvbWVcIjtcbiAgQ2Fpcm9PcHRpb25WYXJpYW50MltDYWlyb09wdGlvblZhcmlhbnQyW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XG4gIHJldHVybiBDYWlyb09wdGlvblZhcmlhbnQyO1xufSkoQ2Fpcm9PcHRpb25WYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb09wdGlvbiA9IGNsYXNzIHtcbiAgU29tZTtcbiAgTm9uZTtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgc29tZUNvbnRlbnQpIHtcbiAgICBpZiAoISh2YXJpYW50IGluIENhaXJvT3B0aW9uVmFyaWFudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIHZhcmlhbnQgOiBzaG91bGQgYmUgQ2Fpcm9PcHRpb25WYXJpYW50LlNvbWUgb3IgLk5vbmUuXCIpO1xuICAgIH1cbiAgICBpZiAodmFyaWFudCA9PT0gMCAvKiBTb21lICovKSB7XG4gICAgICBpZiAodHlwZW9mIHNvbWVDb250ZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIGNyZWF0aW9uIG9mIGEgQ2Fpcm8gT3B0aW9uIHdpdGggXCJTb21lXCIgdmFyaWFudCBuZWVkcyBhIGNvbnRlbnQgYXMgaW5wdXQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5Tb21lID0gc29tZUNvbnRlbnQ7XG4gICAgICB0aGlzLk5vbmUgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuU29tZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuTm9uZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKiAgSWYgTm9uZSwgcmV0dXJucyAndW5kZWZpbmVkJy5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodGhpcy5Ob25lKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5Tb21lO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc1NvbWUnLlxuICAgKi9cbiAgaXNTb21lKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLlNvbWUgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc05vbmUnLlxuICAgKi9cbiAgaXNOb25lKCkge1xuICAgIHJldHVybiB0aGlzLk5vbmUgPT09IHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvUmVzdWx0LnRzXG52YXIgQ2Fpcm9SZXN1bHRWYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9SZXN1bHRWYXJpYW50MikgPT4ge1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJPa1wiXSA9IDBdID0gXCJPa1wiO1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJFcnJcIl0gPSAxXSA9IFwiRXJyXCI7XG4gIHJldHVybiBDYWlyb1Jlc3VsdFZhcmlhbnQyO1xufSkoQ2Fpcm9SZXN1bHRWYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb1Jlc3VsdCA9IGNsYXNzIHtcbiAgT2s7XG4gIEVycjtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgcmVzdWx0Q29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9SZXN1bHRWYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb1Jlc3VsdFZhcmlhbnQuT2sgb3IgLkVyci5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIE9rICovKSB7XG4gICAgICB0aGlzLk9rID0gcmVzdWx0Q29udGVudDtcbiAgICAgIHRoaXMuRXJyID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk9rID0gdm9pZCAwO1xuICAgICAgdGhpcy5FcnIgPSByZXN1bHRDb250ZW50O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBSZXN1bHQuXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLk9rICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5PaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLkVyciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMuRXJyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIFJlc3VsdC5PayBhbmQgLkVyciBhcmUgdW5kZWZpbmVkLiBOb3QgYXV0aG9yaXplZC5cIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ09rJy5cbiAgICovXG4gIGlzT2soKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuT2sgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc0VycicuXG4gICAqL1xuICBpc0VycigpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5FcnIgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZm9ybWF0dGVyLnRzXG52YXIgZ3VhcmQgPSB7XG4gIGlzQk46IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoIWlzQmlnSW50KGRhdGFba2V5XSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEYXRhIGFuZCBmb3JtYXR0ZXIgbWlzbWF0Y2ggb24gJHtrZXl9OiR7dHlwZVtrZXldfSwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSAke2tleX06JHtkYXRhW2tleV19IHRvIGJlIEJOIGluc3RlYWQgaXQgaXMgJHt0eXBlb2YgZGF0YVtrZXldfWBcbiAgICAgICk7XG4gIH0sXG4gIHVua25vd246IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBmb3JtYXR0ZXIgdHlwZSBvbiAke2tleX06JHt0eXBlW2tleV19IGZvciBkYXRhICR7a2V5fToke2RhdGFba2V5XX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZvcm1hdHRlcihkYXRhLCB0eXBlLCBzYW1lVHlwZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKFxuICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgZWxUeXBlID0gc2FtZVR5cGUgPz8gdHlwZVtrZXldO1xuICAgICAgaWYgKCEoa2V5IGluIHR5cGUpICYmICFzYW1lVHlwZSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKGVsVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgICAgY29uc3QgYXJyYXlTdHIgPSBmb3JtYXR0ZXIoXG4gICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICBkYXRhW2tleV0ubWFwKChfKSA9PiBlbFR5cGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlTdHIpLmpvaW4oXCJcIik7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICAgIGFjY1trZXldID0gZGVjb2RlU2hvcnRTdHJpbmcodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKGVsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICAgIGFjY1trZXldID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYWNjW2tleV0gPSBlbFR5cGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxUeXBlKSkge1xuICAgICAgICBjb25zdCBhcnJheU9iaiA9IGZvcm1hdHRlcihkYXRhW2tleV0sIGVsVHlwZSwgZWxUeXBlWzBdKTtcbiAgICAgICAgYWNjW2tleV0gPSBPYmplY3QudmFsdWVzKGFycmF5T2JqKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGFjY1trZXldID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGd1YXJkLnVua25vd24oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL3BhcnNlci0wLTEuMS4wLnRzXG52YXIgQWJpUGFyc2VyMSA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoIHdpdGhvdXQgJ19sZW4nIGlucHV0c1xuICAgKiBjYWlybyAwIHJlZHVjZXJcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+ICFpc0xlbihpbnB1dC5uYW1lKSA/IGFjYyArIDEgOiBhY2MsIDApO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFiaS5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTIuMC4wLnRzXG52YXIgQWJpUGFyc2VyMiA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoXG4gICAqIEBwYXJhbSBhYmlNZXRob2QgRnVuY3Rpb25BYmlcbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBtZXRob2RJbnB1dHNMZW5ndGgoYWJpTWV0aG9kKSB7XG4gICAgcmV0dXJuIGFiaU1ldGhvZC5pbnB1dHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIGNvbnN0IGludGYgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiXG4gICAgKTtcbiAgICByZXR1cm4gaW50Zi5pdGVtcy5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmkuZmxhdE1hcCgoZSkgPT4ge1xuICAgICAgaWYgKGUudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICByZXR1cm4gZS5pdGVtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVBYmlQYXJzZXIoYWJpKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRBYmlWZXJzaW9uKGFiaSk7XG4gIGlmICh2ZXJzaW9uID09PSAwIHx8IHZlcnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IEFiaVBhcnNlcjEoYWJpKTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMihhYmkpO1xuICB9XG4gIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBBQkkgdmVyc2lvbiAke3ZlcnNpb259YCk7XG59XG5mdW5jdGlvbiBnZXRBYmlWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSlcbiAgICByZXR1cm4gMjtcbiAgaWYgKGlzQ2Fpcm8xQWJpKGFiaSkpXG4gICAgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgIWFiaU1ldGhvZCAmJiAhYXJnc0NhbGxkYXRhLmxlbmd0aDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3R1cGxlLnRzXG5mdW5jdGlvbiBwYXJzZU5hbWVkVHVwbGUobmFtZWRUdXBsZSkge1xuICBjb25zdCBuYW1lID0gbmFtZWRUdXBsZS5zdWJzdHJpbmcoMCwgbmFtZWRUdXBsZS5pbmRleE9mKFwiOlwiKSk7XG4gIGNvbnN0IHR5cGUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZyhuYW1lLmxlbmd0aCArIFwiOlwiLmxlbmd0aCk7XG4gIHJldHVybiB7IG5hbWUsIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3ViVHVwbGUocykge1xuICBpZiAoIXMuaW5jbHVkZXMoXCIoXCIpKVxuICAgIHJldHVybiB7IHN1YlR1cGxlOiBbXSwgcmVzdWx0OiBzIH07XG4gIGNvbnN0IHN1YlR1cGxlID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICBpZiAoc1tpXSA9PT0gXCIoXCIpIHtcbiAgICAgIGxldCBjb3VudGVyID0gMTtcbiAgICAgIGNvbnN0IGxCcmFja2V0ID0gaTtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjb3VudGVyKSB7XG4gICAgICAgIGlmIChzW2ldID09PSBcIilcIilcbiAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChzW2ldID09PSBcIihcIilcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHN1YlR1cGxlLnB1c2gocy5zdWJzdHJpbmcobEJyYWNrZXQsIGkpKTtcbiAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgIGktLTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHNbaV07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN1YlR1cGxlLFxuICAgIHJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpIHtcbiAgY29uc3QgY2xlYW5UeXBlID0gdHlwZS5yZXBsYWNlKC9cXHMvZywgXCJcIikuc2xpY2UoMSwgLTEpO1xuICBjb25zdCB7IHN1YlR1cGxlLCByZXN1bHQgfSA9IHBhcnNlU3ViVHVwbGUoY2xlYW5UeXBlKTtcbiAgbGV0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIGlmIChpc1R5cGVOYW1lZFR1cGxlKHR5cGUpKSB7XG4gICAgcmVjb21wb3NlZCA9IHJlY29tcG9zZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZU5hbWVkVHVwbGUoaXQpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIHJlY29tcG9zZWQ7XG59XG5mdW5jdGlvbiBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LCBvcGVuLCBjbG9zZSkge1xuICBmb3IgKGxldCBpID0gMCwgY291bnRlciA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnB1dFtpXSA9PT0gb3Blbikge1xuICAgICAgY291bnRlcisrO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPT09IGNsb3NlICYmIC0tY291bnRlciA9PT0gMCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSkge1xuICBjb25zdCBpbnB1dCA9IHR5cGUuc2xpY2UoMSwgLTEpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gIGxldCBsaW1pdEluZGV4O1xuICB3aGlsZSAoY3VycmVudEluZGV4IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGlucHV0W2N1cnJlbnRJbmRleF0gPT09IFwiKFwiOiB7XG4gICAgICAgIGxpbWl0SW5kZXggPSBjdXJyZW50SW5kZXggKyBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LnNsaWNlKGN1cnJlbnRJbmRleCksIFwiKFwiLCBcIilcIikgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgKGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6PFwiLCBjdXJyZW50SW5kZXgpIHx8IGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OjxcIiwgY3VycmVudEluZGV4KSB8fCBpbnB1dC5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb246OjxcIiwgY3VycmVudEluZGV4KSk6IHtcbiAgICAgICAgbGltaXRJbmRleCA9IGN1cnJlbnRJbmRleCArIGdldENsb3N1cmVPZmZzZXQoaW5wdXQuc2xpY2UoY3VycmVudEluZGV4KSwgXCI8XCIsIFwiPlwiKSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBjb21tYUluZGV4ID0gaW5wdXQuaW5kZXhPZihcIixcIiwgY3VycmVudEluZGV4KTtcbiAgICAgICAgbGltaXRJbmRleCA9IGNvbW1hSW5kZXggIT09IC0xID8gY29tbWFJbmRleCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2goaW5wdXQuc2xpY2UoY3VycmVudEluZGV4LCBsaW1pdEluZGV4KSk7XG4gICAgY3VycmVudEluZGV4ID0gbGltaXRJbmRleCArIDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGUpIHtcbiAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3Byb3BlcnR5T3JkZXIudHNcbmZ1bmN0aW9uIGVycm9yVTI1NihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDI1NiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xvdycgYW5kICdoaWdoJyBrZXlzLmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGVycm9yVTUxMihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDUxMiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xpbWIwJyB0byAnbGltYjMnIGtleXMuYFxuICApO1xufVxuZnVuY3Rpb24gb3JkZXJQcm9wc0J5QWJpKHVub3JkZXJlZE9iamVjdCwgYWJpT2ZPYmplY3QsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IG9yZGVySW5wdXQgPSAodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSkgPT4ge1xuICAgIGlmIChpc1R5cGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyQXJyYXkodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFbnVtKGFiaVR5cGUsIGVudW1zKSkge1xuICAgICAgY29uc3QgYWJpT2JqID0gZW51bXNbYWJpVHlwZV07XG4gICAgICByZXR1cm4gb3JkZXJFbnVtKHVub3JkZXJlZEl0ZW0sIGFiaU9iaik7XG4gICAgfVxuICAgIGlmIChpc1R5cGVUdXBsZShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyVHVwbGUodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFdGhBZGRyZXNzKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU5vblplcm8oYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlQnl0ZUFycmF5KGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVNlY3AyNTZrMVBvaW50KGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUoYWJpVHlwZSkpIHtcbiAgICAgIGNvbnN0IHUyNTYgPSB1bm9yZGVyZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiB1MjU2ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB1MjU2O1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJsb3dcIiBpbiB1MjU2ICYmIFwiaGlnaFwiIGluIHUyNTYpKSB7XG4gICAgICAgIHRocm93IGVycm9yVTI1NihhYmlUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGxvdzogdTI1Ni5sb3csIGhpZ2g6IHUyNTYuaGlnaCB9O1xuICAgIH1cbiAgICBpZiAoQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZShhYmlUeXBlKSkge1xuICAgICAgY29uc3QgdTUxMiA9IHVub3JkZXJlZEl0ZW07XG4gICAgICBpZiAodHlwZW9mIHU1MTIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHU1MTI7XG4gICAgICB9XG4gICAgICBpZiAoIVtcImxpbWIwXCIsIFwibGltYjFcIiwgXCJsaW1iMlwiLCBcImxpbWIzXCJdLmV2ZXJ5KChrZXkpID0+IGtleSBpbiB1NTEyKSkge1xuICAgICAgICB0aHJvdyBlcnJvclU1MTIoYWJpVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsaW1iMDogdTUxMi5saW1iMCwgbGltYjE6IHU1MTIubGltYjEsIGxpbWIyOiB1NTEyLmxpbWIyLCBsaW1iMzogdTUxMi5saW1iMyB9O1xuICAgIH1cbiAgICBpZiAoaXNUeXBlU3RydWN0KGFiaVR5cGUsIHN0cnVjdHMpKSB7XG4gICAgICBjb25zdCBhYmlPZlN0cnVjdCA9IHN0cnVjdHNbYWJpVHlwZV0ubWVtYmVycztcbiAgICAgIHJldHVybiBvcmRlclN0cnVjdCh1bm9yZGVyZWRJdGVtLCBhYmlPZlN0cnVjdCk7XG4gICAgfVxuICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICB9O1xuICBjb25zdCBvcmRlclN0cnVjdCA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IGFiaU9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtLm5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSB8fCAhaXNMZW4oYWJpUGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgWW91ciBvYmplY3QgbmVlZHMgYSBwcm9wZXJ0eSB3aXRoIGtleSA6ICR7YWJpUGFyYW0ubmFtZX0gLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0sIGFiaVBhcmFtLnR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH07XG4gIGZ1bmN0aW9uIG9yZGVyQXJyYXkobXlBcnJheSwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlSW5BcnJheSA9IGdldEFycmF5VHlwZShhYmlQYXJhbSk7XG4gICAgaWYgKGlzU3RyaW5nKG15QXJyYXkpKSB7XG4gICAgICByZXR1cm4gbXlBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIG15QXJyYXkubWFwKChteUVsZW0pID0+IG9yZGVySW5wdXQobXlFbGVtLCB0eXBlSW5BcnJheSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9yZGVyVHVwbGUodW5vcmRlcmVkT2JqZWN0MiwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlTGlzdCA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKGFiaVBhcmFtKTtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IHR5cGVMaXN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpVHlwZUNhaXJvWCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG15T2JqS2V5cyA9IE9iamVjdC5rZXlzKHVub3JkZXJlZE9iamVjdDIpO1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBpbmRleC50b1N0cmluZygpLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFiaVR5cGUgPSBhYmlUeXBlQ2Fpcm9YPy50eXBlID8gYWJpVHlwZUNhaXJvWC50eXBlIDogYWJpVHlwZUNhaXJvWDtcbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXSwgYWJpVHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfVxuICBjb25zdCBvcmRlckVudW0gPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgaWYgKGlzVHlwZVJlc3VsdChhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZFJlc3VsdCA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRPa1R5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCIsXCIpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzdWx0RXJyVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIixcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkUmVzdWx0LmlzT2soKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAgIDAgLyogT2sgKi8sXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRPa1R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAxIC8qIEVyciAqLyxcbiAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRFcnJUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU9wdGlvbihhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZE9wdGlvbiA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRTb21lVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkT3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oXG4gICAgICAgICAgMCAvKiBTb21lICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT3B0aW9uLnVud3JhcCgpLCByZXN1bHRTb21lVHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oMSAvKiBOb25lICovLCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IHVub3JkZXJlZEN1c3RvbUVudW0gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXModW5vcmRlcmVkQ3VzdG9tRW51bS52YXJpYW50KTtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0gdmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhcmlhbnRbMV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50VHlwZSA9IGFiaU9iamVjdC50eXBlLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHZhcmlhbnRUeXBlID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3ZhcmlhbnRbMF0sIG9yZGVySW5wdXQodW5vcmRlcmVkQ3VzdG9tRW51bS51bndyYXAoKSwgdmFyaWFudFR5cGUpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bShPYmplY3QuZnJvbUVudHJpZXMobmV3RW50cmllcykpO1xuICB9O1xuICBjb25zdCBmaW5hbE9yZGVyZWRPYmplY3QgPSBhYmlPZk9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoaXNMZW4oYWJpUGFyYW0ubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0W2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGZpbmFsT3JkZXJlZE9iamVjdDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3JlcXVlc3RQYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbCkge1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk6XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDI1Nih2YWwpLnRvQXBpUmVxdWVzdCgpO1xuICAgIGNhc2UgQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKHZhbCkudG9BcGlSZXF1ZXN0KCk7XG4gICAgY2FzZSBpc1R5cGVCeXRlczMxKHR5cGUpOlxuICAgICAgcmV0dXJuIGVuY29kZVNob3J0U3RyaW5nKHZhbC50b1N0cmluZygpKTtcbiAgICBjYXNlIGlzVHlwZVNlY3AyNTZrMVBvaW50KHR5cGUpOiB7XG4gICAgICBjb25zdCBwdWJLZXlFVEggPSByZW1vdmVIZXhQcmVmaXgodG9IZXgodmFsKSkucGFkU3RhcnQoMTI4LCBcIjBcIik7XG4gICAgICBjb25zdCBwdWJLZXlFVEh5ID0gdWludDI1NihhZGRIZXhQcmVmaXgocHViS2V5RVRILnNsaWNlKC02NCkpKTtcbiAgICAgIGNvbnN0IHB1YktleUVUSHggPSB1aW50MjU2KGFkZEhleFByZWZpeChwdWJLZXlFVEguc2xpY2UoMCwgLTY0KSkpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgZmVsdChwdWJLZXlFVEh4LmxvdyksXG4gICAgICAgIGZlbHQocHViS2V5RVRIeC5oaWdoKSxcbiAgICAgICAgZmVsdChwdWJLZXlFVEh5LmxvdyksXG4gICAgICAgIGZlbHQocHViS2V5RVRIeS5oaWdoKVxuICAgICAgXTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmZWx0KHZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVHVwbGUoZWxlbWVudCwgdHlwZVN0cikge1xuICBjb25zdCBtZW1iZXJUeXBlcyA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGVTdHIpO1xuICBjb25zdCBlbGVtZW50cyA9IE9iamVjdC52YWx1ZXMoZWxlbWVudCk7XG4gIGlmIChlbGVtZW50cy5sZW5ndGggIT09IG1lbWJlclR5cGVzLmxlbmd0aCkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYFBhcnNlVHVwbGU6IHByb3ZpZGVkIGFuZCBleHBlY3RlZCBhYmkgdHVwbGUgc2l6ZSBkbyBub3QgbWF0Y2guXG4gICAgICBwcm92aWRlZDogJHtlbGVtZW50c30gXG4gICAgICBleHBlY3RlZDogJHttZW1iZXJUeXBlc31gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWVtYmVyVHlwZXMubWFwKChpdCwgZHgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudDogZWxlbWVudHNbZHhdLFxuICAgICAgdHlwZTogaXQudHlwZSA/PyBpdFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VCeXRlQXJyYXkoZWxlbWVudCkge1xuICBjb25zdCBteUJ5dGVBcnJheSA9IGJ5dGVBcnJheUZyb21TdHJpbmcoZWxlbWVudCk7XG4gIHJldHVybiBbXG4gICAgbXlCeXRlQXJyYXkuZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAuLi5teUJ5dGVBcnJheS5kYXRhLm1hcCgoYm4pID0+IGJuLnRvU3RyaW5nKCkpLFxuICAgIG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZC50b1N0cmluZygpLFxuICAgIG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZF9sZW4udG9TdHJpbmcoKVxuICBdO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxsZGF0YVZhbHVlKGVsZW1lbnQsIHR5cGUsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBFcnJvcihgTWlzc2luZyBwYXJhbWV0ZXIgZm9yIHR5cGUgJHt0eXBlfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0LnB1c2goZmVsdChlbGVtZW50Lmxlbmd0aCkpO1xuICAgIGNvbnN0IGFycmF5VHlwZSA9IGdldEFycmF5VHlwZSh0eXBlKTtcbiAgICByZXR1cm4gZWxlbWVudC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFWYWx1ZShpdCwgYXJyYXlUeXBlLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH1cbiAgaWYgKHN0cnVjdHNbdHlwZV0gJiYgc3RydWN0c1t0eXBlXS5tZW1iZXJzLmxlbmd0aCkge1xuICAgIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDI1NihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgICB9XG4gICAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGVsZW1lbnQpLnRvQXBpUmVxdWVzdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIilcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbiAgICBpZiAodHlwZSA9PT0gXCJjb3JlOjpieXRlX2FycmF5OjpCeXRlQXJyYXlcIilcbiAgICAgIHJldHVybiBwYXJzZUJ5dGVBcnJheShlbGVtZW50KTtcbiAgICBjb25zdCB7IG1lbWJlcnMgfSA9IHN0cnVjdHNbdHlwZV07XG4gICAgY29uc3Qgc3ViRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoc3ViRWxlbWVudFtpdC5uYW1lXSwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKGlzVHlwZVR1cGxlKHR5cGUpKSB7XG4gICAgY29uc3QgdHVwbGVkID0gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlKTtcbiAgICByZXR1cm4gdHVwbGVkLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShpdC5lbGVtZW50LCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZWREYXRhKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDI1NihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgfVxuICBpZiAoQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGVsZW1lbnQpLnRvQXBpUmVxdWVzdCgpO1xuICB9XG4gIGlmIChpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSkge1xuICAgIGNvbnN0IHsgdmFyaWFudHMgfSA9IGVudW1zW3R5cGVdO1xuICAgIGlmIChpc1R5cGVPcHRpb24odHlwZSkpIHtcbiAgICAgIGNvbnN0IG15T3B0aW9uID0gZWxlbWVudDtcbiAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQyID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIlNvbWVcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBPcHRpb24gaGFzIG5vICdTb21lJyB2YXJpYW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVWYXJpYW50U29tZSA9IGxpc3RUeXBlVmFyaWFudDIudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50U29tZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgICAgcmV0dXJuIDAgLyogU29tZSAqLy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlPcHRpb24udW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRTb21lLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC8qIE5vbmUgKi8udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVJlc3VsdCh0eXBlKSkge1xuICAgICAgY29uc3QgbXlSZXN1bHQgPSBlbGVtZW50O1xuICAgICAgaWYgKG15UmVzdWx0LmlzT2soKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQzID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIk9rXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnT2snIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRPayA9IGxpc3RUeXBlVmFyaWFudDMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50T2sgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiAwIC8qIE9rICovLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMyA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgICBteVJlc3VsdC51bndyYXAoKSxcbiAgICAgICAgICB0eXBlVmFyaWFudE9rLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMykpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogT2sgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswIC8qIE9rICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJFcnJcIik7XG4gICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ0VycicgdmFyaWFudC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGVWYXJpYW50RXJyID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgaWYgKHR5cGVWYXJpYW50RXJyID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogRXJyICovLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIyID0gcGFyc2VDYWxsZGF0YVZhbHVlKG15UmVzdWx0LnVud3JhcCgpLCB0eXBlVmFyaWFudEVyciwgc3RydWN0cywgZW51bXMpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgcmV0dXJuIFsxIC8qIEVyciAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbMSAvKiBFcnIgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgfVxuICAgIGNvbnN0IG15RW51bSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgY29uc3QgbGlzdFR5cGVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3IoYE5vdCBmaW5kIGluIGFiaSA6IEVudW0gaGFzIG5vICcke2FjdGl2ZVZhcmlhbnR9JyB2YXJpYW50LmApO1xuICAgIH1cbiAgICBjb25zdCB0eXBlQWN0aXZlVmFyaWFudCA9IGxpc3RUeXBlVmFyaWFudC50eXBlO1xuICAgIGNvbnN0IG51bUFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kSW5kZXgoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVBY3RpdmVWYXJpYW50ID09PSBcIigpXCIpIHtcbiAgICAgIHJldHVybiBudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlciA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteUVudW0udW53cmFwKCksIHR5cGVBY3RpdmVWYXJpYW50LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyKSkge1xuICAgICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcl07XG4gICAgfVxuICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXJdO1xuICB9XG4gIGlmIChpc1R5cGVOb25aZXJvKHR5cGUpKSB7XG4gICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKGdldEFycmF5VHlwZSh0eXBlKSwgZWxlbWVudCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhcmFtZXRlciAke2VsZW1lbnR9IGRvIG5vdCBhbGlnbiB3aXRoIGFiaSBwYXJhbWV0ZXIgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICBsZXQgeyB2YWx1ZSB9ID0gYXJnc0l0ZXJhdG9yLm5leHQoKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzVGV4dCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEFCSSBleHBlY3RlZCBwYXJhbWV0ZXIgJHtuYW1lfSB0byBiZSBhcnJheSBvciBsb25nIHN0cmluZywgZ290ICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIGlucHV0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZU5vblplcm8odHlwZSk6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXMoZ2V0QXJyYXlUeXBlKHR5cGUpLCB2YWx1ZSk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbHVlKTtcbiAgICBjYXNlIChpc1R5cGVTdHJ1Y3QodHlwZSwgc3RydWN0cykgfHwgaXNUeXBlVHVwbGUodHlwZSkgfHwgQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKSB8fCBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIHR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUVudW0odHlwZSwgZW51bXMpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0cnVjdHMsXG4gICAgICAgIGVudW1zXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXNwb25zZVBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIGl0KSB7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUJvb2wodHlwZSk6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oQmlnSW50KHRlbXApKTtcbiAgICBjYXNlIENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk6XG4gICAgICBjb25zdCBsb3cgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBoaWdoID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYobG93LCBoaWdoKS50b0JpZ0ludCgpO1xuICAgIGNhc2UgQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIGNvbnN0IGxpbWIwID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgbGltYjEgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBsaW1iMiA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IGxpbWIzID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpLnRvQmlnSW50KCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OmJ5dGVzXzMxOjpieXRlczMxXCI6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIGRlY29kZVNob3J0U3RyaW5nKHRlbXApO1xuICAgIGNhc2UgaXNUeXBlU2VjcDI1NmsxUG9pbnQodHlwZSk6XG4gICAgICBjb25zdCB4TG93ID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHhIaWdoID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHlMb3cgPSByZW1vdmVIZXhQcmVmaXgoaXQubmV4dCgpLnZhbHVlKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICAgICAgY29uc3QgeUhpZ2ggPSByZW1vdmVIZXhQcmVmaXgoaXQubmV4dCgpLnZhbHVlKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICAgICAgY29uc3QgcHViSyA9IEJpZ0ludChhZGRIZXhQcmVmaXgoeEhpZ2ggKyB4TG93ICsgeUhpZ2ggKyB5TG93KSk7XG4gICAgICByZXR1cm4gcHViSztcbiAgICBkZWZhdWx0OlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbGVtZW50LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBpZiAoZWxlbWVudC50eXBlID09PSBcIigpXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IGxvdyA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGhpZ2ggPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDI1Nihsb3csIGhpZ2gpLnRvQmlnSW50KCk7XG4gIH1cbiAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IGxpbWIwID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgbGltYjEgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBsaW1iMiA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGxpbWIzID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpLnRvQmlnSW50KCk7XG4gIH1cbiAgaWYgKGlzVHlwZUJ5dGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkQnl0ZXMzMUFyciA9IFtdO1xuICAgIGNvbnN0IGJ5dGVzMzFBcnJMZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWRCeXRlczMxQXJyLmxlbmd0aCA8IGJ5dGVzMzFBcnJMZW4pIHtcbiAgICAgIHBhcnNlZEJ5dGVzMzFBcnIucHVzaCh0b0hleChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nX3dvcmQgPSB0b0hleChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgY29uc3QgcGVuZGluZ193b3JkX2xlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgY29uc3QgbXlCeXRlQXJyYXkgPSB7XG4gICAgICBkYXRhOiBwYXJzZWRCeXRlczMxQXJyLFxuICAgICAgcGVuZGluZ193b3JkLFxuICAgICAgcGVuZGluZ193b3JkX2xlblxuICAgIH07XG4gICAgcmV0dXJuIHN0cmluZ0Zyb21CeXRlQXJyYXkobXlCeXRlQXJyYXkpO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICBpZiAoaXNUeXBlTm9uWmVybyhlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpO1xuICB9XG4gIGlmIChzdHJ1Y3RzICYmIGVsZW1lbnQudHlwZSBpbiBzdHJ1Y3RzICYmIHN0cnVjdHNbZWxlbWVudC50eXBlXSkge1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpIHtcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHNbZWxlbWVudC50eXBlXS5tZW1iZXJzLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgYWNjW2VsLm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoZW51bXMgJiYgZWxlbWVudC50eXBlIGluIGVudW1zICYmIGVudW1zW2VsZW1lbnQudHlwZV0pIHtcbiAgICBjb25zdCB2YXJpYW50TnVtID0gTnVtYmVyKHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCByYXdFbnVtID0gZW51bXNbZWxlbWVudC50eXBlXS52YXJpYW50cy5yZWR1Y2UoKGFjYywgdmFyaWFudCwgbnVtKSA9PiB7XG4gICAgICBpZiAobnVtID09PSB2YXJpYW50TnVtKSB7XG4gICAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB2YXJpYW50LnR5cGUgfSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBhY2NbdmFyaWFudC5uYW1lXSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdmFyaWFudE51bSA9PT0gMCAvKiBTb21lICovID8gcmF3RW51bS5Tb21lIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbih2YXJpYW50TnVtLCBjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHRcIikpIHtcbiAgICAgIGxldCBjb250ZW50O1xuICAgICAgaWYgKHZhcmlhbnROdW0gPT09IDAgLyogT2sgKi8pIHtcbiAgICAgICAgY29udGVudCA9IHJhd0VudW0uT2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5FcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjdXN0b21FbnVtID0gbmV3IENhaXJvQ3VzdG9tRW51bShyYXdFbnVtKTtcbiAgICByZXR1cm4gY3VzdG9tRW51bTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoZWxlbWVudC50eXBlKTtcbiAgICByZXR1cm4gbWVtYmVyVHlwZXMucmVkdWNlKChhY2MsIGl0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpdD8ubmFtZSA/IGl0Lm5hbWUgOiBpZHg7XG4gICAgICBjb25zdCB0eXBlID0gaXQ/LnR5cGUgPyBpdC50eXBlIDogaXQ7XG4gICAgICBjb25zdCBlbCA9IHsgbmFtZSwgdHlwZSB9O1xuICAgICAgYWNjW25hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcywgcGFyc2VkUmVzdWx0KSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gb3V0cHV0O1xuICBsZXQgdGVtcDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc0xlbihuYW1lKTpcbiAgICAgIHRlbXAgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSAoc3RydWN0cyAmJiB0eXBlIGluIHN0cnVjdHMgfHwgaXNUeXBlVHVwbGUodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIChlbnVtcyAmJiBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgaXNUeXBlQXJyYXkodHlwZSk6XG4gICAgICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgICBpZiAocGFyc2VkUmVzdWx0ICYmIHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXSkge1xuICAgICAgICBjb25zdCBhcnJMZW4gPSBwYXJzZWRSZXN1bHRbYCR7bmFtZX1fbGVuYF07XG4gICAgICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGFyckxlbikge1xuICAgICAgICAgIHBhcnNlZERhdGFBcnIucHVzaChcbiAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VWYWx1ZShcbiAgICAgICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICAgICAgeyBuYW1lLCB0eXBlOiBvdXRwdXQudHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSB9LFxuICAgICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgICBlbnVtc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICAgIGNhc2UgaXNUeXBlTm9uWmVybyh0eXBlKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIodHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3ZhbGlkYXRlLnRzXG52YXIgdmFsaWRhdGVGZWx0ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIGlzU3RyaW5nKHBhcmFtZXRlcikgfHwgaXNOdW1iZXIocGFyYW1ldGVyKSB8fCBpc0JpZ0ludChwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgZmVsdCB0eXBlZCBhcyAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KWBcbiAgKTtcbiAgaWYgKGlzU3RyaW5nKHBhcmFtZXRlcikgJiYgIWlzSGV4KHBhcmFtZXRlcikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgYXNzZXJ0KFxuICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjY2XG4gICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUJ5dGVzMzEgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoaXNTdHJpbmcocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYSBzdHJpbmcuYCk7XG4gIGFzc2VydChcbiAgICBwYXJhbWV0ZXIubGVuZ3RoIDwgMzIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBhIHN0cmluZyBvZiBsZXNzIHRoYW4gMzIgY2hhcmFjdGVycy5gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQnl0ZUFycmF5ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KGlzU3RyaW5nKHBhcmFtZXRlciksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgc3RyaW5nLmApO1xufTtcbnZhciB2YWxpZGF0ZVVpbnQgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBpZiAoaXNOdW1iZXIocGFyYW1ldGVyKSkge1xuICAgIGFzc2VydChcbiAgICAgIHBhcmFtZXRlciA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGBWYWxpZGF0aW9uOiBQYXJhbWV0ZXIgaXMgdG8gbGFyZ2UgdG8gYmUgdHlwZWQgYXMgTnVtYmVyIHVzZSAoQmlnSW50IG9yIFN0cmluZylgXG4gICAgKTtcbiAgfVxuICBhc3NlcnQoXG4gICAgaXNTdHJpbmcocGFyYW1ldGVyKSB8fCBpc051bWJlcihwYXJhbWV0ZXIpIHx8IGlzQmlnSW50KHBhcmFtZXRlcikgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBcImxvd1wiIGluIHBhcmFtZXRlciAmJiBcImhpZ2hcIiBpbiBwYXJhbWV0ZXIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBbXCJsaW1iMFwiLCBcImxpbWIxXCIsIFwibGltYjJcIiwgXCJsaW1iM1wiXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gcGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG9mIGNhaXJvIHR5cGUgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgdHlwZSAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KSwgYnV0IGlzICR7dHlwZW9mIHBhcmFtZXRlcn0gJHtwYXJhbWV0ZXJ9LmBcbiAgKTtcbiAgbGV0IHBhcmFtO1xuICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi86XG4gICAgICBwYXJhbSA9IG5ldyBDYWlyb1VpbnQyNTYocGFyYW1ldGVyKS50b0JpZ0ludCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU1MTJcIiAvKiB1NTEyICovOlxuICAgICAgcGFyYW0gPSBuZXcgQ2Fpcm9VaW50NTEyKHBhcmFtZXRlcikudG9CaWdJbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJhbSA9IHRvQmlnSW50KHBhcmFtZXRlcik7XG4gIH1cbiAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU4XCIgLyogdTggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDI1NW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAgLSAyNTVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MTZcIiAvKiB1MTYgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDY1NTM1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNjU1MzVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MzJcIiAvKiB1MzIgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDQyOTQ5NjcyOTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCA0Mjk0OTY3Mjk1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTY0XCIgLyogdTY0ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiA2NG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl42NC0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiIC8qIHUxMjggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDEyOG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xMjgtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTZuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgJHtpbnB1dC50eXBlfSAwIC0gMl4yNTYtMWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTUxMlwiIC8qIHU1MTIgKi86XG4gICAgICBhc3NlcnQoQ2Fpcm9VaW50NTEyLmlzKHBhcmFtKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IDAgLSAyXjUxMi0xYCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiIC8qIENsYXNzSGFzaCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDE2NzBcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiIC8qIENvbnRyYWN0QWRkcmVzcyAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDEyNDVcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OnNlY3AyNTZrMTo6U2VjcDI1NmsxUG9pbnRcIiAvKiBTZWNwMjU2azFQb2ludCAqLzoge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiA1MTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gbXVzdCBiZSAke2lucHV0LnR5cGV9IDogYSA1MTIgYml0cyBudW1iZXIuYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVCb29sID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIGlzQm9vbGVhbihwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gb2YgY2Fpcm8gdHlwZSAke2lucHV0LnR5cGV9IHNob3VsZCBiZSB0eXBlIChCb29sZWFuKWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVTdHJ1Y3QgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cykgPT4ge1xuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLyB8fCBpbnB1dC50eXBlID09PSBcImNvcmU6OmludGVnZXI6OnU1MTJcIiAvKiB1NTEyICovKSB7XG4gICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBwYXJhbWV0ZXIgIT09IFwib2JqZWN0XCIsXG4gICAgICBgRXRoQWRkcmVzcyB0eXBlIGlzIHdhaXRpbmcgYSBCaWdOdW1iZXJpc2guIEdvdCAke3BhcmFtZXRlcn1gXG4gICAgKTtcbiAgICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgICBhc3NlcnQoXG4gICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI1OVxuICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTYwbiAtIDFuLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xNjAtMV1gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgc3RydWN0ICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgc3RydWN0c1tpbnB1dC50eXBlXS5tZW1iZXJzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgYXNzZXJ0KFxuICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5pbmNsdWRlcyhuYW1lKSxcbiAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGhhdmUgYSBwcm9wZXJ0eSAke25hbWV9YFxuICAgICk7XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZUVudW0gPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBFbnVtICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyYW1ldGVyKSk7XG4gIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyYW1ldGVyKSwgLi4ubWV0aG9kc0tleXNdO1xuICBpZiAoaXNUeXBlT3B0aW9uKGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNUeXBlUmVzdWx0KGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBWYWxpZGF0ZSBFbnVtOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlIHJlY2VpdmVkICR7cGFyYW1ldGVyfSwgaXMgbm90IGFuIEVudW0uYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVR1cGxlID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHR1cGxlIChkZWZpbmVkIGFzIG9iamVjdClgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQXJyYXkgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGlmIChpc1R5cGVGZWx0KGJhc2VUeXBlKSAmJiBpc0xvbmdUZXh0KHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYW4gQXJyYXlgKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVGZWx0KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVUdXBsZShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlVHVwbGUoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVBcnJheShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKHBhcmFtKSA9PiB2YWxpZGF0ZUFycmF5KHBhcmFtLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMsIGVudW1zKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlU3RydWN0KGJhc2VUeXBlLCBzdHJ1Y3RzKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAoaXQpID0+IHZhbGlkYXRlU3RydWN0KGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVFbnVtKGJhc2VUeXBlLCBlbnVtcyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlRW51bShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChpc1R5cGVVaW50KGJhc2VUeXBlKSB8fCBpc1R5cGVMaXRlcmFsKGJhc2VUeXBlKSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlVWludChwYXJhbSwgeyBuYW1lOiBcIlwiLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUJvb2woYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUJvb2wocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVOb25aZXJvID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGFzc2VydChcbiAgICBpc1R5cGVVaW50KGJhc2VUeXBlKSAmJiBiYXNlVHlwZSAhPT0gQ2Fpcm9VaW50NTEyLmFiaVNlbGVjdG9yIHx8IGlzVHlwZUZlbHQoYmFzZVR5cGUpLFxuICAgIGBWYWxpZGF0ZTogJHtpbnB1dC5uYW1lfSB0eXBlIGlzIG5vdCBhdXRob3JpemVkIGZvciBOb25aZXJvIHR5cGUuYFxuICApO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUZlbHQoYmFzZVR5cGUpOlxuICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBCaWdJbnQocGFyYW1ldGVyLnRvU3RyaW5nKDEwKSkgPiAwLFxuICAgICAgICBcIlZhbGlkYXRlOiB2YWx1ZSAwIGlzIG5vdCBhdXRob3JpemVkIGluIE5vblplcm8gZmVsdDI1MiB0eXBlLlwiXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVVaW50KGJhc2VUeXBlKTpcbiAgICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIHsgbmFtZTogXCJcIiwgdHlwZTogYmFzZVR5cGUgfSk7XG4gICAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovOlxuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIG5ldyBDYWlyb1VpbnQyNTYocGFyYW1ldGVyKS50b0JpZ0ludCgpID4gMCxcbiAgICAgICAgICAgIFwiVmFsaWRhdGU6IHZhbHVlIDAgaXMgbm90IGF1dGhvcml6ZWQgaW4gTm9uWmVybyB1aW50MjU2IHR5cGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIHRvQmlnSW50KHBhcmFtZXRlcikgPiAwLFxuICAgICAgICAgICAgXCJWYWxpZGF0ZTogdmFsdWUgMCBpcyBub3QgYXV0aG9yaXplZCBpbiBOb25aZXJvIHVpbnQgdHlwZS5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKChhY2MsIGlucHV0KSA9PiB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gYXJnc1thY2NdO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBpc0xlbihpbnB1dC5uYW1lKTpcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIGNhc2UgaXNUeXBlRmVsdChpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlQnl0ZXMzMShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVCeXRlczMxKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKGlzVHlwZVVpbnQoaW5wdXQudHlwZSkgfHwgaXNUeXBlTGl0ZXJhbChpbnB1dC50eXBlKSk6XG4gICAgICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJvb2woaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQm9vbChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJ5dGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVCeXRlQXJyYXkocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVBcnJheShwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVTdHJ1Y3QoaW5wdXQudHlwZSwgc3RydWN0cyk6XG4gICAgICAgIHZhbGlkYXRlU3RydWN0KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlRW51bShpbnB1dC50eXBlLCBlbnVtcyk6XG4gICAgICAgIHZhbGlkYXRlRW51bShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVR1cGxlKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZVR1cGxlKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlTm9uWmVybyhpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVOb25aZXJvKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIDE7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvaW5kZXgudHNcbnZhciBDYWxsRGF0YSA9IGNsYXNzIF9DYWxsRGF0YSB7XG4gIGFiaTtcbiAgcGFyc2VyO1xuICBzdHJ1Y3RzO1xuICBlbnVtcztcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gX0NhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZW51bXMgPSBfQ2FsbERhdGEuZ2V0QWJpRW51bShhYmkpO1xuICAgIHRoaXMucGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSB0aGlzLnBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9uZXMgaW4gdGhlIGFiaVxuICAgKiBAcGFyYW0gdHlwZSBWYWxpZGF0ZVR5cGUgLSB0eXBlIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBuYW1lIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIGFyZ3MgQXJnc09yQ2FsbGRhdGEgLSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICovXG4gIHZhbGlkYXRlKHR5cGUsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgaWYgKHR5cGUgIT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICBjb25zdCBpbnZvY2FibGVGdW5jdGlvbk5hbWVzID0gdGhpcy5hYmkuZmlsdGVyKChhYmkpID0+IHtcbiAgICAgICAgaWYgKGFiaS50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpc1ZpZXcgPSBhYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBhYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCI7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/ICFpc1ZpZXcgOiBpc1ZpZXc7XG4gICAgICB9KS5tYXAoKGFiaSkgPT4gYWJpLm5hbWUpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBpbnZvY2FibGVGdW5jdGlvbk5hbWVzLmluY2x1ZGVzKG1ldGhvZCksXG4gICAgICAgIGAke3R5cGUgPT09IFwiSU5WT0tFXCIgLyogSU5WT0tFICovID8gXCJpbnZvY2FibGVcIiA6IFwidmlld2FibGVcIn0gbWV0aG9kIG5vdCBmb3VuZCBpbiBhYmlgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGFiaSkgPT4gdHlwZSA9PT0gXCJERVBMT1lcIiAvKiBERVBMT1kgKi8gPyBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIgOiBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICApO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3MsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRzTGVuZ3RoID0gdGhpcy5wYXJzZXIubWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBpbnB1dHNMZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAke2lucHV0c0xlbmd0aH0gYXJndW1lbnRzLCBidXQgZ290ICR7YXJncy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGggYWJpXG4gICAqIFBhcnNlIHRoZSBjYWxsZGF0YSBieSB1c2luZyBpbnB1dCBmaWVsZHMgZnJvbSB0aGUgYWJpIGZvciB0aGF0IG1ldGhvZFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzQ2FsbGRhdGEgUmF3QXJncyAtIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZC4gQ2FuIGJlIGFuIGFycmF5IG9mIGFyZ3VtZW50cyAoaW4gdGhlIG9yZGVyIG9mIGFiaSBkZWZpbml0aW9uKSwgb3IgYW4gb2JqZWN0IGNvbnN0cnVjdGVkIGluIGNvbmZvcm1pdHkgd2l0aCBhYmkgKGluIHRoaXMgY2FzZSwgdGhlIHBhcmFtZXRlciBjYW4gYmUgaW4gYSB3cm9uZyBvcmRlcikuXG4gICAqIEByZXR1cm4gQ2FsbGRhdGEgLSBwYXJzZWQgYXJndW1lbnRzIGluIGZvcm1hdCB0aGF0IGNvbnRyYWN0IGlzIGV4cGVjdGluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhID0gbXlDYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgW1wiMHgzNGFcIiwgWzEsIDNuXV0pO1xuICAgKiBgYGBcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsZGF0YTIgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCB7bGlzdDpbMSwgM25dLCBiYWxhbmNlOlwiMHgzNFwifSk7IC8vIHdyb25nIG9yZGVyIGlzIHZhbGlkXG4gICAqIGBgYFxuICAgKi9cbiAgY29tcGlsZShtZXRob2QsIGFyZ3NDYWxsZGF0YSkge1xuICAgIGNvbnN0IGFiaU1ldGhvZCA9IHRoaXMuYWJpLmZpbmQoKGFiaUZ1bmN0aW9uKSA9PiBhYmlGdW5jdGlvbi5uYW1lID09PSBtZXRob2QpO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3NDYWxsZGF0YSwgYWJpTWV0aG9kKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgYXJncztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzQ2FsbGRhdGEpKSB7XG4gICAgICBhcmdzID0gYXJnc0NhbGxkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmRlcmVkT2JqZWN0ID0gb3JkZXJQcm9wc0J5QWJpKFxuICAgICAgICBhcmdzQ2FsbGRhdGEsXG4gICAgICAgIGFiaU1ldGhvZC5pbnB1dHMsXG4gICAgICAgIHRoaXMuc3RydWN0cyxcbiAgICAgICAgdGhpcy5lbnVtc1xuICAgICAgKTtcbiAgICAgIGFyZ3MgPSBPYmplY3QudmFsdWVzKG9yZGVyZWRPYmplY3QpO1xuICAgICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICAgIH1cbiAgICBjb25zdCBhcmdzSXRlcmF0b3IgPSBhcmdzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBjYWxsQXJyYXkgPSBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZShcbiAgICAgIChhY2MsIGlucHV0KSA9PiBpc0xlbihpbnB1dC5uYW1lKSAmJiAhaXNDYWlybzFUeXBlKGlucHV0LnR5cGUpID8gYWNjIDogYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhRmllbGQoYXJnc0l0ZXJhdG9yLCBpbnB1dCwgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKSksXG4gICAgICBbXVxuICAgICk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxBcnJheSwgXCJfX2NvbXBpbGVkX19cIiwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsQXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBpbGUgY29udHJhY3QgY2FsbERhdGEgd2l0aG91dCBhYmlcbiAgICogQHBhcmFtIHJhd0FyZ3MgUmF3QXJncyByZXByZXNlbnRpbmcgY2Fpcm8gbWV0aG9kIGFyZ3VtZW50cyBvciBzdHJpbmcgYXJyYXkgb2YgY29tcGlsZWQgZGF0YVxuICAgKiBAcmV0dXJucyBDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIGNvbXBpbGUocmF3QXJncykge1xuICAgIGNvbnN0IGNyZWF0ZVRyZWUgPSAob2JqKSA9PiB7XG4gICAgICBjb25zdCBnZXRFbnRyaWVzID0gKG8sIHByZWZpeCA9IFwiLlwiKSA9PiB7XG4gICAgICAgIGNvbnN0IG9lID0gQXJyYXkuaXNBcnJheShvKSA/IFtvLmxlbmd0aC50b1N0cmluZygpLCAuLi5vXSA6IG87XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvZSkuZmxhdE1hcCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdjtcbiAgICAgICAgICBpZiAoayA9PT0gXCJlbnRyeXBvaW50XCIpXG4gICAgICAgICAgICB2YWx1ZSA9IGdldFNlbGVjdG9yRnJvbU5hbWUodmFsdWUpO1xuICAgICAgICAgIGVsc2UgaWYgKGlzTG9uZ1RleHQodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXlGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBrayA9IEFycmF5LmlzQXJyYXkob2UpICYmIGsgPT09IFwiMFwiID8gXCIkJGxlblwiIDogaztcbiAgICAgICAgICBpZiAoaXNCaWdJbnQodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgICBpZiAoT2JqZWN0KHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHNLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSwgLi4ubWV0aG9kc0tleXNdO1xuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteU9wdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteU9wdGlvbi5pc1NvbWUoKSA/IDAgLyogU29tZSAqLyA6IDEgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgaWYgKG15T3B0aW9uLmlzU29tZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteU9wdGlvbi51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFyaWFudE5iKV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteVJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteVJlc3VsdC5pc09rKCkgPyAwIC8qIE9rICovIDogMSAvKiBFcnIgKi87XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteVJlc3VsdC51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlFbnVtID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSBteUVudW0uYWN0aXZlVmFyaWFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsaXN0VmFyaWFudHMgPSBPYmplY3Qua2V5cyhteUVudW0udmFyaWFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnROYiA9IGxpc3RWYXJpYW50cy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgKHZhcmlhbnQpID0+IHZhcmlhbnQgPT09IGFjdGl2ZVZhcmlhbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUVudW0udW53cmFwKCkgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMobXlFbnVtLnVud3JhcCgpKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KGFjdGl2ZVZhcmlhbnROYildXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IGFjdGl2ZVZhcmlhbnROYiwgMTogbXlFbnVtLnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHZhbHVlLCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRFbnRyaWVzKG9iaikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGxldCBjYWxsVHJlZUFycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYXdBcmdzKSkge1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKHJhd0FyZ3MpO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYWxsT2JqID0geyAuLi5yYXdBcmdzIH07XG4gICAgICBjb25zdCBjYWxsVHJlZSA9IGNyZWF0ZVRyZWUoY2FsbE9iaik7XG4gICAgICBjYWxsVHJlZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhjYWxsVHJlZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsVHJlZUFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxUcmVlQXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGVsZW1lbnRzIG9mIHRoZSByZXNwb25zZSBhcnJheSBhbmQgc3RydWN0dXJpbmcgdGhlbSBpbnRvIHJlc3BvbnNlIG9iamVjdFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIHJlc3BvbnNlIGZyb20gdGhlIG1ldGhvZFxuICAgKiBAcmV0dXJuIFJlc3VsdCAtIHBhcnNlZCByZXNwb25zZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBhYmlcbiAgICovXG4gIHBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCB7IG91dHB1dHMgfSA9IHRoaXMuYWJpLmZpbmQoKGFiaSkgPT4gYWJpLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgY29uc3QgcmVzcG9uc2VJdGVyYXRvciA9IHJlc3BvbnNlLmZsYXQoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgcGFyc2VkID0gb3V0cHV0cy5mbGF0KCkucmVkdWNlKChhY2MsIG91dHB1dCwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IG91dHB1dC5uYW1lID8/IGlkeDtcbiAgICAgIGFjY1twcm9wTmFtZV0gPSByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcywgYWNjKTtcbiAgICAgIGlmIChhY2NbcHJvcE5hbWVdICYmIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF0pIHtcbiAgICAgICAgZGVsZXRlIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggPT09IDEgJiYgMCBpbiBwYXJzZWQgPyBwYXJzZWRbMF0gOiBwYXJzZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEZvcm1hdCBjYWlybyBtZXRob2QgcmVzcG9uc2UgZGF0YSB0byBuYXRpdmUganMgdmFsdWVzIGJhc2VkIG9uIHByb3ZpZGVkIGZvcm1hdCBzY2hlbWFcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBjYWlybyBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSBjYWlybyBtZXRob2QgcmVzcG9uc2VcbiAgICogQHBhcmFtIGZvcm1hdCBvYmplY3QgLSBmb3JtYXR0ZXIgb2JqZWN0IHNjaGVtYVxuICAgKiBAcmV0dXJucyBSZXN1bHQgLSBwYXJzZWQgYW5kIGZvcm1hdHRlZCByZXNwb25zZSBvYmplY3RcbiAgICovXG4gIGZvcm1hdChtZXRob2QsIHJlc3BvbnNlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIocGFyc2VkLCBmb3JtYXQpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaVN0cnVjdHMgLSBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpU3RydWN0KGFiaSkge1xuICAgIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJzdHJ1Y3RcIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IGVudW1zIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaUVudW1zIC0gZW51bXMgZnJvbSBhYmlcbiAgICovXG4gIHN0YXRpYyBnZXRBYmlFbnVtKGFiaSkge1xuICAgIGNvbnN0IGZ1bGxFbnVtTGlzdCA9IGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImVudW1cIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gICAgZGVsZXRlIGZ1bGxFbnVtTGlzdFtcImNvcmU6OmJvb2xcIl07XG4gICAgcmV0dXJuIGZ1bGxFbnVtTGlzdDtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb21waWxlIEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEBwYXJhbSByYXdDYWxsZGF0YSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvQ2FsbGRhdGEocmF3Q2FsbGRhdGEgPSBbXSkge1xuICAgIHJldHVybiBfQ2FsbERhdGEuY29tcGlsZShyYXdDYWxsZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29udmVydCByYXcgdG8gSGV4Q2FsbGRhdGFcbiAgICogQHBhcmFtIHJhdyBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBIZXhDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvSGV4KHJhdyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBfQ2FsbERhdGEuY29tcGlsZShyYXcpO1xuICAgIHJldHVybiBjYWxsZGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgZWxlbWVudHMgb2YgYSBjb250cmFjdCByZXNwb25zZSBhbmQgc3RydWN0dXJlIHRoZW0gaW50byBvbmUgb3Igc2V2ZXJhbCBSZXN1bHQuXG4gICAqIEluIENhaXJvIDAsIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICogQHBhcmFtIHR5cGVDYWlybyBzdHJpbmcgb3Igc3RyaW5nW10gLSBDYWlybyB0eXBlIG5hbWUsIGV4IDogXCJoZWxsbzo6aGVsbG86OlVzZXJEYXRhXCJcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gc2VyaWFsaXplZCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gdHlwZUNhaXJvLlxuICAgKiBAcmV0dXJuIFJlc3VsdCBvciBSZXN1bHRbXSAtIHBhcnNlZCByZXNwb25zZSBjb3JyZXNwb25kaW5nIHRvIHR5cGVEYXRhLlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXMyPWhlbGxvQ2FsbERhdGEuZGVjb2RlUGFyYW1ldGVycyhcImhlbGxvOjpoZWxsbzo6VXNlckRhdGFcIixbXCIweDEyMzQ1NlwiLFwiMHgxXCJdKTtcbiAgICogcmVzdWx0ID0geyBhZGRyZXNzOiAxMTkzMDQ2biwgaXNfY2xhaW1lZDogdHJ1ZSB9XG4gICAqL1xuICBkZWNvZGVQYXJhbWV0ZXJzKHR5cGVDYWlybywgcmVzcG9uc2UpIHtcbiAgICBjb25zdCB0eXBlQ2Fpcm9BcnJheSA9IEFycmF5LmlzQXJyYXkodHlwZUNhaXJvKSA/IHR5cGVDYWlybyA6IFt0eXBlQ2Fpcm9dO1xuICAgIGNvbnN0IHJlc3BvbnNlSXRlcmF0b3IgPSByZXNwb25zZS5mbGF0KClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGRlY29kZWRBcnJheSA9IHR5cGVDYWlyb0FycmF5Lm1hcChcbiAgICAgICh0eXBlUGFyYW0pID0+IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICByZXNwb25zZUl0ZXJhdG9yLFxuICAgICAgICB7IG5hbWU6IFwiXCIsIHR5cGU6IHR5cGVQYXJhbSB9LFxuICAgICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICAgIHRoaXMuZW51bXNcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBkZWNvZGVkQXJyYXkubGVuZ3RoID09PSAxID8gZGVjb2RlZEFycmF5WzBdIDogZGVjb2RlZEFycmF5O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaGFzaC9pbmRleC50c1xudmFyIGhhc2hfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaGFzaF9leHBvcnRzLCB7XG4gIGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoOiAoKSA9PiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaCxcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzLFxuICBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIsXG4gIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHMyLFxuICBjb21wdXRlSGludGVkQ2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlSGludGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaDogKCkgPT4gY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlUG9zZWlkb25IYXNoOiAoKSA9PiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBmb3JtYXRTcGFjZXM6ICgpID0+IGZvcm1hdFNwYWNlcyxcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBoYXNoQnl0ZUNvZGVTZWdtZW50czogKCkgPT4gaGFzaEJ5dGVDb2RlU2VnbWVudHMsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgcG9zZWlkb246ICgpID0+IHBvc2VpZG9uLFxuICBzdGFya25ldEtlY2NhazogKCkgPT4gc3RhcmtuZXRLZWNjYWtcbn0pO1xuaW1wb3J0ICogYXMgcG9zZWlkb24gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvcG9zZWlkb25cIjtcblxuLy8gc3JjL3V0aWxzL2hhc2gvdHJhbnNhY3Rpb25IYXNoL3YyLnRzXG52YXIgdjJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodjJfZXhwb3J0cywge1xuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24sXG4gIGNvbXB1dGVIYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzXG59KTtcblxuLy8gc3JjL3V0aWxzL2VjLnRzXG52YXIgZWNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZWNfZXhwb3J0cywge1xuICBzdGFya0N1cnZlOiAoKSA9PiBzdGFya0N1cnZlLFxuICB3ZWllcnN0cmFzczogKCkgPT4gd2VpZXJzdHJhc3Ncbn0pO1xuaW1wb3J0ICogYXMgc3RhcmtDdXJ2ZSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgKiBhcyB3ZWllcnN0cmFzcyBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzc1wiO1xuXG4vLyBzcmMvdXRpbHMvaGFzaC90cmFuc2FjdGlvbkhhc2gvdjIudHNcbmZ1bmN0aW9uIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhKSB7XG4gIHJldHVybiBbLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gc3RhcmtDdXJ2ZS5wZWRlcnNlbih0b0JpZ0ludCh4KSwgdG9CaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKHR4SGFzaFByZWZpeCwgdmVyc2lvbiwgY29udHJhY3RBZGRyZXNzLCBlbnRyeVBvaW50U2VsZWN0b3IsIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgY2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNhbGxkYXRhKTtcbiAgY29uc3QgZGF0YVRvSGFzaCA9IFtcbiAgICB0eEhhc2hQcmVmaXgsXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlQb2ludFNlbGVjdG9yLFxuICAgIGNhbGxkYXRhSGFzaCxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICAuLi5hZGRpdGlvbmFsRGF0YVxuICBdO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGFUb0hhc2gpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaChjbGFzc0hhc2gsIHNlbmRlckFkZHJlc3MsIHZlcnNpb24sIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UsIGNvbXBpbGVkQ2xhc3NIYXNoKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU2MzZjNjE3MjY1XCIgLyogREVDTEFSRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIHNlbmRlckFkZHJlc3MsXG4gICAgMCxcbiAgICBbY2xhc3NIYXNoXSxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICBbbm9uY2UsIC4uLmNvbXBpbGVkQ2xhc3NIYXNoID8gW2NvbXBpbGVkQ2xhc3NIYXNoXSA6IFtdXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdmVyc2lvbiwgbWF4RmVlLCBjaGFpbklkLCBub25jZSkge1xuICBjb25zdCBjYWxsZGF0YSA9IFtjbGFzc0hhc2gsIHNhbHQsIC4uLmNvbnN0cnVjdG9yQ2FsbGRhdGFdO1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgMCxcbiAgICBjYWxsZGF0YSxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICBbbm9uY2VdXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2goY29udHJhY3RBZGRyZXNzLCB2ZXJzaW9uLCBjYWxsZGF0YSwgbWF4RmVlLCBjaGFpbklkLCBub25jZSkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2OTZlNzY2ZjZiNjVcIiAvKiBJTlZPS0UgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgMCxcbiAgICBjYWxsZGF0YSxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICBbbm9uY2VdXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92My50c1xudmFyIHYzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHYzX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyLFxuICBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yLFxuICBoYXNoREFNb2RlOiAoKSA9PiBoYXNoREFNb2RlLFxuICBoYXNoRmVlRmllbGQ6ICgpID0+IGhhc2hGZWVGaWVsZFxufSk7XG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xudmFyIEFUb0JJID0gKGFycmF5KSA9PiBhcnJheS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKTtcbnZhciBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMgPSAzMm47XG52YXIgTUFYX0FNT1VOVF9CSVRTID0gNjRuO1xudmFyIE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTID0gMTI4bjtcbnZhciBSRVNPVVJDRV9WQUxVRV9PRkZTRVQgPSBNQVhfQU1PVU5UX0JJVFMgKyBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUztcbnZhciBMMV9HQVNfTkFNRSA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhcIkwxX0dBU1wiKSk7XG52YXIgTDJfR0FTX05BTUUgPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoXCJMMl9HQVNcIikpO1xuZnVuY3Rpb24gaGFzaERBTW9kZShub25jZURBTW9kZSwgZmVlREFNb2RlKSB7XG4gIHJldHVybiAoQmlnSW50KG5vbmNlREFNb2RlKSA8PCBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMpICsgQmlnSW50KGZlZURBTW9kZSk7XG59XG5mdW5jdGlvbiBoYXNoRmVlRmllbGQodGlwLCBib3VuZHMpIHtcbiAgY29uc3QgTDFCb3VuZCA9IChMMV9HQVNfTkFNRSA8PCBSRVNPVVJDRV9WQUxVRV9PRkZTRVQpICsgKEJpZ0ludChib3VuZHMubDFfZ2FzLm1heF9hbW91bnQpIDw8IE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTKSArIEJpZ0ludChib3VuZHMubDFfZ2FzLm1heF9wcmljZV9wZXJfdW5pdCk7XG4gIGNvbnN0IEwyQm91bmQgPSAoTDJfR0FTX05BTUUgPDwgUkVTT1VSQ0VfVkFMVUVfT0ZGU0VUKSArIChCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfYW1vdW50KSA8PCBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUykgKyBCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfcHJpY2VfcGVyX3VuaXQpO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueShbQmlnSW50KHRpcCksIEwxQm91bmQsIEwyQm91bmRdKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIodHhIYXNoUHJlZml4LCB2ZXJzaW9uLCBzZW5kZXJBZGRyZXNzLCBjaGFpbklkLCBub25jZSwgdGlwLCBwYXltYXN0ZXJEYXRhLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgZmVlRmllbGRIYXNoID0gaGFzaEZlZUZpZWxkKHRpcCwgcmVzb3VyY2VCb3VuZHMpO1xuICBjb25zdCBkQU1vZGVIYXNoID0gaGFzaERBTW9kZShub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSk7XG4gIGNvbnN0IGRhdGFUb0hhc2ggPSBBVG9CSShbXG4gICAgdHhIYXNoUHJlZml4LFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBmZWVGaWVsZEhhc2gsXG4gICAgcG9zZWlkb25IYXNoTWFueShBVG9CSShwYXltYXN0ZXJEYXRhKSksXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICBkQU1vZGVIYXNoLFxuICAgIC4uLkFUb0JJKGFkZGl0aW9uYWxEYXRhKVxuICBdKTtcbiAgcmV0dXJuIHRvSGV4KHBvc2VpZG9uSGFzaE1hbnkoZGF0YVRvSGFzaCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDIoY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdmVyc2lvbiwgY2hhaW5JZCwgbm9uY2UsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICB0aXAsXG4gICAgcGF5bWFzdGVyRGF0YSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSkpLCBjbGFzc0hhc2gsIHNhbHRdXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMihjbGFzc0hhc2gsIGNvbXBpbGVkQ2xhc3NIYXNoLCBzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBjaGFpbklkLCBub25jZSwgYWNjb3VudERlcGxveW1lbnREYXRhLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIHRpcCwgcGF5bWFzdGVyRGF0YSkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIHRpcCxcbiAgICBBVG9CSShwYXltYXN0ZXJEYXRhKSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGFjY291bnREZXBsb3ltZW50RGF0YSkpLCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2xhc3NIYXNoXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoKHNlbmRlckFkZHJlc3MsIHZlcnNpb24sIGNvbXBpbGVkQ2FsbGRhdGEsIGNoYWluSWQsIG5vbmNlLCBhY2NvdW50RGVwbG95bWVudERhdGEsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2OTZlNzY2ZjZiNjVcIiAvKiBJTlZPS0UgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2UsXG4gICAgdGlwLFxuICAgIHBheW1hc3RlckRhdGEsXG4gICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICByZXNvdXJjZUJvdW5kcyxcbiAgICBbcG9zZWlkb25IYXNoTWFueShBVG9CSShhY2NvdW50RGVwbG95bWVudERhdGEpKSwgcG9zZWlkb25IYXNoTWFueShBVG9CSShjb21waWxlZENhbGxkYXRhKSldXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC9pbmRleC50c1xuZnVuY3Rpb24gaXNWM0ludm9rZVR4KGFyZ3MpIHtcbiAgcmV0dXJuIFthcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXS5pbmNsdWRlcyhhcmdzLnZlcnNpb24pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMihhcmdzKSB7XG4gIGlmIChpc1YzSW52b2tlVHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoKFxuICAgICAgYXJncy5zZW5kZXJBZGRyZXNzLFxuICAgICAgYXJncy52ZXJzaW9uLFxuICAgICAgYXJncy5jb21waWxlZENhbGxkYXRhLFxuICAgICAgYXJncy5jaGFpbklkLFxuICAgICAgYXJncy5ub25jZSxcbiAgICAgIGFyZ3MuYWNjb3VudERlcGxveW1lbnREYXRhLFxuICAgICAgYXJncy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MucmVzb3VyY2VCb3VuZHMsXG4gICAgICBhcmdzLnRpcCxcbiAgICAgIGFyZ3MucGF5bWFzdGVyRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MuY29tcGlsZWRDYWxsZGF0YSxcbiAgICBhcmdzLm1heEZlZSxcbiAgICBhcmdzLmNoYWluSWQsXG4gICAgYXJncy5ub25jZVxuICApO1xufVxuZnVuY3Rpb24gaXNWM0RlY2xhcmVUeChhcmdzKSB7XG4gIHJldHVybiBbYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMywgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GM10uaW5jbHVkZXMoYXJncy52ZXJzaW9uKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKGFyZ3MpIHtcbiAgaWYgKGlzVjNEZWNsYXJlVHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIoXG4gICAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5hY2NvdW50RGVwbG95bWVudERhdGEsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlLFxuICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2hcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVjNEZXBsb3lBY2NvdW50VHgoYXJncykge1xuICByZXR1cm4gW2FwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjNdLmluY2x1ZGVzKGFyZ3MudmVyc2lvbik7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyhhcmdzKSB7XG4gIGlmIChpc1YzRGVwbG95QWNjb3VudFR4KGFyZ3MpKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyKFxuICAgICAgYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICAgIGFyZ3MuY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgYXJncy5zYWx0LFxuICAgICAgYXJncy52ZXJzaW9uLFxuICAgICAgYXJncy5jaGFpbklkLFxuICAgICAgYXJncy5ub25jZSxcbiAgICAgIGFyZ3Mubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLnJlc291cmNlQm91bmRzLFxuICAgICAgYXJncy50aXAsXG4gICAgICBhcmdzLnBheW1hc3RlckRhdGFcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgIGFyZ3MuY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICBhcmdzLnNhbHQsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL2NsYXNzSGFzaC50c1xuaW1wb3J0IHsgcG9zZWlkb25IYXNoTWFueSBhcyBwb3NlaWRvbkhhc2hNYW55MiB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcblxuLy8gc3JjL3V0aWxzL2pzb24udHNcbnZhciBqc29uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGpzb25fZXhwb3J0cywge1xuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICBwYXJzZUFsd2F5c0FzQmlnOiAoKSA9PiBwYXJzZUFsd2F5c0FzQmlnLFxuICBzdHJpbmdpZnk6ICgpID0+IHN0cmluZ2lmeTIsXG4gIHN0cmluZ2lmeUFsd2F5c0FzQmlnOiAoKSA9PiBzdHJpbmdpZnlBbHdheXNBc0JpZ1xufSk7XG5pbXBvcnQgKiBhcyBqc29uIGZyb20gXCJsb3NzbGVzcy1qc29uXCI7XG52YXIgcGFyc2VJbnRBc051bWJlck9yQmlnSW50ID0gKHN0cikgPT4ge1xuICBpZiAoIWpzb24uaXNJbnRlZ2VyKHN0cikpXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgY29uc3QgbnVtID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pID8gbnVtIDogQmlnSW50KHN0cik7XG59O1xudmFyIHBhcnNlMiA9IChzdHIpID0+IGpzb24ucGFyc2UoU3RyaW5nKHN0ciksIHZvaWQgMCwgcGFyc2VJbnRBc051bWJlck9yQmlnSW50KTtcbnZhciBwYXJzZUFsd2F5c0FzQmlnID0gKHN0cikgPT4ganNvbi5wYXJzZShTdHJpbmcoc3RyKSwgdm9pZCAwLCBqc29uLnBhcnNlTnVtYmVyQW5kQmlnSW50KTtcbnZhciBzdHJpbmdpZnkyID0gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycykgPT4ganNvbi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKTtcbnZhciBzdHJpbmdpZnlBbHdheXNBc0JpZyA9IHN0cmluZ2lmeTI7XG5cbi8vIHNyYy91dGlscy9oYXNoL2NsYXNzSGFzaC50c1xuZnVuY3Rpb24gY29tcHV0ZVBlZGVyc2VuSGFzaChhLCBiKSB7XG4gIHJldHVybiBzdGFya0N1cnZlLnBlZGVyc2VuKEJpZ0ludChhKSwgQmlnSW50KGIpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQb3NlaWRvbkhhc2goYSwgYikge1xuICByZXR1cm4gdG9IZXgoc3RhcmtDdXJ2ZS5wb3NlaWRvbkhhc2goQmlnSW50KGEpLCBCaWdJbnQoYikpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYXNoT25FbGVtZW50czIoZGF0YSkge1xuICByZXR1cm4gWy4uLmRhdGEsIGRhdGEubGVuZ3RoXS5yZWR1Y2UoKHgsIHkpID0+IHN0YXJrQ3VydmUucGVkZXJzZW4oQmlnSW50KHgpLCBCaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxudmFyIGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMjtcbmZ1bmN0aW9uIGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIHRvSGV4KHBvc2VpZG9uSGFzaE1hbnkyKGRhdGEubWFwKCh4KSA9PiBCaWdJbnQoeCkpKSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChzYWx0LCBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGRlcGxveWVyQWRkcmVzcykge1xuICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgY29uc3QgY29uc3RydWN0b3JDYWxsZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGNvbXBpbGVkQ2FsbGRhdGEpO1xuICBjb25zdCBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCA9IGZlbHQoXCIweDUzNTQ0MTUyNGI0ZTQ1NTQ1ZjQzNGY0ZTU0NTI0MTQzNTQ1ZjQxNDQ0NDUyNDU1MzUzXCIpO1xuICBjb25zdCBoYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihbXG4gICAgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVgsXG4gICAgZGVwbG95ZXJBZGRyZXNzLFxuICAgIHNhbHQsXG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoXG4gIF0pO1xuICByZXR1cm4gdG9IZXgoQmlnSW50KGhhc2gpICUgQUREUl9CT1VORCk7XG59XG5mdW5jdGlvbiBudWxsU2tpcFJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PT0gXCJhdHRyaWJ1dGVzXCIgfHwga2V5ID09PSBcImFjY2Vzc2libGVfc2NvcGVzXCIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwID8gdm9pZCAwIDogdmFsdWU7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkZWJ1Z19pbmZvXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNwYWNlcyhqc29uMikge1xuICBsZXQgaW5zaWRlUXVvdGVzID0gZmFsc2U7XG4gIGNvbnN0IG5ld1N0cmluZyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2YganNvbjIpIHtcbiAgICBpZiAoY2hhciA9PT0gJ1wiJyAmJiAobmV3U3RyaW5nLmxlbmd0aCA+IDAgJiYgbmV3U3RyaW5nLnNsaWNlKC0xKVswXSA9PT0gXCJcXFxcXCIpID09PSBmYWxzZSkge1xuICAgICAgaW5zaWRlUXVvdGVzID0gIWluc2lkZVF1b3RlcztcbiAgICB9XG4gICAgaWYgKGluc2lkZVF1b3Rlcykge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIgPT09IFwiOlwiID8gXCI6IFwiIDogY2hhciA9PT0gXCIsXCIgPyBcIiwgXCIgOiBjaGFyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1N0cmluZy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KSB7XG4gIGNvbnN0IHsgYWJpLCBwcm9ncmFtIH0gPSBjb21waWxlZENvbnRyYWN0O1xuICBjb25zdCBjb250cmFjdENsYXNzID0geyBhYmksIHByb2dyYW0gfTtcbiAgY29uc3Qgc2VyaWFsaXplZEpzb24gPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdENsYXNzLCBudWxsU2tpcFJlcGxhY2VyKSk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoc2VyaWFsaXplZEpzb24pKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSB0b0hleChBUElfVkVSU0lPTik7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgYnVpbHRpbnNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LnByb2dyYW0uYnVpbHRpbnMubWFwKChzKSA9PiBlbmNvZGVTaG9ydFN0cmluZyhzKSlcbiAgKTtcbiAgY29uc3QgaGludGVkQ2xhc3NIYXNoID0gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgY29uc3QgZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5kYXRhKTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50czIoW1xuICAgIGFwaVZlcnNpb24sXG4gICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoLFxuICAgIGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2gsXG4gICAgYnVpbHRpbnNIYXNoLFxuICAgIGhpbnRlZENsYXNzSGFzaCxcbiAgICBkYXRhSGFzaFxuICBdKTtcbn1cbmZ1bmN0aW9uIGhhc2hCdWlsdGlucyhidWlsdGlucykge1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueTIoXG4gICAgYnVpbHRpbnMuZmxhdE1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFzaEVudHJ5UG9pbnQoZGF0YSkge1xuICBjb25zdCBiYXNlID0gZGF0YS5mbGF0TWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBbQmlnSW50KGl0LnNlbGVjdG9yKSwgQmlnSW50KGl0Lm9mZnNldCksIGhhc2hCdWlsdGlucyhpdC5idWlsdGlucyldO1xuICB9KTtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkyKGJhc2UpO1xufVxuZnVuY3Rpb24gaGFzaEJ5dGVDb2RlU2VnbWVudHMoY2FzbSkge1xuICBjb25zdCBieXRlQ29kZSA9IGNhc20uYnl0ZWNvZGUubWFwKChuKSA9PiBCaWdJbnQobikpO1xuICBjb25zdCBieXRlY29kZVNlZ21lbnRMZW5ndGhzID0gY2FzbS5ieXRlY29kZV9zZWdtZW50X2xlbmd0aHMgPz8gW107XG4gIGxldCBzZWdtZW50U3RhcnQgPSAwO1xuICBjb25zdCBoYXNoTGVhdmVzID0gYnl0ZWNvZGVTZWdtZW50TGVuZ3Rocy5mbGF0TWFwKChsZW4pID0+IHtcbiAgICBjb25zdCBzZWdtZW50ID0gYnl0ZUNvZGUuc2xpY2Uoc2VnbWVudFN0YXJ0LCBzZWdtZW50U3RhcnQgKz0gbGVuKTtcbiAgICByZXR1cm4gW0JpZ0ludChsZW4pLCBwb3NlaWRvbkhhc2hNYW55MihzZWdtZW50KV07XG4gIH0pO1xuICByZXR1cm4gMW4gKyBwb3NlaWRvbkhhc2hNYW55MihoYXNoTGVhdmVzKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaChjYXNtKSB7XG4gIGNvbnN0IENPTVBJTEVEX0NMQVNTX1ZFUlNJT04gPSBcIkNPTVBJTEVEX0NMQVNTX1YxXCI7XG4gIGNvbnN0IGNvbXBpbGVkQ2xhc3NWZXJzaW9uID0gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKENPTVBJTEVEX0NMQVNTX1ZFUlNJT04pKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUik7XG4gIGNvbnN0IGJ5dGVjb2RlID0gY2FzbS5ieXRlY29kZV9zZWdtZW50X2xlbmd0aHMgPyBoYXNoQnl0ZUNvZGVTZWdtZW50cyhjYXNtKSA6IHBvc2VpZG9uSGFzaE1hbnkyKGNhc20uYnl0ZWNvZGUubWFwKChpdCkgPT4gQmlnSW50KGl0KSkpO1xuICByZXR1cm4gdG9IZXgoXG4gICAgcG9zZWlkb25IYXNoTWFueTIoW1xuICAgICAgY29tcGlsZWRDbGFzc1ZlcnNpb24sXG4gICAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICAgIGwxSGFuZGxlcnMsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVjb2RlXG4gICAgXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50U2llcnJhKGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5mdW5jdGlvbl9pZHgpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55MihiYXNlKTtcbn1cbmZ1bmN0aW9uIGhhc2hBYmkoc2llcnJhKSB7XG4gIGNvbnN0IGluZGVudFN0cmluZyA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKHNpZXJyYS5hYmksIG51bGwpKTtcbiAgcmV0dXJuIEJpZ0ludChhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoaW5kZW50U3RyaW5nKSkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goc2llcnJhKSB7XG4gIGNvbnN0IENPTlRSQUNUX0NMQVNTX1ZFUlNJT04gPSBcIkNPTlRSQUNUX0NMQVNTX1YwLjEuMFwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT05UUkFDVF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBhYmlIYXNoID0gaGFzaEFiaShzaWVycmEpO1xuICBjb25zdCBzaWVycmFQcm9ncmFtID0gcG9zZWlkb25IYXNoTWFueTIoc2llcnJhLnNpZXJyYV9wcm9ncmFtLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkyKFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBhYmlIYXNoLFxuICAgICAgc2llcnJhUHJvZ3JhbVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IGlzU3RyaW5nKGNvbnRyYWN0KSA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xufVxuXG4vLyBzcmMvdXRpbHMvc3RhcmsudHNcbnZhciBzdGFya19leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya19leHBvcnRzLCB7XG4gIGNvbXByZXNzUHJvZ3JhbTogKCkgPT4gY29tcHJlc3NQcm9ncmFtLFxuICBkZWNvbXByZXNzUHJvZ3JhbTogKCkgPT4gZGVjb21wcmVzc1Byb2dyYW0sXG4gIGVzdGltYXRlRmVlVG9Cb3VuZHM6ICgpID0+IGVzdGltYXRlRmVlVG9Cb3VuZHMsXG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlOiAoKSA9PiBlc3RpbWF0ZWRGZWVUb01heEZlZSxcbiAgZm9ybWF0U2lnbmF0dXJlOiAoKSA9PiBmb3JtYXRTaWduYXR1cmUsXG4gIGludERBTTogKCkgPT4gaW50REFNLFxuICBtYWtlQWRkcmVzczogKCkgPT4gbWFrZUFkZHJlc3MsXG4gIHJhbmRvbUFkZHJlc3M6ICgpID0+IHJhbmRvbUFkZHJlc3MsXG4gIHJlZHVjZVYyOiAoKSA9PiByZWR1Y2VWMixcbiAgc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXk6ICgpID0+IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5LFxuICBzaWduYXR1cmVUb0hleEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0hleEFycmF5LFxuICB0b0ZlZVZlcnNpb246ICgpID0+IHRvRmVlVmVyc2lvbixcbiAgdG9UcmFuc2FjdGlvblZlcnNpb246ICgpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uLFxuICB2M0RldGFpbHM6ICgpID0+IHYzRGV0YWlsc1xufSk7XG5pbXBvcnQgeyBnZXRTdGFya0tleSwgdXRpbHMgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgeyBnemlwLCB1bmd6aXAgfSBmcm9tIFwicGFrb1wiO1xuZnVuY3Rpb24gY29tcHJlc3NQcm9ncmFtKGpzb25Qcm9ncmFtKSB7XG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gaXNTdHJpbmcoanNvblByb2dyYW0pID8ganNvblByb2dyYW0gOiBzdHJpbmdpZnkyKGpzb25Qcm9ncmFtKTtcbiAgY29uc3QgY29tcHJlc3NlZFByb2dyYW0gPSBnemlwKHN0cmluZ2lmaWVkKTtcbiAgcmV0dXJuIGJ0b2FVbml2ZXJzYWwoY29tcHJlc3NlZFByb2dyYW0pO1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc1Byb2dyYW0oYmFzZTY0Mikge1xuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlNjQyKSlcbiAgICByZXR1cm4gYmFzZTY0MjtcbiAgY29uc3QgZGVjb21wcmVzc2VkID0gYXJyYXlCdWZmZXJUb1N0cmluZyh1bmd6aXAoYXRvYlVuaXZlcnNhbChiYXNlNjQyKSkpO1xuICByZXR1cm4gcGFyc2UyKGRlY29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiByYW5kb21BZGRyZXNzKCkge1xuICBjb25zdCByYW5kb21LZXlQYWlyID0gdXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICByZXR1cm4gZ2V0U3RhcmtLZXkocmFuZG9tS2V5UGFpcik7XG59XG5mdW5jdGlvbiBtYWtlQWRkcmVzcyhpbnB1dCkge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0KS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZm9ybWF0U2lnbmF0dXJlKHNpZykge1xuICBpZiAoIXNpZylcbiAgICB0aHJvdyBFcnJvcihcImZvcm1hdFNpZ25hdHVyZTogcHJvdmlkZWQgc2lnbmF0dXJlIGlzIHVuZGVmaW5lZFwiKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHJldHVybiBzaWcubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIHJldHVybiBbdG9IZXgociksIHRvSGV4KHMpXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBuZWVkIHRvIGJlIHdlaWVyc3RyYXNzLlNpZ25hdHVyZVR5cGUgb3IgYW4gYXJyYXkgZm9yIGN1c3RvbVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGZvcm1hdFNpZ25hdHVyZShzaWcpKTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkID0gNTAgLyogTUFYX0ZFRSAqLykge1xuICByZXR1cm4gYWRkUGVyY2VudChlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkKTtcbn1cbmZ1bmN0aW9uIGVzdGltYXRlRmVlVG9Cb3VuZHMoZXN0aW1hdGUsIGFtb3VudE92ZXJoZWFkID0gNTAgLyogTDFfQk9VTkRfTUFYX0FNT1VOVCAqLywgcHJpY2VPdmVyaGVhZCA9IDUwIC8qIEwxX0JPVU5EX01BWF9QUklDRV9QRVJfVU5JVCAqLykge1xuICBpZiAoaXNCaWdJbnQoZXN0aW1hdGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGwyX2dhczogeyBtYXhfYW1vdW50OiBcIjB4MFwiLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHgwXCIgfSxcbiAgICAgIGwxX2dhczogeyBtYXhfYW1vdW50OiBcIjB4MFwiLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHgwXCIgfVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBlc3RpbWF0ZS5nYXNfY29uc3VtZWQgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVzdGltYXRlLmdhc19wcmljZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IEVycm9yKFwiZXN0aW1hdGVGZWVUb0JvdW5kczogZXN0aW1hdGUgaXMgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGNvbnN0IG1heFVuaXRzID0gZXN0aW1hdGUuZGF0YV9nYXNfY29uc3VtZWQgIT09IHZvaWQgMCAmJiBlc3RpbWF0ZS5kYXRhX2dhc19wcmljZSAhPT0gdm9pZCAwID8gdG9IZXgoYWRkUGVyY2VudChCaWdJbnQoZXN0aW1hdGUub3ZlcmFsbF9mZWUpIC8gQmlnSW50KGVzdGltYXRlLmdhc19wcmljZSksIGFtb3VudE92ZXJoZWFkKSkgOiB0b0hleChhZGRQZXJjZW50KGVzdGltYXRlLmdhc19jb25zdW1lZCwgYW1vdW50T3ZlcmhlYWQpKTtcbiAgY29uc3QgbWF4VW5pdFByaWNlID0gdG9IZXgoYWRkUGVyY2VudChlc3RpbWF0ZS5nYXNfcHJpY2UsIHByaWNlT3ZlcmhlYWQpKTtcbiAgcmV0dXJuIHtcbiAgICBsMl9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH0sXG4gICAgbDFfZ2FzOiB7IG1heF9hbW91bnQ6IG1heFVuaXRzLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IG1heFVuaXRQcmljZSB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnREQU0oZGFtKSB7XG4gIGlmIChkYW0gPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSlcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRURBTW9kZS5MMTtcbiAgaWYgKGRhbSA9PT0gYXBpX2V4cG9ydHMuRURhdGFBdmFpbGFiaWxpdHlNb2RlLkwyKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FREFNb2RlLkwyO1xuICB0aHJvdyBFcnJvcihcIkVEQU0gY29udmVyc2lvblwiKTtcbn1cbmZ1bmN0aW9uIHRvVHJhbnNhY3Rpb25WZXJzaW9uKGRlZmF1bHRWZXJzaW9uLCBwcm92aWRlZFZlcnNpb24pIHtcbiAgY29uc3QgcHJvdmlkZWRWZXJzaW9uMHhzID0gcHJvdmlkZWRWZXJzaW9uID8gdG9IZXgocHJvdmlkZWRWZXJzaW9uKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVmYXVsdFZlcnNpb24weHMgPSB0b0hleChkZWZhdWx0VmVyc2lvbik7XG4gIGlmIChwcm92aWRlZFZlcnNpb24gJiYgIU9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbikuaW5jbHVkZXMocHJvdmlkZWRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBwcm92aWRlZFZlcnNpb24gJHtwcm92aWRlZFZlcnNpb259IGlzIG5vdCBFVHJhbnNhY3Rpb25WZXJzaW9uYCk7XG4gIH1cbiAgaWYgKCFPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24pLmluY2x1ZGVzKGRlZmF1bHRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBkZWZhdWx0VmVyc2lvbiAke2RlZmF1bHRWZXJzaW9ufSBpcyBub3QgRVRyYW5zYWN0aW9uVmVyc2lvbmApO1xuICB9XG4gIHJldHVybiBwcm92aWRlZFZlcnNpb24gPyBwcm92aWRlZFZlcnNpb24weHMgOiBkZWZhdWx0VmVyc2lvbjB4cztcbn1cbmZ1bmN0aW9uIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pIHtcbiAgaWYgKCFwcm92aWRlZFZlcnNpb24pXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdmVyc2lvbiA9IHRvSGV4KHByb3ZpZGVkVmVyc2lvbik7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYwKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYwO1xuICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSlcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMTtcbiAgaWYgKHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIpXG4gICAgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjI7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzO1xuICB0aHJvdyBFcnJvcihgdG9GZWVWZXJzaW9uOiAke3ZlcnNpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbn1cbmZ1bmN0aW9uIHYzRGV0YWlscyhkZXRhaWxzKSB7XG4gIHJldHVybiB7XG4gICAgdGlwOiBkZXRhaWxzLnRpcCB8fCAwLFxuICAgIHBheW1hc3RlckRhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YSB8fCBbXSxcbiAgICBhY2NvdW50RGVwbG95bWVudERhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhIHx8IFtdLFxuICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSB8fCBhcGlfZXhwb3J0cy5FRGF0YUF2YWlsYWJpbGl0eU1vZGUuTDEsXG4gICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUgfHwgYXBpX2V4cG9ydHMuRURhdGFBdmFpbGFiaWxpdHlNb2RlLkwxLFxuICAgIHJlc291cmNlQm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzID8/IGVzdGltYXRlRmVlVG9Cb3VuZHMoWkVSTylcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZHVjZVYyKHByb3ZpZGVkVmVyc2lvbikge1xuICBpZiAocHJvdmlkZWRWZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxO1xuICBpZiAocHJvdmlkZWRWZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxO1xuICByZXR1cm4gcHJvdmlkZWRWZXJzaW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvY29udHJhY3QudHNcbmZ1bmN0aW9uIGlzU2llcnJhKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIHJldHVybiBcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0geyAuLi5wYXlsb2FkIH07XG4gIGlmIChpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSkge1xuICAgIGlmICghcGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCAmJiBwYXlsb2FkLmNhc20pIHtcbiAgICAgIHJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoID0gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKHBheWxvYWQuY2FzbSk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXh0cmFjdCBjb21waWxlZENsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENhaXJvQXNzZW1ibHkpLmNhc20gZmlsZSBvciBjb21waWxlZENsYXNzSGFzaFwiXG4gICAgICApO1xuICB9XG4gIHJlc3BvbnNlLmNsYXNzSGFzaCA9IHBheWxvYWQuY2xhc3NIYXNoID8/IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaChwYXlsb2FkLmNvbnRyYWN0KTtcbiAgaWYgKCFyZXNwb25zZS5jbGFzc0hhc2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0cmFjdCBjbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDb21waWxlZENvbnRyYWN0KS5qc29uIGZpbGUgb3IgY2xhc3NIYXNoXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QoY2NyKSB7XG4gIGlmIChpc1NpZXJyYShjY3IpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdENsYXNzUmVzcG9uc2UgbmVlZCB0byBiZSBMZWdhY3lDb250cmFjdENsYXNzIChjYWlybzAgcmVzcG9uc2UgY2xhc3MpXCIpO1xuICB9XG4gIGNvbnN0IGNvbnRyYWN0ID0gY2NyO1xuICByZXR1cm4geyAuLi5jb250cmFjdCwgcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3QucHJvZ3JhbSkgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2V0aC50c1xudmFyIGV0aF9leHBvcnRzID0ge307XG5fX2V4cG9ydChldGhfZXhwb3J0cywge1xuICBldGhSYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBldGhSYW5kb21Qcml2YXRlS2V5LFxuICB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzczogKCkgPT4gdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3Ncbn0pO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5mdW5jdGlvbiBldGhSYW5kb21Qcml2YXRlS2V5KCkge1xuICByZXR1cm4gc2FuaXRpemVIZXgoYnVmMmhleChzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGFzc2VydEluUmFuZ2UoYWRkcmVzcywgWkVSTywgMm4gKiogMTYwbiAtIDFuLCBcIkV0aGVyZXVtIEFkZHJlc3MgXCIpO1xuICBjb25zdCByZXN1bHQgPSBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KHRvSGV4KGFkZHJlc3MpKS5wYWRTdGFydCg0MCwgXCIwXCIpKTtcbiAgYXNzZXJ0KEJvb2xlYW4ocmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mXXs0MH0kLykpLCBcIkludmFsaWQgRXRoZXJldW0gQWRkcmVzcyBGb3JtYXRcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlscy9mZXRjaFBvbnlmaWxsLnRzXG5pbXBvcnQgbWFrZUZldGNoQ29va2llIGZyb20gXCJmZXRjaC1jb29raWVcIjtcbmltcG9ydCBpc29tb3JwaGljRmV0Y2ggZnJvbSBcImlzb21vcnBoaWMtZmV0Y2hcIjtcbnZhciBmZXRjaFBvbnlmaWxsX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mZXRjaCB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBicm93c2VyIGlmIGF2YWlsYWJsZVxudHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtYWtlRmV0Y2hDb29raWUoZ2xvYmFsLmZldGNoKSB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBub2RlLCByZWFjdC1uYXRpdmUgYW5kIHNlcnZpY2Ugd29ya2VyIGlmIGF2YWlsYWJsZVxuaXNvbW9ycGhpY0ZldGNoO1xuXG4vLyBzcmMvdXRpbHMvcHJvdmlkZXIudHNcbnZhciBwcm92aWRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm92aWRlcl9leHBvcnRzLCB7XG4gIEJsb2NrOiAoKSA9PiBCbG9jayxcbiAgY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzczogKCkgPT4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyxcbiAgZ2V0RGVmYXVsdE5vZGVVcmw6ICgpID0+IGdldERlZmF1bHROb2RlVXJsLFxuICBpc1BlbmRpbmdCbG9jazogKCkgPT4gaXNQZW5kaW5nQmxvY2ssXG4gIGlzUGVuZGluZ1N0YXRlVXBkYXRlOiAoKSA9PiBpc1BlbmRpbmdTdGF0ZVVwZGF0ZSxcbiAgaXNQZW5kaW5nVHJhbnNhY3Rpb246ICgpID0+IGlzUGVuZGluZ1RyYW5zYWN0aW9uLFxuICBpc1YzVHg6ICgpID0+IGlzVjNUeCxcbiAgaXNWZXJzaW9uOiAoKSA9PiBpc1ZlcnNpb24sXG4gIHBhcnNlQ29udHJhY3Q6ICgpID0+IHBhcnNlQ29udHJhY3QsXG4gIHZhbGlkQmxvY2tUYWdzOiAoKSA9PiB2YWxpZEJsb2NrVGFncyxcbiAgd2FpdDogKCkgPT4gd2FpdFxufSk7XG5mdW5jdGlvbiB3YWl0KGRlbGF5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXMsIGRlbGF5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKGNvbnRyYWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uY29udHJhY3QgfTtcbiAgZGVsZXRlIHJlc3VsdC5zaWVycmFfcHJvZ3JhbV9kZWJ1Z19pbmZvO1xuICByZXN1bHQuYWJpID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3QuYWJpKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGNvbXByZXNzUHJvZ3JhbShyZXN1bHQuc2llcnJhX3Byb2dyYW0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VDb250cmFjdChjb250cmFjdCkge1xuICBjb25zdCBwYXJzZWRDb250cmFjdCA9IGlzU3RyaW5nKGNvbnRyYWN0KSA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkQ29udHJhY3QsXG4gICAgICAuLi5cInByb2dyYW1cIiBpbiBwYXJzZWRDb250cmFjdCAmJiB7IHByb2dyYW06IGNvbXByZXNzUHJvZ3JhbShwYXJzZWRDb250cmFjdC5wcm9ncmFtKSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyhwYXJzZWRDb250cmFjdCk7XG59XG52YXIgZ2V0RGVmYXVsdE5vZGVVcmwgPSAobmV0d29ya05hbWUsIG11dGUgPSBmYWxzZSkgPT4ge1xuICBpZiAoIW11dGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IHB1YmxpYyBub2RlIHVybCwgcGxlYXNlIHByb3ZpZGUgbm9kZVVybCBpbiBwcm92aWRlciBvcHRpb25zIVwiKTtcbiAgfVxuICBjb25zdCBub2RlcyA9IFJQQ19OT0RFU1tuZXR3b3JrTmFtZSA/PyBcIlNOX1NFUE9MSUFcIiAvKiBTTl9TRVBPTElBICovXTtcbiAgY29uc3QgcmFuZElkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCk7XG4gIHJldHVybiBub2Rlc1tyYW5kSWR4XTtcbn07XG52YXIgdmFsaWRCbG9ja1RhZ3MgPSBPYmplY3QudmFsdWVzKEJsb2NrVGFnKTtcbnZhciBCbG9jayA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSBoYXNoIGlmIG5vdCBudWxsLCBjb250YWlucyB0aGUgYmxvY2sgaGFzaFxuICAgKi9cbiAgaGFzaCA9IG51bGw7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jsb2NrSWRlbnRpZmllcn0gbnVtYmVyIGlmIG5vdCBudWxsLCBjb250YWlucyB0aGUgYmxvY2sgbnVtYmVyXG4gICAqL1xuICBudW1iZXIgPSBudWxsO1xuICAvKipcbiAgICogQHBhcmFtIHtCbG9ja0lkZW50aWZpZXJ9IHRhZyBpZiBub3QgbnVsbCwgY29udGFpbnMgXCJwZW5kaW5nXCIgb3IgXCJsYXRlc3RcIlxuICAgKi9cbiAgdGFnID0gbnVsbDtcbiAgc2V0SWRlbnRpZmllcihfX2lkZW50aWZpZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoX19pZGVudGlmaWVyKSkge1xuICAgICAgaWYgKGlzRGVjaW1hbFN0cmluZyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMubnVtYmVyID0gcGFyc2VJbnQoX19pZGVudGlmaWVyLCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSGV4KF9faWRlbnRpZmllcikpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gX19pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmICh2YWxpZEJsb2NrVGFncy5pbmNsdWRlcyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMudGFnID0gX19pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGBCbG9jayBpZGVudGlmaWVyIHVubWFuYWdlZDogJHtfX2lkZW50aWZpZXJ9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0JpZ0ludChfX2lkZW50aWZpZXIpKSB7XG4gICAgICB0aGlzLmhhc2ggPSB0b0hleChfX2lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5udW1iZXIgPSBfX2lkZW50aWZpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnID0gXCJwZW5kaW5nXCIgLyogUEVORElORyAqLztcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKHRoaXMubnVtYmVyKSAmJiB0aGlzLm51bWJlciA8IDApIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihgQmxvY2sgbnVtYmVyICgke3RoaXMubnVtYmVyfSkgY2FuJ3QgYmUgbmVnYXRpdmVgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJsb2NrIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSBfaWRlbnRpZmllciAgaGV4IHN0cmluZyBhbmQgQmlnSW50IGFyZSBkZXRlY3RlZCBhcyBibG9jayBoYXNoZXMuXG4gICAqIGRlY2ltYWwgc3RyaW5nIGFuZCBudW1iZXIgYXJlIGRldGVjdGVkIGFzIGJsb2NrIG51bWJlcnMuXG4gICAqIHRleHQgc3RyaW5nIGFyZSBkZXRlY3RlZCBhcyBibG9jayB0YWcuXG4gICAqIG51bGwgaXMgY29uc2lkZXJlZCBhcyBhICdwZW5kaW5nJyBibG9jayB0YWcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICAvKipcbiAgICogQHJldHVybnMge2FueX0gdGhlIGlkZW50aWZpZXIgYXMgYSBzdHJpbmdcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBuZXcgcHJvdmlkZXIuQmxvY2soMTIzNDU2bikucXVlcnlJZGVudGlmaWVyO1xuICAgKiAvLyByZXN1bHQgPSBcImJsb2NrSGFzaD0weDFlMjQwXCJcbiAgICogYGBgXG4gICAqL1xuICBnZXQgcXVlcnlJZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMubnVtYmVyfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tIYXNoPSR7dGhpcy5oYXNofWA7XG4gICAgfVxuICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLnRhZ31gO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgLyoqXG4gICAqIEByZXR1cm5zIHthbnl9IHRoZSBpZGVudGlmaWVyIGFzIGFuIG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IG5ldyBwcm92aWRlci5CbG9jayg1Njc4OSkuaWRlbnRpZmllcjtcbiAgICogLy8gcmVzdWx0ID0geyBibG9ja19udW1iZXI6IDU2Nzg5IH1cbiAgICogYGBgXG4gICAqL1xuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX251bWJlcjogdGhpcy5udW1iZXIgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgYmxvY2tfaGFzaDogdGhpcy5oYXNoIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZztcbiAgfVxuICAvKipcbiAgICogY2hhbmdlIHRoZSBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIEJsb2NrIGluc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbXlCbG9jayA9IG5ldyBwcm92aWRlci5CbG9jayhcImxhdGVzdFwiKTtcbiAgICogbXlCbG9jay5pZGVudGlmaWVyID1cIjB4MzQ1Njc4OWFiY1wiO1xuICAgKiBjb25zdCByZXN1bHQgPSBteUJsb2NrLmlkZW50aWZpZXI7XG4gICAqIC8vIHJlc3VsdCA9IHsgYmxvY2tfaGFzaDogJzB4MzQ1Njc4OWFiYycgfVxuICAgKiBgYGBcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKF9pZGVudGlmaWVyKSB7XG4gICAgdGhpcy5zZXRJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgfVxuICB2YWx1ZU9mID0gKCkgPT4gdGhpcy5udW1iZXI7XG4gIHRvU3RyaW5nID0gKCkgPT4gdGhpcy5oYXNoO1xufTtcbmZ1bmN0aW9uIGlzVjNUeChkZXRhaWxzKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBkZXRhaWxzLnZlcnNpb24gPyB0b0hleChkZXRhaWxzLnZlcnNpb24pIDogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMztcbiAgcmV0dXJuIHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMgfHwgdmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMztcbn1cbmZ1bmN0aW9uIGlzVmVyc2lvbih2ZXJzaW9uLCByZXNwb25zZSkge1xuICBjb25zdCBbbWFqb3JTLCBtaW5vclNdID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IFttYWpvclIsIG1pbm9yUl0gPSByZXNwb25zZS5zcGxpdChcIi5cIik7XG4gIHJldHVybiBtYWpvclMgPT09IG1ham9yUiAmJiBtaW5vclMgPT09IG1pbm9yUjtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ0Jsb2NrKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZS5zdGF0dXMgPT09IFwiUEVORElOR1wiO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nVHJhbnNhY3Rpb24ocmVzcG9uc2UpIHtcbiAgcmV0dXJuICEoXCJibG9ja19oYXNoXCIgaW4gcmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nU3RhdGVVcGRhdGUocmVzcG9uc2UpIHtcbiAgcmV0dXJuICEoXCJibG9ja19oYXNoXCIgaW4gcmVzcG9uc2UpO1xufVxuXG4vLyBzcmMvdXRpbHMvdHJhbnNhY3Rpb24udHNcbnZhciB0cmFuc2FjdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0cmFuc2FjdGlvbl9leHBvcnRzLCB7XG4gIGJ1aWxkVURDQ2FsbDogKCkgPT4gYnVpbGRVRENDYWxsLFxuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEsXG4gIGdldEV4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZ2V0RXhlY3V0ZUNhbGxkYXRhLFxuICBnZXRWZXJzaW9uc0J5VHlwZTogKCkgPT4gZ2V0VmVyc2lvbnNCeVR5cGUsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXM6ICgpID0+IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXNfY2Fpcm8xOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMVxufSk7XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5cyA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBbXTtcbiAgY29uc3QgY2FsbGRhdGEgPSBbXTtcbiAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pO1xuICAgIGNhbGxBcnJheS5wdXNoKHtcbiAgICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgICAgZGF0YV9vZmZzZXQ6IGNhbGxkYXRhLmxlbmd0aC50b1N0cmluZygpLFxuICAgICAgZGF0YV9sZW46IGRhdGEubGVuZ3RoLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICBjYWxsZGF0YS5wdXNoKC4uLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxsQXJyYXksXG4gICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsZGF0YSB9KVxuICB9O1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YSA9IChjYWxscykgPT4ge1xuICBjb25zdCB7IGNhbGxBcnJheSwgY2FsbGRhdGEgfSA9IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMoY2FsbHMpO1xuICBjb25zdCBjb21waWxlZENhbGxzID0gQ2FsbERhdGEuY29tcGlsZSh7IGNhbGxBcnJheSB9KTtcbiAgcmV0dXJuIFsuLi5jb21waWxlZENhbGxzLCAuLi5jYWxsZGF0YV07XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlID0gKGNhbGxzLCBub25jZSkgPT4ge1xuICByZXR1cm4gWy4uLmZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKSwgdG9CaWdJbnQobm9uY2UpLnRvU3RyaW5nKCldO1xufTtcbnZhciB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgdG86IHRvQmlnSW50KGNhbGwuY29udHJhY3RBZGRyZXNzKS50b1N0cmluZygxMCksXG4gICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pXG4gIH0pKTtcbiAgcmV0dXJuIGNhbGxBcnJheTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xID0gKGNhbGxzKSA9PiB7XG4gIGNvbnN0IG9yZGVyQ2FsbHMgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgY29udHJhY3RBZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICBlbnRyeXBvaW50OiBjYWxsLmVudHJ5cG9pbnQsXG4gICAgY2FsbGRhdGE6IEFycmF5LmlzQXJyYXkoY2FsbC5jYWxsZGF0YSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBjYWxsLmNhbGxkYXRhID8gY2FsbC5jYWxsZGF0YSA6IENhbGxEYXRhLmNvbXBpbGUoY2FsbC5jYWxsZGF0YSlcbiAgICAvLyBSYXdBcmdzT2JqZWN0IHwgUmF3QXJnc0FycmF5IHR5cGVcbiAgfSkpO1xuICByZXR1cm4gQ2FsbERhdGEuY29tcGlsZSh7IG9yZGVyQ2FsbHMgfSk7XG59O1xudmFyIGdldEV4ZWN1dGVDYWxsZGF0YSA9IChjYWxscywgY2Fpcm9WZXJzaW9uID0gXCIwXCIpID0+IHtcbiAgaWYgKGNhaXJvVmVyc2lvbiA9PT0gXCIxXCIpIHtcbiAgICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xKGNhbGxzKTtcbiAgfVxuICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEoY2FsbHMpO1xufTtcbmZ1bmN0aW9uIGJ1aWxkVURDQ2FsbChwYXlsb2FkLCBhZGRyZXNzKSB7XG4gIGNvbnN0IHBhcmFtcyA9IFtdLmNvbmNhdChwYXlsb2FkKS5tYXAoKGl0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgc2FsdCxcbiAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW11cbiAgICB9ID0gaXQ7XG4gICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBkZXBsb3lTYWx0ID0gc2FsdCA/PyByYW5kb21BZGRyZXNzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGw6IHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGRlcGxveVNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgYWRkcmVzczogY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goXG4gICAgICAgIHVuaXF1ZSA/IHN0YXJrQ3VydmUucGVkZXJzZW4oYWRkcmVzcywgZGVwbG95U2FsdCkgOiBkZXBsb3lTYWx0LFxuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSxcbiAgICAgICAgdW5pcXVlID8gVURDLkFERFJFU1MgOiAwXG4gICAgICApXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbHM6IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5jYWxsKSxcbiAgICBhZGRyZXNzZXM6IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5hZGRyZXNzKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpIHtcbiAgcmV0dXJuIHZlcnNpb25UeXBlID09PSBcImZlZVwiID8ge1xuICAgIHYxOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLFxuICAgIHYyOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyLFxuICAgIHYzOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXG4gIH0gOiB7IHYxOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLCB2MjogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMiwgdjM6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMgfTtcbn1cblxuLy8gc3JjL2NoYW5uZWwvcnBjXzBfNi50c1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gIGJsb2NrSWRlbnRpZmllcjogXCJwZW5kaW5nXCIgLyogUEVORElORyAqLyxcbiAgcmV0cmllczogMjAwXG59O1xudmFyIFJwY0NoYW5uZWwgPSBjbGFzcyB7XG4gIG5vZGVVcmw7XG4gIGhlYWRlcnM7XG4gIHJldHJpZXM7XG4gIHJlcXVlc3RJZDtcbiAgYmxvY2tJZGVudGlmaWVyO1xuICBjaGFpbklkO1xuICBzcGVjVmVyc2lvbjtcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBjb25zdCB7IG5vZGVVcmwsIHJldHJpZXMsIGhlYWRlcnMsIGJsb2NrSWRlbnRpZmllciwgY2hhaW5JZCwgc3BlY1ZlcnNpb24sIHdhaXRNb2RlIH0gPSBvcHRpb25zT3JQcm92aWRlciB8fCB7fTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhOZXR3b3JrTmFtZSkuaW5jbHVkZXMobm9kZVVybCkpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKG5vZGVVcmwsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9IGVsc2UgaWYgKG5vZGVVcmwpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IG5vZGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKHZvaWQgMCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH1cbiAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzIHx8IGRlZmF1bHRPcHRpb25zLnJldHJpZXM7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9ucy5oZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBibG9ja0lkZW50aWZpZXIgfHwgZGVmYXVsdE9wdGlvbnMuYmxvY2tJZGVudGlmaWVyO1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgdGhpcy5zcGVjVmVyc2lvbiA9IHNwZWNWZXJzaW9uO1xuICAgIHRoaXMud2FpdE1vZGUgPSB3YWl0TW9kZSB8fCBmYWxzZTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IDA7XG4gIH1cbiAgc2V0Q2hhaW5JZChjaGFpbklkKSB7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgY29uc3QgcnBjUmVxdWVzdEJvZHkgPSB7XG4gICAgICBpZCxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICAuLi5wYXJhbXMgJiYgeyBwYXJhbXMgfVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoUG9ueWZpbGxfZGVmYXVsdCh0aGlzLm5vZGVVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBzdHJpbmdpZnkyKHJwY1JlcXVlc3RCb2R5KSxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG4gIGVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgcnBjRXJyb3IsIG90aGVyRXJyb3IpIHtcbiAgICBpZiAocnBjRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gcnBjRXJyb3I7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFxuICAgICAgICBgUlBDOiAke21ldGhvZH0gd2l0aCBwYXJhbXMgJHtzdHJpbmdpZnkyKHBhcmFtcywgbnVsbCwgMil9XG5cbiAgICAgICAgJHtjb2RlfTogJHttZXNzYWdlfTogJHtzdHJpbmdpZnkyKGRhdGEpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yIGluc3RhbmNlb2YgTGlicmFyeUVycm9yKSB7XG4gICAgICB0aHJvdyBvdGhlckVycm9yO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3Iob3RoZXJFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hFbmRwb2ludChtZXRob2QsIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKG1ldGhvZCwgcGFyYW1zLCB0aGlzLnJlcXVlc3RJZCArPSAxKTtcbiAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgcmF3UmVzdWx0Lmpzb24oKTtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3I/LnJlc3BvbnNlPy5kYXRhLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICB0aGlzLmNoYWluSWQgPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NoYWluSWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgfVxuICBhc3luYyBnZXRTcGVjVmVyc2lvbigpIHtcbiAgICB0aGlzLnNwZWNWZXJzaW9uID8/PSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zcGVjVmVyc2lvblwiKTtcbiAgICByZXR1cm4gdGhpcy5zcGVjVmVyc2lvbjtcbiAgfVxuICBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Tm9uY2VcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja0hhc2hBbmROdW1iZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgbnVtYmVyXG4gICAqIHJlZHVuZGFudCB1c2UgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdGhlIGxhdGVzdCBibG9ja1xuICAgKi9cbiAgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrTnVtYmVyXCIpO1xuICB9XG4gIGdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeEhhc2hlc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RhdGVVcGRhdGVcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VCbG9ja1RyYW5zYWN0aW9uc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50XCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2hcbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXhcIiwgeyBibG9ja19pZCwgaW5kZXggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlVHJhbnNhY3Rpb25cIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHJhbnNhY3Rpb25IYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25TdGF0dXNcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQWNjb3VudEludm9jYXRpb25zXG4gICAqIEBwYXJhbSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyBibG9ja0lkZW50aWZpZXIgYW5kIGZsYWdzIHRvIHNraXAgdmFsaWRhdGlvbiBhbmQgZmVlIGNoYXJnZTxici8+XG4gICAqIC0gYmxvY2tJZGVudGlmaWVyPGJyLz5cbiAgICogLSBza2lwVmFsaWRhdGUgKGRlZmF1bHQgZmFsc2UpPGJyLz5cbiAgICogLSBza2lwRmVlQ2hhcmdlIChkZWZhdWx0IHRydWUpPGJyLz5cbiAgICovXG4gIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZSA9IHRydWUsXG4gICAgICBza2lwRmVlQ2hhcmdlID0gdHJ1ZVxuICAgIH0gPSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucztcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3Qgc2ltdWxhdGlvbkZsYWdzID0gW107XG4gICAgaWYgKHNraXBWYWxpZGF0ZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY3NwZWNfMF82X2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEUpO1xuICAgIGlmIChza2lwRmVlQ2hhcmdlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjc3BlY18wXzZfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyA1ZTM7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5SRUpFQ1RFRFxuICAgICAgLy8gVE9ETzogY29tbWVudGVkIG91dCB0byBwcmVzZXJ2ZSB0aGUgbG9uZy1zdGFuZGluZyBiZWhhdmlvciBvZiBcInJldmVydGVkXCIgbm90IGJlaW5nIHRyZWF0ZWQgYXMgYW4gZXJyb3IgYnkgZGVmYXVsdFxuICAgICAgLy8gc2hvdWxkIGRlY2lkZSB3aGljaCBiZWhhdmlvciB0byBrZWVwIGluIHRoZSBmdXR1cmVcbiAgICAgIC8vIFJQQy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuUkVWRVJURUQsXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5TVUNDRUVERUQsXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uU3RhdHVzLkFDQ0VQVEVEX09OX0wxXG4gICAgXTtcbiAgICBsZXQgdHhTdGF0dXM7XG4gICAgd2hpbGUgKCFvbmNoYWluKSB7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhTdGF0dXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblN0YXR1cyA9IHR4U3RhdHVzLmV4ZWN1dGlvbl9zdGF0dXM7XG4gICAgICAgIGNvbnN0IGZpbmFsaXR5U3RhdHVzID0gdHhTdGF0dXMuZmluYWxpdHlfc3RhdHVzO1xuICAgICAgICBpZiAoIWZpbmFsaXR5U3RhdHVzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJ3YWl0aW5nIGZvciB0cmFuc2FjdGlvbiBzdGF0dXNcIik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke2V4ZWN1dGlvblN0YXR1c306ICR7ZmluYWxpdHlTdGF0dXN9YDtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHR4U3RhdHVzO1xuICAgICAgICAgIGlzRXJyb3JTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgb25jaGFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGlzRXJyb3JTdGF0ZSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgfVxuICAgIGxldCB0eFJlY2VpcHQgPSBudWxsO1xuICAgIHdoaWxlICh0eFJlY2VpcHQgPT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9TdG9yYWdlS2V5KGtleSk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdG9yYWdlQXRcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0hhc2hBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2xhc3NfaGFzaCA9IHRvSGV4KGNsYXNzSGFzaCk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc1wiLCB7XG4gICAgICBjbGFzc19oYXNoLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbnMsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IHRydWUgfSkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBsZXQgZmxhZ3MgPSB7fTtcbiAgICBpZiAoIWlzVmVyc2lvbihcIjAuNVwiLCBhd2FpdCB0aGlzLmdldFNwZWNWZXJzaW9uKCkpKSB7XG4gICAgICBmbGFncyA9IHtcbiAgICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2tpcFZhbGlkYXRlID8gW3JwY3NwZWNfMF82X2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEVdIDogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZUZlZVwiLCB7XG4gICAgICByZXF1ZXN0OiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQsIFwiZmVlXCIpKSxcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgLi4uZmxhZ3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZva2UoZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGZ1bmN0aW9uSW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKHsgY29udHJhY3QsIHNpZ25hdHVyZSwgc2VuZGVyQWRkcmVzcywgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpICYmICFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2llcnJhKGNvbnRyYWN0KSAmJiAhaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3Quc2llcnJhX3Byb2dyYW0pLFxuICAgICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMixcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZGVjbGFyZSB1bnNwb3R0ZWQgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IHRvSGV4KHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlTWVzc2FnZUZlZVwiLCB7XG4gICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3luY2luZ1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0RXZlbnRzXCIsIHsgZmlsdGVyOiBldmVudEZpbHRlciB9KTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGlmICghaXNWM1R4KGludm9jYXRpb24pKSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIHJlc291cmNlX2JvdW5kczogaW52b2NhdGlvbi5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgdGlwOiB0b0hleChpbnZvY2F0aW9uLnRpcCksXG4gICAgICAgIHBheW1hc3Rlcl9kYXRhOiBpbnZvY2F0aW9uLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGludm9jYXRpb24uYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB2MCB2MSB2M1xuICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBDYWlybyAxIC0gdjIgdjNcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIC4uLmludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGludm9jYXRpb24uY29udHJhY3Quc2llcnJhX3Byb2dyYW0pXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgY29uc3QgeyBhY2NvdW50X2RlcGxveW1lbnRfZGF0YSwgLi4ucmVzdERldGFpbHMgfSA9IGRldGFpbHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICBjbGFzc19oYXNoOiB0b0hleChpbnZvY2F0aW9uLmNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoaW52b2NhdGlvbi5hZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLnJlc3REZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlJQQyBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY2hhbm5lbC9ycGNfMF83LnRzXG52YXIgcnBjXzBfN19leHBvcnRzID0ge307XG5fX2V4cG9ydChycGNfMF83X2V4cG9ydHMsIHtcbiAgUnBjQ2hhbm5lbDogKCkgPT4gUnBjQ2hhbm5lbDJcbn0pO1xudmFyIGRlZmF1bHRPcHRpb25zMiA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IFwicGVuZGluZ1wiIC8qIFBFTkRJTkcgKi8sXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNDaGFubmVsMiA9IGNsYXNzIHtcbiAgbm9kZVVybDtcbiAgaGVhZGVycztcbiAgcmV0cmllcztcbiAgcmVxdWVzdElkO1xuICBibG9ja0lkZW50aWZpZXI7XG4gIGNoYWluSWQ7XG4gIHNwZWNWZXJzaW9uO1xuICB0cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjaztcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBub2RlVXJsLFxuICAgICAgcmV0cmllcyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBjaGFpbklkLFxuICAgICAgc3BlY1ZlcnNpb24sXG4gICAgICB3YWl0TW9kZSxcbiAgICAgIHRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrXG4gICAgfSA9IG9wdGlvbnNPclByb3ZpZGVyIHx8IHt9O1xuICAgIGlmIChPYmplY3QudmFsdWVzKE5ldHdvcmtOYW1lKS5pbmNsdWRlcyhub2RlVXJsKSkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwobm9kZVVybCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH0gZWxzZSBpZiAobm9kZVVybCkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gbm9kZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwodm9pZCAwLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXMgfHwgZGVmYXVsdE9wdGlvbnMyLnJldHJpZXM7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9uczIuaGVhZGVycywgLi4uaGVhZGVycyB9O1xuICAgIHRoaXMuYmxvY2tJZGVudGlmaWVyID0gYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLnNwZWNWZXJzaW9uID0gc3BlY1ZlcnNpb247XG4gICAgdGhpcy53YWl0TW9kZSA9IHdhaXRNb2RlIHx8IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdElkID0gMDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrID0gdHJhbnNhY3Rpb25SZXRyeUludGVydmFsRmFsbGJhY2s7XG4gIH1cbiAgZ2V0IHRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25SZXRyeUludGVydmFsRmFsbGJhY2sgPz8gNWUzO1xuICB9XG4gIHNldENoYWluSWQoY2hhaW5JZCkge1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIGNvbnN0IHJwY1JlcXVlc3RCb2R5ID0ge1xuICAgICAgaWQsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgLi4ucGFyYW1zICYmIHsgcGFyYW1zIH1cbiAgICB9O1xuICAgIHJldHVybiBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihycGNSZXF1ZXN0Qm9keSksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBlcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIHJwY0Vycm9yLCBvdGhlckVycm9yKSB7XG4gICAgaWYgKHJwY0Vycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IHJwY0Vycm9yO1xuICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihcbiAgICAgICAgYFJQQzogJHttZXRob2R9IHdpdGggcGFyYW1zICR7c3RyaW5naWZ5MihwYXJhbXMsIG51bGwsIDIpfVxuIFxuICAgICAgICAke2NvZGV9OiAke21lc3NhZ2V9OiAke3N0cmluZ2lmeTIoZGF0YSl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpIHtcbiAgICAgIHRocm93IG90aGVyRXJyb3I7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yKSB7XG4gICAgICB0aHJvdyBFcnJvcihvdGhlckVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaEVuZHBvaW50KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHRoaXMuZmV0Y2gobWV0aG9kLCBwYXJhbXMsIHRoaXMucmVxdWVzdElkICs9IDEpO1xuICAgICAgY29uc3QgeyBlcnJvciwgcmVzdWx0IH0gPSBhd2FpdCByYXdSZXN1bHQuanNvbigpO1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcj8ucmVzcG9uc2U/LmRhdGEsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHRoaXMuY2hhaW5JZCA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2hhaW5JZFwiKTtcbiAgICByZXR1cm4gdGhpcy5jaGFpbklkO1xuICB9XG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHRoaXMuc3BlY1ZlcnNpb24gPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NwZWNWZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLnNwZWNWZXJzaW9uO1xuICB9XG4gIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXROb25jZVwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1dpdGhSZWNlaXB0cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoUmVjZWlwdHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZUJsb2NrVHJhbnNhY3Rpb25zXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlID0gdHJ1ZSxcbiAgICAgIHNraXBGZWVDaGFyZ2UgPSB0cnVlXG4gICAgfSA9IHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCBzaW11bGF0aW9uRmxhZ3MgPSBbXTtcbiAgICBpZiAoc2tpcFZhbGlkYXRlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2goUlBDU1BFQzA3LkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFKTtcbiAgICBpZiAoc2tpcEZlZUNoYXJnZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKFJQQ1NQRUMwNy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbERlZmF1bHQ7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBSUENTUEVDMDcuRVRyYW5zYWN0aW9uU3RhdHVzLlJFSkVDVEVEXG4gICAgICAvLyBUT0RPOiBjb21tZW50ZWQgb3V0IHRvIHByZXNlcnZlIHRoZSBsb25nLXN0YW5kaW5nIGJlaGF2aW9yIG9mIFwicmV2ZXJ0ZWRcIiBub3QgYmVpbmcgdHJlYXRlZCBhcyBhbiBlcnJvciBieSBkZWZhdWx0XG4gICAgICAvLyBzaG91bGQgZGVjaWRlIHdoaWNoIGJlaGF2aW9yIHRvIGtlZXAgaW4gdGhlIGZ1dHVyZVxuICAgICAgLy8gUlBDLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5SRVZFUlRFRCxcbiAgICBdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0ZXMgPSBvcHRpb25zPy5zdWNjZXNzU3RhdGVzID8/IFtcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuU1VDQ0VFREVELFxuICAgICAgUlBDU1BFQzA3LkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDFcbiAgICBdO1xuICAgIGxldCB0eFN0YXR1cztcbiAgICB3aGlsZSAoIW9uY2hhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICB0eFN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uU3RhdHVzID0gdHhTdGF0dXMuZXhlY3V0aW9uX3N0YXR1cztcbiAgICAgICAgY29uc3QgZmluYWxpdHlTdGF0dXMgPSB0eFN0YXR1cy5maW5hbGl0eV9zdGF0dXM7XG4gICAgICAgIGlmICghZmluYWxpdHlTdGF0dXMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIndhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIHN0YXR1c1wiKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBlcnJvclN0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7ZXhlY3V0aW9uU3RhdHVzfTogJHtmaW5hbGl0eVN0YXR1c31gO1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gdHhTdGF0dXM7XG4gICAgICAgICAgaXNFcnJvclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBvbmNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgaXNFcnJvclN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICB9XG4gICAgbGV0IHR4UmVjZWlwdCA9IG51bGw7XG4gICAgd2hpbGUgKHR4UmVjZWlwdCA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHhSZWNlaXB0O1xuICB9XG4gIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSB0b1N0b3JhZ2VLZXkoa2V5KTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0b3JhZ2VBdFwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAga2V5OiBwYXJzZWRLZXksXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzSGFzaEF0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjbGFzc19oYXNoID0gdG9IZXgoY2xhc3NIYXNoKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzXCIsIHtcbiAgICAgIGNsYXNzX2hhc2gsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gdHJ1ZSB9KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGxldCBmbGFncyA9IHt9O1xuICAgIGlmICghaXNWZXJzaW9uKFwiMC41XCIsIGF3YWl0IHRoaXMuZ2V0U3BlY1ZlcnNpb24oKSkpIHtcbiAgICAgIGZsYWdzID0ge1xuICAgICAgICBzaW11bGF0aW9uX2ZsYWdzOiBza2lwVmFsaWRhdGUgPyBbUlBDU1BFQzA3LkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFXSA6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZCxcbiAgICAgIC4uLmZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGZ1bmN0aW9uSW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKHsgY29udHJhY3QsIHNpZ25hdHVyZSwgc2VuZGVyQWRkcmVzcywgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpICYmICFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgcHJvZ3JhbTogY29udHJhY3QucHJvZ3JhbSxcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3Quc2llcnJhX3Byb2dyYW0pLFxuICAgICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2llcnJhKGNvbnRyYWN0KSAmJiBpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZGVjbGFyZSB1bnNwb3R0ZWQgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5ULFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjMsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NhbGxcIiwge1xuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBjb250cmFjdF9hZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNhbGwuY2FsbGRhdGEpXG4gICAgICB9LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHsgZnJvbV9hZGRyZXNzLCB0b19hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3RvciwgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0ge1xuICAgICAgZnJvbV9hZGRyZXNzOiB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzcyhmcm9tX2FkZHJlc3MpLFxuICAgICAgdG9fYWRkcmVzczogdG9IZXgodG9fYWRkcmVzcyksXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3IoZW50cnlfcG9pbnRfc2VsZWN0b3IpLFxuICAgICAgcGF5bG9hZDogZ2V0SGV4U3RyaW5nQXJyYXkocGF5bG9hZClcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVNZXNzYWdlRmVlXCIsIHtcbiAgICAgIG1lc3NhZ2U6IGZvcm1hdHRlZE1lc3NhZ2UsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zeW5jaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgYW5kIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBldmVudHNcbiAgICovXG4gIGdldEV2ZW50cyhldmVudEZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRFdmVudHNcIiwgeyBmaWx0ZXI6IGV2ZW50RmlsdGVyIH0pO1xuICB9XG4gIGJ1aWxkVHJhbnNhY3Rpb24oaW52b2NhdGlvbiwgdmVyc2lvblR5cGUpIHtcbiAgICBjb25zdCBkZWZhdWx0VmVyc2lvbnMgPSBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSk7XG4gICAgbGV0IGRldGFpbHM7XG4gICAgaWYgKCFpc1YzVHgoaW52b2NhdGlvbikpIHtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoaW52b2NhdGlvbi5tYXhGZWUgfHwgMClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBpbnZvY2F0aW9uLnJlc291cmNlQm91bmRzLFxuICAgICAgICB0aXA6IHRvSGV4KGludm9jYXRpb24udGlwKSxcbiAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGludm9jYXRpb24ucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBpbnZvY2F0aW9uLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBpbnZvY2F0aW9uLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogaW52b2NhdGlvbi5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIHYwIHYxIHYzXG4gICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICBpZiAoIWlzU2llcnJhKGludm9jYXRpb24uY29udHJhY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gQ2Fpcm8gMSAtIHYyIHYzXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShpbnZvY2F0aW9uLmNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIGNvbnN0IHsgYWNjb3VudF9kZXBsb3ltZW50X2RhdGEsIC4uLnJlc3REZXRhaWxzIH0gPSBkZXRhaWxzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5yZXN0RGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJSUEMgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3Jlc3BvbnNlUGFyc2VyL3JwYy50c1xudmFyIFJQQ1Jlc3BvbnNlUGFyc2VyID0gY2xhc3Mge1xuICBtYXJnaW47XG4gIGNvbnN0cnVjdG9yKG1hcmdpbikge1xuICAgIHRoaXMubWFyZ2luID0gbWFyZ2luO1xuICB9XG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlKGVzdGltYXRlZEZlZSkge1xuICAgIHJldHVybiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIHRoaXMubWFyZ2luPy5tYXhGZWUpO1xuICB9XG4gIGVzdGltYXRlRmVlVG9Cb3VuZHMoZXN0aW1hdGUpIHtcbiAgICByZXR1cm4gZXN0aW1hdGVGZWVUb0JvdW5kcyhcbiAgICAgIGVzdGltYXRlLFxuICAgICAgdGhpcy5tYXJnaW4/LmwxQm91bmRNYXhBbW91bnQsXG4gICAgICB0aGlzLm1hcmdpbj8ubDFCb3VuZE1heFByaWNlUGVyVW5pdFxuICAgICk7XG4gIH1cbiAgcGFyc2VHZXRCbG9ja1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJQRU5ESU5HXCIsIC4uLnJlcyB9O1xuICB9XG4gIHBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0KHJlcykge1xuICAgIGlmIChcImFjdHVhbF9mZWVcIiBpbiByZXMgJiYgaXNTdHJpbmcocmVzLmFjdHVhbF9mZWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIGFjdHVhbF9mZWU6IHtcbiAgICAgICAgICBhbW91bnQ6IHJlcy5hY3R1YWxfZmVlLFxuICAgICAgICAgIHVuaXQ6IFwiRlJJXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgdmFsID0gcmVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHModmFsKSxcbiAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiB2YWwuZGF0YV9nYXNfY29uc3VtZWQgPyB0b0JpZ0ludCh2YWwuZGF0YV9nYXNfY29uc3VtZWQpIDogMG4sXG4gICAgICBkYXRhX2dhc19wcmljZTogdmFsLmRhdGFfZ2FzX3ByaWNlID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX3ByaWNlKSA6IDBuXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKCh2YWwpID0+ICh7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHModmFsKSxcbiAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiB2YWwuZGF0YV9nYXNfY29uc3VtZWQgPyB0b0JpZ0ludCh2YWwuZGF0YV9nYXNfY29uc3VtZWQpIDogMG4sXG4gICAgICBkYXRhX2dhc19wcmljZTogdmFsLmRhdGFfZ2FzX3ByaWNlID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX3ByaWNlKSA6IDBuXG4gICAgfSkpO1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXQsXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogdGhpcy5lc3RpbWF0ZWRGZWVUb01heEZlZShpdC5mZWVfZXN0aW1hdGlvbi5vdmVyYWxsX2ZlZSksXG4gICAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHMoaXQuZmVlX2VzdGltYXRpb24pXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBhYmk6IGlzU3RyaW5nKHJlcy5hYmkpID8gSlNPTi5wYXJzZShyZXMuYWJpKSA6IHJlcy5hYmlcbiAgICB9O1xuICB9XG4gIHBhcnNlTDFHYXNQcmljZVJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubDFfZ2FzX3ByaWNlLnByaWNlX2luX3dlaTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uUmVjZWlwdC50c1xudmFyIFJlY2VpcHRUeCA9IGNsYXNzIF9SZWNlaXB0VHgge1xuICBzdGF0dXNSZWNlaXB0O1xuICB2YWx1ZTtcbiAgY29uc3RydWN0b3IocmVjZWlwdCkge1xuICAgIFt0aGlzLnN0YXR1c1JlY2VpcHQsIHRoaXMudmFsdWVdID0gX1JlY2VpcHRUeC5pc1N1Y2Nlc3MocmVjZWlwdCkgPyBbXCJzdWNjZXNzXCIsIHJlY2VpcHRdIDogX1JlY2VpcHRUeC5pc1JldmVydGVkKHJlY2VpcHQpID8gW1wicmV2ZXJ0ZWRcIiwgcmVjZWlwdF0gOiBfUmVjZWlwdFR4LmlzUmVqZWN0ZWQocmVjZWlwdCkgPyBbXCJyZWplY3RlZFwiLCByZWNlaXB0XSA6IFtcImVycm9yXCIsIG5ldyBFcnJvcihcIlVua25vd24gcmVzcG9uc2UgdHlwZVwiKV07XG4gICAgZm9yIChjb25zdCBba2V5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlY2VpcHQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBtYXRjaChjYWxsYmFja3MpIHtcbiAgICBpZiAodGhpcy5zdGF0dXNSZWNlaXB0IGluIGNhbGxiYWNrcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrc1t0aGlzLnN0YXR1c1JlY2VpcHRdKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2tzLl8oKTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJzdWNjZXNzXCI7XG4gIH1cbiAgaXNSZXZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcInJldmVydGVkXCI7XG4gIH1cbiAgaXNSZWplY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcInJlamVjdGVkXCI7XG4gIH1cbiAgaXNFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcImVycm9yXCI7XG4gIH1cbiAgc3RhdGljIGlzU3VjY2Vzcyh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LmV4ZWN1dGlvbl9zdGF0dXMgPT09IFwiU1VDQ0VFREVEXCIgLyogU1VDQ0VFREVEICovO1xuICB9XG4gIHN0YXRpYyBpc1JldmVydGVkKHRyYW5zYWN0aW9uUmVjZWlwdCkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblJlY2VpcHQuZXhlY3V0aW9uX3N0YXR1cyA9PT0gXCJSRVZFUlRFRFwiIC8qIFJFVkVSVEVEICovO1xuICB9XG4gIHN0YXRpYyBpc1JlamVjdGVkKHRyYW5zYWN0aW9uUmVjZWlwdCkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblJlY2VpcHQuc3RhdHVzID09PSBcIlJFSkVDVEVEXCIgLyogUkVKRUNURUQgKi87XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9ycGMudHNcbnZhciBScGNQcm92aWRlciA9IGNsYXNzIHtcbiAgcmVzcG9uc2VQYXJzZXI7XG4gIGNoYW5uZWw7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgaWYgKG9wdGlvbnNPclByb3ZpZGVyICYmIFwiY2hhbm5lbFwiIGluIG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBvcHRpb25zT3JQcm92aWRlci5jaGFubmVsO1xuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlciA9IFwicmVzcG9uc2VQYXJzZXJcIiBpbiBvcHRpb25zT3JQcm92aWRlciA/IG9wdGlvbnNPclByb3ZpZGVyLnJlc3BvbnNlUGFyc2VyIDogbmV3IFJQQ1Jlc3BvbnNlUGFyc2VyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IG5ldyBScGNDaGFubmVsMih7IC4uLm9wdGlvbnNPclByb3ZpZGVyLCB3YWl0TW9kZTogZmFsc2UgfSk7XG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyID0gbmV3IFJQQ1Jlc3BvbnNlUGFyc2VyKG9wdGlvbnNPclByb3ZpZGVyPy5mZWVNYXJnaW5QZXJjZW50YWdlKTtcbiAgICB9XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkKTtcbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2hhaW5JZCgpO1xuICB9XG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0U3BlY1ZlcnNpb24oKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldEJsb2NrUmVzcG9uc2UpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIGhhc2ggYW5kIG51bWJlclxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrTnVtYmVyKCk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBzY3JpcHQgdW50aWwgYSBzcGVjaWZpZWQgYmxvY2sgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtCbG9ja0lkZW50aWZpZXJ9IGJsb2NrSWRlbnRpZmllciBibG9jIG51bWJlciAoQmlnTnVtYmVyaXNrKSBvciAncGVuZGluZycgb3IgJ2xhdGVzdCcuXG4gICAqIFVzZSBvZiAnbGF0ZXN0XCIgb3Igb2YgYSBibG9jayBhbHJlYWR5IGNyZWF0ZWQgd2lsbCBnZW5lcmF0ZSBubyBwYXVzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXRyeUludGVydmFsXSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gMiByZXF1ZXN0cyB0byB0aGUgbm9kZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IG15UHJvdmlkZXIud2FpdEZvckJsb2NrKCk7XG4gICAqIC8vIHdhaXQgdGhlIGNyZWF0aW9uIG9mIHRoZSBwZW5kaW5nIGJsb2NrXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgd2FpdEZvckJsb2NrKGJsb2NrSWRlbnRpZmllciA9IFwicGVuZGluZ1wiLCByZXRyeUludGVydmFsID0gNWUzKSB7XG4gICAgaWYgKGJsb2NrSWRlbnRpZmllciA9PT0gXCJsYXRlc3RcIiAvKiBMQVRFU1QgKi8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xuICAgIGNvbnN0IHRhcmdldEJsb2NrID0gYmxvY2tJZGVudGlmaWVyID09PSBcInBlbmRpbmdcIiAvKiBQRU5ESU5HICovID8gY3VycmVudEJsb2NrICsgMSA6IE51bWJlcih0b0hleChibG9ja0lkZW50aWZpZXIpKTtcbiAgICBpZiAodGFyZ2V0QmxvY2sgPD0gY3VycmVudEJsb2NrKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgcmV0cmllcyB9ID0gdGhpcy5jaGFubmVsO1xuICAgIGxldCByZXRyaWVzQ291bnQgPSByZXRyaWVzO1xuICAgIGxldCBpc1RhcmdldEJsb2NrID0gZmFsc2U7XG4gICAgd2hpbGUgKCFpc1RhcmdldEJsb2NrKSB7XG4gICAgICBjb25zdCBjdXJyQmxvY2sgPSBhd2FpdCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICBpZiAoY3VyckJsb2NrID09PSB0YXJnZXRCbG9jaykge1xuICAgICAgICBpc1RhcmdldEJsb2NrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgICByZXRyaWVzQ291bnQgLT0gMTtcbiAgICAgIGlmIChyZXRyaWVzQ291bnQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JCbG9jaygpIHRpbWVkLW91dCBhZnRlciAke3JldHJpZXN9IHRyaWVzLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBnZXRMMUdhc1ByaWNlKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VMMUdhc1ByaWNlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldEwxTWVzc2FnZUhhc2gobDJUeEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5SGFzaChsMlR4SGFzaCk7XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiTDFfSEFORExFUlwiLCBcIlRoaXMgTDIgdHJhbnNhY3Rpb24gaXMgbm90IGEgTDEgbWVzc2FnZS5cIik7XG4gICAgY29uc3QgeyBjYWxsZGF0YSwgY29udHJhY3RfYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIG5vbmNlIH0gPSB0cmFuc2FjdGlvbjtcbiAgICBjb25zdCBwYXJhbXMgPSBbXG4gICAgICBjYWxsZGF0YVswXSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yLFxuICAgICAgY2FsbGRhdGEubGVuZ3RoIC0gMSxcbiAgICAgIC4uLmNhbGxkYXRhLnNsaWNlKDEpXG4gICAgXTtcbiAgICBjb25zdCBteUVuY29kZSA9IGFkZEhleFByZWZpeChcbiAgICAgIHBhcmFtcy5yZWR1Y2UoXG4gICAgICAgIChyZXMsIHBhcikgPT4gcmVzICsgcmVtb3ZlSGV4UHJlZml4KHRvSGV4KHBhcikpLnBhZFN0YXJ0KDY0LCBcIjBcIiksXG4gICAgICAgIFwiXCJcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoYnl0ZXNUb0hleChrZWNjYWtfMjU2KGhleFRvQnl0ZXMobXlFbmNvZGUpKSkpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFJlY2VpcHRzKGJsb2NrSWRlbnRpZmllcikge1xuICAgIGlmICh0aGlzLmNoYW5uZWwgaW5zdGFuY2VvZiBycGNfMF82X2V4cG9ydHMuUnBjQ2hhbm5lbClcbiAgICAgIHRocm93IG5ldyBMaWJyYXJ5RXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRob2QgZm9yIFJQQyB2ZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoUmVjZWlwdHMoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBnZXRTdGF0ZVVwZGF0ZSA9IHRoaXMuZ2V0QmxvY2tTdGF0ZVVwZGF0ZTtcbiAgYXN5bmMgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cmFuc2FjdGlvbnMgZnJvbSBwZW5kaW5nIGJsb2NrXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQgdXNlIGdldEJsb2NrKEJsb2NrVGFnLlBFTkRJTkcpOyAod2lsbCBiZSByZW1vdmVkIGluIG5leHQgbWlub3IgdmVyc2lvbilcbiAgICogVXRpbGl0eSBtZXRob2QsIHNhbWUgcmVzdWx0IGNhbiBiZSBhY2hpZXZlZCB1c2luZyBnZXRCbG9ja1dpdGhUeEhhc2hlcyhCbG9ja1RhZy5wZW5kaW5nKTtcbiAgICovXG4gIGFzeW5jIGdldFBlbmRpbmdUcmFuc2FjdGlvbnMoKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoXCJwZW5kaW5nXCIgLyogUEVORElORyAqLykudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgoaXQpID0+IHRoaXMuZ2V0VHJhbnNhY3Rpb25CeUhhc2goaXQpKSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIGNvbnN0IHR4UmVjZWlwdFdvSGVscGVyID0gYXdhaXQgdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgIGNvbnN0IHR4UmVjZWlwdFdvSGVscGVyTW9kaWZpZWQgPSB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0KHR4UmVjZWlwdFdvSGVscGVyKTtcbiAgICByZXR1cm4gbmV3IFJlY2VpcHRUeCh0eFJlY2VpcHRXb0hlbHBlck1vZGlmaWVkKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgYmxvY2tJZGVudGlmaWVyIGFuZCBmbGFncyB0byBza2lwIHZhbGlkYXRpb24gYW5kIGZlZSBjaGFyZ2U8YnIvPlxuICAgKiAtIGJsb2NrSWRlbnRpZmllcjxici8+XG4gICAqIC0gc2tpcFZhbGlkYXRlIChkZWZhdWx0IGZhbHNlKTxici8+XG4gICAqIC0gc2tpcEZlZUNoYXJnZSAoZGVmYXVsdCB0cnVlKTxici8+XG4gICAqL1xuICBhc3luYyBnZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5zaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWlwdFdvSGVscGVyID0gYXdhaXQgdGhpcy5jaGFubmVsLndhaXRGb3JUcmFuc2FjdGlvbihcbiAgICAgIHR4SGFzaCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiBuZXcgUmVjZWlwdFR4KHJlY2VpcHRXb0hlbHBlcik7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5jaGFubmVsLmJsb2NrSWRlbnRpZmllcixcbiAgICBjb21waWxlciA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgbGV0IGNvbnRyYWN0Q2xhc3M7XG4gICAgaWYgKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChjbGFzc0hhc2gpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXRDb250cmFjdFZlcnNpb24gcmVxdWlyZSBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXQqdHlwZSpFc3RpbWF0ZUZlZSAod2lsbCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHR5cGUgYWZ0ZXIgc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBhc3luYyBnZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sXG4gICAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uRGV0YWlsc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9XG4gICAgKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH1cbiAgICApLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9XG4gICAgKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9ucywgb3B0aW9ucykudGhlbigocikgPT4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmludm9rZShmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh0cmFuc2FjdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZGVjbGFyZSh0cmFuc2FjdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudENvbnRyYWN0KHRyYW5zYWN0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5kZXBsb3lBY2NvdW50KFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0U3luY2luZ1N0YXRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAqIEByZXR1cm5zIGV2ZW50cyBhbmQgdGhlIHBhZ2luYXRpb24gb2YgdGhlIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgZ2V0RXZlbnRzKGV2ZW50RmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFdmVudHMoZXZlbnRGaWx0ZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9kZWZhdWx0LnRzXG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gXCJ0cy1taXhlclwiO1xuXG4vLyBzcmMvdXRpbHMvc3RhcmtuZXRJZC50c1xudmFyIHN0YXJrbmV0SWRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtuZXRJZF9leHBvcnRzLCB7XG4gIFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZENvbnRyYWN0LFxuICBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QsXG4gIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0LFxuICBTdGFya25ldElkUGZwQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRQZnBDb250cmFjdCxcbiAgU3RhcmtuZXRJZFBvcENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkUG9wQ29udHJhY3QsXG4gIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCxcbiAgZHluYW1pY0NhbGxEYXRhOiAoKSA9PiBkeW5hbWljQ2FsbERhdGEsXG4gIGR5bmFtaWNGZWx0OiAoKSA9PiBkeW5hbWljRmVsdCxcbiAgZXhlY3V0aW9uOiAoKSA9PiBleGVjdXRpb24sXG4gIGdldFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkUGZwQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRQZnBDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZFBvcENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkUG9wQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCxcbiAgdXNlRGVjb2RlZDogKCkgPT4gdXNlRGVjb2RlZCxcbiAgdXNlRW5jb2RlZDogKCkgPT4gdXNlRW5jb2RlZFxufSk7XG52YXIgYmFzaWNBbHBoYWJldCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LVwiO1xudmFyIGJhc2ljU2l6ZVBsdXNPbmUgPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGggKyAxKTtcbnZhciBiaWdBbHBoYWJldCA9IFwiXFx1OEZEOVxcdTY3NjVcIjtcbnZhciBiYXNpY0FscGhhYmV0U2l6ZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplUGx1c09uZSA9IEJpZ0ludChiaWdBbHBoYWJldC5sZW5ndGggKyAxKTtcbmZ1bmN0aW9uIGV4dHJhY3RTdGFycyhzdHIpIHtcbiAgbGV0IGsgPSAwO1xuICB3aGlsZSAoc3RyLmVuZHNXaXRoKGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdKSkge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIGsgKz0gMTtcbiAgfVxuICByZXR1cm4gW3N0ciwga107XG59XG5mdW5jdGlvbiB1c2VEZWNvZGVkKGVuY29kZWQpIHtcbiAgbGV0IGRlY29kZWQgPSBcIlwiO1xuICBlbmNvZGVkLmZvckVhY2goKHN1YmRvbWFpbikgPT4ge1xuICAgIHdoaWxlIChzdWJkb21haW4gIT09IFpFUk8pIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdWJkb21haW4gJSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgc3ViZG9tYWluIC89IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBpZiAoY29kZSA9PT0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKSkge1xuICAgICAgICBjb25zdCBuZXh0U3ViZG9tYWluID0gc3ViZG9tYWluIC8gYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgaWYgKG5leHRTdWJkb21haW4gPT09IFpFUk8pIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmU7XG4gICAgICAgICAgc3ViZG9tYWluID0gbmV4dFN1YmRvbWFpbjtcbiAgICAgICAgICBpZiAoY29kZTIgPT09IFpFUk8pXG4gICAgICAgICAgICBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbMF07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVjb2RlZCArPSBiaWdBbHBoYWJldFtOdW1iZXIoY29kZTIpIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY29kZTIgPSBzdWJkb21haW4gJSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgICAgZGVjb2RlZCArPSBiaWdBbHBoYWJldFtOdW1iZXIoY29kZTIpXTtcbiAgICAgICAgICBzdWJkb21haW4gLz0gYmlnQWxwaGFiZXRTaXplO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgZGVjb2RlZCArPSBiYXNpY0FscGhhYmV0W051bWJlcihjb2RlKV07XG4gICAgfVxuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKVxuICAgICAgZGVjb2RlZCA9IHN0ciArIChrICUgMiA9PT0gMCA/IGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdChrIC8gMiAtIDEpICsgYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdIDogYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KChrIC0gMSkgLyAyICsgMSkpO1xuICAgIGRlY29kZWQgKz0gXCIuXCI7XG4gIH0pO1xuICBpZiAoIWRlY29kZWQpIHtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxuICByZXR1cm4gZGVjb2RlZC5jb25jYXQoXCJzdGFya1wiKTtcbn1cbmZ1bmN0aW9uIHVzZUVuY29kZWQoZGVjb2RlZCkge1xuICBsZXQgZW5jb2RlZCA9IEJpZ0ludCgwKTtcbiAgbGV0IG11bHRpcGxpZXIgPSBCaWdJbnQoMSk7XG4gIGlmIChkZWNvZGVkLmVuZHNXaXRoKGJpZ0FscGhhYmV0WzBdICsgYmFzaWNBbHBoYWJldFsxXSkpIHtcbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkLnN1YnN0cmluZygwLCBkZWNvZGVkLmxlbmd0aCAtIDIpKTtcbiAgICBkZWNvZGVkID0gc3RyICsgYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KDIgKiAoayArIDEpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkKTtcbiAgICBpZiAoaylcbiAgICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMSArIDIgKiAoayAtIDEpKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gZGVjb2RlZFtpXTtcbiAgICBjb25zdCBpbmRleCA9IGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICBjb25zdCBibkluZGV4ID0gQmlnSW50KGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSAmJiBkZWNvZGVkW2ldID09PSBiYXNpY0FscGhhYmV0WzBdKSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJuSW5kZXg7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcikgIT09IC0xKSB7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBiYXNpY0FscGhhYmV0U2l6ZTtcbiAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGNvbnN0IG5ld2lkID0gKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSA/IDEgOiAwKSArIGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcik7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBCaWdJbnQobmV3aWQpO1xuICAgICAgbXVsdGlwbGllciAqPSBiaWdBbHBoYWJldFNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxudmFyIFN0YXJrbmV0SWRDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCI7XG4gIFN0YXJrbmV0SWRDb250cmFjdDJbXCJURVNUTkVUX1NFUE9MSUFcIl0gPSBcIjB4MTU0YmMyZTFhZjkyNjBiOWU2NmFmMGU5YzQ2ZmM3NTdmZjg5M2IzZmY2YTg1NzE4YTgxMGJhZjE0NzRcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRDb250cmFjdDI7XG59KShTdGFya25ldElkQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIiAvKiBNQUlOTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBcIjB4MTU0YmMyZTFhZjkyNjBiOWU2NmFmMGU5YzQ2ZmM3NTdmZjg5M2IzZmY2YTg1NzE4YTgxMGJhZjE0NzRcIiAvKiBURVNUTkVUX1NFUE9MSUEgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG52YXIgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHgwNWRiZGVkYzIwM2U5Mjc0OWUyZTc0NmUyZDQwYTc2OGQ5NjZiZDI0M2RmMDRhNmI3MTJlMjIyYmMwNDBhOWFmXCI7XG4gIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MltcIlRFU1RORVRfU0VQT0xJQVwiXSA9IFwiMHgzNjk3NjYwYTA5ODFkNzM0NzgwNzMxOTQ5ZWNiMmI0YTM4ZDZhNThmYzQxNjI5ZWQ2MTFlOGRlZmRhXCI7XG4gIHJldHVybiBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDI7XG59KShTdGFya25ldElkSWRlbnRpdHlDb250cmFjdCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDVkYmRlZGMyMDNlOTI3NDllMmU3NDZlMmQ0MGE3NjhkOTY2YmQyNDNkZjA0YTZiNzEyZTIyMmJjMDQwYTlhZlwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFwiMHgzNjk3NjYwYTA5ODFkNzM0NzgwNzMxOTQ5ZWNiMmI0YTM4ZDZhNThmYzQxNjI5ZWQ2MTFlOGRlZmRhXCIgLyogVEVTVE5FVF9TRVBPTElBICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCB2ZXJpZmllciBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdCA9IFwiMHgwMzRmZmI4ZjQ0NTJkZjdhNjEzYTAyMTA4MjRkNjQxNGRiYWRjZGRjZTZjNmUxOWJmNGRkYzllMjJjZTVmOTcwXCI7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICByZXR1cm4gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0O1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIG11bHRpY2FsbCBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDdkMTRkZmQ4ZWU5NWI0MWZjZTE3OTE3MGQ4OGJhMWYwZDVhNTEyZTEzYWViMjMyZjE5Y2ZlZWMwYTg4ZjhiZlwiO1xuICBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDJbXCJURVNUTkVUX1NFUE9MSUFcIl0gPSBcIjB4NjBCOTRmRURlNTI1ZjgxNUFFNUU4Mzc3QTQ2M2UxMjFDNzg3Y0NDZjNhMzYzNThBYTlCMThjMTJjNEQ1NjZcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0Mjtcbn0pKFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHgwN2QxNGRmZDhlZTk1YjQxZmNlMTc5MTcwZDg4YmExZjBkNWE1MTJlMTNhZWIyMzJmMTljZmVlYzBhODhmOGJmXCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gXCIweDYwQjk0ZkVEZTUyNWY4MTVBRTVFODM3N0E0NjNlMTIxQzc4N2NDQ2YzYTM2MzU4QWE5QjE4YzEyYzRENTY2XCIgLyogVEVTVE5FVF9TRVBPTElBICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCB2ZXJpZmllciBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRQZnBDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRQZnBDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZFBmcENvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDcwYWFhMjBlYzRhNDZkYTU3YzkzMmQ5ZmQ4OWNhNWU2YmI5Y2EzMTg4ZDNkZjM2MWEzMjMwNmFmZjdkNTljN1wiO1xuICBTdGFya25ldElkUGZwQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDllN2JkYjhkYWJkMDJlYThjZmMyM2IxZDFjNTI3OGU0NjQ5MGYxOTNmODc1MTZlZDVmZjJkZmVjMDJcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRQZnBDb250cmFjdDI7XG59KShTdGFya25ldElkUGZwQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZFBmcENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHgwNzBhYWEyMGVjNGE0NmRhNTdjOTMyZDlmZDg5Y2E1ZTZiYjljYTMxODhkM2RmMzYxYTMyMzA2YWZmN2Q1OWM3XCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gXCIweDllN2JkYjhkYWJkMDJlYThjZmMyM2IxZDFjNTI3OGU0NjQ5MGYxOTNmODc1MTZlZDVmZjJkZmVjMDJcIiAvKiBURVNUTkVUX1NFUE9MSUEgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJTdGFya25ldC5pZCBwcm9maWxlIHBpY3R1cmUgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIlxuICAgICAgKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRQb3BDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRQb3BDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZFBvcENvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDI5M2ViMmJhOTg2MmY3NjJiZDMwMzY1ODZkNTc1NWE3ODJiZDIyZTZmNTAyODMyMGYxZDA0MDVmZDQ3YmZmNFwiO1xuICBTdGFya25ldElkUG9wQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDE1YWU4OGFlMDU0Y2FhNzQwOTBiODkwMjVjMTU5NTY4M2YxMmVkZjdhNGVkMmFkMDI3NGRlM2UxZDRhXCI7XG4gIHJldHVybiBTdGFya25ldElkUG9wQ29udHJhY3QyO1xufSkoU3RhcmtuZXRJZFBvcENvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRQb3BDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDI5M2ViMmJhOTg2MmY3NjJiZDMwMzY1ODZkNTc1NWE3ODJiZDIyZTZmNTAyODMyMGYxZDA0MDVmZDQ3YmZmNFwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFwiMHgxNWFlODhhZTA1NGNhYTc0MDkwYjg5MDI1YzE1OTU2ODNmMTJlZGY3YTRlZDJhZDAyNzRkZTNlMWQ0YVwiIC8qIFRFU1RORVRfU0VQT0xJQSAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlN0YXJrbmV0LmlkIHByb29mIG9mIHBlcnNvbmhvb2QgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIlxuICAgICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0aW9uKHN0YXRpY0V4LCBpZkVxdWFsID0gdm9pZCAwLCBpZk5vdEVxdWFsID0gdm9pZCAwKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBTdGF0aWM6IHN0YXRpY0V4LFxuICAgIElmRXF1YWw6IGlmRXF1YWwgPyB0dXBsZShpZkVxdWFsWzBdLCBpZkVxdWFsWzFdLCBpZkVxdWFsWzJdKSA6IHZvaWQgMCxcbiAgICBJZk5vdEVxdWFsOiBpZk5vdEVxdWFsID8gdHVwbGUoaWZOb3RFcXVhbFswXSwgaWZOb3RFcXVhbFsxXSwgaWZOb3RFcXVhbFsyXSkgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkeW5hbWljRmVsdChoYXJkY29kZWQsIHJlZmVyZW5jZSA9IHZvaWQgMCkge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgSGFyZGNvZGVkOiBoYXJkY29kZWQsXG4gICAgUmVmZXJlbmNlOiByZWZlcmVuY2UgPyB0dXBsZShyZWZlcmVuY2VbMF0sIHJlZmVyZW5jZVsxXSkgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkeW5hbWljQ2FsbERhdGEoaGFyZGNvZGVkLCByZWZlcmVuY2UgPSB2b2lkIDAsIGFycmF5UmVmZXJlbmNlID0gdm9pZCAwKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBIYXJkY29kZWQ6IGhhcmRjb2RlZCxcbiAgICBSZWZlcmVuY2U6IHJlZmVyZW5jZSA/IHR1cGxlKHJlZmVyZW5jZVswXSwgcmVmZXJlbmNlWzFdKSA6IHZvaWQgMCxcbiAgICBBcnJheVJlZmVyZW5jZTogYXJyYXlSZWZlcmVuY2UgPyB0dXBsZShhcnJheVJlZmVyZW5jZVswXSwgYXJyYXlSZWZlcmVuY2VbMV0pIDogdm9pZCAwXG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9zdGFya25ldElkLnRzXG52YXIgU3RhcmtuZXRJZCA9IGNsYXNzIF9TdGFya25ldElkIHtcbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gX1N0YXJrbmV0SWQuZ2V0U3RhcmtOYW1lKFxuICAgICAgLy8gQWZ0ZXIgTWl4aW4sIHRoaXMgaXMgUHJvdmlkZXJJbnRlcmZhY2VcbiAgICAgIHRoaXMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgU3RhcmtuZXRJZENvbnRyYWN0MlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBfU3RhcmtuZXRJZC5nZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShcbiAgICAgIC8vIEFmdGVyIE1peGluLCB0aGlzIGlzIFByb3ZpZGVySW50ZXJmYWNlXG4gICAgICB0aGlzLFxuICAgICAgbmFtZSxcbiAgICAgIFN0YXJrbmV0SWRDb250cmFjdDJcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrUHJvZmlsZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyLCBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIsIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MiwgU3RhcmtuZXRJZFBmcENvbnRyYWN0MiwgU3RhcmtuZXRJZFBvcENvbnRyYWN0MiwgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0Mikge1xuICAgIHJldHVybiBfU3RhcmtuZXRJZC5nZXRTdGFya1Byb2ZpbGUoXG4gICAgICAvLyBBZnRlciBNaXhpbiwgdGhpcyBpcyBQcm92aWRlckludGVyZmFjZVxuICAgICAgdGhpcyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBTdGFya25ldElkQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZFBmcENvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRQb3BDb250cmFjdDIsXG4gICAgICBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QyXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3RhcmtOYW1lKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZXhEb21haW4gPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgICBlbnRyeXBvaW50OiBcImFkZHJlc3NfdG9fZG9tYWluXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGhpbnQ6IFtdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlY2ltYWxEb21haW4gPSBoZXhEb21haW4ubWFwKChlbGVtZW50KSA9PiBCaWdJbnQoZWxlbWVudCkpLnNsaWNlKDEpO1xuICAgICAgY29uc3Qgc3RyaW5nRG9tYWluID0gdXNlRGVjb2RlZChkZWNpbWFsRG9tYWluKTtcbiAgICAgIGlmICghc3RyaW5nRG9tYWluKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmdEb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UgPT09IFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgc3RhcmsgbmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHByb3ZpZGVyLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNvZGVkRG9tYWluID0gbmFtZS5yZXBsYWNlKFwiLnN0YXJrXCIsIFwiXCIpLnNwbGl0KFwiLlwiKS5tYXAoKHBhcnQpID0+IHVzZUVuY29kZWQocGFydCkudG9TdHJpbmcoMTApKTtcbiAgICAgIGNvbnN0IGFkZHJlc3NEYXRhID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgICAgZW50cnlwb2ludDogXCJkb21haW5fdG9fYWRkcmVzc1wiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7IGRvbWFpbjogZW5jb2RlZERvbWFpbiwgaGludDogW10gfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFkZHJlc3NEYXRhWzBdO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGFkZHJlc3MgZnJvbSBzdGFyayBuYW1lXCIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3RhcmtQcm9maWxlKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyLCBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIsIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MiwgU3RhcmtuZXRJZFBmcENvbnRyYWN0MiwgU3RhcmtuZXRJZFBvcENvbnRyYWN0MiwgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0Mikge1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCBpZGVudGl0eUNvbnRyYWN0ID0gU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IHZlcmlmaWVyQ29udHJhY3QgPSBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgcGZwQ29udHJhY3QgPSBTdGFya25ldElkUGZwQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRQZnBDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCBwb3BDb250cmFjdCA9IFN0YXJrbmV0SWRQb3BDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZFBvcENvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IG11bHRpY2FsbEFkZHJlc3MgPSBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdChjaGFpbklkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FsbHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNDYWxsRGF0YShjb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNDYWxsRGF0YShnZXRTZWxlY3RvckZyb21OYW1lKFwiYWRkcmVzc190b19kb21haW5cIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbZHluYW1pY0NhbGxEYXRhKGFkZHJlc3MpLCBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChjb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJkb21haW5fdG9faWRcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgdm9pZCAwLCBbMCwgMF0pXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcInR3aXR0ZXJcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZlcmlmaWVyQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJnaXRodWJcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZlcmlmaWVyQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJkaXNjb3JkXCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2ZXJpZmllckNvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwicHJvb2Zfb2ZfcGVyc29uaG9vZFwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEocG9wQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gUEZQXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwibmZ0X3BwX2NvbnRyYWN0XCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShwZnBDb250cmFjdCksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF9leHRlbmRlZF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcIm5mdF9wcF9pZFwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIyXCIpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHBmcENvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih2b2lkIDAsIHZvaWQgMCwgWzYsIDAsIDBdKSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQodm9pZCAwLCBbNiwgMF0pLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwidG9rZW5VUklcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzcsIDFdKSwgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzcsIDJdKV1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IG11bHRpY2FsbEFkZHJlc3MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiYWdncmVnYXRlXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBjYWxsc1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQoZGF0YVswXSwgMTYpO1xuICAgICAgICBjb25zdCBmaW5hbEFycmF5ID0gW107XG4gICAgICAgIGxldCBpbmRleCA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkFycmF5U2l6ZSA9IHBhcnNlSW50KGRhdGFbaW5kZXhdLCAxNik7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgY29uc3Qgc3ViQXJyYXkgPSBkYXRhLnNsaWNlKGluZGV4LCBpbmRleCArIHN1YkFycmF5U2l6ZSk7XG4gICAgICAgICAgICBmaW5hbEFycmF5LnB1c2goc3ViQXJyYXkpO1xuICAgICAgICAgICAgaW5kZXggKz0gc3ViQXJyYXlTaXplO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHVzZURlY29kZWQoZmluYWxBcnJheVswXS5zbGljZSgxKS5tYXAoKGhleFN0cmluZykgPT4gQmlnSW50KGhleFN0cmluZykpKTtcbiAgICAgICAgY29uc3QgdHdpdHRlciA9IGZpbmFsQXJyYXlbMl1bMF0gIT09IFwiMHgwXCIgPyBCaWdJbnQoZmluYWxBcnJheVsyXVswXSkudG9TdHJpbmcoKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZ2l0aHViID0gZmluYWxBcnJheVszXVswXSAhPT0gXCIweDBcIiA/IEJpZ0ludChmaW5hbEFycmF5WzNdWzBdKS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBkaXNjb3JkID0gZmluYWxBcnJheVs0XVswXSAhPT0gXCIweDBcIiA/IEJpZ0ludChmaW5hbEFycmF5WzRdWzBdKS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBwcm9vZk9mUGVyc29uaG9vZCA9IGZpbmFsQXJyYXlbNV1bMF0gPT09IFwiMHgxXCI7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVQaWN0dXJlTWV0YWRhdGEgPSBkYXRhWzBdID09PSBcIjB4OVwiID8gZmluYWxBcnJheVs4XS5zbGljZSgxKS5tYXAoKHZhbCkgPT4gZGVjb2RlU2hvcnRTdHJpbmcodmFsKSkuam9pbihcIlwiKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcHJvZmlsZVBpY3R1cmUgPSBwcm9maWxlUGljdHVyZU1ldGFkYXRhIHx8IGBodHRwczovL3N0YXJrbmV0LmlkL2FwaS9pZGVudGljb25zLyR7QmlnSW50KGZpbmFsQXJyYXlbMV1bMF0pLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHR3aXR0ZXIsXG4gICAgICAgICAgZ2l0aHViLFxuICAgICAgICAgIGRpc2NvcmQsXG4gICAgICAgICAgcHJvb2ZPZlBlcnNvbmhvb2QsXG4gICAgICAgICAgcHJvZmlsZVBpY3R1cmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiRXJyb3Igd2hpbGUgY2FsbGluZyBhZ2dyZWdhdGUgZnVuY3Rpb25cIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHVzZXIgc3RhcmsgcHJvZmlsZSBkYXRhIGZyb20gYWRkcmVzc1wiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9leHRlbnNpb25zL2RlZmF1bHQudHNcbnZhciBScGNQcm92aWRlcjIgPSBjbGFzcyBleHRlbmRzIE1peGluKFJwY1Byb3ZpZGVyLCBTdGFya25ldElkKSB7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW50ZXJmYWNlLnRzXG52YXIgUHJvdmlkZXJJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW5kZXgudHNcbnZhciBkZWZhdWx0UHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIoeyBkZWZhdWx0OiB0cnVlIH0pO1xuXG4vLyBzcmMvc2lnbmVyL2ludGVyZmFjZS50c1xudmFyIFNpZ25lckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciB0eXBlZERhdGFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZWREYXRhX2V4cG9ydHMsIHtcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBlbmNvZGVEYXRhOiAoKSA9PiBlbmNvZGVEYXRhLFxuICBlbmNvZGVUeXBlOiAoKSA9PiBlbmNvZGVUeXBlLFxuICBlbmNvZGVWYWx1ZTogKCkgPT4gZW5jb2RlVmFsdWUsXG4gIGdldERlcGVuZGVuY2llczogKCkgPT4gZ2V0RGVwZW5kZW5jaWVzLFxuICBnZXRNZXNzYWdlSGFzaDogKCkgPT4gZ2V0TWVzc2FnZUhhc2gsXG4gIGdldFN0cnVjdEhhc2g6ICgpID0+IGdldFN0cnVjdEhhc2gsXG4gIGdldFR5cGVIYXNoOiAoKSA9PiBnZXRUeXBlSGFzaCxcbiAgaXNNZXJrbGVUcmVlVHlwZTogKCkgPT4gaXNNZXJrbGVUcmVlVHlwZSxcbiAgcHJlcGFyZVNlbGVjdG9yOiAoKSA9PiBwcmVwYXJlU2VsZWN0b3Jcbn0pO1xuXG4vLyBzcmMvdXRpbHMvbWVya2xlLnRzXG52YXIgbWVya2xlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1lcmtsZV9leHBvcnRzLCB7XG4gIE1lcmtsZVRyZWU6ICgpID0+IE1lcmtsZVRyZWUsXG4gIHByb29mTWVya2xlUGF0aDogKCkgPT4gcHJvb2ZNZXJrbGVQYXRoXG59KTtcbnZhciBNZXJrbGVUcmVlID0gY2xhc3MgX01lcmtsZVRyZWUge1xuICBsZWF2ZXM7XG4gIGJyYW5jaGVzID0gW107XG4gIHJvb3Q7XG4gIGhhc2hNZXRob2Q7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBNZXJrbGUgdHJlZVxuICAgKlxuICAgKiBAcGFyYW0gbGVhZkhhc2hlcyBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoTWV0aG9kIGhhc2ggbWV0aG9kIHRvIHVzZSwgZGVmYXVsdDogUGVkZXJzZW5cbiAgICogQHJldHVybnMgY3JlYXRlZCBNZXJrbGUgdHJlZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGxlYXZlcyA9IFsnMHgxJywgJzB4MicsICcweDMnLCAnMHg0JywgJzB4NScsICcweDYnLCAnMHg3J107XG4gICAqIGNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShsZWF2ZXMpO1xuICAgKiAvLyB0cmVlID0ge1xuICAgKiAvLyAgIGJyYW5jaGVzOiBbWycweDViYjk0NDBlMi4uLicsICcweDI2MjY5N2I4OC4uLicsIC4uLl0sIFsnMHgzODExOGEzNDAuLi4nLCAuLi5dLCAuLi5dLFxuICAgKiAvLyAgIGxlYXZlczogWycweDEnLCAnMHgyJywgJzB4MycsICcweDQnLCAnMHg1JywgJzB4NicsICcweDcnXSxcbiAgICogLy8gICByb290OiAnMHg3Zjc0OGM3NWU1YmRiN2FlMjgwMTNmMDc2YjhhYjY1MGM0ZTAxZDM1MzBjNmU1YWI2NjVmOWYxYWNjYmU3ZDQnLFxuICAgKiAvLyAgIGhhc2hNZXRob2Q6IFtGdW5jdGlvbiBjb21wdXRlUGVkZXJzZW5IYXNoXSxcbiAgICogLy8gfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlYWZIYXNoZXMsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gICAgdGhpcy5oYXNoTWV0aG9kID0gaGFzaE1ldGhvZDtcbiAgICB0aGlzLmxlYXZlcyA9IGxlYWZIYXNoZXM7XG4gICAgdGhpcy5yb290ID0gdGhpcy5idWlsZChsZWFmSGFzaGVzKTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBidWlsZChsZWF2ZXMpIHtcbiAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGxlYXZlc1swXTtcbiAgICB9XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggIT09IHRoaXMubGVhdmVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5icmFuY2hlcy5wdXNoKGxlYXZlcyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0xlYXZlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoaSArIDEgPT09IGxlYXZlcy5sZW5ndGgpIHtcbiAgICAgICAgbmV3TGVhdmVzLnB1c2goX01lcmtsZVRyZWUuaGFzaChsZWF2ZXNbaV0sIFwiMHgwXCIsIHRoaXMuaGFzaE1ldGhvZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TGVhdmVzLnB1c2goX01lcmtsZVRyZWUuaGFzaChsZWF2ZXNbaV0sIGxlYXZlc1tpICsgMV0sIHRoaXMuaGFzaE1ldGhvZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5idWlsZChuZXdMZWF2ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgaGFzaCBmcm9tIG9yZGVyZWQgYSBhbmQgYiwgUGVkZXJzZW4gaGFzaCBkZWZhdWx0XG4gICAqXG4gICAqIEBwYXJhbSBhIGZpcnN0IHZhbHVlXG4gICAqIEBwYXJhbSBiIHNlY29uZCB2YWx1ZVxuICAgKiBAcGFyYW0gaGFzaE1ldGhvZCBoYXNoIG1ldGhvZCB0byB1c2UsIGRlZmF1bHQ6IFBlZGVyc2VuXG4gICAqIEByZXR1cm5zIHJlc3VsdCBvZiB0aGUgaGFzaCBmdW5jdGlvblxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdDEgPSBNZXJrbGVUcmVlLmhhc2goJzB4YWJjJywgJzB4ZGVmJyk7XG4gICAqIC8vIHJlc3VsdDEgPSAnMHg0ODRmMDI5ZGE3OTE0YWRhMDM4YjFhZGY2N2ZjODM2MzIzNjRhM2ViYzJjZDkzNDliNDFhYjYxNjI2ZDllODInXG4gICAqXG4gICAqIGNvbnN0IGN1c3RvbUhhc2hNZXRob2QgPSAoYSwgYikgPT4gYGN1c3RvbV8ke2F9XyR7Yn1gO1xuICAgKiBjb25zdCByZXN1bHQyID0gTWVya2xlVHJlZS5oYXNoKCcweGFiYycsICcweGRlZicsIGN1c3RvbUhhc2hNZXRob2QpO1xuICAgKiAvLyByZXN1bHQyID0gJ2N1c3RvbV8yNzQ4XzM1NjcnXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGhhc2goYSwgYiwgaGFzaE1ldGhvZCA9IGNvbXB1dGVQZWRlcnNlbkhhc2gpIHtcbiAgICBjb25zdCBbYVNvcnRlZCwgYlNvcnRlZF0gPSBbQmlnSW50KGEpLCBCaWdJbnQoYildLnNvcnQoKHgsIHkpID0+IHggPj0geSA/IDEgOiAtMSk7XG4gICAgcmV0dXJuIGhhc2hNZXRob2QoYVNvcnRlZCwgYlNvcnRlZCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1lcmtsZSBtZW1iZXJzaGlwIHByb29mIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIGxlYWYgaGV4LXN0cmluZ1xuICAgKiBAcGFyYW0gYnJhbmNoIGhleC1zdHJpbmcgYXJyYXlcbiAgICogQHBhcmFtIGhhc2hQYXRoIGhleC1zdHJpbmcgYXJyYXlcbiAgICogQHJldHVybnMgY29sbGVjdGlvbiBvZiBtZXJrbGUgcHJvb2YgaGV4LXN0cmluZyBoYXNoZXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBsZWF2ZXMgPSBbJzB4MScsICcweDInLCAnMHgzJywgJzB4NCcsICcweDUnLCAnMHg2JywgJzB4NyddO1xuICAgKiBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzKTtcbiAgICogY29uc3QgcmVzdWx0ID0gdHJlZS5nZXRQcm9vZignMHgzJyk7XG4gICAqIC8vIHJlc3VsdCA9IFtcbiAgICogLy8gICAnMHg0JyxcbiAgICogLy8gICAnMHg1YmI5NDQwZTI3ODg5YTM2NGJjYjY3OGIxZjY3OWVjZDEzNDdhY2RlZGNiZjM2ZTgzNDk0Zjg1N2NjNTgwMjYnLFxuICAgKiAvLyAgICcweDhjMGU0NmRkMmRmOWFhZjNhOGViZmJjMjU0MDhhNTgyYWQ3ZmE3MTcxZjA2OThkZGJiYzUxMzBiNGI0ZTYwJyxcbiAgICogLy8gXVxuICAgKiBgYGBcbiAgICovXG4gIGdldFByb29mKGxlYWYsIGJyYW5jaCA9IHRoaXMubGVhdmVzLCBoYXNoUGF0aCA9IFtdKSB7XG4gICAgY29uc3QgaW5kZXggPSBicmFuY2guaW5kZXhPZihsZWFmKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWFmIG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgaWYgKGJyYW5jaC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBoYXNoUGF0aDtcbiAgICB9XG4gICAgY29uc3QgaXNMZWZ0ID0gaW5kZXggJSAyID09PSAwO1xuICAgIGNvbnN0IG5lZWRlZEJyYW5jaCA9IChpc0xlZnQgPyBicmFuY2hbaW5kZXggKyAxXSA6IGJyYW5jaFtpbmRleCAtIDFdKSA/PyBcIjB4MFwiO1xuICAgIGNvbnN0IG5ld0hhc2hQYXRoID0gWy4uLmhhc2hQYXRoLCBuZWVkZWRCcmFuY2hdO1xuICAgIGNvbnN0IGN1cnJlbnRCcmFuY2hMZXZlbEluZGV4ID0gdGhpcy5sZWF2ZXMubGVuZ3RoID09PSBicmFuY2gubGVuZ3RoID8gLTEgOiB0aGlzLmJyYW5jaGVzLmZpbmRJbmRleCgoYikgPT4gYi5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGgpO1xuICAgIGNvbnN0IG5leHRCcmFuY2ggPSB0aGlzLmJyYW5jaGVzW2N1cnJlbnRCcmFuY2hMZXZlbEluZGV4ICsgMV0gPz8gW3RoaXMucm9vdF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2YoXG4gICAgICBfTWVya2xlVHJlZS5oYXNoKGlzTGVmdCA/IGxlYWYgOiBuZWVkZWRCcmFuY2gsIGlzTGVmdCA/IG5lZWRlZEJyYW5jaCA6IGxlYWYsIHRoaXMuaGFzaE1ldGhvZCksXG4gICAgICBuZXh0QnJhbmNoLFxuICAgICAgbmV3SGFzaFBhdGhcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIGxlYWYsIHBhdGgsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByb290ID09PSBsZWFmO1xuICB9XG4gIGNvbnN0IFtuZXh0LCAuLi5yZXN0XSA9IHBhdGg7XG4gIHJldHVybiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgTWVya2xlVHJlZS5oYXNoKGxlYWYsIG5leHQsIGhhc2hNZXRob2QpLCByZXN0LCBoYXNoTWV0aG9kKTtcbn1cblxuLy8gc3JjL3V0aWxzL3R5cGVkRGF0YS50c1xudmFyIHByZXNldFR5cGVzID0ge1xuICB1MjU2OiBKU09OLnBhcnNlKCdbeyBcIm5hbWVcIjogXCJsb3dcIiwgXCJ0eXBlXCI6IFwidTEyOFwiIH0sIHsgXCJuYW1lXCI6IFwiaGlnaFwiLCBcInR5cGVcIjogXCJ1MTI4XCIgfV0nKSxcbiAgVG9rZW5BbW91bnQ6IEpTT04ucGFyc2UoXG4gICAgJ1t7IFwibmFtZVwiOiBcInRva2VuX2FkZHJlc3NcIiwgXCJ0eXBlXCI6IFwiQ29udHJhY3RBZGRyZXNzXCIgfSwgeyBcIm5hbWVcIjogXCJhbW91bnRcIiwgXCJ0eXBlXCI6IFwidTI1NlwiIH1dJ1xuICApLFxuICBOZnRJZDogSlNPTi5wYXJzZShcbiAgICAnW3sgXCJuYW1lXCI6IFwiY29sbGVjdGlvbl9hZGRyZXNzXCIsIFwidHlwZVwiOiBcIkNvbnRyYWN0QWRkcmVzc1wiIH0sIHsgXCJuYW1lXCI6IFwidG9rZW5faWRcIiwgXCJ0eXBlXCI6IFwidTI1NlwiIH1dJ1xuICApXG59O1xudmFyIHJldmlzaW9uQ29uZmlndXJhdGlvbiA9IHtcbiAgW1R5cGVkRGF0YVJldmlzaW9uLkFDVElWRV06IHtcbiAgICBkb21haW46IFwiU3RhcmtuZXREb21haW5cIixcbiAgICBoYXNoTWV0aG9kOiBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50cyxcbiAgICBoYXNoTWVya2xlTWV0aG9kOiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICAgIGVzY2FwZVR5cGVTdHJpbmc6IChzKSA9PiBgXCIke3N9XCJgLFxuICAgIHByZXNldFR5cGVzXG4gIH0sXG4gIFtUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1ldOiB7XG4gICAgZG9tYWluOiBcIlN0YXJrTmV0RG9tYWluXCIsXG4gICAgaGFzaE1ldGhvZDogY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHMsXG4gICAgaGFzaE1lcmtsZU1ldGhvZDogY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgICBlc2NhcGVUeXBlU3RyaW5nOiAocykgPT4gcyxcbiAgICBwcmVzZXRUeXBlczoge31cbiAgfVxufTtcbmZ1bmN0aW9uIGFzc2VydFJhbmdlKGRhdGEsIHR5cGUsIHsgbWluLCBtYXggfSkge1xuICBjb25zdCB2YWx1ZSA9IEJpZ0ludChkYXRhKTtcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXgsIGAke3ZhbHVlfSAoJHt0eXBlfSkgaXMgb3V0IG9mIGJvdW5kcyBbJHttaW59LCAke21heH1dYCk7XG59XG5mdW5jdGlvbiBpZGVudGlmeVJldmlzaW9uKHsgdHlwZXMsIGRvbWFpbiB9KSB7XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFXS5kb21haW4gaW4gdHlwZXMgJiYgZG9tYWluLnJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpXG4gICAgcmV0dXJuIFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRTtcbiAgaWYgKHJldmlzaW9uQ29uZmlndXJhdGlvbltUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1ldLmRvbWFpbiBpbiB0eXBlcyAmJiAoZG9tYWluLnJldmlzaW9uID8/IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkgPT09IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSlcbiAgICByZXR1cm4gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZO1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0SGV4KHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRvSGV4KHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b0hleChlbmNvZGVTaG9ydFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmlnTnVtYmVyaXNoOiAke3ZhbHVlfWApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVkRGF0YShkYXRhKSB7XG4gIGNvbnN0IHR5cGVkRGF0YSA9IGRhdGE7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHR5cGVkRGF0YS5tZXNzYWdlICYmIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSAmJiB0eXBlZERhdGEudHlwZXMgJiYgaWRlbnRpZnlSZXZpc2lvbih0eXBlZERhdGEpXG4gICk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGlzSGV4KHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogZ2V0U2VsZWN0b3JGcm9tTmFtZShzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBpc01lcmtsZVRyZWVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA9PT0gXCJtZXJrbGV0cmVlXCI7XG59XG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXModHlwZXMsIHR5cGUsIGRlcGVuZGVuY2llcyA9IFtdLCBjb250YWlucyA9IFwiXCIsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09IFwiKlwiKSB7XG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgLTEpO1xuICB9IGVsc2UgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJlbnVtXCIpIHtcbiAgICAgIHR5cGUgPSBjb250YWlucztcbiAgICB9IGVsc2UgaWYgKHR5cGUubWF0Y2goL15cXCguKlxcKSQvKSkge1xuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHR5cGUpIHx8ICF0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIC4uLnR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAgIChwcmV2aW91cywgdCkgPT4gW1xuICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgLi4uZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0LnR5cGUsIHByZXZpb3VzLCB0LmNvbnRhaW5zLCByZXZpc2lvbikuZmlsdGVyKFxuICAgICAgICAgIChkZXBlbmRlbmN5KSA9PiAhcHJldmlvdXMuaW5jbHVkZXMoZGVwZW5kZW5jeSlcbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIFtdXG4gICAgKVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCkge1xuICBpZiAoY3R4LnBhcmVudCAmJiBjdHgua2V5KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdO1xuICAgIGNvbnN0IG1lcmtsZVR5cGUgPSBwYXJlbnRUeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgY29uc3QgaXNNZXJrbGVUcmVlID0gaXNNZXJrbGVUcmVlVHlwZShtZXJrbGVUeXBlKTtcbiAgICBpZiAoIWlzTWVya2xlVHJlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2N0eC5rZXl9IGlzIG5vdCBhIG1lcmtsZSB0cmVlYCk7XG4gICAgfVxuICAgIGlmIChtZXJrbGVUeXBlLmNvbnRhaW5zLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXJrbGUgdHJlZSBjb250YWluIHByb3BlcnR5IG11c3Qgbm90IGJlIGFuIGFycmF5IGJ1dCB3YXMgZ2l2ZW4gJHtjdHgua2V5fWApO1xuICAgIH1cbiAgICByZXR1cm4gbWVya2xlVHlwZS5jb250YWlucztcbiAgfVxuICByZXR1cm4gXCJyYXdcIjtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUodHlwZXMsIHR5cGUsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGNvbnN0IGFsbFR5cGVzID0gcmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSA/IHsgLi4udHlwZXMsIC4uLnJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXMgfSA6IHR5cGVzO1xuICBjb25zdCBbcHJpbWFyeSwgLi4uZGVwZW5kZW5jaWVzXSA9IGdldERlcGVuZGVuY2llcyhcbiAgICBhbGxUeXBlcyxcbiAgICB0eXBlLFxuICAgIHZvaWQgMCxcbiAgICB2b2lkIDAsXG4gICAgcmV2aXNpb25cbiAgKTtcbiAgY29uc3QgbmV3VHlwZXMgPSAhcHJpbWFyeSA/IFtdIDogW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llcy5zb3J0KCldO1xuICBjb25zdCBlc2MgPSByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmVzY2FwZVR5cGVTdHJpbmc7XG4gIHJldHVybiBuZXdUeXBlcy5tYXAoKGRlcGVuZGVuY3kpID0+IHtcbiAgICBjb25zdCBkZXBlbmRlbmN5RWxlbWVudHMgPSBhbGxUeXBlc1tkZXBlbmRlbmN5XS5tYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSB0LnR5cGUgPT09IFwiZW51bVwiICYmIHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUgPyB0LmNvbnRhaW5zIDogdC50eXBlO1xuICAgICAgY29uc3QgdHlwZVN0cmluZyA9IHRhcmdldFR5cGUubWF0Y2goL15cXCguKlxcKSQvKSA/IGAoJHt0YXJnZXRUeXBlLnNsaWNlKDEsIC0xKS5zcGxpdChcIixcIikubWFwKChlKSA9PiBlID8gZXNjKGUpIDogZSkuam9pbihcIixcIil9KWAgOiBlc2ModGFyZ2V0VHlwZSk7XG4gICAgICByZXR1cm4gYCR7ZXNjKHQubmFtZSl9OiR7dHlwZVN0cmluZ31gO1xuICAgIH0pO1xuICAgIHJldHVybiBgJHtlc2MoZGVwZW5kZW5jeSl9KCR7ZGVwZW5kZW5jeUVsZW1lbnRzfSlgO1xuICB9KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUhhc2godHlwZXMsIHR5cGUsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIHJldHVybiBnZXRTZWxlY3RvckZyb21OYW1lKGVuY29kZVR5cGUodHlwZXMsIHR5cGUsIHJldmlzaW9uKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVWYWx1ZSh0eXBlcywgdHlwZSwgZGF0YSwgY3R4ID0ge30sIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGlmICh0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBbdHlwZSwgZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24pXTtcbiAgfVxuICBpZiAocmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBbXG4gICAgICB0eXBlLFxuICAgICAgZ2V0U3RydWN0SGFzaChcbiAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcmV2aXNpb25cbiAgICAgIClcbiAgICBdO1xuICB9XG4gIGlmICh0eXBlLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIGNvbnN0IGhhc2hlcyA9IGRhdGEubWFwKFxuICAgICAgKGVudHJ5KSA9PiBlbmNvZGVWYWx1ZSh0eXBlcywgdHlwZS5zbGljZSgwLCAtMSksIGVudHJ5LCB2b2lkIDAsIHJldmlzaW9uKVsxXVxuICAgICk7XG4gICAgcmV0dXJuIFt0eXBlLCByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoaGFzaGVzKV07XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImVudW1cIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgY29uc3QgW3ZhcmlhbnRLZXksIHZhcmlhbnREYXRhXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpWzBdO1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gdHlwZXNbY3R4LnBhcmVudF1bMF07XG4gICAgICAgIGNvbnN0IGVudW1UeXBlID0gdHlwZXNbcGFyZW50VHlwZS5jb250YWluc107XG4gICAgICAgIGNvbnN0IHZhcmlhbnRUeXBlID0gZW51bVR5cGUuZmluZCgodCkgPT4gdC5uYW1lID09PSB2YXJpYW50S2V5KTtcbiAgICAgICAgY29uc3QgdmFyaWFudEluZGV4ID0gZW51bVR5cGUuaW5kZXhPZih2YXJpYW50VHlwZSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRTdWJ0eXBlcyA9IHZhcmlhbnRUeXBlLnR5cGUuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoKHN1YnR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJ0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG4gICAgICAgICAgY29uc3Qgc3VidHlwZURhdGEgPSB2YXJpYW50RGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBzdWJ0eXBlLCBzdWJ0eXBlRGF0YSwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKFt2YXJpYW50SW5kZXgsIC4uLmVuY29kZWRTdWJ0eXBlc10pXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJtZXJrbGV0cmVlXCI6IHtcbiAgICAgIGNvbnN0IG1lcmtsZVRyZWVUeXBlID0gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCk7XG4gICAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVWYWx1ZSh0eXBlcywgbWVya2xlVHJlZVR5cGUsIHN0cnVjdCwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgcm9vdCB9ID0gbmV3IE1lcmtsZVRyZWUoXG4gICAgICAgIHN0cnVjdEhhc2hlcyxcbiAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWVya2xlTWV0aG9kXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtcImZlbHRcIiwgcm9vdF07XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3RvclwiOiB7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCBwcmVwYXJlU2VsZWN0b3IoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IGJ5dGVBcnJheUZyb21TdHJpbmcoZGF0YSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW1xuICAgICAgICAgIGJ5dGVBcnJheS5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5ieXRlQXJyYXkuZGF0YSxcbiAgICAgICAgICBieXRlQXJyYXkucGVuZGluZ193b3JkLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmRfbGVuXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBbdHlwZSwgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGVsZW1lbnRzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJpMTI4XCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KGRhdGEpO1xuICAgICAgICBhc3NlcnRSYW5nZSh2YWx1ZSwgdHlwZSwgUkFOR0VfSTEyOCk7XG4gICAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KHZhbHVlIDwgMG4gPyBQUklNRSArIHZhbHVlIDogdmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcInRpbWVzdGFtcFwiOlxuICAgIGNhc2UgXCJ1MTI4XCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGFzc2VydFJhbmdlKGRhdGEsIHR5cGUsIFJBTkdFX1UxMjgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiZmVsdFwiOlxuICAgIGNhc2UgXCJzaG9ydHN0cmluZ1wiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICBhc3NlcnRSYW5nZShnZXRIZXgoZGF0YSksIHR5cGUsIFJBTkdFX0ZFTFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiQ2xhc3NIYXNoXCI6XG4gICAgY2FzZSBcIkNvbnRyYWN0QWRkcmVzc1wiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICBhc3NlcnRSYW5nZShkYXRhLCB0eXBlLCBSQU5HRV9GRUxUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcImJvb2xcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIiwgYFR5cGUgbWlzbWF0Y2ggZm9yICR7dHlwZX0gJHtkYXRhfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGNvbnN0IHRhcmdldFR5cGUgPSB0eXBlc1t0eXBlXSA/PyByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzW3R5cGVdO1xuICBjb25zdCBbcmV0dXJuVHlwZXMsIHZhbHVlc10gPSB0YXJnZXRUeXBlLnJlZHVjZShcbiAgICAoW3RzLCB2c10sIGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZGF0YVtmaWVsZC5uYW1lXSA9PT0gdm9pZCAwIHx8IGRhdGFbZmllbGQubmFtZV0gPT09IG51bGwgJiYgZmllbGQudHlwZSAhPT0gXCJlbnVtXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZW5jb2RlIGRhdGE6IG1pc3NpbmcgZGF0YSBmb3IgJyR7ZmllbGQubmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICBjb25zdCBjdHggPSB7IHBhcmVudDogdHlwZSwga2V5OiBmaWVsZC5uYW1lIH07XG4gICAgICBjb25zdCBbdCwgZW5jb2RlZFZhbHVlXSA9IGVuY29kZVZhbHVlKHR5cGVzLCBmaWVsZC50eXBlLCB2YWx1ZSwgY3R4LCByZXZpc2lvbik7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4udHMsIHRdLFxuICAgICAgICBbLi4udnMsIGVuY29kZWRWYWx1ZV1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW1wiZmVsdFwiXSwgW2dldFR5cGVIYXNoKHR5cGVzLCB0eXBlLCByZXZpc2lvbildXVxuICApO1xuICByZXR1cm4gW3JldHVyblR5cGVzLCB2YWx1ZXNdO1xufVxuZnVuY3Rpb24gZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpIHtcbiAgcmV0dXJuIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uaGFzaE1ldGhvZChlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbilbMV0pO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50KSB7XG4gIGlmICghdmFsaWRhdGVUeXBlZERhdGEodHlwZWREYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVkIGRhdGEgZG9lcyBub3QgbWF0Y2ggSlNPTiBzY2hlbWFcIik7XG4gIH1cbiAgY29uc3QgcmV2aXNpb24gPSBpZGVudGlmeVJldmlzaW9uKHR5cGVkRGF0YSk7XG4gIGNvbnN0IHsgZG9tYWluLCBoYXNoTWV0aG9kIH0gPSByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dO1xuICBjb25zdCBtZXNzYWdlID0gW1xuICAgIGVuY29kZVNob3J0U3RyaW5nKFwiU3RhcmtOZXQgTWVzc2FnZVwiKSxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgZG9tYWluLCB0eXBlZERhdGEuZG9tYWluLCByZXZpc2lvbiksXG4gICAgYWNjb3VudCxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgdHlwZWREYXRhLnByaW1hcnlUeXBlLCB0eXBlZERhdGEubWVzc2FnZSwgcmV2aXNpb24pXG4gIF07XG4gIHJldHVybiBoYXNoTWV0aG9kKG1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvc2lnbmVyL2RlZmF1bHQudHNcbnZhciBTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICBjb25zdHJ1Y3RvcihwayA9IHN0YXJrQ3VydmUudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKSB7XG4gICAgdGhpcy5wayA9IHBrIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZjJoZXgocGspIDogdG9IZXgocGspO1xuICB9XG4gIGFzeW5jIGdldFB1YktleSgpIHtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5nZXRTdGFya0tleSh0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEodHJhbnNhY3Rpb25zLCBkZXRhaWxzLmNhaXJvVmVyc2lvbik7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25UcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbihkZXRhaWxzKSB7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduUmF3KG1zZ0hhc2gpIHtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVyL2V0aFNpZ25lci50c1xuaW1wb3J0IHsgc2VjcDI1NmsxIGFzIHNlY3AyNTZrMTIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcblxuLy8gc3JjL3V0aWxzL3VpbnQyNTYudHNcbnZhciB1aW50MjU2X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHVpbnQyNTZfZXhwb3J0cywge1xuICBVSU5UXzEyOF9NQVg6ICgpID0+IFVJTlRfMTI4X01BWCxcbiAgVUlOVF8yNTZfTUFYOiAoKSA9PiBVSU5UXzI1Nl9NQVgsXG4gIGJuVG9VaW50MjU2OiAoKSA9PiBiblRvVWludDI1NixcbiAgaXNVaW50MjU2OiAoKSA9PiBpc1VpbnQyNTYsXG4gIHVpbnQyNTZUb0JOOiAoKSA9PiB1aW50MjU2VG9CTlxufSk7XG5mdW5jdGlvbiB1aW50MjU2VG9CTih1aW50MjU2Mikge1xuICByZXR1cm4gbmV3IENhaXJvVWludDI1Nih1aW50MjU2MikudG9CaWdJbnQoKTtcbn1cbmZ1bmN0aW9uIGlzVWludDI1Nihibikge1xuICByZXR1cm4gQ2Fpcm9VaW50MjU2LmlzKGJuKTtcbn1cbmZ1bmN0aW9uIGJuVG9VaW50MjU2KGJuKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGJuKS50b1VpbnQyNTZIZXhTdHJpbmcoKTtcbn1cblxuLy8gc3JjL3NpZ25lci9ldGhTaWduZXIudHNcbnZhciBFdGhTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICAvLyBoZXggc3RyaW5nIHdpdGhvdXQgMHggYW5kIHdpdGggYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gIGNvbnN0cnVjdG9yKHBrID0gZXRoUmFuZG9tUHJpdmF0ZUtleSgpKSB7XG4gICAgdGhpcy5wayA9IHBrIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZjJoZXgocGspLnBhZFN0YXJ0KDY0LCBcIjBcIikgOiByZW1vdmVIZXhQcmVmaXgodG9IZXgocGspKS5wYWRTdGFydCg2NCwgXCIwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBwcm92aWRlcyB0aGUgRXRoZXJldW0gZnVsbCBwdWJsaWMga2V5ICh3aXRob3V0IHBhcml0eSBwcmVmaXgpXG4gICAqIEByZXR1cm5zIGFuIGhleCBzdHJpbmcgOiA2NCBmaXJzdCBjaGFyYWN0ZXJzIGFyZSBQb2ludCBYIGNvb3JkaW5hdGUuIDY0IGxhc3QgY2hhcmFjdGVycyBhcmUgUG9pbnQgWSBjb29yZGluYXRlLlxuICAgKi9cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoXG4gICAgICBidWYyaGV4KHNlY3AyNTZrMTIuZ2V0UHVibGljS2V5KHRoaXMucGssIGZhbHNlKSkucGFkU3RhcnQoMTMwLCBcIjBcIikuc2xpY2UoMilcbiAgICApO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgZGV0YWlscy5jYWlyb1ZlcnNpb24pO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMTIuc2lnbihcbiAgICAgIHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksXG4gICAgICB0aGlzLnBrXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRFdGhTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfVxuICBhc3luYyBzaWduRGVjbGFyZVRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEyLnNpZ24oXG4gICAgICByZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgobXNnSGFzaCkpLFxuICAgICAgdGhpcy5wa1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0RXRoU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgc2lnbmF0dXJlIGluIGNvbmZvcm1pdHkgd2l0aCBzdGFya25ldDo6ZXRoX3NpZ25hdHVyZTo6U2lnbmF0dXJlXG4gICAqIEBwYXJhbSBldGhTaWduYXR1cmUgc2VjcDI1NmsxIHNpZ25hdHVyZSBmcm9tIE5vYmxlIGN1cnZlcyBsaWJyYXJ5XG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgZmVsdHMsIHJlcHJlc2VudGluZyBhIENhaXJvIEV0aCBTaWduYXR1cmUuXG4gICAqL1xuICBmb3JtYXRFdGhTaWduYXR1cmUoZXRoU2lnbmF0dXJlKSB7XG4gICAgY29uc3QgciA9IGJuVG9VaW50MjU2KGV0aFNpZ25hdHVyZS5yKTtcbiAgICBjb25zdCBzID0gYm5Ub1VpbnQyNTYoZXRoU2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBbXG4gICAgICB0b0hleChyLmxvdyksXG4gICAgICB0b0hleChyLmhpZ2gpLFxuICAgICAgdG9IZXgocy5sb3cpLFxuICAgICAgdG9IZXgocy5oaWdoKSxcbiAgICAgIHRvSGV4KGV0aFNpZ25hdHVyZS5yZWNvdmVyeSlcbiAgICBdO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvZXZlbnRzL2luZGV4LnRzXG52YXIgZXZlbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV2ZW50c19leHBvcnRzLCB7XG4gIGdldEFiaUV2ZW50czogKCkgPT4gZ2V0QWJpRXZlbnRzLFxuICBpc0FiaUV2ZW50OiAoKSA9PiBpc0FiaUV2ZW50LFxuICBpc09iamVjdDogKCkgPT4gaXNPYmplY3QsXG4gIHBhcnNlRXZlbnRzOiAoKSA9PiBwYXJzZUV2ZW50cyxcbiAgcGFyc2VVRENFdmVudDogKCkgPT4gcGFyc2VVRENFdmVudFxufSk7XG5mdW5jdGlvbiBpc0FiaUV2ZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0LnR5cGUgPT09IFwiZXZlbnRcIjtcbn1cbmZ1bmN0aW9uIGdldENhaXJvMEFiaUV2ZW50cyhhYmkpIHtcbiAgcmV0dXJuIGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImV2ZW50XCIpLnJlZHVjZSgoYWNjLCBhYmlFbnRyeSkgPT4ge1xuICAgIGNvbnN0IGVudHJ5TmFtZSA9IGFiaUVudHJ5Lm5hbWU7XG4gICAgY29uc3QgYWJpRW50cnlNb2QgPSB7IC4uLmFiaUVudHJ5IH07XG4gICAgYWJpRW50cnlNb2QubmFtZSA9IGVudHJ5TmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShlbnRyeU5hbWUpKS50b1N0cmluZygxNikpXTogYWJpRW50cnlNb2RcbiAgICB9O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRDYWlybzFBYmlFdmVudHMoYWJpKSB7XG4gIGNvbnN0IGFiaUV2ZW50c1N0cnVjdHMgPSBhYmkuZmlsdGVyKChvYmopID0+IGlzQWJpRXZlbnQob2JqKSAmJiBvYmoua2luZCA9PT0gXCJzdHJ1Y3RcIik7XG4gIGNvbnN0IGFiaUV2ZW50c0VudW1zID0gYWJpLmZpbHRlcigob2JqKSA9PiBpc0FiaUV2ZW50KG9iaikgJiYgb2JqLmtpbmQgPT09IFwiZW51bVwiKTtcbiAgY29uc3QgYWJpRXZlbnRzRGF0YSA9IGFiaUV2ZW50c1N0cnVjdHMucmVkdWNlKChhY2MsIGV2ZW50KSA9PiB7XG4gICAgbGV0IG5hbWVMaXN0ID0gW107XG4gICAgbGV0IHsgbmFtZSB9ID0gZXZlbnQ7XG4gICAgbGV0IGZsYXQgPSBmYWxzZTtcbiAgICBjb25zdCBmaW5kTmFtZSA9ICh2YXJpYW50KSA9PiB2YXJpYW50LnR5cGUgPT09IG5hbWU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGV2ZW50RW51bSA9IGFiaUV2ZW50c0VudW1zLmZpbmQoKGV2ZW50RSkgPT4gZXZlbnRFLnZhcmlhbnRzLnNvbWUoZmluZE5hbWUpKTtcbiAgICAgIGlmICh0eXBlb2YgZXZlbnRFbnVtID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSBldmVudEVudW0udmFyaWFudHMuZmluZChmaW5kTmFtZSk7XG4gICAgICBuYW1lTGlzdC51bnNoaWZ0KHZhcmlhbnQubmFtZSk7XG4gICAgICBpZiAodmFyaWFudC5raW5kID09PSBcImZsYXRcIilcbiAgICAgICAgZmxhdCA9IHRydWU7XG4gICAgICBuYW1lID0gZXZlbnRFbnVtLm5hbWU7XG4gICAgfVxuICAgIGlmIChuYW1lTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVuY3kgaW4gQUJJIGV2ZW50cyBkZWZpbml0aW9uLlwiKTtcbiAgICB9XG4gICAgaWYgKGZsYXQpXG4gICAgICBuYW1lTGlzdCA9IFtuYW1lTGlzdFtuYW1lTGlzdC5sZW5ndGggLSAxXV07XG4gICAgY29uc3QgZmluYWwgPSBuYW1lTGlzdC5wb3AoKTtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShmaW5hbCkpLnRvU3RyaW5nKDE2KSldOiBldmVudFxuICAgIH07XG4gICAgd2hpbGUgKG5hbWVMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShuYW1lTGlzdC5wb3AoKSkpLnRvU3RyaW5nKDE2KSldOiByZXN1bHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJlc3VsdCA9IHsgLi4ucmVzdWx0IH07XG4gICAgcmV0dXJuIG1lcmdlQWJpRXZlbnRzKGFjYywgcmVzdWx0KTtcbiAgfSwge30pO1xuICByZXR1cm4gYWJpRXZlbnRzRGF0YTtcbn1cbmZ1bmN0aW9uIGdldEFiaUV2ZW50cyhhYmkpIHtcbiAgcmV0dXJuIGlzQ2Fpcm8xQWJpKGFiaSkgPyBnZXRDYWlybzFBYmlFdmVudHMoYWJpKSA6IGdldENhaXJvMEFiaUV2ZW50cyhhYmkpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpdGVtKTtcbn1cbmZ1bmN0aW9uIG1lcmdlQWJpRXZlbnRzKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XG4gIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSlcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlQWJpRXZlbnRzKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHByb3ZpZGVyUmVjZWl2ZWRFdmVudHMsIGFiaUV2ZW50cywgYWJpU3RydWN0cywgYWJpRW51bXMpIHtcbiAgY29uc3QgcmV0ID0gcHJvdmlkZXJSZWNlaXZlZEV2ZW50cy5mbGF0KCkucmVkdWNlKChhY2MsIHJlY0V2ZW50KSA9PiB7XG4gICAgbGV0IGFiaUV2ZW50ID0gYWJpRXZlbnRzW3JlY0V2ZW50LmtleXMuc2hpZnQoKSA/PyAwXTtcbiAgICBpZiAoIWFiaUV2ZW50KSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICB3aGlsZSAoIWFiaUV2ZW50Lm5hbWUpIHtcbiAgICAgIGNvbnN0IGhhc2hOYW1lID0gcmVjRXZlbnQua2V5cy5zaGlmdCgpO1xuICAgICAgYXNzZXJ0KCEhaGFzaE5hbWUsICdOb3QgZW5vdWdoIGRhdGEgaW4gXCJrZXlcIiBwcm9wZXJ0eSBvZiB0aGlzIGV2ZW50LicpO1xuICAgICAgYWJpRXZlbnQgPSBhYmlFdmVudFtoYXNoTmFtZV07XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0ge307XG4gICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV0gPSB7fTtcbiAgICBjb25zdCBrZXlzSXRlciA9IHJlY0V2ZW50LmtleXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGRhdGFJdGVyID0gcmVjRXZlbnQuZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgYWJpRXZlbnRLZXlzID0gYWJpRXZlbnQubWVtYmVycz8uZmlsdGVyKChpdCkgPT4gaXQua2luZCA9PT0gXCJrZXlcIikgfHwgYWJpRXZlbnQua2V5cztcbiAgICBjb25zdCBhYmlFdmVudERhdGEgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImRhdGFcIikgfHwgYWJpRXZlbnQuZGF0YTtcbiAgICBhYmlFdmVudEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtrZXkubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAga2V5c0l0ZXIsXG4gICAgICAgIGtleSxcbiAgICAgICAgYWJpU3RydWN0cyxcbiAgICAgICAgYWJpRW51bXMsXG4gICAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFiaUV2ZW50RGF0YS5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtkYXRhLm5hbWVdID0gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIGRhdGFJdGVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWNjLnB1c2gocGFyc2VkRXZlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KSB7XG4gIGlmICghdHhSZWNlaXB0LmV2ZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVEQyBlbWl0dGVkIGV2ZW50IGlzIGVtcHR5XCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gdHhSZWNlaXB0LmV2ZW50cy5maW5kKFxuICAgIChpdCkgPT4gY2xlYW5IZXgoaXQuZnJvbV9hZGRyZXNzKSA9PT0gY2xlYW5IZXgoVURDLkFERFJFU1MpXG4gICkgfHwge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHJhbnNhY3Rpb25faGFzaDogdHhSZWNlaXB0LnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgY29udHJhY3RfYWRkcmVzczogZXZlbnQuZGF0YVswXSxcbiAgICBhZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGRlcGxveWVyOiBldmVudC5kYXRhWzFdLFxuICAgIHVuaXF1ZTogZXZlbnQuZGF0YVsyXSxcbiAgICBjbGFzc0hhc2g6IGV2ZW50LmRhdGFbM10sXG4gICAgY2FsbGRhdGFfbGVuOiBldmVudC5kYXRhWzRdLFxuICAgIGNhbGxkYXRhOiBldmVudC5kYXRhLnNsaWNlKDUsIDUgKyBwYXJzZUludChldmVudC5kYXRhWzRdLCAxNikpLFxuICAgIHNhbHQ6IGV2ZW50LmRhdGFbZXZlbnQuZGF0YS5sZW5ndGggLSAxXVxuICB9O1xufVxuXG4vLyBzcmMvYWNjb3VudC9kZWZhdWx0LnRzXG52YXIgQWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgUnBjUHJvdmlkZXIyIHtcbiAgc2lnbmVyO1xuICBhZGRyZXNzO1xuICBjYWlyb1ZlcnNpb247XG4gIHRyYW5zYWN0aW9uVmVyc2lvbjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIGFkZHJlc3MsIHBrT3JTaWduZXIsIGNhaXJvVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uID0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMikge1xuICAgIHN1cGVyKHByb3ZpZGVyT3JPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zaWduZXIgPSBpc1N0cmluZyhwa09yU2lnbmVyKSB8fCBwa09yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBTaWduZXIocGtPclNpZ25lcikgOiBwa09yU2lnbmVyO1xuICAgIGlmIChjYWlyb1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm9WZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID0gdHJhbnNhY3Rpb25WZXJzaW9uO1xuICB9XG4gIC8vIHByb3ZpZGVkIHZlcnNpb24gb3IgY29udHJhY3QgYmFzZWQgcHJlZmVycmVkIHRyYW5zYWN0aW9uVmVyc2lvblxuICBnZXRQcmVmZXJyZWRWZXJzaW9uKHR5cGUxMiwgdHlwZTMpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpXG4gICAgICByZXR1cm4gdHlwZTM7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyKVxuICAgICAgcmV0dXJuIHR5cGUxMjtcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMztcbiAgfVxuICBhc3luYyBnZXROb25jZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKHRoaXMuYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXROb25jZVNhZmUobm9uY2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvQmlnSW50KG5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAwbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2Fpcm8gdmVyc2lvbiBmcm9tIHRoZSBuZXR3b3JrIGFuZCBzZXRzIGBjYWlyb1ZlcnNpb25gIGlmIG5vdCBhbHJlYWR5IHNldCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBjbGFzc0hhc2ggaWYgcHJvdmlkZWQgZGV0ZWN0cyBDYWlybyB2ZXJzaW9uIGZyb20gY2xhc3NIYXNoLCBvdGhlcndpc2UgZnJvbSB0aGUgYWNjb3VudCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBnZXRDYWlyb1ZlcnNpb24oY2xhc3NIYXNoKSB7XG4gICAgaWYgKCF0aGlzLmNhaXJvVmVyc2lvbikge1xuICAgICAgY29uc3QgeyBjYWlybyB9ID0gY2xhc3NIYXNoID8gYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHZvaWQgMCwgY2xhc3NIYXNoKSA6IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlybztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2Fpcm9WZXJzaW9uO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBub25jZTogcHJvdmlkZWROb25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbixcbiAgICAgIHNraXBWYWxpZGF0ZSA9IHRydWVcbiAgICB9ID0gZGV0YWlscztcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBBcnJheS5pc0FycmF5KGNhbGxzKSA/IGNhbGxzIDogW2NhbGxzXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMyksXG4gICAgICB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKVxuICAgICk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24odHJhbnNhY3Rpb25zLCBzaWduZXJEZXRhaWxzKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0SW52b2tlRXN0aW1hdGVGZWUoXG4gICAgICB7IC4uLmludm9jYXRpb24gfSxcbiAgICAgIHsgLi4udjNEZXRhaWxzKGRldGFpbHMpLCB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgZGV0YWlscy5za2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVjbGFyZUZlZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBub25jZTogcHJvdmlkZWROb25jZSxcbiAgICAgIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbixcbiAgICAgIHNraXBWYWxpZGF0ZSA9IHRydWVcbiAgICB9ID0gZGV0YWlscztcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxIDogdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjMpLFxuICAgICAgdG9GZWVWZXJzaW9uKHByb3ZpZGVkVmVyc2lvbilcbiAgICApO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChwYXlsb2FkLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBub25jZSxcbiAgICAgIGNoYWluSWQsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDAsXG4gICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RGVjbGFyZUVzdGltYXRlRmVlKFxuICAgICAgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sXG4gICAgICB7IC4uLnYzRGV0YWlscyhkZXRhaWxzKSwgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGRldGFpbHMuc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUFjY291bnREZXBsb3lGZWUoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IGJsb2NrSWRlbnRpZmllciwgdmVyc2lvbjogcHJvdmlkZWRWZXJzaW9uLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzKSxcbiAgICAgIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pXG4gICAgKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGNvbnRyYWN0QWRkcmVzcyB9LFxuICAgICAge1xuICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMCxcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlcixcbiAgICAgICAgc2tpcFZhbGlkYXRlXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5wYXlsb2FkIH0sXG4gICAgICB7IC4uLnYzRGV0YWlscyhkZXRhaWxzKSwgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGRldGFpbHMuc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCB2ZXJzaW9uLCBza2lwVmFsaWRhdGUgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB2ZXJzaW9uczogW1xuICAgICAgICBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLFxuICAgICAgICAvLyBub24tc2llcnJhXG4gICAgICAgIHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzKSxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgIClcbiAgICAgICAgLy8gc2llcnJhXG4gICAgICBdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RXN0aW1hdGVGZWVCdWxrKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlLCBza2lwRXhlY3V0ZSwgdmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHZlcnNpb25zOiBbXG4gICAgICAgIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgIC8vIG5vbi1zaWVycmFcbiAgICAgICAgdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIG5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldFNpbXVsYXRlVHJhbnNhY3Rpb24oYWNjb3VudEludm9jYXRpb25zLCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGUsXG4gICAgICBza2lwRXhlY3V0ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGUodHJhbnNhY3Rpb25zLCBhcmcyLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IGRldGFpbHMgPSBhcmcyID09PSB2b2lkIDAgfHwgQXJyYXkuaXNBcnJheShhcmcyKSA/IHRyYW5zYWN0aW9uc0RldGFpbCA6IGFyZzI7XG4gICAgY29uc3QgY2FsbHMgPSBBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykgPyB0cmFuc2FjdGlvbnMgOiBbdHJhbnNhY3Rpb25zXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KGRldGFpbHMubm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyksXG4gICAgICAvLyBUT0RPOiBkb2VzIHRoaXMgZGVwZW5kIG9uIGNhaXJvIHZlcnNpb24gP1xuICAgICAgZGV0YWlscy52ZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHsgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sIHBheWxvYWQ6IHRyYW5zYWN0aW9ucyB9LFxuICAgICAge1xuICAgICAgICAuLi5kZXRhaWxzLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNhaXJvVmVyc2lvbjogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKVxuICAgIH07XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YShjYWxscywgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgcmV0dXJuIHRoaXMuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7IGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLCBjYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCBjaGVjayBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBub3QgZGVjbGFyZSBpdFxuICAgKiBJZiBjb250cmFjdCBhbHJlYWR5IGRlY2xhcmVkIHJldHVybmVkIHRyYW5zYWN0aW9uX2hhc2ggaXMgJycuXG4gICAqIE1ldGhvZCB3aWxsIHBhc3MgZXZlbiBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnNEZXRhaWwgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZGVjbGFyZUlmTm90KHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwiXCIsXG4gICAgICBjbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVjbGFyZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbm9uY2UsIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxIDogdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgcHJvdmlkZWRWZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgcGF5bG9hZDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4uZGV0YWlscyxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZGVjbGFyZURldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgIG5vbmNlOiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQ6IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKFxuICAgICAgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCxcbiAgICAgIGRlY2xhcmVEZXRhaWxzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJlQ29udHJhY3QoZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sIGRlY2xhcmVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3kocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBjYWxscywgYWRkcmVzc2VzIH0gPSBidWlsZFVEQ0NhbGwocGF5bG9hZCwgdGhpcy5hZGRyZXNzKTtcbiAgICBjb25zdCBpbnZva2VSZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShjYWxscywgdm9pZCAwLCBkZXRhaWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW52b2tlUmVzcG9uc2UsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBhZGRyZXNzZXNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRlcGxveUNvbnRyYWN0KHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IGRlcGxveVR4ID0gYXdhaXQgdGhpcy5kZXBsb3kocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgY29uc3QgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oZGVwbG95VHgudHJhbnNhY3Rpb25faGFzaCk7XG4gICAgcmV0dXJuIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQW5kRGVwbG95KHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdW5pcXVlIH0gPSBwYXlsb2FkO1xuICAgIGxldCBkZWNsYXJlID0gYXdhaXQgdGhpcy5kZWNsYXJlSWZOb3QocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgaWYgKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgICAgZGVjbGFyZSA9IHsgLi4uZGVjbGFyZSwgLi4udHggfTtcbiAgICB9XG4gICAgY29uc3QgZGVwbG95ID0gYXdhaXQgdGhpcy5kZXBsb3lDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoOiBkZWNsYXJlLmNsYXNzX2hhc2gsIHNhbHQsIHVuaXF1ZSwgY29uc3RydWN0b3JDYWxsZGF0YSB9LFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gICAgcmV0dXJuIHsgZGVjbGFyZTogeyAuLi5kZWNsYXJlIH0sIGRlcGxveSB9O1xuICB9XG4gIGRlcGxveVNlbGYgPSB0aGlzLmRlcGxveUFjY291bnQ7XG4gIGFzeW5jIGRlcGxveUFjY291bnQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgZGV0YWlscy52ZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IGVzdGltYXRlID0gYXdhaXQgdGhpcy5nZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUoXG4gICAgICB2ZXJzaW9uLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgICBhZGRyZXNzU2FsdCxcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3NcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oe1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIG5vbmNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVwbG95QWNjb3VudENvbnRyYWN0KFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzaWduYXR1cmUgfSxcbiAgICAgIHtcbiAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICBub25jZSxcbiAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgdGhpcy5hZGRyZXNzKTtcbiAgfVxuICBhc3luYyBoYXNoTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIHZlcmlmeU1lc3NhZ2VIYXNoKGhhc2gsIHNpZ25hdHVyZSwgc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lLCBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZSkge1xuICAgIGNvbnN0IGtub3duU2lnVmVyaWZpY2F0aW9uRk5hbWUgPSBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUgPyBbc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lXSA6IFtcImlzVmFsaWRTaWduYXR1cmVcIiwgXCJpc192YWxpZF9zaWduYXR1cmVcIl07XG4gICAgY29uc3Qga25vd25TaWduYXR1cmVSZXNwb25zZSA9IHNpZ25hdHVyZVZlcmlmaWNhdGlvblJlc3BvbnNlIHx8IHtcbiAgICAgIG9rUmVzcG9uc2U6IFtcbiAgICAgICAgLy8gYW55IG5vbi1ub2sgcmVzcG9uc2UgaXMgdHJ1ZVxuICAgICAgXSxcbiAgICAgIG5va1Jlc3BvbnNlOiBbXG4gICAgICAgIFwiMHgwXCIsXG4gICAgICAgIC8vIERldm5ldFxuICAgICAgICBcIjB4MDBcIlxuICAgICAgICAvLyBPcGVuWmVwcGVsaW4gMC43LjAgdG8gMC45LjAgaW52YWxpZCBzaWduYXR1cmVcbiAgICAgIF0sXG4gICAgICBlcnJvcjogW1xuICAgICAgICBcImFyZ2VudC9pbnZhbGlkLXNpZ25hdHVyZVwiLFxuICAgICAgICAvLyBBcmdlbnRYIDAuMy4wIHRvIDAuMy4xXG4gICAgICAgIFwiaXMgaW52YWxpZCwgd2l0aCByZXNwZWN0IHRvIHRoZSBwdWJsaWMga2V5XCIsXG4gICAgICAgIC8vIE9wZW5aZXBwZWxpbiB1bnRpbCAwLjYuMSwgQnJhYXZvcyAwLjAuMTFcbiAgICAgICAgXCJJTlZBTElEX1NJR1wiXG4gICAgICAgIC8vIEJyYWF2b3MgMS4wLjBcbiAgICAgIF1cbiAgICB9O1xuICAgIGxldCBlcnJvcjtcbiAgICBmb3IgKGNvbnN0IFNpZ1ZlcmlmaWNhdGlvbkZOYW1lIG9mIGtub3duU2lnVmVyaWZpY2F0aW9uRk5hbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGxDb250cmFjdCh7XG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgZW50cnlwb2ludDogU2lnVmVyaWZpY2F0aW9uRk5hbWUsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICAgICAgaGFzaDogdG9CaWdJbnQoaGFzaCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZm9ybWF0U2lnbmF0dXJlKHNpZ25hdHVyZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGtub3duU2lnbmF0dXJlUmVzcG9uc2Uubm9rUmVzcG9uc2UuaW5jbHVkZXMocmVzcFswXS50b1N0cmluZygpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa25vd25TaWduYXR1cmVSZXNwb25zZS5va1Jlc3BvbnNlLmxlbmd0aCA9PT0gMCB8fCBrbm93blNpZ25hdHVyZVJlc3BvbnNlLm9rUmVzcG9uc2UuaW5jbHVkZXMocmVzcFswXS50b1N0cmluZygpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKFwic2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2UgRXJyb3I6IHJlc3BvbnNlIGlzIG5vdCBwYXJ0IG9mIGtub3duIHJlc3BvbnNlc1wiKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoa25vd25TaWduYXR1cmVSZXNwb25zZS5lcnJvci5zb21lKFxuICAgICAgICAgIChlcnJNZXNzYWdlKSA9PiBlcnIubWVzc2FnZS5pbmNsdWRlcyhlcnJNZXNzYWdlKVxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihgU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBFcnJvcjogJHtlcnJvcn1gKTtcbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlLCBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUsIHNpZ25hdHVyZVZlcmlmaWNhdGlvblJlc3BvbnNlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaE1lc3NhZ2UodHlwZWREYXRhKTtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlNZXNzYWdlSGFzaChcbiAgICAgIGhhc2gsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUsXG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLypcbiAgICogU3VwcG9ydCBtZXRob2RzXG4gICAqL1xuICBhc3luYyBnZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUodmVyc2lvbiwgeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgbWF4RmVlID0gMDtcbiAgICBsZXQgcmVzb3VyY2VCb3VuZHMgPSBlc3RpbWF0ZUZlZVRvQm91bmRzKFpFUk8pO1xuICAgIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSB7XG4gICAgICByZXNvdXJjZUJvdW5kcyA9IGRldGFpbHMucmVzb3VyY2VCb3VuZHMgPz8gKGF3YWl0IHRoaXMuZ2V0U3VnZ2VzdGVkRmVlKHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSkucmVzb3VyY2VCb3VuZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEZlZSA9IGRldGFpbHMubWF4RmVlID8/IChhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykpLnN1Z2dlc3RlZE1heEZlZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEZlZSxcbiAgICAgIHJlc291cmNlQm91bmRzXG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRTdWdnZXN0ZWRGZWUoeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgZmVlRXN0aW1hdGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVJbnZva2VGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVEZWNsYXJlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERVBMT1lcIiAvKiBERVBMT1kgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IHtcbiAgICAgICAgICBnYXNfY29uc3VtZWQ6IDBuLFxuICAgICAgICAgIGdhc19wcmljZTogMG4sXG4gICAgICAgICAgb3ZlcmFsbF9mZWU6IFpFUk8sXG4gICAgICAgICAgdW5pdDogXCJGUklcIixcbiAgICAgICAgICBzdWdnZXN0ZWRNYXhGZWU6IFpFUk8sXG4gICAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlRmVlVG9Cb3VuZHMoWkVSTyksXG4gICAgICAgICAgZGF0YV9nYXNfY29uc3VtZWQ6IDBuLFxuICAgICAgICAgIGRhdGFfZ2FzX3ByaWNlOiAwblxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZlZUVzdGltYXRlO1xuICB9XG4gIGFzeW5jIGJ1aWxkSW52b2NhdGlvbihjYWxsLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEoY2FsbCwgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gIWRldGFpbHMuc2tpcFZhbGlkYXRlID8gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKGNhbGwsIGRldGFpbHMpIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2FsbGRhdGEsXG4gICAgICBzaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkRGVjbGFyZVBheWxvYWQocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHsgY2xhc3NIYXNoLCBjb250cmFjdCwgY29tcGlsZWRDbGFzc0hhc2ggfSA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCA9IHBhcnNlQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGlmICh0eXBlb2YgY29tcGlsZWRDbGFzc0hhc2ggPT09IFwidW5kZWZpbmVkXCIgJiYgKGRldGFpbHMudmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMuRjMgfHwgZGV0YWlscy52ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMy5WMykpIHtcbiAgICAgIHRocm93IEVycm9yKFwiVjMgVHJhbnNhY3Rpb24gd29yayB3aXRoIENhaXJvMSBDb250cmFjdHMgYW5kIHJlcXVpcmUgY29tcGlsZWRDbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICFkZXRhaWxzLnNraXBWYWxpZGF0ZSA/IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgICAgLi4uZGV0YWlscyxcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgLy8gVE9ETzogVFMsIGNhc3QgYmVjYXVzZSBvcHRpb25hbCBmb3IgdjIgYW5kIHJlcXVpcmVkIGZvciB2MywgdGhyb3duIGlmIG5vdCBwcmVzZW50XG4gICAgICBzZW5kZXJBZGRyZXNzOiBkZXRhaWxzLndhbGxldEFkZHJlc3NcbiAgICB9KSA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBzZW5kZXJBZGRyZXNzOiBkZXRhaWxzLndhbGxldEFkZHJlc3MsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBjb250cmFjdDogY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QsXG4gICAgICBjb21waWxlZENsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgPz8gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goYWRkcmVzc1NhbHQsIGNsYXNzSGFzaCwgY29tcGlsZWRDYWxsZGF0YSwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gIWRldGFpbHMuc2tpcFZhbGlkYXRlID8gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgICAuLi5kZXRhaWxzLFxuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhXG4gICAgfSkgOiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgY2FsbHMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQgPSBcIjBcIixcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxscztcbiAgfVxuICBhc3luYyBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHNhZmVOb25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VTYWZlKG5vbmNlKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdmVyc2lvbnMgPSBkZXRhaWxzLnZlcnNpb25zLm1hcCgoaXQpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uKGl0KSk7XG4gICAgY29uc3QgdHgwUGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIGludm9jYXRpb25zWzBdID8gaW52b2NhdGlvbnNbMF0ucGF5bG9hZCA6IGludm9jYXRpb25zWzBdO1xuICAgIGNvbnN0IGNhaXJvVmVyc2lvbiA9IGludm9jYXRpb25zWzBdLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyA/IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKHR4MFBheWxvYWQuY2xhc3NIYXNoKSA6IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgW10uY29uY2F0KGludm9jYXRpb25zKS5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0eFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiB0cmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnBheWxvYWQgOiB0cmFuc2FjdGlvbjtcbiAgICAgICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICBjYWlyb1ZlcnNpb24sXG4gICAgICAgICAgdmVyc2lvbjogXCJcIixcbiAgICAgICAgICBza2lwVmFsaWRhdGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tbW9uID0ge1xuICAgICAgICAgIHR5cGU6IHRyYW5zYWN0aW9uLnR5cGUsXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25YID0gcmVkdWNlVjIodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbW1vbi52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKFxuICAgICAgICAgICAgW10uY29uY2F0KHR4UGF5bG9hZCksXG4gICAgICAgICAgICBzaWduZXJEZXRhaWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSByZWR1Y2VWMih2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQodHhQYXlsb2FkKTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oY2FsbHMsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi9cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSAhaXNTaWVycmEodHhQYXlsb2FkLmNvbnRyYWN0KSA/IHZlcnNpb25zWzBdIDogdmVyc2lvbnNbMV07XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uWCA9IHJlZHVjZVYyKHZlcnNpb25zWzFdKTtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb21tb24udmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgRXJyb3IoYGFjY291bnRJbnZvY2F0aW9uc0ZhY3Rvcnk6IHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHJhbnNhY3Rpb259YCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG59O1xuXG4vLyBzcmMvYWNjb3VudC9pbnRlcmZhY2UudHNcbnZhciBBY2NvdW50SW50ZXJmYWNlID0gY2xhc3MgZXh0ZW5kcyBQcm92aWRlckludGVyZmFjZSB7XG59O1xuXG4vLyBzcmMvd2FsbGV0L2Nvbm5lY3QudHNcbnZhciBjb25uZWN0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbm5lY3RfZXhwb3J0cywge1xuICBhZGREZWNsYXJlVHJhbnNhY3Rpb246ICgpID0+IGFkZERlY2xhcmVUcmFuc2FjdGlvbixcbiAgYWRkSW52b2tlVHJhbnNhY3Rpb246ICgpID0+IGFkZEludm9rZVRyYW5zYWN0aW9uLFxuICBhZGRTdGFya25ldENoYWluOiAoKSA9PiBhZGRTdGFya25ldENoYWluLFxuICBkZXBsb3ltZW50RGF0YTogKCkgPT4gZGVwbG95bWVudERhdGEsXG4gIGdldFBlcm1pc3Npb25zOiAoKSA9PiBnZXRQZXJtaXNzaW9ucyxcbiAgb25BY2NvdW50Q2hhbmdlOiAoKSA9PiBvbkFjY291bnRDaGFuZ2UsXG4gIG9uTmV0d29ya0NoYW5nZWQ6ICgpID0+IG9uTmV0d29ya0NoYW5nZWQsXG4gIHJlcXVlc3RBY2NvdW50czogKCkgPT4gcmVxdWVzdEFjY291bnRzLFxuICByZXF1ZXN0Q2hhaW5JZDogKCkgPT4gcmVxdWVzdENoYWluSWQsXG4gIHNpZ25NZXNzYWdlOiAoKSA9PiBzaWduTWVzc2FnZSxcbiAgc3VwcG9ydGVkU3BlY3M6ICgpID0+IHN1cHBvcnRlZFNwZWNzLFxuICBzd2l0Y2hTdGFya25ldENoYWluOiAoKSA9PiBzd2l0Y2hTdGFya25ldENoYWluLFxuICB3YXRjaEFzc2V0OiAoKSA9PiB3YXRjaEFzc2V0XG59KTtcbmZ1bmN0aW9uIHJlcXVlc3RBY2NvdW50cyhzd28sIHNpbGVudF9tb2RlID0gZmFsc2UpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0QWNjb3VudHNcIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIHNpbGVudF9tb2RlXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBlcm1pc3Npb25zKHN3bykge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiIH0pO1xufVxuZnVuY3Rpb24gd2F0Y2hBc3NldChzd28sIGFzc2V0KSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfd2F0Y2hBc3NldFwiLFxuICAgIHBhcmFtczogYXNzZXRcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRTdGFya25ldENoYWluKHN3bywgY2hhaW4pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGRTdGFya25ldENoYWluXCIsXG4gICAgcGFyYW1zOiBjaGFpblxuICB9KTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFN0YXJrbmV0Q2hhaW4oc3dvLCBjaGFpbklkKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfc3dpdGNoU3RhcmtuZXRDaGFpblwiLFxuICAgIHBhcmFtczoge1xuICAgICAgY2hhaW5JZFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXF1ZXN0Q2hhaW5JZChzd28pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdENoYWluSWRcIiB9KTtcbn1cbmZ1bmN0aW9uIGRlcGxveW1lbnREYXRhKHN3bykge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9kZXBsb3ltZW50RGF0YVwiIH0pO1xufVxuZnVuY3Rpb24gYWRkSW52b2tlVHJhbnNhY3Rpb24oc3dvLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLFxuICAgIHBhcmFtc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY2xhcmVUcmFuc2FjdGlvbihzd28sIHBhcmFtcykge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLFxuICAgIHBhcmFtc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNpZ25NZXNzYWdlKHN3bywgdHlwZWREYXRhKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfc2lnblR5cGVkRGF0YVwiLFxuICAgIHBhcmFtczogdHlwZWREYXRhXG4gIH0pO1xufVxuZnVuY3Rpb24gc3VwcG9ydGVkU3BlY3Moc3dvKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X3N1cHBvcnRlZFNwZWNzXCIgfSk7XG59XG5mdW5jdGlvbiBvbkFjY291bnRDaGFuZ2Uoc3dvLCBjYWxsYmFjaykge1xuICBzd28ub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gb25OZXR3b3JrQ2hhbmdlZChzd28sIGNhbGxiYWNrKSB7XG4gIHN3by5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsIGNhbGxiYWNrKTtcbn1cblxuLy8gc3JjL3dhbGxldC9hY2NvdW50LnRzXG52YXIgV2FsbGV0QWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgQWNjb3VudCB7XG4gIGFkZHJlc3MgPSBcIlwiO1xuICB3YWxsZXRQcm92aWRlcjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIHdhbGxldFByb3ZpZGVyLCBjYWlyb1ZlcnNpb24pIHtcbiAgICBzdXBlcihwcm92aWRlck9yT3B0aW9ucywgXCJcIiwgXCJcIiwgY2Fpcm9WZXJzaW9uKTtcbiAgICB0aGlzLndhbGxldFByb3ZpZGVyID0gd2FsbGV0UHJvdmlkZXI7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAocmVzKSA9PiB7XG4gICAgICBpZiAoIXJlcylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5hZGRyZXNzID0gcmVzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlci5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsIChyZXMpID0+IHtcbiAgICAgIGlmICghcmVzKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmNoYW5uZWwuc2V0Q2hhaW5JZChyZXMpO1xuICAgIH0pO1xuICAgIHdhbGxldFByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgc2lsZW50X21vZGU6IGZhbHNlXG4gICAgICB9XG4gICAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgICB0aGlzLmFkZHJlc3MgPSByZXNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV0FMTEVUIEVWRU5UU1xuICAgKi9cbiAgb25BY2NvdW50Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgb25BY2NvdW50Q2hhbmdlKHRoaXMud2FsbGV0UHJvdmlkZXIsIGNhbGxiYWNrKTtcbiAgfVxuICBvbk5ldHdvcmtDaGFuZ2VkKGNhbGxiYWNrKSB7XG4gICAgb25OZXR3b3JrQ2hhbmdlZCh0aGlzLndhbGxldFByb3ZpZGVyLCBjYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFdBTExFVCBTUEVDSUZJQyBNRVRIT0RTXG4gICAqL1xuICByZXF1ZXN0QWNjb3VudHMoc2lsZW50TW9kZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBY2NvdW50cyh0aGlzLndhbGxldFByb3ZpZGVyLCBzaWxlbnRNb2RlKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gZ2V0UGVybWlzc2lvbnModGhpcy53YWxsZXRQcm92aWRlcik7XG4gIH1cbiAgc3dpdGNoU3RhcmtuZXRDaGFpbihjaGFpbklkKSB7XG4gICAgcmV0dXJuIHN3aXRjaFN0YXJrbmV0Q2hhaW4odGhpcy53YWxsZXRQcm92aWRlciwgY2hhaW5JZCk7XG4gIH1cbiAgd2F0Y2hBc3NldChhc3NldCkge1xuICAgIHJldHVybiB3YXRjaEFzc2V0KHRoaXMud2FsbGV0UHJvdmlkZXIsIGFzc2V0KTtcbiAgfVxuICBhZGRTdGFya25ldENoYWluKGNoYWluKSB7XG4gICAgcmV0dXJuIGFkZFN0YXJrbmV0Q2hhaW4odGhpcy53YWxsZXRQcm92aWRlciwgY2hhaW4pO1xuICB9XG4gIC8qKlxuICAgKiBBQ0NPVU5UIE1FVEhPRFNcbiAgICovXG4gIGV4ZWN1dGUoY2FsbHMpIHtcbiAgICBjb25zdCB0eENhbGxzID0gW10uY29uY2F0KGNhbGxzKS5tYXAoKGl0KSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRyYWN0QWRkcmVzcywgZW50cnlwb2ludCwgY2FsbGRhdGEgfSA9IGl0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludDogZW50cnlwb2ludCxcbiAgICAgICAgY2FsbGRhdGFcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgY2FsbHM6IHR4Q2FsbHNcbiAgICB9O1xuICAgIHJldHVybiBhZGRJbnZva2VUcmFuc2FjdGlvbih0aGlzLndhbGxldFByb3ZpZGVyLCBwYXJhbXMpO1xuICB9XG4gIGRlY2xhcmUocGF5bG9hZCkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgcENvbnRyYWN0ID0gcGF5bG9hZC5jb250cmFjdDtcbiAgICBjb25zdCBjYWlybzFDb250cmFjdCA9IHtcbiAgICAgIC4uLnBDb250cmFjdCxcbiAgICAgIGFiaTogc3RyaW5naWZ5MihwQ29udHJhY3QuYWJpKVxuICAgIH07XG4gICAgaWYgKCFkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNvbXBpbGVkQ2xhc3NIYXNoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcImNvbXBpbGVkQ2xhc3NIYXNoIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RfY2xhc3M6IGNhaXJvMUNvbnRyYWN0XG4gICAgfTtcbiAgICByZXR1cm4gYWRkRGVjbGFyZVRyYW5zYWN0aW9uKHRoaXMud2FsbGV0UHJvdmlkZXIsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95KHBheWxvYWQpIHtcbiAgICBjb25zdCB7IGNhbGxzLCBhZGRyZXNzZXMgfSA9IGJ1aWxkVURDQ2FsbChwYXlsb2FkLCB0aGlzLmFkZHJlc3MpO1xuICAgIGNvbnN0IGludm9rZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlKGNhbGxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW52b2tlUmVzcG9uc2UsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBhZGRyZXNzZXNcbiAgICB9O1xuICB9XG4gIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiBzaWduTWVzc2FnZSh0aGlzLndhbGxldFByb3ZpZGVyLCB0eXBlZERhdGEpO1xuICB9XG4gIC8vIFRPRE86IE1JU1NJTkcgRVNUSU1BVEVTXG59O1xuXG4vLyBzcmMvY29udHJhY3QvZGVmYXVsdC50c1xudmFyIHNwbGl0QXJnc0FuZE9wdGlvbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gW1xuICAgIFwiYmxvY2tJZGVudGlmaWVyXCIsXG4gICAgXCJwYXJzZVJlcXVlc3RcIixcbiAgICBcInBhcnNlUmVzcG9uc2VcIixcbiAgICBcImZvcm1hdFJlc3BvbnNlXCIsXG4gICAgXCJtYXhGZWVcIixcbiAgICBcIm5vbmNlXCIsXG4gICAgXCJzaWduYXR1cmVcIixcbiAgICBcImFkZHJlc3NTYWx0XCJcbiAgXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuc29tZSgoeCkgPT4geCBpbiBsYXN0QXJnKSkge1xuICAgIHJldHVybiB7IGFyZ3MsIG9wdGlvbnM6IGFyZ3MucG9wKCkgfTtcbiAgfVxuICByZXR1cm4geyBhcmdzIH07XG59O1xuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuaW52b2tlKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICBpZiAoZnVuY3Rpb25BYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBmdW5jdGlvbkFiaS5zdGF0ZV9tdXRhYmlsaXR5ID09PSBcInZpZXdcIikge1xuICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbiAgfVxuICByZXR1cm4gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LnBvcHVsYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QuZXN0aW1hdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDYWxsZGF0YShhcmdzLCBjYWxsYmFjaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3MpXG4gICAgcmV0dXJuIGFyZ3M7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzWzBdKVxuICAgIHJldHVybiBhcmdzWzBdO1xuICByZXR1cm4gY2FsbGJhY2soKTtcbn1cbnZhciBDb250cmFjdCA9IGNsYXNzIHtcbiAgYWJpO1xuICBhZGRyZXNzO1xuICBwcm92aWRlck9yQWNjb3VudDtcbiAgZGVwbG95VHJhbnNhY3Rpb25IYXNoO1xuICBzdHJ1Y3RzO1xuICBldmVudHM7XG4gIGZ1bmN0aW9ucztcbiAgY2FsbFN0YXRpYztcbiAgcG9wdWxhdGVUcmFuc2FjdGlvbjtcbiAgZXN0aW1hdGVGZWU7XG4gIGNhbGxEYXRhO1xuICAvKipcbiAgICogQ29udHJhY3QgY2xhc3MgdG8gaGFuZGxlIGNvbnRyYWN0IG1ldGhvZHNcbiAgICpcbiAgICogQHBhcmFtIGFiaSAtIEFiaSBvZiB0aGUgY29udHJhY3Qgb2JqZWN0XG4gICAqIEBwYXJhbSBhZGRyZXNzIChvcHRpb25hbCkgLSBhZGRyZXNzIHRvIGNvbm5lY3QgdG9cbiAgICogQHBhcmFtIHByb3ZpZGVyT3JBY2NvdW50IChvcHRpb25hbCkgLSBQcm92aWRlciBvciBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWJpLCBhZGRyZXNzLCBwcm92aWRlck9yQWNjb3VudCA9IGRlZmF1bHRQcm92aWRlcikge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MgJiYgYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdmlkZXJPckFjY291bnQgPSBwcm92aWRlck9yQWNjb3VudDtcbiAgICB0aGlzLmNhbGxEYXRhID0gbmV3IENhbGxEYXRhKGFiaSk7XG4gICAgdGhpcy5zdHJ1Y3RzID0gQ2FsbERhdGEuZ2V0QWJpU3RydWN0KGFiaSk7XG4gICAgdGhpcy5ldmVudHMgPSBnZXRBYmlFdmVudHMoYWJpKTtcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVBYmlQYXJzZXIoYWJpKTtcbiAgICB0aGlzLmFiaSA9IHBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgICBjb25zdCBvcHRpb25zID0geyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGZ1bmN0aW9uczogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgY2FsbFN0YXRpYzogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbjogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgZXN0aW1hdGVGZWU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfVxuICAgIH0pO1xuICAgIHRoaXMuYWJpLmZvckVhY2goKGFiaUVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChhYmlFbGVtZW50LnR5cGUgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYWJpRWxlbWVudC5uYW1lO1xuICAgICAgaWYgKCF0aGlzW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRGVmYXVsdCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5mdW5jdGlvbnMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRGVmYXVsdCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYWxsU3RhdGljW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuY2FsbFN0YXRpYywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRDYWxsKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZFBvcHVsYXRlKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVzdGltYXRlRmVlW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZXN0aW1hdGVGZWUsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRXN0aW1hdGUodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoKGFkZHJlc3MpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICB9XG4gIGNvbm5lY3QocHJvdmlkZXJPckFjY291bnQpIHtcbiAgICB0aGlzLnByb3ZpZGVyT3JBY2NvdW50ID0gcHJvdmlkZXJPckFjY291bnQ7XG4gIH1cbiAgYXN5bmMgZGVwbG95ZWQoKSB7XG4gICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LndhaXRGb3JUcmFuc2FjdGlvbih0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgY2FsbChtZXRob2QsIGFyZ3MgPSBbXSwge1xuICAgIHBhcnNlUmVxdWVzdCA9IHRydWUsXG4gICAgcGFyc2VSZXNwb25zZSA9IHRydWUsXG4gICAgZm9ybWF0UmVzcG9uc2UgPSB2b2lkIDAsXG4gICAgYmxvY2tJZGVudGlmaWVyID0gdm9pZCAwXG4gIH0gPSB7fSkge1xuICAgIGFzc2VydCh0aGlzLmFkZHJlc3MgIT09IG51bGwsIFwiY29udHJhY3QgaXMgbm90IGNvbm5lY3RlZCB0byBhbiBhZGRyZXNzXCIpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEoYXJncywgKCkgPT4ge1xuICAgICAgaWYgKHBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmNhbGxEYXRhLnZhbGlkYXRlKFwiQ0FMTFwiIC8qIENBTEwgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuY2FsbENvbnRyYWN0KFxuICAgICAge1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGEsXG4gICAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgICAgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgICkudGhlbigoaXQpID0+IHtcbiAgICAgIGlmICghcGFyc2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gaXQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuZm9ybWF0KG1ldGhvZCwgaXQsIGZvcm1hdFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLnBhcnNlKG1ldGhvZCwgaXQpO1xuICAgIH0pO1xuICB9XG4gIGludm9rZShtZXRob2QsIGFyZ3MgPSBbXSwgeyBwYXJzZVJlcXVlc3QgPSB0cnVlLCBtYXhGZWUsIG5vbmNlLCBzaWduYXR1cmUgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25jZSBpcyByZXF1aXJlZCB3aGVuIGludm9raW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhbiBhY2NvdW50YCk7XG4gICAgY29uc29sZS53YXJuKGBJbnZva2luZyAke21ldGhvZH0gd2l0aG91dCBhbiBhY2NvdW50LiBUaGlzIHdpbGwgbm90IHdvcmsgb24gYSBwdWJsaWMgbm9kZS5gKTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5pbnZva2VGdW5jdGlvbihcbiAgICAgIHtcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBpZiAoIWdldENhbGxkYXRhKGFyZ3MsICgpID0+IGZhbHNlKSkge1xuICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgICByZWNlaXB0LmV2ZW50cz8uZmlsdGVyKFxuICAgICAgICAoZXZlbnQpID0+IGNsZWFuSGV4KGV2ZW50LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KHRoaXMuYWRkcmVzcyksXG4gICAgICAgIFtdXG4gICAgICApIHx8IFtdLFxuICAgICAgdGhpcy5ldmVudHMsXG4gICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICBDYWxsRGF0YS5nZXRBYmlFbnVtKHRoaXMuYWJpKVxuICAgICk7XG4gIH1cbiAgaXNDYWlybzEoKSB7XG4gICAgcmV0dXJuIGNhaXJvX2V4cG9ydHMuaXNDYWlybzFBYmkodGhpcy5hYmkpO1xuICB9XG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgdHlwZWR2Mih0QWJpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250cmFjdC9pbnRlcmZhY2UudHNcbnZhciBDb250cmFjdEludGVyZmFjZSA9IGNsYXNzIHtcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbn07XG5cbi8vIHNyYy9jb250cmFjdC9jb250cmFjdEZhY3RvcnkudHNcbnZhciBDb250cmFjdEZhY3RvcnkgPSBjbGFzcyB7XG4gIGNvbXBpbGVkQ29udHJhY3Q7XG4gIGFjY291bnQ7XG4gIGFiaTtcbiAgY2xhc3NIYXNoO1xuICBjYXNtO1xuICBjb21waWxlZENsYXNzSGFzaDtcbiAgQ2FsbERhdGE7XG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zIENGUGFyYW1zXG4gICAqICAtIGNvbXBpbGVkQ29udHJhY3Q6IENvbXBpbGVkQ29udHJhY3Q7XG4gICAqICAtIGFjY291bnQ6IEFjY291bnRJbnRlcmZhY2U7XG4gICAqICAtIGNhc20/OiBDYWlyb0Fzc2VtYmx5O1xuICAgKiAgLSBjbGFzc0hhc2g/OiBzdHJpbmc7XG4gICAqICAtIGNvbXBpbGVkQ2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBhYmk/OiBBYmk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QgPSBwYXJhbXMuY29tcGlsZWRDb250cmFjdDtcbiAgICB0aGlzLmFjY291bnQgPSBwYXJhbXMuYWNjb3VudDtcbiAgICB0aGlzLmNhc20gPSBwYXJhbXMuY2FzbTtcbiAgICB0aGlzLmFiaSA9IHBhcmFtcy5hYmkgPz8gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3QuYWJpO1xuICAgIHRoaXMuY2xhc3NIYXNoID0gcGFyYW1zLmNsYXNzSGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoID0gcGFyYW1zLmNvbXBpbGVkQ2xhc3NIYXNoO1xuICAgIHRoaXMuQ2FsbERhdGEgPSBuZXcgQ2FsbERhdGEodGhpcy5hYmkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3lzIGNvbnRyYWN0IGFuZCByZXR1cm5zIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29udHJhY3RcbiAgICpcbiAgICogSWYgY29udHJhY3QgaXMgbm90IGRlY2xhcmVkIGl0IHdpbGwgZmlyc3QgZGVjbGFyZSBpdCwgYW5kIHRoZW4gZGVwbG95XG4gICAqL1xuICBhc3luYyBkZXBsb3koLi4uYXJncykge1xuICAgIGNvbnN0IHsgYXJnczogcGFyYW0sIG9wdGlvbnMgPSB7IHBhcnNlUmVxdWVzdDogdHJ1ZSB9IH0gPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBnZXRDYWxsZGF0YShwYXJhbSwgKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuQ2FsbERhdGEudmFsaWRhdGUoXCJERVBMT1lcIiAvKiBERVBMT1kgKi8sIFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZGVwbG95OiB7IGNvbnRyYWN0X2FkZHJlc3MsIHRyYW5zYWN0aW9uX2hhc2ggfVxuICAgIH0gPSBhd2FpdCB0aGlzLmFjY291bnQuZGVjbGFyZUFuZERlcGxveSh7XG4gICAgICBjb250cmFjdDogdGhpcy5jb21waWxlZENvbnRyYWN0LFxuICAgICAgY2FzbTogdGhpcy5jYXNtLFxuICAgICAgY2xhc3NIYXNoOiB0aGlzLmNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoOiB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgIHNhbHQ6IG9wdGlvbnMuYWRkcmVzc1NhbHRcbiAgICB9KTtcbiAgICBhc3NlcnQoQm9vbGVhbihjb250cmFjdF9hZGRyZXNzKSwgXCJEZXBsb3ltZW50IG9mIHRoZSBjb250cmFjdCBmYWlsZWRcIik7XG4gICAgY29uc3QgY29udHJhY3RJbnN0YW5jZSA9IG5ldyBDb250cmFjdChcbiAgICAgIHRoaXMuY29tcGlsZWRDb250cmFjdC5hYmksXG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgdGhpcy5hY2NvdW50XG4gICAgKTtcbiAgICBjb250cmFjdEluc3RhbmNlLmRlcGxveVRyYW5zYWN0aW9uSGFzaCA9IHRyYW5zYWN0aW9uX2hhc2g7XG4gICAgcmV0dXJuIGNvbnRyYWN0SW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHRvIG5ldyBBY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBhY2NvdW50IC0gbmV3IEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25uZWN0KGFjY291bnQpIHtcbiAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBjdXJyZW50IGFiaSBhbmQgYWNjb3VudCB0byB0aGUgbmV3IGFkZHJlc3NcbiAgICovXG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdCh0aGlzLmFiaSwgYWRkcmVzcywgdGhpcy5hY2NvdW50KTtcbiAgfVxuICAvLyBldGhlcnMuanMnIGdldERlcGxveVRyYW5zYWN0aW9uIGNhbid0IGJlIHN1cHBvcnRlZCBhcyBpdCByZXF1aXJlcyB0aGUgYWNjb3VudCBvciBzaWduZXIgdG8gcmV0dXJuIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG59O1xuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvaW50ZXJmYWNlLnRzXG52YXIgUmVzcG9uc2VQYXJzZXIgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvdXRpbHMvYWRkcmVzcy50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKSB7XG4gIGNvbnN0IGhleCA9IHRvSGV4KGFkZEhleFByZWZpeChhZGRyZXNzLnRvU3RyaW5nKCkpKTtcbiAgY29uc3QgcGFkZGVkID0gcmVtb3ZlSGV4UHJlZml4KGhleCkucGFkU3RhcnQoNjQsIFwiMFwiKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChwYWRkZWQpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykge1xuICBjb25zdCByZXN1bHQgPSBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKTtcbiAgaWYgKCFyZXN1bHQubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezY0fSQvKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQWRkcmVzcyBGb3JtYXRcIik7XG4gIH1cbiAgYXNzZXJ0SW5SYW5nZShyZXN1bHQsIFpFUk8sIEFERFJfQk9VTkQgLSAxbiwgXCJTdGFya25ldCBBZGRyZXNzXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgY29uc3QgY2hhcnMgPSByZW1vdmVIZXhQcmVmaXgodmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykpLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJcIik7XG4gIGNvbnN0IGhleCA9IHJlbW92ZUhleFByZWZpeChrZWNjYWtCbihhZGRyZXNzKSk7XG4gIGNvbnN0IGhhc2hlZCA9IGhleFRvQnl0ZXMyKGhleC5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChoYXNoZWRbaSA+PiAxXSA+PiA0ID49IDgpIHtcbiAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDE1KSA+PSA4KSB7XG4gICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZEhleFByZWZpeChjaGFycy5qb2luKFwiXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn1cblxuLy8gc3JjL3V0aWxzL3VybC50c1xuaW1wb3J0IHVybGpvaW4gZnJvbSBcInVybC1qb2luXCI7XG52YXIgcHJvdG9jb2xBbmREb21haW5SRSA9IC9eKD86XFx3KzopP1xcL1xcLyhcXFMrKSQvO1xudmFyIGxvY2FsaG9zdERvbWFpblJFID0gL15sb2NhbGhvc3RbOj9cXGRdKig/OlteOj9cXGRdXFxTKik/JC87XG52YXIgbm9uTG9jYWxob3N0RG9tYWluUkUgPSAvXlteXFxzLl0rXFwuXFxTezIsfSQvO1xuZnVuY3Rpb24gaXNVcmwocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gcy5tYXRjaChwcm90b2NvbEFuZERvbWFpblJFKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCA9IG1hdGNoWzFdO1xuICBpZiAoIWV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsb2NhbGhvc3REb21haW5SRS50ZXN0KGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSB8fCBub25Mb2NhbGhvc3REb21haW5SRS50ZXN0KGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVXJsKGJhc2VVcmwsIGRlZmF1bHRQYXRoLCB1cmxPclBhdGgpIHtcbiAgcmV0dXJuIGlzVXJsKHVybE9yUGF0aCkgPyB1cmxPclBhdGggOiB1cmxqb2luKGJhc2VVcmwsIHVybE9yUGF0aCA/PyBkZWZhdWx0UGF0aCk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIG51bWJlciA9IG51bV9leHBvcnRzO1xuZXhwb3J0IHtcbiAgQWNjb3VudCxcbiAgQWNjb3VudEludGVyZmFjZSxcbiAgQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnLFxuICBDYWlyb0N1c3RvbUVudW0sXG4gIENhaXJvT3B0aW9uLFxuICBDYWlyb09wdGlvblZhcmlhbnQsXG4gIENhaXJvUmVzdWx0LFxuICBDYWlyb1Jlc3VsdFZhcmlhbnQsXG4gIENhaXJvVWludDI1NixcbiAgQ2Fpcm9VaW50NTEyLFxuICBDYWxsRGF0YSxcbiAgQ29udHJhY3QsXG4gIENvbnRyYWN0RmFjdG9yeSxcbiAgQ29udHJhY3RJbnRlcmZhY2UsXG4gIEN1c3RvbUVycm9yLFxuICBFbnRyeVBvaW50VHlwZSxcbiAgRXRoU2lnbmVyLFxuICBHYXRld2F5RXJyb3IsXG4gIEh0dHBFcnJvcixcbiAgTGlicmFyeUVycm9yLFxuICBMaXRlcmFsLFxuICBScGNQcm92aWRlcjIgYXMgUHJvdmlkZXIsXG4gIFByb3ZpZGVySW50ZXJmYWNlLFxuICBhcGlfZXhwb3J0cyBhcyBSUEMsXG4gIHJwY18wXzZfZXhwb3J0cyBhcyBSUEMwNixcbiAgcnBjXzBfN19leHBvcnRzIGFzIFJQQzA3LFxuICBSUENSZXNwb25zZVBhcnNlcixcbiAgUmVjZWlwdFR4LFxuICBSZXNwb25zZVBhcnNlcixcbiAgUnBjQ2hhbm5lbDIgYXMgUnBjQ2hhbm5lbCxcbiAgUnBjUHJvdmlkZXIyIGFzIFJwY1Byb3ZpZGVyLFxuICBTaWduZXIsXG4gIFNpZ25lckludGVyZmFjZSxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFR5cGVkRGF0YVJldmlzaW9uLFxuICBVSU5UXzEyOF9NQVgsXG4gIFVJTlRfMTI4X01JTixcbiAgVUlOVF8yNTZfSElHSF9NQVgsXG4gIFVJTlRfMjU2X0hJR0hfTUlOLFxuICBVSU5UXzI1Nl9MT1dfTUFYLFxuICBVSU5UXzI1Nl9MT1dfTUlOLFxuICBVSU5UXzI1Nl9NQVgsXG4gIFVJTlRfMjU2X01JTixcbiAgVUlOVF81MTJfTUFYLFxuICBVSU5UXzUxMl9NSU4sXG4gIFVpbnQsXG4gIFZhbGlkYXRlVHlwZSxcbiAgV2FsbGV0QWNjb3VudCxcbiAgYWRkQWRkcmVzc1BhZGRpbmcsXG4gIGJ1aWxkVXJsLFxuICBieXRlQXJyYXlfZXhwb3J0cyBhcyBieXRlQXJyYXksXG4gIGNhaXJvX2V4cG9ydHMgYXMgY2Fpcm8sXG4gIGNvbnN0YW50c19leHBvcnRzIGFzIGNvbnN0YW50cyxcbiAgY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0LFxuICBkZWZhdWx0UHJvdmlkZXIsXG4gIGVjX2V4cG9ydHMgYXMgZWMsXG4gIGVuY29kZV9leHBvcnRzIGFzIGVuY29kZSxcbiAgZXRoX2V4cG9ydHMgYXMgZXRoLFxuICBldmVudHNfZXhwb3J0cyBhcyBldmVudHMsXG4gIGV4dHJhY3RDb250cmFjdEhhc2hlcyxcbiAgZml4UHJvdG8sXG4gIGZpeFN0YWNrLFxuICBnZXRDYWxsZGF0YSxcbiAgZ2V0Q2hlY2tzdW1BZGRyZXNzLFxuICBoYXNoX2V4cG9ydHMgYXMgaGFzaCxcbiAgaXNTaWVycmEsXG4gIGlzVXJsLFxuICBqc29uX2V4cG9ydHMgYXMganNvbixcbiAgbWVya2xlX2V4cG9ydHMgYXMgbWVya2xlLFxuICBudW1fZXhwb3J0cyBhcyBudW0sXG4gIG51bWJlcixcbiAgcGFyc2VDYWxsZGF0YUZpZWxkLFxuICBwcm92aWRlcl9leHBvcnRzIGFzIHByb3ZpZGVyLFxuICBzZWxlY3Rvcl9leHBvcnRzIGFzIHNlbGVjdG9yLFxuICBzaG9ydFN0cmluZ19leHBvcnRzIGFzIHNob3J0U3RyaW5nLFxuICBzcGxpdEFyZ3NBbmRPcHRpb25zLFxuICBzdGFya19leHBvcnRzIGFzIHN0YXJrLFxuICBzdGFya25ldElkX2V4cG9ydHMgYXMgc3RhcmtuZXRJZCxcbiAgdHJhbnNhY3Rpb25fZXhwb3J0cyBhcyB0cmFuc2FjdGlvbixcbiAgdHlwZWREYXRhX2V4cG9ydHMgYXMgdHlwZWREYXRhLFxuICB0eXBlc19leHBvcnRzIGFzIHR5cGVzLFxuICB1aW50MjU2X2V4cG9ydHMgYXMgdWludDI1NixcbiAgdjJfZXhwb3J0cyBhcyB2Mmhhc2gsXG4gIHYzX2V4cG9ydHMgYXMgdjNoYXNoLFxuICB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyxcbiAgdmFsaWRhdGVDaGVja3N1bUFkZHJlc3MsXG4gIGNvbm5lY3RfZXhwb3J0cyBhcyB3YWxsZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_esm/utils/unit/formatUnits.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits)\n/* harmony export */ });\n/**\n *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..\n *\n * - Docs: https://viem.sh/docs/utilities/formatUnits\n *\n * @example\n * import { formatUnits } from 'viem'\n *\n * formatUnits(420000000000n, 9)\n * // '420'\n */\nfunction formatUnits(value, decimals) {\n    let display = value.toString();\n    const negative = display.startsWith('-');\n    if (negative)\n        display = display.slice(1);\n    display = display.padStart(decimals, '0');\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals),\n    ];\n    fraction = fraction.replace(/(0+)$/, '');\n    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n}\n//# sourceMappingURL=formatUnits.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdW5pdC9mb3JtYXRVbml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CLEVBQUUsZUFBZSxFQUFFLGVBQWUsU0FBUyxPQUFPO0FBQ3BGO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3dpbGZyaWQtay9wcm9qZWN0cy9vbmx5ZHVzdC9jaGFpbmV2ZW50cy1mcm9udGVuZC9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3VuaXQvZm9ybWF0VW5pdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRGl2aWRlcyBhIG51bWJlciBieSBhIGdpdmVuIGV4cG9uZW50IG9mIGJhc2UgMTAgKDEwZXhwb25lbnQpLCBhbmQgZm9ybWF0cyBpdCBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuLlxuICpcbiAqIC0gRG9jczogaHR0cHM6Ly92aWVtLnNoL2RvY3MvdXRpbGl0aWVzL2Zvcm1hdFVuaXRzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGZvcm1hdFVuaXRzIH0gZnJvbSAndmllbSdcbiAqXG4gKiBmb3JtYXRVbml0cyg0MjAwMDAwMDAwMDBuLCA5KVxuICogLy8gJzQyMCdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGxldCBkaXNwbGF5ID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IGRpc3BsYXkuc3RhcnRzV2l0aCgnLScpO1xuICAgIGlmIChuZWdhdGl2ZSlcbiAgICAgICAgZGlzcGxheSA9IGRpc3BsYXkuc2xpY2UoMSk7XG4gICAgZGlzcGxheSA9IGRpc3BsYXkucGFkU3RhcnQoZGVjaW1hbHMsICcwJyk7XG4gICAgbGV0IFtpbnRlZ2VyLCBmcmFjdGlvbl0gPSBbXG4gICAgICAgIGRpc3BsYXkuc2xpY2UoMCwgZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyksXG4gICAgICAgIGRpc3BsYXkuc2xpY2UoZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyksXG4gICAgXTtcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnJlcGxhY2UoLygwKykkLywgJycpO1xuICAgIHJldHVybiBgJHtuZWdhdGl2ZSA/ICctJyA6ICcnfSR7aW50ZWdlciB8fCAnMCd9JHtmcmFjdGlvbiA/IGAuJHtmcmFjdGlvbn1gIDogJyd9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdFVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-sans%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistSans%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.jsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Geist_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22variable%5C%22%3A%5C%22--font-geist-mono%5C%22%2C%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22geistMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fwilfrid-k%2Fprojects%2Fonlydust%2Fchainevents-frontend%2Fsrc%2Fcomponents%2FProviders.jsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);